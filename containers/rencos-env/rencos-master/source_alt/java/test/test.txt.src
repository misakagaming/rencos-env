public XmlWrapperSerializer createSerializer(File file, JsonEncoding encoding) {         try {                    XMLSerializer xmlStreamWriter=new XMLSerializer(new FileWriter(file));    return new XmlWrapperSerializer(xmlStreamWriter);   } catch (Exception e) {    e.printStackTrace();    throw new KriptonRuntimeException(e);   }  }
@Override     public BlogResource newResource(final String name, final String contentType, final byte[] bytes) throws BlogClientException {         if (resourcesCollection == null) {             throw new BlogClientException(""No resource collection"");         }         return resourcesCollection.newResource(name, contentType, bytes);     }
@Override     public ListChangeSetsResult listChangeSets(ListChangeSetsRequest request) {         request = beforeClientExecution(request);         return executeListChangeSets(request);     }
public void setType(int type) {         this.type = type;         if (level == LEVEL_UNDEFINED) {             switch (type) {                 case TYPE_INT:                 case TYPE_LONG:                 case TYPE_DOUBLE:                     level = LEVEL_LOW;                     break;                 case TYPE_STAT:                     level = LEVEL_MEDIUM;                     unit = ""unit.ms"";                     break;                 case TYPE_LOAD:                     level = LEVEL_HIGH;                     break;                 case TYPE_SUBMODULE:                     level = LEVEL_MAX;                     break;                 default:                     break;             }         }     }
public ReadyState getReadyState() {         if (stream == null) {             return EventSource.ReadyState.CONNECTING;         }         else {             switch (stream.getReadyState()) {             case CONNECTING:                 return EventSource.ReadyState.CONNECTING;                              case OPEN:                 return EventSource.ReadyState.OPEN;              case CLOSING:             case CLOSED:             default:                 return EventSource.ReadyState.CLOSED;             }         }             }
private RouteDoc extractDocInfo(RouteMeta routeMeta) {         RouteDoc routeDoc = new RouteDoc();         routeDoc.setGroup(routeMeta.getGroup());         routeDoc.setPath(routeMeta.getPath());         routeDoc.setDescription(routeMeta.getName());         routeDoc.setType(routeMeta.getType().name().toLowerCase());         routeDoc.setMark(routeMeta.getExtra());          return routeDoc;     }
@Override     public GetAccountPasswordPolicyResult getAccountPasswordPolicy(GetAccountPasswordPolicyRequest request) {         request = beforeClientExecution(request);         return executeGetAccountPasswordPolicy(request);     }
@Programmatic     public DocumentType create(             final String reference,             final String name) {         final DocumentType documentType = new DocumentType(reference, name);         repositoryService.persistAndFlush(documentType);         return documentType;     }
public static TApplicationException read(TProtocol iprot) throws TException {         TField field;         iprot.readStructBegin();          String message = null;         int type = TApplicationException.UNKNOWN;          while (true) {             field = iprot.readFieldBegin();             if (field.type == TType.STOP) {                 break;             }             switch (field.id) {                 case 1:                     if (field.type == TType.STRING) {                         message = iprot.readString();                     } else {                         TProtocolUtil.skip(iprot, field.type);                     }                     break;                 case 2:                     if (field.type == TType.I32) {                         type = iprot.readI32();                     } else {                         TProtocolUtil.skip(iprot, field.type);                     }                     break;                 default:                     TProtocolUtil.skip(iprot, field.type);                     break;             }             iprot.readFieldEnd();         }         iprot.readStructEnd();          return new TApplicationException(type, message);     }
static boolean isCharsetSupported() throws IOException {     try {       ZipFile.class.getConstructor(new Class[] { File.class, Charset.class });       return true;     }     catch (NoSuchMethodException e) {       return false;     }   }
private void mapPrimitiveOrEnumToVertex(ITypedInstance typedInstance, AtlasVertex instanceVertex,                                             AttributeInfo attributeInfo) throws AtlasException {         Object attrValue = typedInstance.get(attributeInfo.name);          final String vertexPropertyName = GraphHelper.getQualifiedFieldName(typedInstance, attributeInfo);         Object propertyValue = null;          if (attrValue == null) {             propertyValue = null;         } else if (attributeInfo.dataType() == DataTypes.STRING_TYPE) {             propertyValue = typedInstance.getString(attributeInfo.name);         } else if (attributeInfo.dataType() == DataTypes.SHORT_TYPE) {             propertyValue = typedInstance.getShort(attributeInfo.name);         } else if (attributeInfo.dataType() == DataTypes.INT_TYPE) {             propertyValue = typedInstance.getInt(attributeInfo.name);         } else if (attributeInfo.dataType() == DataTypes.BIGINTEGER_TYPE) {             propertyValue = typedInstance.getBigInt(attributeInfo.name);         } else if (attributeInfo.dataType() == DataTypes.BOOLEAN_TYPE) {             propertyValue = typedInstance.getBoolean(attributeInfo.name);         } else if (attributeInfo.dataType() == DataTypes.BYTE_TYPE) {             propertyValue = typedInstance.getByte(attributeInfo.name);         } else if (attributeInfo.dataType() == DataTypes.LONG_TYPE) {             propertyValue = typedInstance.getLong(attributeInfo.name);         } else if (attributeInfo.dataType() == DataTypes.FLOAT_TYPE) {             propertyValue = typedInstance.getFloat(attributeInfo.name);         } else if (attributeInfo.dataType() == DataTypes.DOUBLE_TYPE) {             propertyValue = typedInstance.getDouble(attributeInfo.name);         } else if (attributeInfo.dataType() == DataTypes.BIGDECIMAL_TYPE) {             propertyValue = typedInstance.getBigDecimal(attributeInfo.name);         } else if (attributeInfo.dataType() == DataTypes.DATE_TYPE) {             final Date dateVal = typedInstance.getDate(attributeInfo.name);             //Convert Property value to Long  while persisting             if (dateVal != null) {                 propertyValue = dateVal.getTime();             }         } else if (attributeInfo.dataType().getTypeCategory() == TypeCategory.ENUM) {             if (attrValue != null) {                 propertyValue = ((EnumValue) attrValue).value;             }         }          GraphHelper.setProperty(instanceVertex, vertexPropertyName, propertyValue);     }
public static List<PersistenceUnitMetadata> findPersistenceUnits(final URL url, final String[] persistenceUnits,              PersistenceUnitTransactionType defaultTransactionType) throws InvalidConfigurationException      {          Document doc;          try          {              doc = getDocument(url);          }          catch (InvalidConfigurationException e)          {              throw e;          }          doc.getXmlVersion();          Element top = doc.getDocumentElement();            String versionName = top.getAttribute(""version"");            NodeList children = top.getChildNodes();          ArrayList<PersistenceUnitMetadata> units = new ArrayList<PersistenceUnitMetadata>();            // parse for persistenceUnitRootInfoURL.          for (int i = 0; i < children.getLength(); i++)          {              if (children.item(i).getNodeType() == Node.ELEMENT_NODE)              {                  Element element = (Element) children.item(i);                  String tag = element.getTagName();                  // look for ""persistence-unit"" element                  if (tag.equals(""persistence-unit""))                  {                      PersistenceUnitMetadata metadata = parsePersistenceUnit(url, persistenceUnits, element, versionName);                      if (metadata != null)                      {                          units.add(metadata);                      }                  }              }          }          return units;      }
public void setEndRule(int endMonth, int endDay, int endDayOfWeek, int endTime, boolean after)     {         if (after) {             setEndRule(endMonth, endDay, -endDayOfWeek, endTime);         } else {             setEndRule(endMonth, -endDay, -endDayOfWeek, endTime);         }     }
public void setHsmsPendingDeletion(java.util.Collection<String> hsmsPendingDeletion) {         if (hsmsPendingDeletion == null) {             this.hsmsPendingDeletion = null;             return;         }          this.hsmsPendingDeletion = new com.amazonaws.internal.SdkInternalList<String>(hsmsPendingDeletion);     }
static ClassifiedTBox classify(OntologyImpl.UnclassifiedOntologyTBox onto) {    DefaultDirectedGraph<ObjectPropertyExpression, DefaultEdge> objectPropertyGraph =     getObjectPropertyGraph(onto);   EquivalencesDAGImpl<ObjectPropertyExpression> objectPropertyDAG =     EquivalencesDAGImpl.getEquivalencesDAG(objectPropertyGraph);    DefaultDirectedGraph<DataPropertyExpression, DefaultEdge> dataPropertyGraph =     getDataPropertyGraph(onto);   EquivalencesDAGImpl<DataPropertyExpression> dataPropertyDAG =     EquivalencesDAGImpl.getEquivalencesDAG(dataPropertyGraph);    EquivalencesDAGImpl<ClassExpression> classDAG =     EquivalencesDAGImpl.getEquivalencesDAG(getClassGraph(onto, objectPropertyGraph, dataPropertyGraph));    EquivalencesDAGImpl<DataRangeExpression> dataRangeDAG =     EquivalencesDAGImpl.getEquivalencesDAG(getDataRangeGraph(onto, dataPropertyGraph));    chooseObjectPropertyRepresentatives(objectPropertyDAG);   chooseDataPropertyRepresentatives(dataPropertyDAG);   chooseClassRepresentatives(classDAG, objectPropertyDAG, dataPropertyDAG);   chooseDataRangeRepresentatives(dataRangeDAG, dataPropertyDAG);    ClassifiedTBoxImpl r = new ClassifiedTBoxImpl(                 onto.classes(),                 onto.objectProperties(),                 onto.dataProperties(),                 onto.annotationProperties(),                 classDAG,                 objectPropertyDAG,                 dataPropertyDAG,                 dataRangeDAG,                 onto.getDisjointClassesAxioms(),                 onto.getDisjointObjectPropertiesAxioms(),                 onto.getDisjointDataPropertiesAxioms(),                 onto.getReflexiveObjectPropertyAxioms(),                 onto.getIrreflexiveObjectPropertyAxioms(),                 onto.getFunctionalObjectProperties(),                 onto.getFunctionalDataProperties()); //  if (equivalenceReduced) { //   r = getEquivalenceSimplifiedReasoner(r); //  }   return r;  }
public List<String> collect(@NonNull HString hString) {       return stream(hString).collect(Collectors.toList());    }
@Override     public void elemAdd(MVec addend) {         if (addend instanceof Tensor) {             elemAdd((Tensor)addend);         } else {             throw new IllegalArgumentException(""Addend must be of type "" + this.getClass());         }     }
public void processAnonymousField(Properties attributes) throws XDocletException      {          if (!attributes.containsKey(ATTRIBUTE_NAME))          {              throw new XDocletException(Translator.getString(XDocletModulesOjbMessages.class,                                         XDocletModulesOjbMessages.PARAMETER_IS_REQUIRED,                                         new String[]{ATTRIBUTE_NAME}));          }            String             name     = attributes.getProperty(ATTRIBUTE_NAME);          FieldDescriptorDef fieldDef = _curClassDef.getField(name);          String             attrName;            if (fieldDef == null)          {              fieldDef = new FieldDescriptorDef(name);              _curClassDef.addField(fieldDef);          }          fieldDef.setAnonymous();          LogHelper.debug(false, OjbTagsHandler.class, ""processAnonymousField"", ""  Processing anonymous field ""+fieldDef.getName());            attributes.remove(ATTRIBUTE_NAME);          for (Enumeration attrNames = attributes.propertyNames(); attrNames.hasMoreElements(); )          {              attrName = (String)attrNames.nextElement();              fieldDef.setProperty(attrName, attributes.getProperty(attrName));          }          fieldDef.setProperty(PropertyHelper.OJB_PROPERTY_ACCESS, ""anonymous"");      }
public Entry getLast()   {     if (tc.isEntryEnabled())     {       SibTr.entry(tc, ""getLast"");            SibTr.exit(tc, ""getLast"", last);     }      return last;   }
protected synchronized void destroyServerSocket() {         if (null == this.serverSocket) {             // already closed             return;         }         if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {             Tr.debug(tc, ""ServerSocket being closed for port "" + this.listenPort);         }         closeServerSocket();         this.serverSocket = null;     }
public static int multiplyRgb(int rgb, double fr, double fg, double fb)      {          if (rgb == 0)          {              return rgb;          }            final int a = rgb >> Constant.BYTE_4 & 0xFF;          final int r = (int) UtilMath.clamp((rgb >> Constant.BYTE_3 & 0xFF) * fr, 0, 255);          final int g = (int) UtilMath.clamp((rgb >> Constant.BYTE_2 & 0xFF) * fg, 0, 255);          final int b = (int) UtilMath.clamp((rgb >> Constant.BYTE_1 & 0xFF) * fb, 0, 255);            // CHECKSTYLE IGNORE LINE: BooleanExpressionComplexity|TrailingComment          return (a & 0xFF) << Constant.BYTE_4                 | (r & 0xFF) << Constant.BYTE_3                 | (g & 0xFF) << Constant.BYTE_2                 | (b & 0xFF) << Constant.BYTE_1;      }
public static String rewriteMethodSignature(ClassNameRewriter classNameRewriter, String methodSignature) {         if (classNameRewriter != IdentityClassNameRewriter.instance()) {             SignatureParser parser = new SignatureParser(methodSignature);              StringBuilder buf = new StringBuilder();              buf.append('(');             for (Iterator<String> i = parser.parameterSignatureIterator(); i.hasNext();) {                 buf.append(rewriteSignature(classNameRewriter, i.next()));             }              buf.append(')');             buf.append(rewriteSignature(classNameRewriter, parser.getReturnTypeSignature()));              methodSignature = buf.toString();         }          return methodSignature;     }
private static ProteinSequence getProteinSequence(String str) {   try {    ProteinSequence s = new ProteinSequence(str);    return s;   } catch (CompoundNotFoundException e) {     logger.error(""Unexpected error when creating ProteinSequence"",e);   }   return null;  }
public static boolean isMappedIPv4Address(String ipString) {     byte[] bytes = ipStringToBytes(ipString);     if (bytes != null && bytes.length == 16) {       for (int i = 0; i < 10; i++) {         if (bytes[i] != 0) {           return false;         }       }       for (int i = 10; i < 12; i++) {         if (bytes[i] != (byte) 0xff) {           return false;         }       }       return true;     }     return false;   }
public String getCategories(int i) {     if (GOMention_Type.featOkTst && ((GOMention_Type)jcasType).casFeat_categories == null)       jcasType.jcas.throwFeatMissing(""categories"", ""de.julielab.jules.types.GOMention"");     jcasType.jcas.checkArrayBounds(jcasType.ll_cas.ll_getRefValue(addr, ((GOMention_Type)jcasType).casFeatCode_categories), i);     return jcasType.ll_cas.ll_getStringArrayValue(jcasType.ll_cas.ll_getRefValue(addr, ((GOMention_Type)jcasType).casFeatCode_categories), i);}
@Override  public CommerceSubscriptionEntry fetchByPrimaryKey(Serializable primaryKey) {   Serializable serializable = entityCache.getResult(CommerceSubscriptionEntryModelImpl.ENTITY_CACHE_ENABLED,     CommerceSubscriptionEntryImpl.class, primaryKey);    if (serializable == nullModel) {    return null;   }    CommerceSubscriptionEntry commerceSubscriptionEntry = (CommerceSubscriptionEntry)serializable;    if (commerceSubscriptionEntry == null) {    Session session = null;     try {     session = openSession();      commerceSubscriptionEntry = (CommerceSubscriptionEntry)session.get(CommerceSubscriptionEntryImpl.class,       primaryKey);      if (commerceSubscriptionEntry != null) {      cacheResult(commerceSubscriptionEntry);     }     else {      entityCache.putResult(CommerceSubscriptionEntryModelImpl.ENTITY_CACHE_ENABLED,       CommerceSubscriptionEntryImpl.class, primaryKey,       nullModel);     }    }    catch (Exception e) {     entityCache.removeResult(CommerceSubscriptionEntryModelImpl.ENTITY_CACHE_ENABLED,      CommerceSubscriptionEntryImpl.class, primaryKey);      throw processException(e);    }    finally {     closeSession(session);    }   }    return commerceSubscriptionEntry;  }
public Collector<Type, ClosureHolder, List<Type>> closureCollector(boolean minClosure, BiPredicate<Type, Type> shouldSkip) {         return Collector.of(() -> new ClosureHolder(minClosure, shouldSkip),                 ClosureHolder::add,                 ClosureHolder::merge,                 ClosureHolder::closure);     }
public static void copyTypeParametersFromJvmOperation(List<JvmTypeParameter> inputParameters,    List<JvmTypeParameter> outputParameters,    Map<String, JvmTypeReference> superTypeParameterMapping,    JvmTypeReferenceBuilder typeParameterBuilder, JvmTypesBuilder typeBuilder,    TypeReferences typeReferences, TypesFactory jvmTypesFactory) {   // Copy the generic types in two steps: first step is the name's copy.   for (final JvmTypeParameter typeParameter : inputParameters) {    final JvmTypeParameter typeParameterCopy = jvmTypesFactory.createJvmTypeParameter();    typeParameterCopy.setName(typeParameter.getName());    outputParameters.add(typeParameterCopy);   }   // Second step is the constraints' copy   for (int i = 0; i < inputParameters.size(); ++i) {    final JvmTypeParameter typeParameter = inputParameters.get(i);    final JvmTypeParameter typeParameterCopy = outputParameters.get(i);    for (final JvmTypeConstraint constraint : typeParameter.getConstraints()) {     JvmTypeConstraint cst = null;     if (constraint instanceof JvmLowerBound) {      cst = jvmTypesFactory.createJvmLowerBound();     } else if (constraint instanceof JvmUpperBound) {      cst = jvmTypesFactory.createJvmUpperBound();     }     if (cst != null) {      typeParameterCopy.getConstraints().add(cst);      cst.setTypeReference(cloneWithTypeParametersAndProxies(        constraint.getTypeReference(),        outputParameters,        superTypeParameterMapping,        typeParameterBuilder, typeBuilder, typeReferences, jvmTypesFactory));     }    }   }  }
static Object find(String factoryId)         throws SOAPException     {         ClassLoader classLoader;         try {             classLoader = getContextClassLoader();         } catch (Exception x) {             throw new SOAPException(x.toString(), x);         }          // Use the system property first         try {             String systemProp =                 System.getProperty( factoryId );             if( systemProp!=null) {                 return newInstance(systemProp, classLoader);             }         } catch (SecurityException se) {         }          // try to read from $java.home/lib/jaxm.properties         try {             String javah=System.getProperty( ""java.home"" );             String configFile = javah + File.separator +                 ""lib"" + File.separator + ""jaxm.properties"";             File f=new File( configFile );             if( f.exists()) {                 Properties props=new Properties();                 props.load( new FileInputStream(f));                 String factoryClassName = props.getProperty(factoryId);                 return newInstance(factoryClassName, classLoader);             }         } catch(Exception ex ) {         }          String serviceId = ""META-INF/services/"" + factoryId;         // try to find services in CLASSPATH         try {             InputStream is=null;             if (classLoader == null) {                 is=ClassLoader.getSystemResourceAsStream(serviceId);             } else {                 is=classLoader.getResourceAsStream(serviceId);             }                      if( is!=null ) {                 BufferedReader rd =                     new BufferedReader(new InputStreamReader(is, ""UTF-8""));                          String factoryClassName = rd.readLine();                 rd.close();                  if (factoryClassName != null &&                     ! """".equals(factoryClassName)) {                     return newInstance(factoryClassName, classLoader);                 }             }         } catch( Exception ex ) {         }          ClassLoader moduleClassLoader = null;         try {             final Class<?> moduleClass = Class.forName(""org.jboss.modules.Module"");             final Class<?> moduleIdentifierClass = Class.forName(""org.jboss.modules.ModuleIdentifier"");             final Class<?> moduleLoaderClass = Class.forName(""org.jboss.modules.ModuleLoader"");             final SecurityManager sm = System.getSecurityManager();             Object moduleLoader = null;             if (sm != null) {                 moduleLoader = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {                     public Object run() throws Exception {                         return moduleClass.getMethod(""getBootModuleLoader"").invoke(null);                      }                 });             } else {                 moduleLoader = moduleClass.getMethod(""getBootModuleLoader"").invoke(null);             }             Object moduleIdentifier = moduleIdentifierClass.getMethod(""create"", String.class).invoke(null, JBOSS_SAAJ_IMPL_MODULE);             final Object module = moduleLoaderClass.getMethod(""loadModule"", moduleIdentifierClass).invoke(moduleLoader, moduleIdentifier);             if (sm != null) {                 try {                     moduleClassLoader = AccessController.doPrivileged(new PrivilegedExceptionAction<ClassLoader>() {                         @Override                         public ClassLoader run() throws Exception {                             return (ClassLoader) moduleClass.getMethod(""getClassLoader"").invoke(module);                         }                     });                 } catch (PrivilegedActionException pae) {                     throw pae.getException();                 }             } else {                 moduleClassLoader = (ClassLoader) moduleClass.getMethod(""getClassLoader"").invoke(module);             }         } catch (ClassNotFoundException e) {            //ignore, JBoss Modules might not be available at all         } catch (Exception e) {            throw new SOAPException(e);         }         if (moduleClassLoader != null) {            try {               InputStream is = moduleClassLoader.getResourceAsStream(serviceId);                          if( is!=null ) {                   BufferedReader rd =                       new BufferedReader(new InputStreamReader(is, ""UTF-8""));                              String factoryClassName = rd.readLine();                   rd.close();                    if (factoryClassName != null &&                       ! """".equals(factoryClassName)) {                       return newInstance(factoryClassName, moduleClassLoader);                   }               }           } catch( Exception ex ) {           }         }          return null;     }
public RoleInner createOrUpdate(String deviceName, String name, String resourceGroupName, RoleInner role) {         return createOrUpdateWithServiceResponseAsync(deviceName, name, resourceGroupName, role).toBlocking().last().body();     }
@Override     public List<StorageState> decodeContent(InputStream in, Charset charset) throws IOException {         // 解析报文内容         byte[] bytes = new byte[(int) getContentLength()];         int contentSize = in.read(bytes);         if (contentSize != getContentLength()) {             throw new IOException(""读取到的数据长度与协议长度不符"");         }         return decode(bytes, charset);      }
public static DocumentBuilder createDocumentBuilder() {    final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();    disableXXE(dbf);    DocumentBuilder builder = null;    try {     builder = dbf.newDocumentBuilder();    } catch (Exception e) {     throw new UtilException(e, ""Create xml document error!"");    }    return builder;   }
private XSSFCellStyle updateSubreportBandElementStyle(XSSFCellStyle cellStyle, BandElement bandElement, Object value, int gridRow, int gridColumn, int colSpan) {      if (subreportCellStyle == null) {       return cellStyle;      }                           if (gridColumn == 0) {             cellStyle.setBorderLeft(subreportCellStyle.getBorderLeft());            cellStyle.setLeftBorderColor(subreportCellStyle.getLeftBorderColor());           } else if (gridColumn+colSpan-1 == bean.getReportLayout().getColumnCount()-1) {             cellStyle.setBorderRight(subreportCellStyle.getBorderRight());       cellStyle.setRightBorderColor(subreportCellStyle.getRightBorderColor());      }                       if (pageRow == 0) {                   cellStyle.setBorderTop(subreportCellStyle.getBorderTop());         cellStyle.setTopBorderColor(subreportCellStyle.getTopBorderColor());        } else if ( (pageRow+1) == getRowsCount()) {                  cellStyle.setBorderBottom(subreportCellStyle.getBorderBottom());            cellStyle.setBottomBorderColor(subreportCellStyle.getBottomBorderColor());      }                     return cellStyle;     }
public Request acceptEncoding(String encoding){         final String acceptEncoding = RequestHeaderFields.ACCEPT_ENCODING.getName();         String encodingValue = headers.get(acceptEncoding);         if (encodingValue == null){             encodingValue = encoding;         } else {             encodingValue = encodingValue + "", "" + encoding;         }         return this.setHeader(acceptEncoding, encodingValue);     }
public void marshall(APNSSandboxChannelResponse aPNSSandboxChannelResponse, ProtocolMarshaller protocolMarshaller) {          if (aPNSSandboxChannelResponse == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(aPNSSandboxChannelResponse.getApplicationId(), APPLICATIONID_BINDING);             protocolMarshaller.marshall(aPNSSandboxChannelResponse.getCreationDate(), CREATIONDATE_BINDING);             protocolMarshaller.marshall(aPNSSandboxChannelResponse.getDefaultAuthenticationMethod(), DEFAULTAUTHENTICATIONMETHOD_BINDING);             protocolMarshaller.marshall(aPNSSandboxChannelResponse.getEnabled(), ENABLED_BINDING);             protocolMarshaller.marshall(aPNSSandboxChannelResponse.getHasCredential(), HASCREDENTIAL_BINDING);             protocolMarshaller.marshall(aPNSSandboxChannelResponse.getHasTokenKey(), HASTOKENKEY_BINDING);             protocolMarshaller.marshall(aPNSSandboxChannelResponse.getId(), ID_BINDING);             protocolMarshaller.marshall(aPNSSandboxChannelResponse.getIsArchived(), ISARCHIVED_BINDING);             protocolMarshaller.marshall(aPNSSandboxChannelResponse.getLastModifiedBy(), LASTMODIFIEDBY_BINDING);             protocolMarshaller.marshall(aPNSSandboxChannelResponse.getLastModifiedDate(), LASTMODIFIEDDATE_BINDING);             protocolMarshaller.marshall(aPNSSandboxChannelResponse.getPlatform(), PLATFORM_BINDING);             protocolMarshaller.marshall(aPNSSandboxChannelResponse.getVersion(), VERSION_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
protected Connection createConnection(Socket socket, InputStream inputStream,    OutputStream outputStream) throws IOException {   return new Connection(socket, inputStream, outputStream);  }
public Date getFirstValueAsDate() throws ParseException {         String valueString = getFirstValue();         if (valueString == null) {             return null;         }         return XmppDateTime.parseXEP0082Date(valueString);     }
public CmsPermissionSet getPermissions(String resourceName, String userName) throws CmsException {          // reading permissions is allowed even if the resource is marked as deleted         CmsResource resource = readResource(resourceName, CmsResourceFilter.ALL);         CmsUser user = readUser(userName);         return m_securityManager.getPermissions(m_context, resource, user);     }
public ProjectCalendarHours addCalendarHours(Day day)    {       ProjectCalendarHours bch = new ProjectCalendarHours(this);       bch.setDay(day);       m_hours[day.getValue() - 1] = bch;       return (bch);    }
private DateTime providedOrDefaultFromValue(DateTime from, DateTime to,    AggregateCounterResolution resolution) {   if (from != null) {    return from;   }   switch (resolution) {   case minute:    return to.minusMinutes(59);   case hour:    return to.minusHours(23);   case day:    return to.minusDays(6);   case month:    return to.minusMonths(11);   case year:    return to.minusYears(4);   default:    throw new IllegalStateException(      ""Shouldn't happen. Unhandled resolution: "" + resolution);   }  }
@Override     public IRenderingElement generate(IAtomContainer container, RendererModel model) {          final Map<IChemObject, Integer> highlight = container.getProperty(ID_MAP);          if (highlight == null) return null;          final Palette palette = model.getParameter(HighlightPalette.class).getValue();         final double radius = model.getParameter(HighlightRadius.class).getValue()                 / model.getParameter(BasicSceneGenerator.Scale.class).getValue();          final Map<Integer, Area> shapes = new HashMap<Integer, Area>();          for (IAtom atom : container.atoms()) {              Integer id = highlight.get(atom);              if (id == null) continue;              Area area = shapes.get(id);             Shape shape = createAtomHighlight(atom, radius);              if (area == null)                 shapes.put(id, new Area(shape));             else                 area.add(new Area(shape));         }          for (IBond bond : container.bonds()) {              Integer id = highlight.get(bond);              if (id == null) continue;              Area area = shapes.get(id);             Shape shape = createBondHighlight(bond, radius);              if (area == null)                 shapes.put(id, (area = new Area(shape)));             else                 area.add(new Area(shape));              // punch out the area occupied by atoms highlighted with a             // different color              IAtom   a1   = bond.getBegin(), a2 = bond.getEnd();             Integer a1Id = highlight.get(a1), a2Id = highlight.get(a2);              if (a1Id != null && !a1Id.equals(id)) area.subtract(shapes.get(a1Id));             if (a2Id != null && !a2Id.equals(id)) area.subtract(shapes.get(a2Id));         }          // create rendering elements for each highlight shape         ElementGroup group = new ElementGroup();         for (Map.Entry<Integer, Area> e : shapes.entrySet()) {             group.add(GeneralPath.shapeOf(e.getValue(), palette.color(e.getKey())));         }          return group;     }
@Override  public CPDefinitionLocalization fetchByCPDefinitionId_Last(   long CPDefinitionId,   OrderByComparator<CPDefinitionLocalization> orderByComparator) {   int count = countByCPDefinitionId(CPDefinitionId);    if (count == 0) {    return null;   }    List<CPDefinitionLocalization> list = findByCPDefinitionId(CPDefinitionId,     count - 1, count, orderByComparator);    if (!list.isEmpty()) {    return list.get(0);   }    return null;  }
public <T extends RegressionEvaluation> T evaluateRegression(JavaRDD<DataSet> data, int minibatchSize) {         long nOut = ((FeedForwardLayer) network.getOutputLayer().conf().getLayer()).getNOut();         return (T)doEvaluation(data, new org.deeplearning4j.eval.RegressionEvaluation(nOut), minibatchSize);     }
public EEnum getObjectClassificationStrucFlgs() {   if (objectClassificationStrucFlgsEEnum == null) {    objectClassificationStrucFlgsEEnum = (EEnum)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(101);   }   return objectClassificationStrucFlgsEEnum;  }
private void startNegotiators() {          for (ContentNegotiator contentNegotiator : contentNegotiators) {             TransportNegotiator transNeg = contentNegotiator.getTransportNegotiator();             transNeg.start();         }     }
@Override     public DeleteInstanceResult deleteInstance(DeleteInstanceRequest request) {         request = beforeClientExecution(request);         return executeDeleteInstance(request);     }
public static void printSystemOut(String message1, long message2) {          if (TRACESYSTEMOUT) {             System.out.print(message1);             System.out.println(message2);         }     }
public void marshall(ListTagsForProjectRequest listTagsForProjectRequest, ProtocolMarshaller protocolMarshaller) {          if (listTagsForProjectRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(listTagsForProjectRequest.getId(), ID_BINDING);             protocolMarshaller.marshall(listTagsForProjectRequest.getNextToken(), NEXTTOKEN_BINDING);             protocolMarshaller.marshall(listTagsForProjectRequest.getMaxResults(), MAXRESULTS_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public String getTextureFile(AiTextureType type, int index) {         checkTexRange(type, index);                  return getTyped(PropertyKey.TEX_FILE, type, index, String.class);     }
static private Vector3f[] copyVertices(Vector3f[] vertices) {         if (vertices == null) {             return null;         }         Vector3f[] copy = new Vector3f[vertices.length];         for (int i = 0; i < vertices.length; ++i) {             copy[i] = new Vector3f(vertices[i]);         }         return copy;     }
public static <ID, T extends Model> Finder<ID, T> withFinder() {         return withFinder(DataSourceManager.getDefaultDataSourceName());     }
@Route(method = HttpMethod.POST, uri = ""samples/auto-validation"")     public Result auto(@Valid @Body Car car) throws IOException {         return ok();     }
public static boolean isValid(final String cssValue) {         if (cssValue == null || StringUtil.isBlank(cssValue)) {             return false;         }          final String[] cssValueParts = StringUtil.splitBySpace(cssValue);          ColumnWidth columnWidth = null;         ColumnCount columnCount = null;          for (final String eachPart : cssValueParts) {             boolean invalid = true;             if (columnWidth == null && ColumnWidth.isValid(eachPart)) {                 columnWidth = new ColumnWidth(eachPart);                 invalid = false;             } else if (columnCount == null && ColumnCount.isValid(eachPart)) {                 columnCount = new ColumnCount(eachPart);                 invalid = false;             }             if (invalid) {                 return false;             }         }          return columnWidth != null || columnCount != null;     }
@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> concatWith(@NonNull CompletableSource other) {         ObjectHelper.requireNonNull(other, ""other is null"");         return RxJavaPlugins.onAssembly(new ObservableConcatWithCompletable<T>(this, other));     }
public static void closeWindow(Component component) {          Window window = getWindow(component);         if (window != null) {             window.close();         }     }
public static CPRule fetchByGroupId_Last(long groupId,   OrderByComparator<CPRule> orderByComparator) {   return getPersistence().fetchByGroupId_Last(groupId, orderByComparator);  }
public static void computePosition (         Point start, Point end, long elapsed, long duration, Point pos)     {         float pct = (float)elapsed / duration;         int travx = (int)((end.x - start.x) * pct);         int travy = (int)((end.y - start.y) * pct);         pos.setLocation(start.x + travx, start.y + travy);     }
@Override     public DeleteDeliveryStreamResult deleteDeliveryStream(DeleteDeliveryStreamRequest request) {         request = beforeClientExecution(request);         return executeDeleteDeliveryStream(request);     }
@Subscribe     public synchronized void renew(final SchemaAddedEvent schemaAddedEvent) {         logicSchemas.put(schemaAddedEvent.getShardingSchemaName(), createLogicSchema(schemaAddedEvent.getShardingSchemaName(),                  Collections.singletonMap(schemaAddedEvent.getShardingSchemaName(), DataSourceConverter.getDataSourceParameterMap(schemaAddedEvent.getDataSourceConfigurations())),                  schemaAddedEvent.getRuleConfiguration(), true));     }
@Override     protected Event doExecute(final RequestContext context) {         try {             val request = WebUtils.getHttpServletRequestFromExternalWebflowContext(context);             val wa = request.getParameter(WA);             if (StringUtils.isNotBlank(wa) && wa.equalsIgnoreCase(WSIGNIN)) {                 wsFederationResponseValidator.validateWsFederationAuthenticationRequest(context);                 return super.doExecute(context);             }             return wsFederationRequestBuilder.buildAuthenticationRequestEvent(context);         } catch (final Exception ex) {             LOGGER.error(ex.getMessage(), ex);             throw new UnauthorizedServiceException(UnauthorizedServiceException.CODE_UNAUTHZ_SERVICE, ex.getMessage());         }     }
@XmlElementDecl(namespace = ""http://schema.intuit.com/finance/v3"", name = ""Status"", substitutionHeadNamespace = ""http://schema.intuit.com/finance/v3"", substitutionHeadName = ""IntuitObject"")     public JAXBElement<Status> createStatus(Status value) {         return new JAXBElement<Status>(_Status_QNAME, Status.class, null, value);     }
public void subtract(final AbstractHistogram otherHistogram)             throws ArrayIndexOutOfBoundsException, IllegalArgumentException {         long highestRecordableValue = valueFromIndex(countsArrayLength - 1);         if (highestRecordableValue < otherHistogram.getMaxValue()) {             if (!isAutoResize()) {                 throw new ArrayIndexOutOfBoundsException(                         ""The other histogram includes values that do not fit in this histogram's range."");             }             resize(otherHistogram.getMaxValue());         }         if ((bucketCount == otherHistogram.bucketCount) &&                 (subBucketCount == otherHistogram.subBucketCount) &&                 (unitMagnitude == otherHistogram.unitMagnitude) &&                 (getNormalizingIndexOffset() == otherHistogram.getNormalizingIndexOffset())) {             // Counts arrays are of the same length and meaning, so we can just iterate and add directly:             long observedOtherTotalCount = 0;             for (int i = 0; i < otherHistogram.countsArrayLength; i++) {                 long otherCount = otherHistogram.getCountAtIndex(i);                 if (otherCount > 0) {                     if (getCountAtIndex(i) < otherCount) {                         throw new IllegalArgumentException(""otherHistogram count ("" + otherCount + "") at value "" +                                 valueFromIndex(i) + "" is larger than this one's ("" + getCountAtIndex(i) + "")"");                     }                     addToCountAtIndex(i, -otherCount);                     observedOtherTotalCount += otherCount;                 }             }             setTotalCount(getTotalCount() - observedOtherTotalCount);             updatedMaxValue(Math.max(getMaxValue(), otherHistogram.getMaxValue()));             updateMinNonZeroValue(Math.min(getMinNonZeroValue(), otherHistogram.getMinNonZeroValue()));         } else {             // Arrays are not a direct match, so we can't just stream through and add them.             // Instead, go through the array and add each non-zero value found at it's proper value:             for (int i = 0; i < otherHistogram.countsArrayLength; i++) {                 long otherCount = otherHistogram.getCountAtIndex(i);                 if (otherCount > 0) {                     long otherValue = otherHistogram.valueFromIndex(i);                     if (getCountAtValue(otherValue) < otherCount) {                         throw new IllegalArgumentException(""otherHistogram count ("" + otherCount + "") at value "" +                                 otherValue + "" is larger than this one's ("" + getCountAtValue(otherValue) + "")"");                     }                     recordValueWithCount(otherValue, -otherCount);                 }             }         }         // With subtraction, the max and minNonZero values could have changed:         if ((getCountAtValue(getMaxValue()) <= 0) || getCountAtValue(getMinNonZeroValue()) <= 0) {             establishInternalTackingValues();         }     }
public final RuntimeException processDoMethodInvokeException (Exception e, Object object, Object [] argumentArray) { //        if (e instanceof IllegalArgumentException) { //            //TODO: test if this is OK with new MOP, should be changed! //            // we don't want the exception being unwrapped if it is a IllegalArgumentException //            // but in the case it is for example a IllegalThreadStateException, we want the unwrapping //            // from the runtime //            //Note: the reason we want unwrapping sometimes and sometimes not is that the method //            // invocation tries to invoke the method with and then reacts with type transformation //            // if the invocation failed here. This is OK for IllegalArgumentException, but it is //            // possible that a Reflector will be used to execute the call and then an Exception from inside //            // the method is not wrapped in a InvocationTargetException and we will end here. //            boolean setReason = e.getClass() != IllegalArgumentException.class || this instanceof org.codehaus.groovy.reflection.GeneratedMetaMethod; //            return MetaClassHelper.createExceptionText(""failed to invoke method: "", this, object, argumentArray, e, setReason); //        }          if (e instanceof RuntimeException)           return (RuntimeException) e;          return MetaClassHelper.createExceptionText(""failed to invoke method: "", this, object, argumentArray, e, true);     }
private Map<FileInfo, FileInfo> getCopyToMap() {         final Map<FileInfo, FileInfo> copyToMap = new HashMap<>();          if (forceUnique) {             forceUniqueFilter.copyToMap.forEach((dstFi, srcFi) -> {                 job.add(dstFi);                 copyToMap.put(dstFi, srcFi);             });         }          for (final Map.Entry<URI, URI> e : reader.getCopyToMap().entrySet()) {             final URI target = job.tempDirURI.relativize(e.getKey());             final FileInfo targetFi = job.getFileInfo(target);             final URI source = job.tempDirURI.relativize(e.getValue());             final FileInfo sourceFi = job.getFileInfo(source);             // Filter when copy-to was ignored (so target is not in job),             // or where target is used directly             if (targetFi == null ||                     (targetFi != null && targetFi.src != null)) {                 continue;             }             copyToMap.put(targetFi, sourceFi);         }          return copyToMap;     }
@Override     public BoundStatement bindInsert(PreparedStatement statement, P pojo, int ttl) {         List<Object> parameters = new LinkedList<>();         keyBinding.collectParameters(pojo, parameters);         facetBindings.forEach(facetBinding -> facetBinding.collectParameters(pojo, parameters));         parameters.add(ttl);         return bind(statement, parameters);     }
private void close(Store store) {         StoreKey key = keysByStore.get(store);         LOGGER.info(""Closing store in directory '"" + key.getUri() + ""'."");         store.stop();     }
@SuppressWarnings(""unused"")     private CharSequence readData() throws IOException {         if (!_eventSource.isConnected()) {             String s = ""Can't read using the MessageReader if the event "" +                        ""source is not connected"";             throw new SseException(s);         }          synchronized (this) {                     if (_payload != null) {                 // If we are here, then it means that readData() was invoked                  // after next(). So, the _payload is already setup and we just                 // have to return the data.                 if (_eventType != SseEventType.DATA) {                     String s = ""readData() can only be used to read events "" +                                ""of type SseEventType.DATA"";                     throw new SseException(s);                             }                                  // Clear the _payload member variable for the internal state                  // machine.                 _payload = null;                             return _data;             }                          // This will block the thread. If we are here, this means that             // readData() was invoked without a previous invocation of next().             // So, we invoke next() and ensure that the next message is a text             // message. Otherwise, throw an exception.             SseEventType type = next();                          if (type != SseEventType.DATA) {                 String s = ""readData() can only be used to read events "" +                            ""of type SseEventType.DATA"";                 throw new SseException(s);                         }                  _data = _payload.getData();             _eventName = _payload.getEventName();                  // Clear the _payload member variable for the internal state machine.             _payload = null;             return _data;         }     }
public void into(@NonNull BitmapTarget target) {     long started = System.nanoTime();     checkMain();      if (target == null) {       throw new IllegalArgumentException(""Target must not be null."");     }     if (deferred) {       throw new IllegalStateException(""Fit cannot be used with a Target."");     }      if (!data.hasImage()) {       picasso.cancelRequest(target);       target.onPrepareLoad(setPlaceholder ? getPlaceholderDrawable() : null);       return;     }      Request request = createRequest(started);      if (shouldReadFromMemoryCache(request.memoryPolicy)) {       Bitmap bitmap = picasso.quickMemoryCacheCheck(request.key);       if (bitmap != null) {         picasso.cancelRequest(target);         target.onBitmapLoaded(bitmap, MEMORY);         return;       }     }      target.onPrepareLoad(setPlaceholder ? getPlaceholderDrawable() : null);      Action action = new BitmapTargetAction(picasso, target, request, errorDrawable, errorResId);     picasso.enqueueAndSubmit(action);   }
public static Alignment<NucleotideSequence> align(LinearGapAlignmentScoring scoring, NucleotideSequence seq1, NucleotideSequence seq2,                                                       int offset1, int length1, int offset2, int length2, int width) {         try {             MutationsBuilder<NucleotideSequence> mutations = new MutationsBuilder<>(NucleotideSequence.ALPHABET);             float score = align0(scoring, seq1, seq2, offset1, length1, offset2, length2, width,                     mutations, AlignmentCache.get());             return new Alignment<>(seq1, mutations.createAndDestroy(),                     new Range(offset1, offset1 + length1), new Range(offset2, offset2 + length2), score);         } finally {             AlignmentCache.release();         }     }
Constraint getUniqueConstraintForExprs(Expression[] indexExprs) {         for (int i = 0, size = constraintList.length; i < size; i++) {             Constraint exprc = constraintList[i];              if (exprc.isUniqueWithExprs(indexExprs)) {                 return exprc;             }         }         return null;     }
public static void addLibrary(final JobID jobID, final Path name, final long size, final DataInput in)    throws IOException {    final LibraryCacheManager lib = get();   lib.addLibraryInternal(jobID, name, size, in);  }
@SuppressWarnings(""unchecked"")   public EList<IfcStructuralAnalysisModel> getLoadGroupFor() {    return (EList<IfcStructuralAnalysisModel>) eGet(      Ifc2x3tc1Package.Literals.IFC_STRUCTURAL_LOAD_GROUP__LOAD_GROUP_FOR, true);   }
@Override  public void removeListener(InvalidationListener listener) {   Objects.requireNonNull(listener);   if (0 < invalidationSize) {    if (size == 1) {     if (invalidationSize == 1 && this.listener.equals(listener)) {      sentinel = false;      this.listener = null;      invalidationSize--;      size--;     }    } else if (size == 2) {     Object[] l = (Object[]) this.listener;     if (listener.equals(l[0])) {      sentinel = false;      invalidationSize--;      size--;      this.listener = l[1];     } else if (invalidationSize == 2 && listener.equals(l[1])) {      sentinel = false;      invalidationSize--;      size--;      this.listener = l[0];     }    } else {     Object[] l = (Object[]) this.listener;      for (int i = 0; i < invalidationSize; i++) {      if (listener.equals(l[i])) {       if (sentinel) {        sentinel = false;        l = Arrays.copyOf(l, l.length);        this.listener = l;       }       if (i + 1 < size) {        System.arraycopy(l, i + 1, l, i, size - i - 1);       } else {        l[i] = null;       }       invalidationSize--;       size--;       break;      }     }    }   }  }
public static synchronized void setChannelGroups(Collection<WonderPushChannelGroup> channelGroups) {         if (channelGroups == null) return;         boolean save = false;         try {             Set<String> groupIdsToRemove = new HashSet<>(sChannelGroups.keySet());             for (WonderPushChannelGroup channelGroup : channelGroups) {                 if (channelGroup == null) continue;                 groupIdsToRemove.remove(channelGroup.getId());                 if (_putChannelGroup(channelGroup)) save = true;             }             for (String groupId : groupIdsToRemove) {                 if (_removeChannelGroup(groupId)) save = true;             }         } catch (Exception ex) {             Log.e(WonderPush.TAG, ""Unexpected error while setting channel groups "" + channelGroups, ex);         } finally {             try {                 if (save) {                     save();                 }             } catch (Exception ex) {                 Log.e(WonderPush.TAG, ""Unexpected error while setting channel groups "" + channelGroups, ex);             }         }     }
private void generateEntity(M2MEntity entity) {   entity.propertyPrimaryKey = TypeName.LONG;   entity.propertyKey1 = findPrimaryKeyFieldType(entity.entity1Name.toString());   entity.propertyKey2 = findPrimaryKeyFieldType(entity.entity2Name.toString());   if (!entity.needToCreate) {    return;   }    String tableName = entity.tableName;   String entityClassName = entity.name;    AnnotationProcessorUtilis.infoOnGeneratedClasses(BindDaoMany2Many.class, entity.getPackageName(),     entityClassName);    Converter<String, String> converterFK = CaseFormat.LOWER_CAMEL.converterTo(CaseFormat.UPPER_CAMEL);   Converter<String, String> converterFieldName = CaseFormat.UPPER_CAMEL.converterTo(CaseFormat.LOWER_CAMEL);   Converter<String, String> converterField2ColumnName = CaseFormat.LOWER_CAMEL     .converterTo(CaseFormat.LOWER_UNDERSCORE);   String fkPrefix = converterFK.convert(entity.idName);    String fk1Name = converterField2ColumnName.convert(entity.entity1Name.simpleName() + fkPrefix);   String fk2Name = converterField2ColumnName.convert(entity.entity2Name.simpleName() + fkPrefix);    String field1Name = converterFieldName.convert(entity.entity1Name.simpleName() + fkPrefix);   String field2Name = converterFieldName.convert(entity.entity2Name.simpleName() + fkPrefix);    List<SQLProperty> properties = new ArrayList<SQLProperty>();    // we define property type later   {    SQLProperty property = new SQLProperty(entity.idName, entity.getClassName(), entity.propertyPrimaryKey);    property.columnType = ColumnType.PRIMARY_KEY;    property.columnName = entity.idName;    property.setNullable(false);    property.setPrimaryKey(true);    property.foreignParentClassName = null;    properties.add(property);   }    {    SQLProperty property = new SQLProperty(field1Name, entity.getClassName(), entity.propertyKey1);    property.columnType = ColumnType.INDEXED;    property.columnName = fk1Name;    property.setNullable(false);    property.setPrimaryKey(false);    property.onDeleteAction = ForeignKeyAction.CASCADE;    property.foreignParentClassName = entity.entity1Name.toString();    properties.add(property);   }    {    SQLProperty property = new SQLProperty(field2Name, entity.getClassName(), entity.propertyKey2);    property.columnType = ColumnType.INDEXED;    property.columnName = fk2Name;    property.setNullable(false);    property.setPrimaryKey(false);    property.onDeleteAction = ForeignKeyAction.CASCADE;    property.foreignParentClassName = entity.entity2Name.toString();    properties.add(property);   }    // @formatter:off   classBuilder = TypeSpec.classBuilder(entityClassName).addModifiers(Modifier.PUBLIC)     .addAnnotation(AnnotationSpec.builder(BindSqlType.class).addMember(""name"", ""$S"", tableName).build());   // @formatter:on    if (entity.immutable) {    // create constructor    Builder constructorBuilder = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC);    for (SQLProperty p : properties) {     constructorBuilder       .addParameter(ParameterSpec.builder(p.getPropertyType().getTypeName(), p.getName()).build());     constructorBuilder.addStatement(""this.$L=$L"", p.getName(), p.getName());    }    classBuilder.addMethod(constructorBuilder.build());   }    Modifier fieldModifier = entity.immutable ? Modifier.PRIVATE : Modifier.PUBLIC;    // javadoc for class   classBuilder.addJavadoc(""<p>"");   classBuilder.addJavadoc(""\nGenerated entity implementation for <code>$L</code>\n"", entity.name);   classBuilder.addJavadoc(""</p>\n"");   JavadocUtility.generateJavadocGeneratedBy(classBuilder);   // classBuilder.addJavadoc("" @see $T\n"",      {    // @formatter:off    FieldSpec fieldSpec = FieldSpec.builder(entity.propertyPrimaryKey, entity.idName, fieldModifier)      .addJavadoc(""Primary key\n"")      .addAnnotation(AnnotationSpec.builder(BindSqlColumn.class)        .addMember(""columnType"", ""$T.$L"", ColumnType.class, ColumnType.PRIMARY_KEY).build())      .build();    // @formatter:on    classBuilder.addField(fieldSpec);   }    {    // @formatter:off    FieldSpec fieldSpec = FieldSpec      .builder(entity.propertyKey1, field1Name, fieldModifier)      .addJavadoc(""Foreign key to $T model class\n"", entity.entity1Name)      .addAnnotation(AnnotationSpec.builder(BindSqlColumn.class)        .addMember(AnnotationAttributeType.PARENT_ENTITY.getValue(), ""$T.class"", entity.entity1Name)        .addMember(AnnotationAttributeType.ON_DELETE.getValue(), ""$T.$L"", ForeignKeyAction.class,          ForeignKeyAction.CASCADE)        .build())      .build();    // @formatter:on    classBuilder.addField(fieldSpec);   }    {    // @formatter:off    FieldSpec fieldSpec = FieldSpec      .builder(entity.propertyKey2, field2Name, fieldModifier)      .addJavadoc(""Foreign key to $T model class\n"", entity.entity2Name)      .addAnnotation(AnnotationSpec.builder(BindSqlColumn.class)        .addMember(AnnotationAttributeType.PARENT_ENTITY.getValue(), ""$T.class"", entity.entity2Name)        .addMember(AnnotationAttributeType.ON_DELETE.getValue(), ""$T.$L"", ForeignKeyAction.class,          ForeignKeyAction.CASCADE)        .build())      .build();    // @formatter:on    classBuilder.addField(fieldSpec);   }    if (entity.immutable) {    // getters    for (SQLProperty p : properties) {     Builder methodBuilder = MethodSpec       .methodBuilder(""get"" + CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_CAMEL, p.getName()))       .returns(p.getPropertyType().getTypeName()).addStatement(""return this.$L"", p.getName())       .addModifiers(Modifier.PUBLIC);      classBuilder.addMethod(methodBuilder.build());    }   }    TypeSpec typeSpec = classBuilder.build();    try {    JavaWriterHelper.writeJava2File(filer, entity.getPackageName(), typeSpec);   } catch (IOException e) {    throw new KriptonRuntimeException(e);   }    GeneratedTypeElement entityElement = new GeneratedTypeElement(entity.getPackageName(), classBuilder.build(),     tableName, fk1Name + "", "" + fk2Name);    entityElement.properties = properties;    entityResult.add(entityElement);  }
public static void set(MutableIntTuple t, int v)      {          for (int i=0; i<t.getSize(); i++)          {              t.set(i, v);          }      }
public static SecondaryIndex createInstance(ColumnFamilyStore baseCfs, ColumnDefinition cdef) throws ConfigurationException     {         SecondaryIndex index;          switch (cdef.getIndexType())         {         case KEYS:             index = new KeysIndex();             break;         case COMPOSITES:             index = CompositesIndex.create(cdef);             break;         case CUSTOM:             assert cdef.getIndexOptions() != null;             String class_name = cdef.getIndexOptions().get(CUSTOM_INDEX_OPTION_NAME);             assert class_name != null;             try             {                 index = (SecondaryIndex) Class.forName(class_name).newInstance();             }             catch (Exception e)             {                 throw new RuntimeException(e);             }             break;             default:                 throw new RuntimeException(""Unknown index type: "" + cdef.getIndexName());         }          index.addColumnDef(cdef);         index.validateOptions();         index.setBaseCfs(baseCfs);          return index;     }
@Override     public boolean onTouchEvent(MotionEvent ev) {         if (null != mGestureDetector) {             return mGestureDetector.onTouchEvent(ev);         } else {             return super.onTouchEvent(ev);         }     }
public RegistryCredentialsInner regenerateCredentials(String resourceGroupName, String registryName) {         return regenerateCredentialsWithServiceResponseAsync(resourceGroupName, registryName).toBlocking().single().body();     }
public static void replaceMultipleTo (@Nullable final String sInputString,                                         @Nonnull final char [] aSearchChars,                                         final char cReplacementChar,                                         @Nonnull final StringBuilder aTarget)   {     ValueEnforcer.notNull (aSearchChars, ""SearchChars"");     ValueEnforcer.notNull (aTarget, ""Target"");      // Any input text?     if (hasText (sInputString))     {       // Any search chars?       if (aSearchChars.length == 0)       {         aTarget.append (sInputString);       }       else       {         // Perform the replacement         for (final char c : sInputString.toCharArray ())         {           if (ArrayHelper.contains (aSearchChars, c))             aTarget.append (cReplacementChar);           else             aTarget.append (c);         }       }     }   }
public void flushChildScopes(QName unitId) {         Set<Integer> childScopes = findChildScopes(unitId);         for(Integer scopeId : childScopes)         {             MutableContext mutableContext = statementContexts.get(scopeId);             mutableContext.clearStatements();         }     }
public boolean execInsert(D6Model[] modelObjects, D6Inex includeExcludeColumnNames) {     boolean ignoreDuplicate = false;     return execInsert(modelObjects, includeExcludeColumnNames, ignoreDuplicate);   }
public void setRelatedEvents(java.util.Collection<String> relatedEvents) {         if (relatedEvents == null) {             this.relatedEvents = null;             return;         }          this.relatedEvents = new com.amazonaws.internal.SdkInternalList<String>(relatedEvents);     }
private static void sort1(Quicksortable q, int off, int k, int len) {         // we don't care about anything >= to k         if (off >= k)             return;         // Insertion sort on smallest arrays         if (len < 7) {             for (int i = off; i < len + off; i++)                 for (int j = i; j > off && q.compare(j, j - 1) < 0; j--)                     q.swap(j, j - 1);             return;         }          // Choose a partition element, v         int m = off + (len >> 1);       // Small arrays, middle element         if (len > 7) {             int l = off;             int n = off + len - 1;             if (len > 40) {        // Big arrays, pseudomedian of 9                 int s = len / 8;                 l = med3(q, l, l + s, l + 2 * s);                 m = med3(q, m - s, m, m + s);                 n = med3(q, n - 2 * s, n - s, n);             }             m = med3(q, l, m, n); // Mid-size, med of 3         }         // move the pivot element to to the front         q.swap(off, m);         m = off;          // Establish Invariant: m* (<m)* (>m)* m*         int a = off+1, b = a, c = off + len - 1, d = c;         int cmp;         while (true) {             while (b <= c && (cmp = q.compare(b, off)) <= 0) {                 if (cmp == 0)                     q.swap(a++, b);                 b++;             }             while (c >= b && (cmp = q.compare(c, off)) >= 0) {                 if (cmp == 0)                     q.swap(c, d--);                 c--;             }             if (b > c)                 break;             q.swap(b++, c--);         }          // Swap partition elements back to middle         int s, n = off + len;         s = Math.min(a - off, b - a);         vecswap(q, off, b - s, s);         s = Math.min(d - c, n - d - 1);         vecswap(q, b, n - s, s);          // Recursively sort non-partition-elements         if ((s = b - a) > 1)             sort1(q, off, k, s);         if ((s = d - c) > 1)             sort1(q, n - s, k, s);     }
@Deprecated     public static String parseRegionName(final String host,                                          final String serviceHint) {         String region = parseRegion(host, serviceHint);          // If region is null, then endpoint is totally non-standard;         // guess us-east-1 for lack of a better option.         return region == null ? ""us-east-1"" : region;     }
private static String getRealDeptId(String deptId){    int start=deptId.indexOf(""["");    String realKey=deptId;    if(start>0){     realKey=deptId.substring(0,start);    }    return realKey;   }
void write(ByteCodeWriter out)     throws IOException   {     out.write(ConstantPool.CP_UTF8);     out.writeUTF8(_value);   }
protected void sequence_XSynchronizedExpression(ISerializationContext context, XSynchronizedExpression semanticObject) {   if (errorAcceptor != null) {    if (transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XSYNCHRONIZED_EXPRESSION__PARAM) == ValueTransient.YES)     errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XSYNCHRONIZED_EXPRESSION__PARAM));    if (transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XSYNCHRONIZED_EXPRESSION__EXPRESSION) == ValueTransient.YES)     errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XSYNCHRONIZED_EXPRESSION__EXPRESSION));   }   SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);   feeder.accept(grammarAccess.getXSynchronizedExpressionAccess().getParamXExpressionParserRuleCall_1_0(), semanticObject.getParam());   feeder.accept(grammarAccess.getXSynchronizedExpressionAccess().getExpressionXExpressionParserRuleCall_3_0(), semanticObject.getExpression());   feeder.finish();  }
public String getRedirectUri(AccessTokenRequest request) {    String redirectUri = request.getFirst(""redirect_uri"");    if (redirectUri == null && request.getCurrentUri() != null && useCurrentUri) {    redirectUri = request.getCurrentUri();   }    if (redirectUri == null && getPreEstablishedRedirectUri() != null) {    // Override the redirect_uri if it is pre-registered    redirectUri = getPreEstablishedRedirectUri();   }    return redirectUri;   }
public boolean remove(Set<?> set, Object object) {   if (set == null || object == null) {    return false;   }      return set.remove(object);  }
public IntStream ones() {   return IntStream.range(0, length())    .filter(index -> bit.get(_genes, index));  }
public static LUDecomposition<FloatMatrix> lu(FloatMatrix A) {       int[] ipiv = new int[min(A.rows, A.columns)];       FloatMatrix result = A.dup();       NativeBlas.sgetrf(A.rows, A.columns, result.data, 0, A.rows, ipiv, 0);        // collect result       FloatMatrix l = new FloatMatrix(A.rows, min(A.rows, A.columns));       FloatMatrix u = new FloatMatrix(min(A.columns, A.rows), A.columns);       decomposeLowerUpper(result, l, u);       FloatMatrix p = Permutations.permutationFloatMatrixFromPivotIndices(A.rows, ipiv);       return new LUDecomposition<FloatMatrix>(l, u, p);   }
private boolean containsRestrictedPrefix(String tpl)  {   for (String i : blackPrefixList) {    if (tpl.startsWith(i))     return true;   }   return false;  }
public NormalizedUserProfile getUserProfileInfo(AccessToken accessTokenParam)     {         if(accessTokenParam == null || (accessTokenParam.getAccessToken() == null ||                 accessTokenParam.getAccessToken().trim().isEmpty()))         {             throw new FluidClientException(                     ""Code must be provided."",                     FluidClientException.ErrorCode.FIELD_VALIDATE);         }          try {             String accessToken = accessTokenParam.getAccessToken();              List<HeaderNameValue> headerListing = new ArrayList<HeaderNameValue>();              headerListing.add(new HeaderNameValue(                     NormalizedUserProfile.HeaderMapping.AUTHORIZATION,                     ""Bearer ""+accessToken));              return new NormalizedUserProfile(                     this.getJson(true, WS.Path.Auth0.Version1.userInfo(),headerListing));         }         //         catch (UnsupportedEncodingException e) {              throw new FluidClientException(                     ""Unable to Encode (Not Supported). ""+ e.getMessage(),                     FluidClientException.ErrorCode.ILLEGAL_STATE_ERROR);         }     }
public static java.sql.Date newDate() {         return new java.sql.Date((System.currentTimeMillis() / DAY_MILLIS) * DAY_MILLIS);     }
public final void castExpression() throws RecognitionException {   BaseDescr expr =null;    try {    // src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:521:5: ( ( LEFT_PAREN primitiveType )=> LEFT_PAREN primitiveType RIGHT_PAREN expr= unaryExpression | ( LEFT_PAREN type )=> LEFT_PAREN type RIGHT_PAREN unaryExpressionNotPlusMinus )    int alt54=2;    int LA54_0 = input.LA(1);    if ( (LA54_0==LEFT_PAREN) ) {     int LA54_1 = input.LA(2);     if ( (synpred17_DRL5Expressions()) ) {      alt54=1;     }     else if ( (synpred18_DRL5Expressions()) ) {      alt54=2;     }      else {      if (state.backtracking>0) {state.failed=true; return;}      int nvaeMark = input.mark();      try {       input.consume();       NoViableAltException nvae =        new NoViableAltException("""", 54, 1, input);       throw nvae;      } finally {       input.rewind(nvaeMark);      }     }     }     else {     if (state.backtracking>0) {state.failed=true; return;}     NoViableAltException nvae =      new NoViableAltException("""", 54, 0, input);     throw nvae;    }     switch (alt54) {     case 1 :      // src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:521:8: ( LEFT_PAREN primitiveType )=> LEFT_PAREN primitiveType RIGHT_PAREN expr= unaryExpression      {      match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_castExpression2593); if (state.failed) return;      pushFollow(FOLLOW_primitiveType_in_castExpression2595);      primitiveType();      state._fsp--;      if (state.failed) return;      match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_castExpression2597); if (state.failed) return;      pushFollow(FOLLOW_unaryExpression_in_castExpression2601);      expr=unaryExpression();      state._fsp--;      if (state.failed) return;      }      break;     case 2 :      // src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:522:8: ( LEFT_PAREN type )=> LEFT_PAREN type RIGHT_PAREN unaryExpressionNotPlusMinus      {      match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_castExpression2618); if (state.failed) return;      pushFollow(FOLLOW_type_in_castExpression2620);      type();      state._fsp--;      if (state.failed) return;      match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_castExpression2622); if (state.failed) return;      pushFollow(FOLLOW_unaryExpressionNotPlusMinus_in_castExpression2624);      unaryExpressionNotPlusMinus();      state._fsp--;      if (state.failed) return;      }      break;     }   }    catch (RecognitionException re) {       throw re;   }    finally {    // do for sure before leaving   }  }
@Override     public void markInitialState() {          super.markInitialState();         Converter c = getConverter();         if (c != null && c instanceof PartialStateHolder) {             ((PartialStateHolder) c).markInitialState();         }      }
private Sha256Hash recursiveExtractHashes(int height, int pos, ValuesUsed used, List<Sha256Hash> matchedHashes) throws VerificationException {         if (used.bitsUsed >= matchedChildBits.length*8) {             // overflowed the bits array - failure             throw new VerificationException(""PartialMerkleTree overflowed its bits array"");         }         boolean parentOfMatch = checkBitLE(matchedChildBits, used.bitsUsed++);         if (height == 0 || !parentOfMatch) {             // if at height 0, or nothing interesting below, use stored hash and do not descend             if (used.hashesUsed >= hashes.size()) {                 // overflowed the hash array - failure                 throw new VerificationException(""PartialMerkleTree overflowed its hash array"");             }             Sha256Hash hash = hashes.get(used.hashesUsed++);             if (height == 0 && parentOfMatch) // in case of height 0, we have a matched txid                 matchedHashes.add(hash);             return hash;         } else {             // otherwise, descend into the subtrees to extract matched txids and hashes             byte[] left = recursiveExtractHashes(height - 1, pos * 2, used, matchedHashes).getBytes(), right;             if (pos * 2 + 1 < getTreeWidth(transactionCount, height-1)) {                 right = recursiveExtractHashes(height - 1, pos * 2 + 1, used, matchedHashes).getBytes();                 if (Arrays.equals(right, left))                     throw new VerificationException(""Invalid merkle tree with duplicated left/right branches"");             } else {                 right = left;             }             // and combine them before returning             return combineLeftRight(left, right);         }     }
public AABBf setMax(float maxX, float maxY, float maxZ) {         this.maxX = maxX;         this.maxY = maxY;         this.maxZ = maxZ;         return this;     }
public IssueDto setComponentUuid(@Nullable String s) {     checkArgument(s == null || s.length() <= 50, ""Value is too long for column ISSUES.COMPONENT_UUID: %s"", s);     this.componentUuid = s;     return this;   }
public Object saveState(FacesContext context) {          if (context == null) {             throw new NullPointerException();         }         if (attachedObjects == null) {             return null;         }         if (initialState) {             Object[] attachedObjects = new Object[this.attachedObjects.size()];             boolean stateWritten = false;             for (int i = 0, len = attachedObjects.length; i < len; i++) {                 T attachedObject = this.attachedObjects.get(i);                 if (attachedObject instanceof StateHolder) {                     StateHolder sh = (StateHolder) attachedObject;                     if (!sh.isTransient()) {                         attachedObjects[i] = sh.saveState(context);                     }                     if (attachedObjects[i] != null) {                         stateWritten = true;                     }                 }             }             return ((stateWritten) ? attachedObjects : null);         } else {              Object[] attachedObjects = new Object[this.attachedObjects.size()];             for (int i = 0, len = attachedObjects.length; i < len; i++) {                 attachedObjects[i] = UIComponentBase.saveAttachedState(context, this.attachedObjects.get(i));             }             return (attachedObjects);         }      }
@Override     public com.spatial4j.core.shape.Shape toSpatial4j(SpatialContext spatialContext) {         return spatialContext.makePoint(longitude, latitude);     }
private static int toAnsi(int red, int green, int blue)     {         // rescale to 0-5 range         red = red * 6 / 256;         green = green * 6 / 256;         blue = blue * 6 / 256;          return 16 + red * 36 + green * 6 + blue;     }
private HttpOutboundServiceContextImpl getInterface(VirtualConnection inVC) {          if (null == this.myInterface) {             this.myInterface = new HttpOutboundServiceContextImpl((TCPConnectionContext) getDeviceLink().getChannelAccessor(), this, inVC, this.myChannel.getHttpConfig());         }         return this.myInterface;     }
public static final int lastIndexOf(char toBeFound, char[] array,    int startIndex, int endIndex)  {   for (int i = endIndex; --i >= startIndex;)   {    if (toBeFound == array[i])    {     return i;    }   }   return -1;  }
public void upsert(Term term, Document document) {         Log.debug(""Updating document %s with term %s"", document, term);         try {             indexWriter.updateDocument(term, document);         } catch (IOException e) {             Log.error(e, ""Error while updating document %s with term %s"", document, term);             throw new RuntimeException(e);         }     }
public  MaterialAccount getAccountAtCurrentPosition(int position) {          if (position < 0 || position >= accountManager.size())             throw  new RuntimeException(""Account Index Overflow"");          return findAccountNumber(position);     }
@Override protected void resizeDynamicText() {         double maxWidth = unitText.isVisible() ? width - size * 0.275 : width - size * 0.1;         double fontSize = size * 0.24;         valueText.setFont(Fonts.latoRegular(fontSize));         if (valueText.getLayoutBounds().getWidth() > maxWidth) { Helper.adjustTextSize(valueText, maxWidth, fontSize); }     }
public static void startTrack(final Object... args){      if(isClosed){ return; }      //--Create Record      final int len = args.length == 0 ? 0 : args.length-1;      final Object content = args.length == 0 ? """" : args[len];      final Object[] tags = new Object[len];      final StackTraceElement ste = getStackTrace();      final long timestamp = System.currentTimeMillis();      System.arraycopy(args,0,tags,0,len);      //--Create Task      final long threadID = Thread.currentThread().getId();      final Runnable startTrack = new Runnable(){        public void run(){          assert !isThreaded || control.isHeldByCurrentThread();          Record toPass = new Record(content,tags,depth,ste,timestamp);          depth += 1;          titleStack.push(args.length == 0 ? """" : args[len].toString());          handlers.process(toPass, MessageType.START_TRACK, depth, toPass.timesstamp);          assert !isThreaded || control.isHeldByCurrentThread();        }      };      //--Run Task      if(isThreaded){        //(case: multithreaded)        long threadId = Thread.currentThread().getId();        attemptThreadControl( threadId, startTrack );      } else {        //(case: no threading)        startTrack.run();      }    }
private RegisteredCommand searchCommands(String cmdOwner, HttpMethod method, String uri,                                               String query, Map<String, String> variableMap) {          Map<HttpMethod, SortedSet<RegisteredCommand>> evalMap = getCmdEvalMap(cmdOwner);          if (evalMap == null) {              return null;          }                    // Find the sorted command set for the given HTTP method.          SortedSet<RegisteredCommand> cmdSet = evalMap.get(method);          if (cmdSet == null) {              return null;          }                    // Split uri into a list of non-empty nodes.          List<String> pathNodeList = new ArrayList<>();          String[] pathNodes = uri.split(""/"");          for (String pathNode : pathNodes) {              if (pathNode.length() > 0) {                  pathNodeList.add(pathNode);              }          }                    // Attempt to match commands in this set in order.          for (RegisteredCommand cmd : cmdSet) {              if (cmd.matches(pathNodeList, query, variableMap)) {                  return cmd;              }          }          return null;      }
public EEnum getIfcControllerTypeEnum() {    if (ifcControllerTypeEnumEEnum == null) {     ifcControllerTypeEnumEEnum = (EEnum) EPackage.Registry.INSTANCE.getEPackage(Ifc2x3tc1Package.eNS_URI)       .getEClassifiers().get(800);    }    return ifcControllerTypeEnumEEnum;   }
protected Object readValue (Class type, Class elementType, Class defaultType)    throws YamlException, ParserException, TokenizerException {    String tag = null, anchor = null;    Event event = parser.peekNextEvent();      switch (event.type) {    case ALIAS:     parser.getNextEvent();     anchor = ((AliasEvent)event).anchor;     Object value = anchors.get(anchor);     if (value == null) throw new YamlReaderException(""Unknown anchor: "" + anchor);     return value;    case MAPPING_START:    case SEQUENCE_START:     tag = ((CollectionStartEvent)event).tag;     anchor = ((CollectionStartEvent)event).anchor;     break;    case SCALAR:     tag = ((ScalarEvent)event).tag;     anchor = ((ScalarEvent)event).anchor;     break;    default:    }      return readValueInternal(this.chooseType(tag, defaultType, type), elementType, anchor);   }
public void write(LangProfile langProfile, OutputStream outputStream) throws IOException {   try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(outputStream, Charset.forName(""utf-8"")))) {             writer.write(""{\""freq\"":{"");             boolean first = true;             for (Map.Entry<String, Integer> entry : langProfile.getFreq().entrySet()) {                 if (!first) {                     writer.write(',');                 }                 writer.write('""');                 writer.write(entry.getKey());                 writer.write(""\"":"");                 writer.write(entry.getValue().toString());                 first = false;             }             writer.write(""},\""n_words\"":["");             first = true;             for (int nWord : langProfile.getNWords()) {                 if (!first) {                     writer.write(',');                 }                 writer.write(Integer.toString(nWord));                 first = false;             }             writer.write(""],\""name\"":\"""");             writer.write(langProfile.getName());             writer.write(""\""}"");             writer.flush();         }  }
public final ServiceTracker<T, ServletContextHelperElement> create(final Class<? extends T> trackedClass) {    return new ServiceTracker<>(bundleContext, createFilter(bundleContext, trackedClass), this);   }
protected XmlMappingException convertCastorException(XMLException ex, boolean marshalling) {   if (ex instanceof ValidationException) {    return new ValidationFailureException(""Castor validation exception"", ex);   }   else if (ex instanceof MarshalException) {    if (marshalling) {     return new MarshallingFailureException(""Castor marshalling exception"", ex);    }    else {     return new UnmarshallingFailureException(""Castor unmarshalling exception"", ex);    }   }   else {    // fallback    return new UncategorizedMappingException(""Unknown Castor exception"", ex);   }  }
public double sim(DoubleVector v1, DoubleVector v2) {         double dotProduct = VectorMath.dotProduct(v1, v2);         return Math.pow(dotProduct + 1, degree);     }
@Action(name = ""Customize Linux Guest"",             outputs = {                     @Output(Outputs.RETURN_CODE),                     @Output(Outputs.RETURN_RESULT),                     @Output(Outputs.EXCEPTION)             },             responses = {                     @Response(text = Outputs.SUCCESS, field = Outputs.RETURN_CODE, value = Outputs.RETURN_CODE_SUCCESS,                             matchType = MatchType.COMPARE_EQUAL, responseType = ResponseType.RESOLVED),                     @Response(text = Outputs.FAILURE, field = Outputs.RETURN_CODE, value = Outputs.RETURN_CODE_FAILURE,                             matchType = MatchType.COMPARE_EQUAL, responseType = ResponseType.ERROR, isOnFail = true)             })     public Map<String, String> customizeLinuxGuest(@Param(value = Inputs.HOST, required = true) String host,                                                    @Param(value = PORT) String port,                                                    @Param(value = PROTOCOL) String protocol,                                                    @Param(value = USERNAME, required = true) String username,                                                    @Param(value = PASSWORD, encrypted = true) String password,                                                    @Param(value = TRUST_EVERYONE) String trustEveryone,                                                    @Param(value = CLOSE_SESSION) String closeSession,                                                     @Param(value = VM_NAME, required = true) String virtualMachineName,                                                    @Param(value = COMPUTER_NAME, required = true) String computerName,                                                    @Param(value = DOMAIN) String domain,                                                    @Param(value = IP_ADDRESS) String ipAddress,                                                    @Param(value = SUBNET_MASK) String subnetMask,                                                    @Param(value = DEFAULT_GATEWAY) String defaultGateway,                                                    @Param(value = UTC_CLOCK) String hwClockUTC,                                                    @Param(value = TIME_ZONE) String timeZone,                                                    @Param(value = VMWARE_GLOBAL_SESSION_OBJECT) GlobalSessionObject<Map<String, Connection>> globalSessionObject) {           try {             final HttpInputs httpInputs = new HttpInputs.HttpInputsBuilder()                     .withHost(host)                     .withPort(port)                     .withProtocol(protocol)                     .withUsername(username)                     .withPassword(password)                     .withTrustEveryone(defaultIfEmpty(trustEveryone, FALSE))                     .withCloseSession(defaultIfEmpty(closeSession, TRUE))                     .withGlobalSessionObject(globalSessionObject)                     .build();              final VmInputs vmInputs = new VmInputs.VmInputsBuilder().withVirtualMachineName(virtualMachineName).build();              final GuestInputs guestInputs = new GuestInputs.GuestInputsBuilder()                     .withComputerName(computerName)                     .withDomain(domain)                     .withIpAddress(ipAddress)                     .withSubnetMask(subnetMask)                     .withDefaultGateway(defaultGateway)                     .withHwClockUTC(hwClockUTC)                     .withTimeZone(timeZone)                     .build();              return new GuestService().customizeVM(httpInputs, vmInputs, guestInputs, false);         } catch (Exception ex) {             return OutputUtilities.getFailureResultsMap(ex);         }      }
public int getAttempts() {         String attempts = this.properties.get(""attempts"");         if (attempts == null) {             attempts = ""0"";         }          return Integer.parseInt(attempts);     }
private int ensureIndex(int key, boolean intType) {         int index = -1;         int firstDeleted = -1;         int[] keys = this.keys;         if (keys != null) {             int fraction = key * A;             index = fraction >>> (32 - power);             int entry = keys[index];             if (entry == key) { return index; }             if (entry != EMPTY) {                 if (entry == DELETED) { firstDeleted = index; }                 // Search in table after first failed attempt                 int mask = (1 << power) - 1;                 int step = tableLookupStep(fraction, mask, power);                 int n = 0;                 do {                     if (check) {                         if (n >= occupiedCount) Kit.codeBug();                         ++n;                     }                     index = (index + step) & mask;                     entry = keys[index];                     if (entry == key) { return index; }                     if (entry == DELETED && firstDeleted < 0) {                         firstDeleted = index;                     }                 } while (entry != EMPTY);             }         }         // Inserting of new key         if (check && keys != null && keys[index] != EMPTY)             Kit.codeBug();         if (firstDeleted >= 0) {             index = firstDeleted;         }         else {             // Need to consume empty entry: check occupation level             if (keys == null || occupiedCount * 4 >= (1 << power) * 3) {                 // Too litle unused entries: rehash                 rehashTable(intType);                 return insertNewKey(key);             }             ++occupiedCount;         }         keys[index] = key;         ++keyCount;         return index;     }
@Override  public int compareTo(final StorageSize that)  {   if (that == null)    throw new NullPointerException(""Cannot compareTo a null value!"");    return this.getBits().compareTo(that.getBits());  }
public <X> X until(Callable<X> condition) {     long end = clock.laterBy(timeout.in(MILLISECONDS));     Exception lastException = null;      while (true) {       try {         X toReturn = condition.call();          if (toReturn != null && Boolean.class.equals(toReturn.getClass())) {           if (Boolean.TRUE.equals(toReturn)) {             return toReturn;           }         } else if (toReturn != null) {           return toReturn;         }       } catch (Exception e) {         lastException = propagateIfNotIgnored(e);       }        if (!clock.isNowBefore(end)) {         String toAppend =             (message == null) ? "" waiting for "" + condition.toString() : "": "" + message;          String timeoutMessage = String.format(""Timed out after %d milliseconds%s"",                                               timeout.in(MILLISECONDS), toAppend);         throw timeoutException(timeoutMessage, lastException);       }        try {         sleeper.sleep(interval);       } catch (InterruptedException e) {         Thread.currentThread().interrupt();         throw new WebDriverException(e);       }     }   }
private int compareToReleaseMinor(GitVersion that) {         if (this.containsReleaseMinor() && that.containsReleaseMinor())             return compareToInt(this.getReleaseMinor(), that.getReleaseMinor());         else if (!this.containsReleaseMinor() && !that.containsReleaseMinor())             return SAME;         else if (this.containsReleaseMinor() && !that.containsReleaseMinor())             return LATER;         else             return PREVIOUS;     }
@Nonnull   public static String getPathWithinServletContext (@Nonnull final HttpServletRequest aHttpRequest)   {     ValueEnforcer.notNull (aHttpRequest, ""HttpRequest"");      final String sRequestURI = getRequestURI (aHttpRequest);     if (StringHelper.hasNoText (sRequestURI))     {       // Can e.g. happen for ""Request(GET //localhost:90/)""       if (LOGGER.isDebugEnabled ())         LOGGER.debug (""Having empty request URI '"" + sRequestURI + ""' from request "" + aHttpRequest);       return ""/"";     }      // Always use the context path     final String sContextPath = ServletContextPathHolder.getContextPath ();     if (StringHelper.hasNoText (sContextPath) || !sRequestURI.startsWith (sContextPath))       return sRequestURI;      // Normal case: URI contains context path.     final String sPath = sRequestURI.substring (sContextPath.length ());     return sPath.length () > 0 ? sPath : ""/"";   }
public static IOException create(IOException exn)   {     if (exn.getClass().equals(IOException.class)         || exn.getClass().equals(java.net.SocketException.class)         || exn.getClass().getName().equals(""javax.net.ssl.SSLException""))       return new SocketTimeoutException(exn);     else       return exn;   }
public void marshall(DescribePipelineRequest describePipelineRequest, ProtocolMarshaller protocolMarshaller) {          if (describePipelineRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(describePipelineRequest.getPipelineName(), PIPELINENAME_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
private void initDataDictionaryMap() {         DataDictionary dd = rawPmml.getDataDictionary();         if (dd != null) {             dataDictionaryMap = new HashMap<>();             for (DataField dataField : dd.getDataFields()) {                 PMMLDataField df = new PMMLDataField(dataField);                 dataDictionaryMap.put(df.getName(), df);             }         } else {             throw new IllegalStateException(""BRMS-PMML requires a data dictionary section in the definition file"");         }     }
@Override     public List readAll(final String tableName, Class clazz, EntityMetadata m, final List<Object> rowKey,             List<String> relationNames, String... columns) throws IOException     {         Table hTable = gethTable(tableName);         List<HBaseDataWrapper> results = ((HBaseReader) hbaseReader).loadAll(hTable, rowKey, null, columns);         return onRead(m, null, hTable, results);     }
private void readAllImagesAndVariations(String root) {          File basedir = new File(CmsImageLoader.getImageRepositoryPath() + root);         visitImages(m_clonedCms, basedir);         m_variations = Collections.unmodifiableMap(m_variations);         m_sizes = Collections.unmodifiableMap(m_sizes);         m_lengths = Collections.unmodifiableMap(m_lengths);      }
public ServiceFuture<List<SyncDatabaseIdPropertiesInner>> listSyncDatabaseIdsNextAsync(final String nextPageLink, final ServiceFuture<List<SyncDatabaseIdPropertiesInner>> serviceFuture, final ListOperationCallback<SyncDatabaseIdPropertiesInner> serviceCallback) {         return AzureServiceFuture.fromPageResponse(             listSyncDatabaseIdsNextSinglePageAsync(nextPageLink),             new Func1<String, Observable<ServiceResponse<Page<SyncDatabaseIdPropertiesInner>>>>() {                 @Override                 public Observable<ServiceResponse<Page<SyncDatabaseIdPropertiesInner>>> call(String nextPageLink) {                     return listSyncDatabaseIdsNextSinglePageAsync(nextPageLink);                 }             },             serviceCallback);     }
public SDVariable eye(SDVariable rows, SDVariable cols, SDVariable batchDimension) {         return eye(null, rows, cols, batchDimension);     }
public EthereumBlock readBlock() throws IOException, EthereumBlockReadException {   ByteBuffer rawBlock = this.readRawBlock();   if (rawBlock==null) {    return null;   }   RLPObject blockObject =  EthereumUtil.rlpDecodeNextItem(rawBlock);   if ((blockObject==null) || (!(blockObject instanceof RLPList))){    throw new EthereumBlockReadException(""Invalid Ethereum Block: Not encoded RLPList"");   }   RLPList block = (RLPList)blockObject;   // block header   RLPList rlpHeader = (RLPList) block.getRlpList().get(0);   // transactions   RLPList rlpTransactions = (RLPList) block.getRlpList().get(1);   // uncles   RLPList rlpUncles =  (RLPList) block.getRlpList().get(2);   //// create header object   EthereumBlockHeader ethereumBlockHeader = parseRLPBlockHeader(rlpHeader);   List<EthereumTransaction> ethereumTransactions = parseRLPTransactions(rlpTransactions);   List<EthereumBlockHeader> uncleHeaders = parseRLPUncleHeaders(rlpUncles);    return new EthereumBlock(ethereumBlockHeader,ethereumTransactions,uncleHeaders);  }
public void add(final ClassLoader classLoader) {         if (classLoader == null) {             return;         }         if (added.add(classLoader)) {             final ClassLoaderHandlerRegistryEntry entry = getRegistryEntry(classLoader);             if (entry != null) {                 classLoaderOrder.add(new SimpleEntry<>(classLoader, entry));             }         }     }
@SuppressWarnings(""unchecked"")   @Override   public EList<IfcObjectDefinition> getRelatedObjects() {    return (EList<IfcObjectDefinition>) eGet(Ifc4Package.Literals.IFC_REL_ASSIGNS__RELATED_OBJECTS, true);   }
public Yasson doWith(final Consumer<JsonbConfig> configurer) {     requireNonNull(configurer, ""Configurer callback is required."");     this.configurer = (jsonConfig, conf) -> configurer.accept(jsonConfig);     return this;   }
@NullSafe   public static String toLowerCase(String value) {     return value != null ? value.toLowerCase() : null;   }
public SIBusMessage nextLocked()       throws SISessionUnavailableException, SISessionDroppedException,              SIConnectionUnavailableException, SIConnectionDroppedException,              SIResourceException, SIConnectionLostException,               SIErrorException    {       if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc,""nextLocked"");       JsMessage retMsg = null;              synchronized(lmeOperationMonitor)       {          checkValid();                       // At this point we look at each item in the array up to end of the array for the next          // non-null item. This is because some points in the array may be null if they have been          // deleted or unlocked.          while (nextIndex != messages.length)          {             retMsg = messages[nextIndex];             nextIndex++;                          if (retMsg != null) break;          }       }              if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc,""nextLocked"", retMsg);       return retMsg;  }
public static String createTimestampAntiLeechUrl(             String host, String fileName, final StringMap queryStringMap, String encryptKey, long deadline)             throws QiniuException {         URL urlObj = null;         try {             String urlToSign = null;             if (queryStringMap != null && queryStringMap.size() > 0) {                 List<String> queryStrings = new ArrayList<String>();                 for (Map.Entry<String, Object> entry : queryStringMap.map().entrySet()) {                     StringBuilder queryStringBuilder = new StringBuilder();                     queryStringBuilder.append(URLEncoder.encode(entry.getKey(), ""utf-8""));                     queryStringBuilder.append(""="");                     queryStringBuilder.append(URLEncoder.encode(entry.getValue().toString(), ""utf-8""));                     queryStrings.add(queryStringBuilder.toString());                 }                 urlToSign = String.format(""%s/%s?%s"", host, fileName, StringUtils.join(queryStrings, ""&""));             } else {                 urlToSign = String.format(""%s/%s"", host, fileName);             }              urlObj = new URL(urlToSign);         } catch (Exception e) {             throw new QiniuException(e, ""timestamp anti leech failed"");         }         return createTimestampAntiLeechUrl(urlObj, encryptKey, deadline);     }
public void writeClosePortal(String portal) {     ensureBuffer();     int pos = out.writerIndex();     out.writeByte(CLOSE);     out.writeInt(0);     out.writeByte('P'); // 'S' to close a prepared statement or 'P' to close a portal     Util.writeCStringUTF8(out, portal);     out.setInt(pos + 1, out.writerIndex() - pos - 1);   }
@Override     public void attachView(@NonNull V view) {         presenterDestroyed = false;         viewRef = new WeakReference<V>(view);         runQueuedActions();     }
public static <T> List<T> reverse(List<T> list) {    Collections.reverse(list);    return list;   }
public java.lang.String getVariableName() {     java.lang.Object ref = variableName_;     if (ref instanceof java.lang.String) {       return (java.lang.String) ref;     } else {       com.google.protobuf.ByteString bs =            (com.google.protobuf.ByteString) ref;       java.lang.String s = bs.toStringUtf8();       variableName_ = s;       return s;     }   }
protected void initMaxCellWidth() {          m_maxCellWidth = m_opener.getOffsetWidth() - 2 /*border*/;         for (Widget widget : m_selector) {             if (widget instanceof A_CmsSelectCell) {                 int cellWidth = ((A_CmsSelectCell)widget).getRequiredWidth();                 if (cellWidth > m_maxCellWidth) {                     m_maxCellWidth = cellWidth;                 }             }         }     }
public static OrderBook adaptOrderBook(EXXOrderbook exxOrderbook, CurrencyPair currencyPair) {     List<LimitOrder> asks = new ArrayList<LimitOrder>();     List<LimitOrder> bids = new ArrayList<LimitOrder>();      for (BigDecimal[] exxAsk : exxOrderbook.getAsks()) {       asks.add(new LimitOrder(OrderType.ASK, exxAsk[1], currencyPair, null, null, exxAsk[0]));     }      for (BigDecimal[] exxBid : exxOrderbook.getBids()) {       bids.add(new LimitOrder(OrderType.BID, exxBid[1], currencyPair, null, null, exxBid[0]));     }      return new OrderBook(new Date(), asks, bids);   }
public boolean waitForFragmentById(int id, int timeout){   if(config.commandLogging){    Log.d(config.commandLoggingTag, ""waitForFragmentById(""+id+"", ""+timeout+"")"");   }      return waiter.waitForFragment(null, id, timeout);  }
public static void debug(String format, Object... arguments) {    debug(LogFactory.get(CallerUtil.getCallerCaller()), format, arguments);   }
private <T> Iterator<T> getAll(String entityType, IUnmarshaller<T> unmarshaller) throws StorageException {         String query = matchAllQuery();         return getAll(entityType, unmarshaller, query);     }
private void updateOneConfFile(String fileName, DisconfCenterFile disconfCenterFile) throws Exception {          if (disconfCenterFile == null) {             throw new Exception(""cannot find disconfCenterFile "" + fileName);         }          String filePath = fileName;         Map<String, Object> dataMap = new HashMap<String, Object>();          //         // 开启disconf才需要远程下载, 否则就本地就好         //         if (DisClientConfig.getInstance().ENABLE_DISCONF) {              //             // 下载配置             //             try {                  String url = disconfCenterFile.getRemoteServerUrl();                 filePath = fetcherMgr.downloadFileFromServer(url, fileName, disconfCenterFile.getFileDir());              } catch (Exception e) {                  //                 // 下载失败了, 尝试使用本地的配置                 //                  LOGGER.error(e.toString(), e);                 LOGGER.warn(""using local properties in class path: "" + fileName);                  // change file path                 filePath = fileName;             }             LOGGER.debug(""download ok."");         }          try {             dataMap = FileTypeProcessorUtils.getKvMap(disconfCenterFile.getSupportFileTypeEnum(),                     disconfCenterFile.getFilePath());         } catch (Exception e) {             LOGGER.error(""cannot get kv data for "" + filePath, e);         }          //         // 注入到仓库中         //         disconfStoreProcessor.inject2Store(fileName, new DisconfValue(null, dataMap));         LOGGER.debug(""inject ok."");          //         // 开启disconf才需要进行watch         //         if (DisClientConfig.getInstance().ENABLE_DISCONF) {             //             // Watch             //             DisConfCommonModel disConfCommonModel = disconfStoreProcessor.getCommonModel(fileName);             if (watchMgr != null) {                 watchMgr.watchPath(this, disConfCommonModel, fileName, DisConfigTypeEnum.FILE,                         GsonUtils.toJson(disconfCenterFile.getKV()));                 LOGGER.debug(""watch ok."");             } else {                 LOGGER.warn(""cannot monitor {} because watch mgr is null"", fileName);             }         }     }
@Override     public ResendContactReachabilityEmailResult resendContactReachabilityEmail(ResendContactReachabilityEmailRequest request) {         request = beforeClientExecution(request);         return executeResendContactReachabilityEmail(request);     }
public static void setValue(ExpressionAccessor expression, OgnlContext context,                                 Object root, Object value)     {         expression.set(context, root, value);     }
@Override     public ScheduledEntry<K, V> get(K key) {         synchronized (mutex) {             if (scheduleType.equals(ScheduleType.FOR_EACH)) {                 return getByCompositeKey(key);             }             Integer second = secondsOfKeys.get(key);             if (second != null) {                 Map<Object, ScheduledEntry<K, V>> entries = scheduledEntries.get(second);                 if (entries != null) {                     return entries.get(key);                 }             }             return null;         }     }
static int makeKey(int center, int subcenter, int version) {      if (center < 0) center = 255;      if (subcenter < 0) subcenter = 255;      if (version < 0) version = 255;      return center * 1000 * 1000 + subcenter * 1000 + version;    }
public ServiceFuture<DenyAssignmentInner> getAsync(String scope, String denyAssignmentId, final ServiceCallback<DenyAssignmentInner> serviceCallback) {         return ServiceFuture.fromResponse(getWithServiceResponseAsync(scope, denyAssignmentId), serviceCallback);     }
public ModelAndView getRuleNode(String surt) throws URIException {         return new ModelAndView(view, ""object"", ruleDao.getRulesWithExactSurt(surt));             }
public static ComputationGraphSpace fromYaml(String yaml) {         try {             return YamlMapper.getMapper().readValue(yaml, ComputationGraphSpace.class);         } catch (IOException e) {             throw new RuntimeException(e);         }     }
private int[] hiddenIndices(boolean[] disclosure) {         if (disclosure == null) {             throw new IllegalArgumentException(""cannot compute hidden indices of null disclosure"");         }         List<Integer> hiddenIndicesList = new ArrayList<>();         for (int i = 0; i < disclosure.length; i++) {             if (!disclosure[i]) {                 hiddenIndicesList.add(i);             }         }         int[] hiddenIndices = new int[hiddenIndicesList.size()];         for (int i = 0; i < hiddenIndicesList.size(); i++) {             hiddenIndices[i] = hiddenIndicesList.get(i);         }          return hiddenIndices;     }
public static Builder builder() {     return new AutoValue_OffsetPaginationConfiguration.Builder()         .setDefaultOffset(0L)         .setDefaultLimit(20)         .setMaxLimit(100)         .setLimitFieldName(""limit"")         .setOffsetFieldName(""offset"")         .setAllowZeroLimit(false);   }
@Override     public Request<DescribeAddressesRequest> getDryRunRequest() {         Request<DescribeAddressesRequest> request = new DescribeAddressesRequestMarshaller().marshall(this);         request.addParameter(""DryRun"", Boolean.toString(true));         return request;     }
private DatanodeDescriptor[] chooseTargetF4(       String fileName,       int numOfReplicas,       DatanodeDescriptor writer,       List<DatanodeDescriptor> chosenNodes,       List<Node> exclNodes,       long blocksize) {     FSNamesystem.LOG.info(""F4: F4 policy invoked for file: "" + fileName +       "", with replica count: "" + numOfReplicas);     // If replica>1 then just default back to RAID     if (numOfReplicas > 1) {       return super.chooseTarget(         numOfReplicas, writer, chosenNodes, exclNodes, blocksize);     }     FileInfo info;     LocatedBlocks blocks;     int blockIndex = -1;     try {       blocks = this.namesystem.getBlockLocations(fileName, 0, Long.MAX_VALUE);       info = getFileInfo(null, fileName);       blockIndex = blocks.getLocatedBlocks().size();     } catch (IOException e) {       FSNamesystem.LOG.error(         ""F4: Error happened when calling getFileInfo/getBlockLocations"");       return super.chooseTarget(         fileName, numOfReplicas, writer, chosenNodes, exclNodes, blocksize);     }     FSNamesystem.LOG.info(       ""F4: The file: "" + fileName + "" has a type: "" + info.type);     HashMap<String, HashSet<Node>> rackToHosts =       new HashMap<String, HashSet<Node>>();     try {        // First handle the ""localdir"" case       if (isLocal(fileName)) {         return chooseLocalTarget(fileName,                                  writer,                                  blocks,                                  exclNodes,                                  chosenNodes,                                  blocksize);       }        // For a data file, the locations of its own blocks as the reference       int stripeIndex = -1;       String srcFileName = null;       String parityFileName = null;       int parityLength = 0;       int stripeLength = 0;       switch (info.type) {         case NOT_RAID:         case SOURCE:           srcFileName = fileName;           parityFileName = null;           stripeLength = this.stripeLen;           stripeIndex = blockIndex / stripeLength;           break;         case TEMP_PARITY:         case PARITY:           srcFileName = getSourceFileFromParity(fileName, info);           parityFileName = fileName;           if (srcFileName == null ||               this.namesystem.getHdfsFileInfo(srcFileName) == null) {             srcFileName = null;             FSNamesystem.LOG.error(""F4: "" + srcFileName + "" does not exist"");           }           Codec c = getCodec(fileName);           parityLength = c.parityLength;           stripeLength = c.stripeLength;           stripeIndex = blockIndex / parityLength;           break;         default:           return super.chooseTarget(             numOfReplicas, writer, chosenNodes, exclNodes, blocksize);       }        rackToHosts = getRackToHostsMapForStripe(srcFileName,                                                parityFileName,                                                stripeLength,                                                parityLength,                                                stripeIndex);     } catch (IOException e) {       FSNamesystem.LOG.error(""F4: Error happened when calling ""         + ""getParityFile/getSourceFileFromParity"");       return super.chooseTarget(           numOfReplicas, writer, chosenNodes, exclNodes, blocksize);     } catch (NotEnoughReplicasException e) {       FSNamesystem.LOG.error(""F4: Error happend when calling ""         + ""getCompanionSourceNodes/getSourceFile"");       return super.chooseTarget(           numOfReplicas, writer, chosenNodes, exclNodes, blocksize);     }     return chooseTargetOnNewFailureDomain(fileName,                                           writer,                                           chosenNodes,                                           exclNodes,                                           rackToHosts,                                           blocksize);   }
public static String stringifyAliasesParameters(Map<Byte, AbstractType<?>> aliases)     {         StringBuilder sb = new StringBuilder();         sb.append('(');         Iterator<Map.Entry<Byte, AbstractType<?>>> iter = aliases.entrySet().iterator();         if (iter.hasNext())         {             Map.Entry<Byte, AbstractType<?>> entry = iter.next();             sb.append((char)(byte)entry.getKey()).append(""=>"").append(entry.getValue());         }         while (iter.hasNext())         {             Map.Entry<Byte, AbstractType<?>> entry = iter.next();             sb.append(',').append((char)(byte)entry.getKey()).append(""=>"").append(entry.getValue());         }         sb.append(')');         return sb.toString();     }
@Override     public void to(final NodeDescriptor descriptor, final OutputStream output) throws DescriptorExportException,         IllegalArgumentException {         // Precondition checks         if (descriptor == null) {             throw new IllegalArgumentException(""descriptor must be specified"");         }         if (output == null) {             throw new IllegalArgumentException(""stream must be specified"");         }          // Get the root node         final Node root = descriptor.getRootNode();          // Delegate         this.to(root, output);     }
private static Document getDocument(URL pathToPersistenceXml) throws InvalidConfigurationException      {          InputStream is = null;          Document xmlRootNode = null;            try          {              if (pathToPersistenceXml != null)              {                  URLConnection conn = pathToPersistenceXml.openConnection();                  conn.setUseCaches(false); // avoid JAR locking on Windows and                                            // Tomcat.                  is = conn.getInputStream();              }                if (is == null)              {                  throw new IOException(""Failed to obtain InputStream from url: "" + pathToPersistenceXml);              }                xmlRootNode = parseDocument(is);              validateDocumentAgainstSchema(xmlRootNode);          }          catch (IOException e)          {              throw new InvalidConfigurationException(e);          }          finally          {              if (is != null)              {                  try                  {                      is.close();                  }                  catch (IOException ex)                  {                      log.warn(""Input stream could not be closed after parsing persistence.xml, caused by: {}"", ex);                  }              }          }            return xmlRootNode;      }
public static boolean isTel(String value) {         String check = ""^\\d{3,4}-?\\d{7,9}$"";         return match(check, Pattern.CASE_INSENSITIVE, value);     }
public void updateVolume(int volumeValue) {         if (null != dialog && dialog.isShowing()) {             int index = volumeValue / 600;             if (index >= volumes.length - 1) {                 index = volumes.length - 1;             }             mImageView.setImageResource(volumes[index]);         }     }
protected Service restoreAuthenticationRequestInContext(final RequestContext requestContext,                                                             final J2EContext webContext,                                                             final String clientName) {         val logoutEndpoint = isLogoutRequest(webContext.getRequest());         if (logoutEndpoint) {             return null;         } else {             try {                 val client = (BaseClient<Credentials, CommonProfile>) this.clients.findClient(clientName);                 return delegatedClientWebflowManager.retrieve(requestContext, webContext, client);             } catch (final Exception e) {                 LOGGER.error(e.getMessage(), e);             }             throw new UnauthorizedServiceException(UnauthorizedServiceException.CODE_UNAUTHZ_SERVICE, ""Service unauthorized"");         }     }
public static Type getType(final Class<?> clazz) {     if (clazz.isPrimitive()) {       if (clazz == Integer.TYPE) {         return INT_TYPE;       } else if (clazz == Void.TYPE) {         return VOID_TYPE;       } else if (clazz == Boolean.TYPE) {         return BOOLEAN_TYPE;       } else if (clazz == Byte.TYPE) {         return BYTE_TYPE;       } else if (clazz == Character.TYPE) {         return CHAR_TYPE;       } else if (clazz == Short.TYPE) {         return SHORT_TYPE;       } else if (clazz == Double.TYPE) {         return DOUBLE_TYPE;       } else if (clazz == Float.TYPE) {         return FLOAT_TYPE;       } else if (clazz == Long.TYPE) {         return LONG_TYPE;       } else {         throw new AssertionError();       }     } else {       return getType(getDescriptor(clazz));     }   }
public void execute()         throws MojoExecutionException, MojoFailureException     {         if ( isSkip() )         {             getLog().info( ""skipping execute as per configuration"" );             return;         }         if ( killAfter != -1 )         {             getLog().warn( ""Warning: killAfter is now deprecated. Do you need it ? Please comment on MEXEC-6."" );         }          if ( null == arguments )         {             arguments = new String[0];         }          if ( getLog().isDebugEnabled() )         {             StringBuffer msg = new StringBuffer( ""Invoking : "" );             msg.append( mainClass );             msg.append( "".main("" );             for ( int i = 0; i < arguments.length; i++ )             {                 if ( i > 0 )                 {                     msg.append( "", "" );                 }                 msg.append( arguments[i] );             }             msg.append( "")"" );             getLog().debug( msg );         }          IsolatedThreadGroup threadGroup = new IsolatedThreadGroup( mainClass /* name */ );         Thread bootstrapThread = new Thread( threadGroup, new Runnable()         {             public void run()             {                 int sepIndex = mainClass.indexOf( '/' );                  final String bootClassName;                 if ( sepIndex >= 0 )                 {                     bootClassName = mainClass.substring( sepIndex + 1 );                 }                 else                  {                     bootClassName = mainClass;                 }                                  try                 {                     Class<?> bootClass = Thread.currentThread().getContextClassLoader().loadClass( bootClassName );                                          MethodHandles.Lookup lookup = MethodHandles.lookup();                      MethodHandle mainHandle =                         lookup.findStatic( bootClass, ""main"",                                                  MethodType.methodType( void.class, String[].class ) );                                          mainHandle.invoke( arguments );                 }                 catch ( IllegalAccessException e )                 { // just pass it on                     Thread.currentThread().getThreadGroup().uncaughtException( Thread.currentThread(),                                                                                new Exception( ""The specified mainClass doesn't contain a main method with appropriate signature."",                                                                                               e ) );                 }                 catch ( InvocationTargetException e )                 { // use the cause if available to improve the plugin execution output                    Throwable exceptionToReport = e.getCause() != null ? e.getCause() : e;                    Thread.currentThread().getThreadGroup().uncaughtException( Thread.currentThread(), exceptionToReport );                 }                 catch ( Throwable e )                 { // just pass it on                     Thread.currentThread().getThreadGroup().uncaughtException( Thread.currentThread(), e );                 }             }         }, mainClass + "".main()"" );         bootstrapThread.setContextClassLoader( getClassLoader() );         setSystemProperties();          bootstrapThread.start();         joinNonDaemonThreads( threadGroup );         // It's plausible that spontaneously a non-daemon thread might be created as we try and shut down,         // but it's too late since the termination condition (only daemon threads) has been triggered.         if ( keepAlive )         {             getLog().warn( ""Warning: keepAlive is now deprecated and obsolete. Do you need it? Please comment on MEXEC-6."" );             waitFor( 0 );         }          if ( cleanupDaemonThreads )         {              terminateThreads( threadGroup );              try             {                 threadGroup.destroy();             }             catch ( IllegalThreadStateException e )             {                 getLog().warn( ""Couldn't destroy threadgroup "" + threadGroup, e );             }         }          if ( originalSystemProperties != null )         {             System.setProperties( originalSystemProperties );         }          synchronized ( threadGroup )         {             if ( threadGroup.uncaughtException != null )             {                 throw new MojoExecutionException( ""An exception occured while executing the Java class. ""                     + threadGroup.uncaughtException.getMessage(), threadGroup.uncaughtException );             }         }          registerSourceRoots();     }
protected ToolStrip buildTools() {         ToolStrip tools = new ToolStrip();         tools.addToolButtonRight(new ToolButton(Console.CONSTANTS.common_label_add(), new ClickHandler() {             @Override             public void onClick(ClickEvent event) {                 onAdd();             }         }));         tools.addToolButtonRight(new ToolButton(Console.CONSTANTS.common_label_delete(), new ClickHandler() {             @Override             public void onClick(ClickEvent event) {                 onRemove(selectionModel.getSelectedObject().getName());             }         }));         return tools;     }
public static Integer versionCompareNumerically(String str1, String str2) {         String[] vals1 = str1.split(""\\."");         String[] vals2 = str2.split(""\\."");         int i = 0;         // set index to first non-equal ordinal or length of shortest version string         while (i < vals1.length && i < vals2.length && vals1[i].equals(vals2[i])) {             i++;         }         try {             // compare first non-equal ordinal number             if (i < vals1.length && i < vals2.length) {                 int diff = Integer.valueOf(vals1[i]).compareTo(Integer.valueOf(vals2[i]));                 return Integer.signum(diff);             }             // the strings are equal or one string is a substring of the other             // e.g. ""1.2.3"" = ""1.2.3"" or ""1.2.3"" < ""1.2.3.4""             else {                 return Integer.signum(vals1.length - vals2.length);             }         } catch (NumberFormatException e) {             // Possibly there are different versions of the app in the store, so we can't check.             return 0;         }     }
protected void initCache(ClassTraversal traversal) {     if (m_CacheNames == null)       m_CacheNames = new HashMap<>();     if (m_CacheClasses == null)       m_CacheClasses = new HashMap<>();     if (m_BlackListed == null)       m_BlackListed = new HashSet<>();     if (m_Cache == null)       m_Cache = newClassCache(traversal);   }
private static List<SerialRow> assembleRowsListFromRowsMapping(     final List<SerialRow> all, final List<SerialRow> current) {    List<SerialRow> list;    if (all == null) {     list = new ArrayList<>();     list.addAll(current);    } else {     list = all;     for (SerialRow row : current) {      if (!all.contains(row)) {       list.add(row);      }     }    }    return list;   }
@NotNull     public CommandExecutor build() {         return new DefaultCommandExecutor(                 logger!=null ? logger : defaultLogger,                 cache!=null ? cache : new ExecutorCache(),                 extensions==null ? Collections.<ModeExtension>emptyList() : extensions         );     }
protected List<Team> updateTeamInformation(FeatureCollector collector) {         long projectDataStart = System.currentTimeMillis();         List<Team> teams = featureSettings.isJiraBoardAsTeam() ? jiraClient.getBoards() : jiraClient.getTeams();         //Add or update teams that we got from api         teams.forEach(newTeam -> {             String teamId = newTeam.getTeamId();             newTeam.setCollectorId(collector.getId());             LOGGER.info(String.format(""Adding %s:%s-%s"", collector.getMode(), teamId, newTeam.getName()));             Team existing = teamRepository.findByTeamId(teamId);             if (existing == null) {                 teamRepository.save(newTeam);             } else {                 newTeam.setId(existing.getId());                 teamRepository.save(newTeam);             }         });         log(collector.getMode() + "" Data Collected. Added "", projectDataStart, teams.size());         projectDataStart = System.currentTimeMillis();          // Delete the ones that are gone from JIRA         List<Team> existingTeams = teamRepository.findByCollectorId(collector.getId());         Set<String> newTeamIds = teams.stream().map(Team::getTeamId).collect(Collectors.toSet());         Set<Team> toDelete = existingTeams.stream().filter(e -> !newTeamIds.contains(e.getTeamId())).collect(Collectors.toSet());          if (!CollectionUtils.isEmpty(toDelete)) {             toDelete.forEach(td -> {                 LOGGER.info(String.format(""Deleting %s:%s-%s"", collector.getMode(), td.getTeamId(), td.getName()));             });             teamRepository.delete(toDelete);             log(collector.getMode() + "" Data Collected. Deleted "", projectDataStart, toDelete.size());         }         return teams;     }
private static double contClassicLB(final double numSamplesF, final double theta,       final double numSDev) {     final double nHat = (numSamplesF - 0.5) / theta;     final double b = numSDev * Math.sqrt((1.0 - theta) / theta);     final double d  = 0.5 * b * Math.sqrt((b * b) + (4.0 * nHat));     final double center = nHat + (0.5 * (b * b));     return (center - d);   }
@Override     public void register(BindingRegisterContext<JsonArray> ctx) throws SQLException {         ctx.statement().registerOutParameter(ctx.index(), Types.VARCHAR);     }
protected Date getFailureInRangeCutOffDate() {         val cutoff = ZonedDateTime.now(ZoneOffset.UTC).minusSeconds(configurationContext.getFailureRangeInSeconds());         return DateTimeUtils.timestampOf(cutoff);     }
public final void mFROM() throws RecognitionException {   try {    int _type = FROM;    int _channel = DEFAULT_TOKEN_CHANNEL;    // hql.g:29:6: ( 'from' )    // hql.g:29:8: 'from'    {    match(""from""); if (state.failed) return;     }     state.type = _type;    state.channel = _channel;   }   finally {    // do for sure before leaving   }  }
@Override  public Object setChild(final String key, final Controller<M, V> controller)  {   if (null != controller.getParent())   {    // controller.getParent().re   }   return children.put(key, controller);  }
private boolean doesIndexExistsiSeries(Connection con, String indexName) {         if (com.ibm.websphere.ras.TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_WAS.isLoggable(Level.FINE)) {             LoggingUtil.SESSION_LOGGER_WAS.entering(methodClassName, methodNames[DOES_INDEX_EXISTS_ISERIES]);         }         boolean indexExists_iSeries = false;          //Introduce noQualifiertblName and set it to ""SESSIONS"" instead of using tableName since tableName is set to         //qualifierName.tableName which is different from the one using in iSeries platform         String sysIndexes = null, sysKeys = null, noQualifiertblName = ""SESSIONS"", qualifierName = null, sqlQueryIndex = null, sqlQueryCol = null, returnIndexName = null, index_colNames = null, schemaSeparator = ""."";          PreparedStatement ps = null, ps1 = null;         ResultSet rs = null, rs1 = null;         int counter = 0;          sysIndexes = ""QSYS2"".concat(schemaSeparator).concat(""sysindexes"");         sysKeys = ""QSYS2"".concat(schemaSeparator).concat(""syskeys"");          //Keep the following line for future reference         //SELECT INDEX_NAME FROM QSYS2.SYSINDEXES  WHERE INDEX_NAME='SESS_INDEX' AND TABLE_NAME='SESSIONS'         //AND IS_UNIQUE='U' AND TABLE_SCHEMA='KPW51BSSSN'FOR READ ONLY         sqlQueryIndex = ""select index_name from "" + sysIndexes + "" where Index_Name = '""                         + indexName.toUpperCase() + ""' and "" + ""Table_Name = '"" + noQualifiertblName                         + ""' and IS_UNIQUE = 'U'"";          //Keep the following line for future reference         //SELECT COLUMN_NAME FROM qsys2.SYSKEYS  WHERE INDEX_NAME='SESS_INDEX' AND INDEX_SCHEMA='KPW51BSSSN'         sqlQueryCol = ""select COLUMN_NAME from "" + sysKeys +                       "" where INDEX_NAME = '"" + indexName.toUpperCase() + ""'"";          if (collectionName != null) {             sqlQueryIndex += "" and table_schema = '"" + collectionName.toUpperCase() + ""'"";             sqlQueryCol += "" and index_schema = '"" + collectionName.toUpperCase() + ""'"";         }         sqlQueryIndex += "" for read only"";         sqlQueryCol += "" for read only"";          if (com.ibm.websphere.ras.TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_WAS.isLoggable(Level.FINE)) {             LoggingUtil.SESSION_LOGGER_WAS.logp(Level.FINE, methodClassName, methodNames[DOES_INDEX_EXISTS_ISERIES], ""sqlQueryIndex: "" + sqlQueryIndex);             LoggingUtil.SESSION_LOGGER_WAS.logp(Level.FINE, methodClassName, methodNames[DOES_INDEX_EXISTS_ISERIES], ""sqlQueryCol: "" + sqlQueryCol);         }          //checking if the index exists first         try {             ps = con.prepareStatement(sqlQueryIndex);             rs = ps.executeQuery();              if (rs.next()) { //ResultSet returning the possible SESS_INDEX                 returnIndexName = rs.getString(1);                 if (returnIndexName != null) {                     if (returnIndexName.indexOf(indexName.toUpperCase()) != -1) {                         if (com.ibm.websphere.ras.TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_WAS.isLoggable(Level.FINE)) {                             LoggingUtil.SESSION_LOGGER_WAS.logp(Level.FINE, methodClassName, methodNames[DOES_INDEX_EXISTS_ISERIES], ""index: "" + returnIndexName + "" exists"");                         }                         indexExists_iSeries = true;                     } else if (com.ibm.websphere.ras.TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_WAS.isLoggable(Level.FINE)) {                         LoggingUtil.SESSION_LOGGER_WAS.logp(Level.FINE, methodClassName, methodNames[DOES_INDEX_EXISTS_ISERIES], ""index: "" + returnIndexName + "" does not exist"");                     }                 }             } else {                 if (com.ibm.websphere.ras.TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_WAS.isLoggable(Level.FINE)) {                     LoggingUtil.SESSION_LOGGER_WAS.logp(Level.FINE, methodClassName, methodNames[DOES_INDEX_EXISTS_ISERIES], ""ResultSet is null"");                 }             }         } catch (Throwable th) {             LoggingUtil.SESSION_LOGGER_WAS.logp(Level.SEVERE, methodClassName, methodNames[DOES_INDEX_EXISTS_ISERIES], ""CommonMessage.exception"", th);         } finally {             if (rs != null) {                 closeResultSet(rs);             }             if (ps != null) {                 closeStatement(ps);             }         }         //If the session index exists, we will check if the index definition is         //what the session manager would have created         if (indexExists_iSeries) {             try {                 ps1 = con.prepareStatement(sqlQueryCol);                 rs1 = ps1.executeQuery();                 while (rs1.next()) {                     String extractedColumn = rs1.getString(1);                     if (extractedColumn != null) {                         if (com.ibm.websphere.ras.TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_WAS.isLoggable(Level.FINE)) {                             LoggingUtil.SESSION_LOGGER_WAS.logp(Level.FINE, methodClassName, methodNames[DOES_INDEX_EXISTS_ISERIES], ""extractedColumn : "" + extractedColumn);                         }                         if ((extractedColumn.indexOf(idCol.toUpperCase()) != -1) ||                                 (extractedColumn.indexOf(propCol.toUpperCase()) != -1) ||                                    (extractedColumn.indexOf(appCol.toUpperCase()) != -1)) {                              if (com.ibm.websphere.ras.TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_WAS.isLoggable(Level.FINE)) {                                 LoggingUtil.SESSION_LOGGER_WAS.logp(Level.FINE, methodClassName, methodNames[DOES_INDEX_EXISTS_ISERIES], ""column is found : "" + extractedColumn);                             }                             counter++;                         }// end if (extractedColumn......)                     }// end if (extractedColumn != null)                 }//end while                  //we issue the warning here as if the index exists and any                  //index column is missing                 if (counter < 3) {                     LoggingUtil.SESSION_LOGGER_WAS.logp(Level.WARNING, methodClassName, methodNames[DOES_INDEX_EXISTS_ISERIES], ""DatabaseHashMap.IndexIncorrect"");                 }             } catch (Throwable th) {                 LoggingUtil.SESSION_LOGGER_WAS.logp(Level.SEVERE, methodClassName, methodNames[DOES_INDEX_EXISTS_ISERIES], ""CommonMessage.exception"", th);             } finally {                 if (rs1 != null) {                     closeResultSet(rs1);                 }                 if (ps1 != null) {                     closeStatement(ps1);                 }             }         }// end  if (indexExists_iSeries)         if (com.ibm.websphere.ras.TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_WAS.isLoggable(Level.FINE)) {             LoggingUtil.SESSION_LOGGER_WAS.exiting(methodClassName, methodNames[DOES_INDEX_EXISTS_ISERIES], indexExists_iSeries);         }         return indexExists_iSeries;     }
private int getWidthOfWidestItem() {          int maxWidth = 0;          for (CmsContextMenuItemWidget item : m_menuItems) {             item.getElement().getStyle().clearWidth();             int itemWidth = measureWidth(item);             if (itemWidth > maxWidth) {                 maxWidth = itemWidth;             }         }          return maxWidth;     }
static boolean regionMatches(    final CharSequence target,    final boolean ignoreCase,    final int toffset,    final CharSequence other,    final int ooffset,    final int length) {   boolean result;   if (target instanceof String && other instanceof String) {    result=delegateCheck((String)target,ignoreCase,toffset,ooffset,length,(String) other);   } else {    result=carryOutCheck(target, ignoreCase, toffset, other, ooffset, length);   }   return result;  }
public double valueAt(double[] x, double xscale, int[] batch) {      double prob = 0; // the log prob of the sequence given the model, which is the negation of value at this point      double[] weights = x;      int[][] wis = getWeightIndices();        int[] given = new int[window - 1];      int[][] docCliqueLabels = new int[window][];      for (int j = 0; j < window; j++) {        docCliqueLabels[j] = new int[j+1];      }      // iterate over all the documents      for (int m = 0; m < batch.length; m++) {        int ind = batch[m];        int[][][] docData = data[ind];        int[] docLabels = labels[ind];          // make a clique tree for this document        CRFCliqueTree cliqueTree = CRFCliqueTree.getCalibratedCliqueTree(weights, xscale, wis, docData,                labelIndices, numClasses, classIndex, backgroundSymbol);          // compute the log probability of the document given the model with the parameters x        Arrays.fill(given, classIndex.indexOf(backgroundSymbol));        if (docLabels.length>docData.length) { // only true for self-training          // fill the given array with the extra docLabels          System.arraycopy(docLabels, 0, given, 0, given.length);          // shift the docLabels array left          int[] newDocLabels = new int[docData.length];          System.arraycopy(docLabels, docLabels.length-newDocLabels.length, newDocLabels, 0, newDocLabels.length);          docLabels = newDocLabels;        }        // iterate over the positions in this document        for (int i = 0; i < docData.length; i++) {          int label = docLabels[i];          double p = cliqueTree.condLogProbGivenPrevious(i, label, given);          if (VERBOSE) {            System.err.println(""P("" + label + ""|"" + ArrayMath.toString(given) + "")="" + p);          }          prob += p;            // Shift window over          System.arraycopy(given, 1, given, 0, given.length - 1);          given[given.length - 1] = label;        }        }        if (Double.isNaN(prob)) { // shouldn't be the case        throw new RuntimeException(""Got NaN for prob in CRFLogConditionalObjectiveFunction.calculate()"");      }        value = -prob;      return value;    }
public void receive(byte[] byteArray) throws IOException {   //register the current application for this thread   // in case a subsystem logs to the environment   if (interpreter.isInSubProcessMode()) {    if (!abortSubprocessModeIfNecessary(byteArray)) {     /*   case CTRLC:        interpreter.abortSubprocessMode();        break;*/     if (echoEnabled) {      echoBytesToClient(byteArray);     }     //every byte is forwarded because the subprocess will interprete the input     interpreter.processRawInput(byteArray);    }   } else {    processInput(byteArray);   }  }
public static long subSeconds(final Date date1, final Date date2) {      return subTime(date1, date2, DatePeriod.SECOND);   }
public static String implode(String[] arr, String delim)    {       StringBuilder buf = new StringBuilder();       for (int i = 0; i < arr.length; i++)       {          if (i > 0)          {             buf.append(delim);          }          buf.append(arr[i]);       }       return buf.toString();    }
public void output(Logger log)     {         Map<String, Entry> entries = config.getSortedEntries();                  if ( entries.isEmpty() )         {             return;         }          ColumnPrinter printer = build(entries);          log.debug(""Configuration Details"");         for ( String line : printer.generate() )         {             log.debug(line);         }     }
public ObjectBank<List<IN>> makeObjectBankFromReader(BufferedReader in,                                                         DocumentReaderAndWriter<IN> readerAndWriter) {      if (flags.announceObjectBankEntries) {        System.err.println(""Reading data using "" + readerAndWriter.getClass());      }      // TODO get rid of objectbankwrapper      // return new ObjectBank<List<IN>>(new ResettableReaderIteratorFactory(in),      // readerAndWriter);      return new ObjectBankWrapper<IN>(flags, new ObjectBank<List<IN>>(new ResettableReaderIteratorFactory(in),          readerAndWriter), knownLCWords);    }
public static Pojo createRun(PojoCallback callback) {   return new NutPojo().setSqlType(SqlType.RUN).setAfter(callback);  }
public HThriftClient open() {     if ( isOpen() ) {       throw new IllegalStateException(""Open called on already open connection. You should not have gotten here."");     }     if ( log.isDebugEnabled() ) {       log.debug(""Creating a new thrift connection to {}"", cassandraHost);     }      TSocket socket;         try {         socket = params == null ?                                  new TSocket(cassandraHost.getHost(), cassandraHost.getPort(), timeout)                                 : TSSLTransportFactory.getClientSocket(cassandraHost.getHost(), cassandraHost.getPort(), timeout, params);     } catch (TTransportException e) {         throw new HectorTransportException(""Could not get client socket: "", e);     }          if ( cassandraHost.getUseSocketKeepalive() ) {       try {         socket.getSocket().setKeepAlive(true);       } catch (SocketException se) {         throw new HectorTransportException(""Could not set SO_KEEPALIVE on socket: "", se);       }     }      transport = maybeWrapWithTFramedTransport(socket);      // If using SSL, the socket will already be connected, and TFramedTransport and     // TSocket just wind up calling socket.isConnected(), so check this before calling     // open() to avoid a ""Socket already connected"" error.     if (!transport.isOpen()) {       try {         transport.open();       } catch (TTransportException e) {         // Thrift exceptions aren't very good in reporting, so we have to catch the exception here and         // add details to it.         log.debug(""Unable to open transport to "" + cassandraHost.getName());         //clientMonitor.incCounter(Counter.CONNECT_ERROR);         throw new HectorTransportException(""Unable to open transport to "" + cassandraHost.getName() +"" , "" +             e.getLocalizedMessage(), e);       }     }     return this;   }
public static TextCorpusStored compose(String lang, TextCorpusLayerStoredAbstract... layers) {         TextCorpusStored tc = new TextCorpusStored(lang);         for (TextCorpusLayerStoredAbstract layer : layers) {             tc.layersInOrder[TextCorpusLayerTag.getFromClass(layer.getClass()).ordinal()] = layer;         }         tc.connectLayers();         return tc;     }
public boolean correct(GrowQueue_I8 input , GrowQueue_I8 ecc )  {   computeSyndromes(input,ecc,syndromes);   findErrorLocatorPolynomialBM(syndromes,errorLocatorPoly);   if( !findErrorLocations_BruteForce(errorLocatorPoly,input.size+ecc.size,errorLocations))    return false;    correctErrors(input,input.size+ecc.size,syndromes,errorLocatorPoly,errorLocations);   return true;  }
public double valueAt( int col, int row ) {         if (isInRaster(col, row)) {             double value = iter.getSampleDouble(col, row, 0);             return value;         }         return HMConstants.doubleNovalue;     }
public void setStart(final double START) {         if (null == start) {             _start = START;             fireSectionEvent(UPDATE_EVENT);         } else {             start.set(START);         }     }
public Either<String, List<String>> dataSources(Map<String, String> reqHeaders) {         Either<String, Either<JSONArray, JSONObject>> resp = fireCommand(""druid/coordinator/v1/metadata/datasources"", null, reqHeaders);         if (resp.isLeft()) {             return new Left<>(resp.left().get());         }         Either<JSONArray, JSONObject> goodResp = resp.right().get();         if (goodResp.isLeft()) {             JSONArray dataSources = goodResp.left().get();             List<String> dataSourceList = new ArrayList<>();             for (int i = 0; i < dataSources.length(); i++) {                 dataSourceList.add(dataSources.getString(i));             }             return new Right<>(dataSourceList);         }         return new Left<>(resp.left().get());     }
public static <T extends MethodDescription> ElementMatcher.Junction<T> isGetter() {         return takesArguments(0).and(not(returns(TypeDescription.VOID))).and(nameStartsWith(""get"").or(nameStartsWith(""is"").and(returnsGeneric(anyOf(boolean.class, Boolean.class)))));     }
public final void setCheckedStateBackgroundColor(@ColorInt int backgroundColor) {         if ((backgroundColor != mCheckedBackgroundColor) &&             (null != mCheckedBackgroundPaint)) {             mCheckedBackgroundPaint.setColor(backgroundColor);             if (isChecked()) {                 invalidate();             }         }          mCheckedBackgroundColor = backgroundColor;     }
public static void debug(JShell state, PrintStream err, Exception ex, String where) {         if (isDebugEnabled(state, 0xFFFFFFFF)) {             err.printf(""Fatal error: %s: %s\n"", where, ex.getMessage());             ex.printStackTrace(err);         }     }
private void initializeIfNeeded() throws BackendInitializationException,             BackendNewInstanceException {         if (isClosed()) {             throw new IllegalStateException(""Knowledge source already closed!"");         }         if (this.inDataSourceGetter == null) {             this.inDataSourceGetter                     = new SubtreePropositionDefinitionGetterRegular(this, true);         }         if (this.collectSubtreeGetter == null) {             this.collectSubtreeGetter                     = new SubtreePropositionDefinitionGetterRegular(this, false);         }     }
private ListenerToken addDocumentChangeListener(         Executor executor,         DocumentChangeListener listener,         String docID) {         // NOTE: caller method is synchronized.         DocumentChangeNotifier docNotifier = docChangeNotifiers.get(docID);         if (docNotifier == null) {             docNotifier = new DocumentChangeNotifier((Database) this, docID);             docChangeNotifiers.put(docID, docNotifier);         }         final ChangeListenerToken token = docNotifier.addChangeListener(executor, listener);         token.setKey(docID);         return token;     }
public void setValues(Variable v, List<String> values) throws IllegalArgumentException {     Array data = Array.makeArray(v.getDataType(), values);      if (data.getSize() != v.getSize())       throw new IllegalArgumentException(""Incorrect number of values specified for the Variable "" + v.getFullName() +               "" needed= "" + v.getSize() + "" given="" + data.getSize());      if (v.getRank() != 1) // dont have to reshape for rank 1       data = data.reshape(v.getShape());      v.setCachedData(data, true);   }
public static Cookies newServerRequestHolder(HttpHeaders headers, ServerCookieDecoder decoder) {   return new Cookies(headers, HttpHeaderNames.COOKIE, false, decoder);  }
public static long currentTimeMicros() {         if (javaVersion() == 8) {             return TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis());         } else {             // Java 9+ support higher precision wall time.             final Instant now = Clock.systemUTC().instant();             return TimeUnit.SECONDS.toMicros(now.getEpochSecond()) + TimeUnit.NANOSECONDS.toMicros(                     now.getNano());         }     }
private void evaluateExpressions() throws JspException {         /*           * Note: we don't check for type mismatches here; we assume          * the expression evaluator will return the expected type          * (by virtue of knowledge we give it about what that type is).          * A ClassCastException here is truly unexpected, so we let it          * propagate up.          */          xml = ExpressionUtil.evalNotNull(                 ""transform"", ""xml"", xml_, Object.class, this, pageContext);         xmlSystemId = (String) ExpressionUtil.evalNotNull(                 ""transform"", ""xmlSystemId"", xmlSystemId_, String.class,                 this, pageContext);         xslt = ExpressionUtil.evalNotNull(                 ""transform"", ""xslt"", xslt_, Object.class, this,                 pageContext);         xsltSystemId = (String) ExpressionUtil.evalNotNull(                 ""transform"", ""xsltSystemId"", xsltSystemId_, String.class,                 this, pageContext);         result = (Result) ExpressionUtil.evalNotNull(                 ""transform"", ""result"", result_, Result.class, this, pageContext);      }
public Agreement getAgreement(String agreementId) {         return getJerseyClient().target(getEndpoint() + ""/agreements/"" + agreementId).request()                 .header(""Accept"", MediaType.APPLICATION_JSON)                 .header(""Content-Type"", MediaType.APPLICATION_JSON)                 .buildGet().invoke().readEntity(Agreement.class);     }
@Override   public void setOwner(Path path, final String username, final String groupname)       throws IOException {     LOG.debug(""setOwner({},{},{})"", path, username, groupname);     AlluxioURI uri = new AlluxioURI(HadoopUtils.getPathWithoutScheme(path));     SetAttributePOptions.Builder optionsBuilder = SetAttributePOptions.newBuilder();     boolean ownerOrGroupChanged = false;     if (username != null && !username.isEmpty()) {       optionsBuilder.setOwner(username).setRecursive(false);       ownerOrGroupChanged = true;     }     if (groupname != null && !groupname.isEmpty()) {       optionsBuilder.setGroup(groupname).setRecursive(false);       ownerOrGroupChanged = true;     }     if (ownerOrGroupChanged) {       try {         mFileSystem.setAttribute(uri, optionsBuilder.build());       } catch (AlluxioException e) {         throw new IOException(e);       }     }   }
public static <C> Module configModule(final Class<C> configInterface, final Optional<Named> nameOpt)     {         checkNotNull(configInterface);         checkNotNull(nameOpt);         final Optional<String> nameStrOpt = nameOpt.map(Named::value);          // Build config descriptors for the given config interface         final List<ConfigDescriptor> configDescList = ConfigSystem.descriptorFactory.buildDescriptors(configInterface, nameStrOpt);          return new AbstractModule()         {             @Override             protected void configure()             {                 // Create Implementation Builder                 DynamicType.Builder<C> typeBuilder = new ByteBuddy().subclass(configInterface);                  Multibinder<ConfigDescriptor> multiBinder = Multibinder.newSetBinder(binder(), ConfigDescriptor.class);                  // Define a field to keep a local reference to the list of propertyAccessorProviders on the dynamic                 // instance so the provideres dont get GCed. The providers are supplied to the InvocationHandlerImpl                 // using a WeakReference so the generated (static) code will not have a strong reference to the injector                 // which will cause a memory leak.                 final String propertyAccessorProvidersFieldName = ""propertyAccessorProviders$"" + ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);                 typeBuilder = typeBuilder.defineField(propertyAccessorProvidersFieldName, Collection.class, Visibility.PRIVATE);                 ImmutableList.Builder<Provider<PropertyAccessor<?>>> propertyAccessorProvidersBuilder = ImmutableList.builder();                  for (ConfigDescriptor desc : configDescList) {                     // Bind the propertyIdentifier                     final PropertyIdentifier propertyId = ConfigSystem.getIdentifier(desc);                     bind(PropertyIdentifier.class).annotatedWith(propertyId).toInstance(propertyId);                      Provider<PropertyAccessor<?>> accessorProvider;                     if (desc.isObservable()) {                         // find associated method descriptor for observable                         ConfigDescriptor otherDesc = findAssociatedDescForObservable(configDescList, desc);                         final PropertyIdentifier otherPropertyId = ConfigSystem.getIdentifier(otherDesc);                          // Get accessorProvider of the associated method for use in the configuration method implementation                         accessorProvider = getAccessorProvider(otherDesc, otherPropertyId);                     }                     else {                         // Bind the named ConfigDescriptor                         bind(ConfigDescriptor.class).annotatedWith(Names.named(desc.getConfigName())).toInstance(desc);                          // MultiBind ConfigDescriptor so we can later inject Set<ConfigDescriptor>                         multiBinder.addBinding().toInstance(desc);                          // Bind the static default value and propertyIdentifier                         bind(ConstantValuePropertyAccessor.class).annotatedWith(propertyId).toInstance(ConstantValuePropertyAccessor.fromStringOpt(desc.getDefaultValue()));                          // Bind the PropertyAccessor                         install(PropertyAccessor.module(propertyId, desc));                          // Get accessorProvider for use in the configuration method implementation                         accessorProvider = getAccessorProvider(desc, propertyId);                     }                     propertyAccessorProvidersBuilder.add(accessorProvider);                      // Register method implementation in the class builder                     // Wrap the accessorProvider in a WeakReference before giving it to ByteBuddy to avoid a reference                     // to the injector making its way into the class loader which results in a memory leak.                     typeBuilder = typeBuilder.method(ElementMatchers.is(desc.getMethod())).intercept(InvocationHandlerAdapter.of(new InvocationHandlerImpl(desc, new WeakReference<>(accessorProvider))));                 }                  Class<? extends C> configImpl = typeBuilder.make()                     .load(configInterface.getClassLoader(), ClassLoadingStrategy.Default.INJECTION)                     .getLoaded();                  // Bind Config Interface to an instance of the newly created impl class                 try {                     C instance = (C) configImpl.newInstance();                      // To prevent the property accessor providers from getting GCed - see comments above:                     Field propertyAccessorProvidersField = instance.getClass().getDeclaredField(propertyAccessorProvidersFieldName);                     if (!propertyAccessorProvidersField.isAccessible()) {                         propertyAccessorProvidersField.setAccessible(true);                     }                     propertyAccessorProvidersField.set(instance, propertyAccessorProvidersBuilder.build());                      if (nameOpt.isPresent()) {                         bind(configInterface).annotatedWith(nameOpt.get()).toInstance(instance);                     }                     else {                         bind(configInterface).toInstance(instance);                     }                 }                 catch (InstantiationException | IllegalAccessException | NoSuchFieldException | SecurityException ex) {                     throw new ConfigException(""Failed to instantiate implementation of Config {}"",                         configInterface.getName(), ex);                 }             }              private Provider<PropertyAccessor<?>> getAccessorProvider(ConfigDescriptor desc, PropertyIdentifier propertyId)             {                 TypeLiteral<PropertyAccessor<?>> accessorKey =                     (TypeLiteral<PropertyAccessor<?>>) TypeLiteral.get(                         Types.newParameterizedType(PropertyAccessor.class, desc.getConfigType()));                 return getProvider(Key.get(accessorKey, propertyId));             }         };     }
@Override     public Expression<Long> count(Expression<?> arg0)     {         // TODO Auto-generated method stub         String arg1 = ""Count(""+arg0.getAlias()+"")"";         return new AggregateExpression(arg0, arg1);     }
public void addChildProperties(final NodeData parentData, final List<PropertyData> childItems)    {       if (enabled && parentData != null && childItems != null)       {          String logInfo = null;          if (LOG.isDebugEnabled())          {             logInfo =                ""parent:   "" + parentData.getQPath().getAsString() + ""    "" + parentData.getIdentifier() + "" ""                   + childItems.size();             LOG.debug(name + "", addChildProperties() >>> "" + logInfo);          }           String operName = """"; // for debug/trace only           writeLock.lock();          try          {             // remove parent (no childs)             operName = ""removing parent"";             removeItem(parentData);              operName = ""caching parent"";             putItem(parentData); // put parent in cache              synchronized (childItems)             {                operName = ""caching child properties list"";                propertiesCache.put(parentData.getIdentifier(), childItems); // put childs in cache CP                 operName = ""caching child properties"";                // put childs in cache C                for (ItemData p : childItems)                {                   if (LOG.isDebugEnabled())                   {                      LOG.debug(name + "", addChildProperties()    "" + p.getQPath().getAsString() + ""    ""                         + p.getIdentifier() + ""  --  "" + p);                   }                    putItem(p);                }             }          }          catch (Exception e)          {             LOG.error(name + "", Error in addChildProperties() "" + operName + "": parent ""                + (parentData != null ? parentData.getQPath().getAsString() : ""[null]""), e);          }          finally          {             writeLock.unlock();          }           if (LOG.isDebugEnabled())          {             LOG.debug(name + "", addChildProperties() <<< "" + logInfo);          }       }    }
public static Query in(String field, Collection<?> values) {         return new Query().in(field, values);     }
public Observable<ServiceResponse<GenericResourceInner>> getWithServiceResponseAsync(String resourceGroupName, String resourceProviderNamespace, String parentResourcePath, String resourceType, String resourceName, String apiVersion) {         if (resourceGroupName == null) {             throw new IllegalArgumentException(""Parameter resourceGroupName is required and cannot be null."");         }         if (resourceProviderNamespace == null) {             throw new IllegalArgumentException(""Parameter resourceProviderNamespace is required and cannot be null."");         }         if (parentResourcePath == null) {             throw new IllegalArgumentException(""Parameter parentResourcePath is required and cannot be null."");         }         if (resourceType == null) {             throw new IllegalArgumentException(""Parameter resourceType is required and cannot be null."");         }         if (resourceName == null) {             throw new IllegalArgumentException(""Parameter resourceName is required and cannot be null."");         }         if (this.client.subscriptionId() == null) {             throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");         }         if (apiVersion == null) {             throw new IllegalArgumentException(""Parameter apiVersion is required and cannot be null."");         }         return service.get(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())             .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<GenericResourceInner>>>() {                 @Override                 public Observable<ServiceResponse<GenericResourceInner>> call(Response<ResponseBody> response) {                     try {                         ServiceResponse<GenericResourceInner> clientResponse = getDelegate(response);                         return Observable.just(clientResponse);                     } catch (Throwable t) {                         return Observable.error(t);                     }                 }             });     }
public boolean await(T t, long timeout, TimeUnit unit) throws InterruptedException     {         synchronized (monitor)         {             // Holds the absolute time when the timeout expires.             long expiryTimeNanos = System.nanoTime() + unit.toNanos(timeout);              // Used to hold the estimated wait time until the condition may pass.             long waitNanos = evaluateWithWaitTimeNanos(t);              // Loop forever until all conditions pass, the timeout expires, or the thread is interrupted.             while (waitNanos > 0)             {                 // Check how much time remains until the timeout expires.                 long remainingTimeNanos = expiryTimeNanos - System.nanoTime();                  // Check if the timeout has expired.                 if (remainingTimeNanos <= 0)                 {                     return false;                 }                  // If some conditions failed, then wait for the shortest of the wait time or the remaining time until the                 // timout expires, or until the thread is woken up by a signal, before re-evaluating conditions.                 long timeToPauseNanos = (waitNanos < remainingTimeNanos) ? waitNanos : remainingTimeNanos;                  long milliPause = timeToPauseNanos / 1000000;                 int nanoPause = (int) (timeToPauseNanos % 1000000);                  monitor.wait(milliPause, nanoPause);                  // Re-evelaute the condition and obtain a new estimate of how long until it may pass.                 waitNanos = evaluateWithWaitTimeNanos(t);             }         }          // All conditions have passed when the above loop terminates.         return true;     }
@Override     public Response toResponse(WebApplicationException ex) {         return Response.status(ex.getResponse().getStatus()).entity(new ErrorMessage(ex.getResponse().getStatus(), ex.getMessage())).type(             MediaType.APPLICATION_JSON_TYPE).build();     }
@Override     public int doStartTag() throws JspException {          ServletRequest req = pageContext.getRequest();          // This will always be true if the page is called through OpenCms         if (!CmsFlexController.isCmsRequest(req)) {             return SKIP_BODY;         }         if (getJs() == null) {             if (isDynamic()) {                 // in case we want to include the needed js functions                 try {                     pageContext.getOut().print(""<script type='text/javascript' src='""                         + CmsWorkplace.getSkinUri()                         + VFS_PATH_LOAD_JS                         + ""' ></script>"");                 } catch (Exception ex) {                     if (LOG.isErrorEnabled()) {                         LOG.error(Messages.get().getBundle().key(Messages.ERR_PROCESS_TAG_1, ""jquery""), ex);                     }                     throw new JspException(ex);                 }             }             return SKIP_BODY;         }          // get the server prefix         CmsObject cms = CmsFlexController.getCmsObject(req);          // first handle js file         String path = VFS_PATH_JQUERY;         if (cms.getRequestContext().getCurrentProject().isOnlineProject()) {             // online             path += VFS_PATH_PACKED;         } else {             // offline             path += VFS_PATH_UNPACKED;         }         String file = path + getJs() + EXTENSION_JS;         try {             cms.readResource(CmsWorkplace.VFS_PATH_RESOURCES + file);             if (isDynamic()) {                 pageContext.getOut().print(""<script type='text/javascript'>load_script('""                     + CmsWorkplace.getSkinUri()                     + file                     + ""', 'js');</script>"");             } else {                 pageContext.getOut().print(                     ""<script type='text/javascript' src='"" + CmsWorkplace.getSkinUri() + file + ""' ></script>"");             }         } catch (Exception ex) {             if (LOG.isErrorEnabled()) {                 LOG.error(Messages.get().getBundle().key(Messages.ERR_PROCESS_TAG_1, ""jquery""), ex);             }             throw new JspException(ex);         }         if (getCss() == null) {             return SKIP_BODY;         }          // now handle css file         path = VFS_PATH_CSS;         file = path + getCss() + EXTENSION_CSS;         try {             cms.readResource(CmsWorkplace.VFS_PATH_RESOURCES + file);             pageContext.getOut().println();             if (isDynamic()) {                 pageContext.getOut().print(""<script type='text/javascript'>load_script('""                     + CmsWorkplace.getSkinUri()                     + file                     + ""', 'css');</script>"");             } else {                 pageContext.getOut().print(                     ""<link href='"" + CmsWorkplace.getSkinUri() + file + ""' rel='stylesheet' type='text/css' >"");             }         } catch (Exception ex) {             if (LOG.isErrorEnabled()) {                 LOG.error(Messages.get().getBundle().key(Messages.ERR_PROCESS_TAG_1, ""jquery""), ex);             }             throw new JspException(ex);         }         return SKIP_BODY;     }
protected OkHttpClient buildHttpClient() {         OkHttpClient.Builder builder = new OkHttpClient.Builder()                 .readTimeout(readTimeoutMs, TimeUnit.MILLISECONDS)                 .writeTimeout(writeTimeoutMs, TimeUnit.MILLISECONDS);         OkHttpClient client = builder.build();         return client;     }
@Override     public void init(PageContext pc) throws IOException {  if (init != null) {      try {   init.invoke(monitor, new Object[] { pc });      }      catch (Exception e) {   throw ExceptionUtil.toIOException(e);      }  }     }
@Override public JobSpecSchedule scheduleOnce(JobSpec jobSpec, Runnable jobRunnable) {     _log.info(""Scheduling once JobSpec "" + jobSpec);     Runnable runOnceRunnable = new RunOnceRunnable(jobSpec.getUri(), jobRunnable);     return scheduleJob(jobSpec, runOnceRunnable);   }
ByteBuffer getBuffer() throws IOException {     /*      * Once this is called, no more data can be added to the packet. setting      * 'buf' to null ensures that. This is called only when the packet is ready      * to be sent.      */     if (buffer != null) {       return buffer;     }      int pktLen = DFSClient.SIZE_OF_INTEGER + (pos - dataStart);      // normally dataStart == checksumPos, i.e., offset is zero.     buffer = ByteBuffer.wrap(buf, 0, dfsOutputStream.getPacketHeaderLen()         + pktLen);     buf = null;     buffer.mark();      /*      * write the header and data length. The format is described in comment      * before DataNode.BlockSender      */     buffer.putInt(pktLen); // pktSize     buffer.putInt(dfsOutputStream.getPacketVersion());     buffer.putLong(offsetInBlock);     buffer.putLong(seqno);      byte booleanFieldValue = 0x00;      if (lastPacketInBlock) {       booleanFieldValue |= DataNode.isLastPacketInBlockMask;     }     if (dfsOutputStream.ifForceSync()) {       booleanFieldValue |= DataNode.forceSyncMask;     }     buffer.put(booleanFieldValue);      // end of pkt header     buffer.putInt(dataLength); // actual data length, excluding checksum.     buffer.reset();     return buffer;   }
private static String annotationToString(       Class<? extends Annotation> type, Map<String, Object> members) throws Exception {     StringBuilder sb = new StringBuilder().append(""@"").append(type.getName()).append(""("");     JOINER.appendTo(         sb,         Maps.transformValues(             members,             arg -> {               String s = Arrays.deepToString(new Object[] {arg});               return s.substring(1, s.length() - 1); // cut off brackets             }));     return sb.append("")"").toString();   }
public static LuceneDefaults fromAnnotation(Defaults defaults) {         LuceneDefaults lid = new LuceneDefaults();         boolean hasValues = false;          if (!StringUtils.isBlank(defaults.field())) {             lid.setField(defaults.field());             hasValues = true;         }         if (!StringUtils.isBlank(defaults.type())) {             lid.setType(defaults.type());             hasValues = true;         }         if (!StringUtils.isBlank(defaults.store())) {             lid.setStore(defaults.store());             hasValues = true;         }         if (!StringUtils.isBlank(defaults.index())) {             lid.setIndex(defaults.index());             hasValues = true;         }         return hasValues ? lid : null;     }
public void marshall(DeleteUserRequest deleteUserRequest, ProtocolMarshaller protocolMarshaller) {          if (deleteUserRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(deleteUserRequest.getUserName(), USERNAME_BINDING);             protocolMarshaller.marshall(deleteUserRequest.getAwsAccountId(), AWSACCOUNTID_BINDING);             protocolMarshaller.marshall(deleteUserRequest.getNamespace(), NAMESPACE_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
private static void          writeNeighborComparison(File neighborFile,                                  MultiMap<Double,String> mostSimilar,                                  SemanticSpace sspace) throws IOException {                  PrintWriter pw = new PrintWriter(neighborFile);                  // print out the header so we know the comparison order         StringBuffer sb = new StringBuffer(mostSimilar.size() * 10);         for (Iterator<String> it = mostSimilar.values().iterator();              it.hasNext();) {             sb.append(it.next());             if (it.hasNext())                  sb.append("" "");         }         pw.println(sb.toString());                  // create an N x N table of how similar all the words are to each         // other.         for (String word : mostSimilar.values()) {             sb = new StringBuffer(mostSimilar.size() * 10);             sb.append(word).append("" "");                          // loop through all of the words             for (String other : mostSimilar.values()) {                 // determine how similar the two words are                 double similarity = Similarity.cosineSimilarity(                         sspace.getVector(word),                         sspace.getVector(other));                 sb.append(similarity).append("" "");             }             pw.println(sb.toString());         }                  pw.close();     }
private void create3WindowFeats(int i, String[] toks, String[] tags,       String[] preds, List<String> feats) {      // Words in a 5-word window     String w_1, w0, w1;      // Tags in a 5-word window     String t_1, t0, t1;      // Previous predictions     String p_2, p_1;      w0 = w1 = null;     t_1 = t0 = t1 = null;     p_1 = p_2 = null;      if (i < 2) {       p_2 = ""p_2=bos"";     } else {       p_2 = ""p_2"" + preds[i - 2];     }      if (i < 1) {       w_1 = ""w_1=bos"";       t_1 = ""t_1=bos"";       p_1 = ""p_1=bos"";     } else {       w_1 = ""w_1="" + toks[i - 1];       t_1 = ""t_1="" + tags[i - 1];       p_1 = ""p_1="" + preds[i - 1];     }      w0 = ""w0="" + toks[i];     t0 = ""t0="" + tags[i];      if (i + 1 >= toks.length) {       w1 = ""w1=eos"";       t1 = ""t1=eos"";     } else {       w1 = ""w1="" + toks[i + 1];       t1 = ""t1="" + tags[i + 1];     }      String[] features = new String[] {         // add word features         w_1, w0, w1,         w_1 + w0,         w0 + w1,          // add tag features         t_1, t0, t1,          t_1 + t0,         t0 + t1,         t_1 + t0 + t1,          // add pred tags         p_2,         p_1,         p_2 + p_1,          // add pred and tag         p_1 + t_1, p_1 + t0, p_1 + t1,         p_1 + t_1 + t0, p_1 + t0 + t1,         p_1 + t_1 + t0 + t1,          // add pred and word         p_1 + w_1, p_1 + w0, p_1 + w1, p_1 + w_1 + w0,         p_1 + w0 + w1 };      feats.addAll(Arrays.asList(features));   }
@Override   public V putIfAbsentFailure(K key, V value, StoreAccessException e) {     // FIXME: Should I care about useLoaderInAtomics?     try {       try {         V loaded = loaderWriter.load(key);         if (loaded != null) {           return loaded;         }       } catch (Exception e1) {         throw ExceptionFactory.newCacheLoadingException(e1, e);       }       try {         loaderWriter.write(key, value);       } catch (Exception e1) {         throw ExceptionFactory.newCacheWritingException(e1, e);       }     } finally {       cleanup(key, e);     }     return null;   }
public static ArrayList<double[]> readBinary(String featuresFileName, int featureLength) throws Exception {    ArrayList<double[]> features = new ArrayList<double[]>();    DataInputStream in = new DataInputStream(new BufferedInputStream(      new FileInputStream(featuresFileName)));      int counter = 0;    double[] desc = new double[featureLength];    while (true) {     try {      desc[counter] = in.readDouble();     } catch (EOFException e) {      break;     }     counter++;     if (counter == featureLength) {      features.add(desc);      counter = 0;      desc = new double[featureLength];     }    }    in.close();    return features;   }
public Map<Boolean, List<T>> partitioningBy(Predicate<? super T> predicate) {         return collect(Collectors.partitioningBy(predicate));     }
public static PublicKey readPublicKey(final byte[] publicKeyBytes)   throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException  {   return readPublicKey(publicKeyBytes, KeyPairGeneratorAlgorithm.RSA.getAlgorithm());  }
public static double cublasDasum(int n, Pointer x, int incx)      {          double result = cublasDasumNative(n, x, incx);          checkResultBLAS();          return result;      }
public String getColumnNameForProperty(final String propertyName)    {      return Optional.ofNullable(propertyToField.get(propertyName))                     .map(fcInfo -> fcInfo.getDelimitedColumnName())                     .orElse(null);    }
public void setMoneyAmountOff(com.google.api.ads.adwords.axis.v201809.cm.MoneyWithCurrency moneyAmountOff) {         this.moneyAmountOff = moneyAmountOff;     }
public Observable<VirtualNetworkInner> beginUpdateTagsAsync(String resourceGroupName, String virtualNetworkName, Map<String, String> tags) {         return beginUpdateTagsWithServiceResponseAsync(resourceGroupName, virtualNetworkName, tags).map(new Func1<ServiceResponse<VirtualNetworkInner>, VirtualNetworkInner>() {             @Override             public VirtualNetworkInner call(ServiceResponse<VirtualNetworkInner> response) {                 return response.body();             }         });     }
static File getLogDirectory(Object newValue, File defaultDirectory) {          File newDirectory = defaultDirectory;          // If a value was specified, try creating a file with it         if (newValue != null && newValue instanceof String) {             newDirectory = new File((String) newValue);         }          if (newDirectory == null) {             String value = ""."";             try {                 value = AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<String>() {                     @Override                     public String run() throws Exception {                         return System.getProperty(""user.dir"");                     }                 });             } catch (Exception ex) {                 // do nothing             }             newDirectory = new File(value);         }          return LoggingFileUtils.validateDirectory(newDirectory);     }
private static boolean applySingletonSubstitution(Function functionalTerm, SingletonSubstitution substitution) {         List<Term> innerTerms = functionalTerm.getTerms();         boolean innerchanges = false;         // TODO this ways of changing inner terms in functions is not         // optimal, modify          for (int i = 0; i < innerTerms.size(); i++) {             Term innerTerm = innerTerms.get(i);              if (innerTerm instanceof Function) {                 // Recursive call                 innerchanges = innerchanges || applySingletonSubstitution((Function)innerTerm, substitution);             }             else if (substitution.getVariable().equals(innerTerm)) { // ROMAN: no need in isEqual(innerTerm, s.getVariable())                 functionalTerm.getTerms().set(i, substitution.getTerm());                 innerchanges = true;             }         }         return innerchanges;     }
public static boolean containsOnly(String str, char[] valid) {         // All these pre-checks are to maintain API with an older version         if ((valid == null) || (str == null)) {             return false;         }         if (str.length() == 0) {             return true;         }         if (valid.length == 0) {             return false;         }         return indexOfAnyBut(str, valid) == INDEX_NOT_FOUND;     }
public static CompletableFuture<IMessageReceiver> createMessageReceiverFromConnectionStringAsync(String amqpConnectionString, ReceiveMode receiveMode) {         Utils.assertNonNull(""amqpConnectionString"", amqpConnectionString);         return createMessageReceiverFromConnectionStringBuilderAsync(new ConnectionStringBuilder(amqpConnectionString), receiveMode);     }
public static int elementWiseStride(DataBuffer buffer) {         int length2 = shapeInfoLength(buffer.getInt(0));         return buffer.getInt(length2 - 2);     }
public static void report(String testId, Throwable cause) {         if (cause == null) {             LOGGER.fatal(""Can't call report with a null exception"");             return;         }          long exceptionCount = FAILURE_ID.incrementAndGet();          if (exceptionCount > MAX_EXCEPTION_COUNT) {             LOGGER.warn(""Exception #"" + exceptionCount + "" detected. The maximum number of exceptions has been exceeded, so it""                     + "" won't be reported to the Agent."", cause);             return;         }          LOGGER.warn(""Exception #"" + exceptionCount + "" detected"", cause);          String targetFileName = exceptionCount + "".exception"";          File dir = getUserDir();         File tmpFile = new File(dir, targetFileName + "".tmp"");         try {             if (!tmpFile.createNewFile()) {                 throw new IOException(""Could not create tmp file: "" + tmpFile.getAbsolutePath());             }         } catch (IOException e) {             LOGGER.fatal(""Could not report exception; this means that this exception is not visible to the coordinator"", e);             return;         }          writeText(testId + NEW_LINE + throwableToString(cause), tmpFile);          File file = new File(dir, targetFileName);         LOGGER.info(file.getAbsolutePath());         rename(tmpFile, file);     }
public Observable<Page<RouteFilterRuleInner>> listByRouteFilterNextAsync(final String nextPageLink) {         return listByRouteFilterNextWithServiceResponseAsync(nextPageLink)             .map(new Func1<ServiceResponse<Page<RouteFilterRuleInner>>, Page<RouteFilterRuleInner>>() {                 @Override                 public Page<RouteFilterRuleInner> call(ServiceResponse<Page<RouteFilterRuleInner>> response) {                     return response.body();                 }             });     }
public <T extends ICalProperty> List<T> removeProperties(Class<T> clazz) {   List<ICalProperty> removed = properties.removeAll(clazz);   return castList(removed, clazz);  }
public List<User> getAllUsers(AccessToken accessToken, String... attributes) {          return getUserService().getAllUsers(accessToken, attributes);      }
String getString(Object scope, String propertyPath) throws TemplateException    {      return getString(scope, propertyPath, null);    }
public void update(ModelConfig modelConfig) throws FOSException {         checkNotNull(modelConfig);          this.dirty = true;          // The class index should be reset everytime a model config is updated.         // TODO: Refactor the classIndex to be in ModelConfig.         this.modelConfig.getProperties().remove(CLASS_INDEX);         this.modelConfig.update(modelConfig);          parseModelConfig();     }
void build() {         RangeDescriptor rlRange;          if (fRB.fDebugEnv!=null  && fRB.fDebugEnv.indexOf(""usets"")>=0) {printSets();}          //  Initialize the process by creating a single range encompassing all characters         //  that is in no sets.         //         fRangeList               = new RangeDescriptor();          fRangeList.fStartChar    = 0;         fRangeList.fEndChar      = 0x10ffff;          //         //  Find the set of non-overlapping ranges of characters         //         for (RBBINode usetNode : fRB.fUSetNodes) {             UnicodeSet      inputSet             = usetNode.fInputSet;             int            inputSetRangeCount   = inputSet.getRangeCount();             int            inputSetRangeIndex   = 0;             rlRange              = fRangeList;              for (;;) {                 if (inputSetRangeIndex >= inputSetRangeCount) {                     break;                 }                 int      inputSetRangeBegin  = inputSet.getRangeStart(inputSetRangeIndex);                 int      inputSetRangeEnd    = inputSet.getRangeEnd(inputSetRangeIndex);                  // skip over ranges from the range list that are completely                 //   below the current range from the input unicode set.                 while (rlRange.fEndChar < inputSetRangeBegin) {                     rlRange = rlRange.fNext;                 }                  // If the start of the range from the range list is before with                 //   the start of the range from the unicode set, split the range list range                 //   in two, with one part being before (wholly outside of) the unicode set                 //   and the other containing the rest.                 //   Then continue the loop; the post-split current range will then be skipped                 //     over                 if (rlRange.fStartChar < inputSetRangeBegin) {                     rlRange.split(inputSetRangeBegin);                      continue;                 }                  // Same thing at the end of the ranges...                 // If the end of the range from the range list doesn't coincide with                 //   the end of the range from the unicode set, split the range list                 //   range in two.  The first part of the split range will be                 //   wholly inside the Unicode set.                 if (rlRange.fEndChar > inputSetRangeEnd) {                     rlRange.split(inputSetRangeEnd+1);                  }                  // The current rlRange is now entirely within the UnicodeSet range.                 // Add this unicode set to the list of sets for this rlRange                 if (rlRange.fIncludesSets.indexOf(usetNode) == -1) {                     rlRange.fIncludesSets.add(usetNode);                 }                  // Advance over ranges that we are finished with.                 if (inputSetRangeEnd == rlRange.fEndChar) {                     inputSetRangeIndex++;                 }                 rlRange = rlRange.fNext;             }         }          if (fRB.fDebugEnv!=null && fRB.fDebugEnv.indexOf(""range"")>=0) { printRanges();}          //         //  Group the above ranges, with each group consisting of one or more         //    ranges that are in exactly the same set of original UnicodeSets.         //    The groups are numbered, and these group numbers are the set of         //    input symbols recognized by the run-time state machine.         //         //    Numbering: # 0  (state table column 0) is unused.         //               # 1  is reserved - table column 1 is for end-of-input         //               # 2  is reserved - table column 2 is for beginning-in-input         //               # 3  is the first range list.         //         RangeDescriptor rlSearchRange;         for (rlRange = fRangeList; rlRange!=null; rlRange=rlRange.fNext) {             for (rlSearchRange=fRangeList; rlSearchRange != rlRange; rlSearchRange=rlSearchRange.fNext) {                 if (rlRange.fIncludesSets.equals(rlSearchRange.fIncludesSets)) {                     rlRange.fNum = rlSearchRange.fNum;                     break;                 }             }             if (rlRange.fNum == 0) {                 fGroupCount ++;                 rlRange.fNum = fGroupCount+2;                  rlRange.setDictionaryFlag();                 addValToSets(rlRange.fIncludesSets, fGroupCount+2);             }         }          // Handle input sets that contain the special string {eof}.         //   Column 1 of the state table is reserved for EOF on input.         //   Column 2 is reserved for before-the-start-input.         //            (This column can be optimized away later if there are no rule         //             references to {bof}.)         //   Add this column value (1 or 2) to the equivalent expression         //     subtree for each UnicodeSet that contains the string {eof}         //   Because {bof} and {eof} are not a characters in the normal sense,         //   they doesn't affect the computation of ranges or TRIE.                  String eofString = ""eof"";         String bofString = ""bof"";          for (RBBINode usetNode : fRB.fUSetNodes) {             UnicodeSet      inputSet = usetNode.fInputSet;             if (inputSet.contains(eofString)) {                 addValToSet(usetNode, 1);             }             if (inputSet.contains(bofString)) {                 addValToSet(usetNode, 2);                 fSawBOF = true;             }         }           if (fRB.fDebugEnv!=null  && fRB.fDebugEnv.indexOf(""rgroup"")>=0) {printRangeGroups();}         if (fRB.fDebugEnv!=null  && fRB.fDebugEnv.indexOf(""esets"")>=0) {printSets();}           //IntTrieBuilder(int aliasdata[], int maxdatalength,          //        int initialvalue, int leadunitvalue,          //        boolean latin1linear)                  fTrie = new IntTrieBuilder(null,   //   Data array  (utrie will allocate one)                                    100000,  //   Max Data Length                                    0,       //   Initial value for all code points                                    0,       //   Lead Surrogate unit value,                                    true);   //   Keep Latin 1 in separately.                  for (rlRange = fRangeList; rlRange!=null; rlRange=rlRange.fNext) {             fTrie.setRange(rlRange.fStartChar, rlRange.fEndChar+1, rlRange.fNum, true);         }     }
private ClassNode getClassNode(InputStream inputStream, int flags) {         ClassNode cn = new ClassNode();         try {             ClassReader reader = new ClassReader(inputStream);             reader.accept(cn, flags);             inputStream.close();         } catch (IOException e) {             cn = null;         }         return cn;     }
public final EObject ruleAndExpression() throws RecognitionException {         EObject current = null;          Token otherlv_2=null;         EObject this_NotExpression_0 = null;          EObject lv_right_3_0 = null;            enterRule();                       try {             // InternalSimpleAntlr.g:1025:28: ( (this_NotExpression_0= ruleNotExpression ( () otherlv_2= '&&' ( (lv_right_3_0= ruleNotExpression ) ) )* ) )             // InternalSimpleAntlr.g:1026:1: (this_NotExpression_0= ruleNotExpression ( () otherlv_2= '&&' ( (lv_right_3_0= ruleNotExpression ) ) )* )             {             // InternalSimpleAntlr.g:1026:1: (this_NotExpression_0= ruleNotExpression ( () otherlv_2= '&&' ( (lv_right_3_0= ruleNotExpression ) ) )* )             // InternalSimpleAntlr.g:1027:2: this_NotExpression_0= ruleNotExpression ( () otherlv_2= '&&' ( (lv_right_3_0= ruleNotExpression ) ) )*             {             if ( state.backtracking==0 ) {                                  /* */                              }             if ( state.backtracking==0 ) {                                       newCompositeNode(grammarAccess.getAndExpressionAccess().getNotExpressionParserRuleCall_0());                                 }             pushFollow(FOLLOW_26);             this_NotExpression_0=ruleNotExpression();              state._fsp--;             if (state.failed) return current;             if ( state.backtracking==0 ) {                                       current = this_NotExpression_0;                        afterParserOrEnumRuleCall();                                }             // InternalSimpleAntlr.g:1038:1: ( () otherlv_2= '&&' ( (lv_right_3_0= ruleNotExpression ) ) )*             loop20:             do {                 int alt20=2;                 int LA20_0 = input.LA(1);                  if ( (LA20_0==32) ) {                     alt20=1;                 }                   switch (alt20) {              case 1 :                  // InternalSimpleAntlr.g:1038:2: () otherlv_2= '&&' ( (lv_right_3_0= ruleNotExpression ) )                  {                  // InternalSimpleAntlr.g:1038:2: ()                  // InternalSimpleAntlr.g:1039:2:                   {                  if ( state.backtracking==0 ) {                                            /* */                                        }                  if ( state.backtracking==0 ) {                             current = forceCreateModelElementAndSet(                                grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(),                                current);                                          }                   }                   otherlv_2=(Token)match(input,32,FOLLOW_20); if (state.failed) return current;                  if ( state.backtracking==0 ) {                          newLeafNode(otherlv_2, grammarAccess.getAndExpressionAccess().getAmpersandAmpersandKeyword_1_1());                                          }                  // InternalSimpleAntlr.g:1051:1: ( (lv_right_3_0= ruleNotExpression ) )                  // InternalSimpleAntlr.g:1052:1: (lv_right_3_0= ruleNotExpression )                  {                  // InternalSimpleAntlr.g:1052:1: (lv_right_3_0= ruleNotExpression )                  // InternalSimpleAntlr.g:1053:3: lv_right_3_0= ruleNotExpression                  {                  if ( state.backtracking==0 ) {                                                  newCompositeNode(grammarAccess.getAndExpressionAccess().getRightNotExpressionParserRuleCall_1_2_0());                                            }                  pushFollow(FOLLOW_26);                  lv_right_3_0=ruleNotExpression();                   state._fsp--;                  if (state.failed) return current;                  if ( state.backtracking==0 ) {                              if (current==null) {                                 current = createModelElementForParent(grammarAccess.getAndExpressionRule());                             }                             set(                              current,                               ""right"",                              lv_right_3_0,                               ""org.eclipse.xtext.generator.parser.antlr.debug.SimpleAntlr.NotExpression"");                             afterParserOrEnumRuleCall();                                           }                   }                    }                    }                  break;               default :                  break loop20;                 }             } while (true);               }               }              if ( state.backtracking==0 ) {                leaveRule();              }         }                       catch (RecognitionException re) {                  recover(input,re);                  appendSkippedTokens();             }          finally {         }         return current;     }
@Override     protected Class<?> loadClass(String name, boolean resolve)             throws ClassNotFoundException {         synchronized (LaunchedURLClassLoader.LOCK_PROVIDER.getLock(this, name)) {             Class<?> loadedClass = findLoadedClass(name);             if (loadedClass == null) {                 Handler.setUseFastConnectionExceptions(true);                 try {                     loadedClass = doLoadClass(name);                 } finally {                     Handler.setUseFastConnectionExceptions(false);                 }             }             if (resolve) {                 resolveClass(loadedClass);             }             return loadedClass;         }     }
@SafeVarargs  public static <G extends Gene<?, G>, C extends Comparable<? super C>>  ConcatEngine<G, C> of(final EvolutionStreamable<G, C>... engines) {   return new ConcatEngine<>(Arrays.asList(engines));  }
public void onModuleLoad() {     asyncGetJson(AGGREGATORS_URL, new GotJsonCallback() {       public void got(final JSONValue json) {         // Do we need more manual type checking?  Not sure what will happen         // in the browser if something other than an array is returned.         final JSONArray aggs = json.isArray();         for (int i = 0; i < aggs.size(); i++) {           aggregators.add(aggs.get(i).isString().stringValue());         }         ((MetricForm) metrics.getWidget(0)).setAggregators(aggregators);         refreshFromQueryString();         refreshGraph();       }     });      // All UI elements need to regenerate the graph when changed.     {       final ValueChangeHandler<Date> vch = new ValueChangeHandler<Date>() {         public void onValueChange(final ValueChangeEvent<Date> event) {           refreshGraph();         }       };       TextBox tb = start_datebox.getTextBox();       tb.addBlurHandler(refreshgraph);       tb.addKeyPressHandler(refreshgraph);       start_datebox.addValueChangeHandler(vch);       tb = end_datebox.getTextBox();       tb.addBlurHandler(refreshgraph);       tb.addKeyPressHandler(refreshgraph);       end_datebox.addValueChangeHandler(vch);     }     autoreoload_interval.addBlurHandler(refreshgraph);     autoreoload_interval.addKeyPressHandler(refreshgraph);     yrange.addBlurHandler(refreshgraph);     yrange.addKeyPressHandler(refreshgraph);     y2range.addBlurHandler(refreshgraph);     y2range.addKeyPressHandler(refreshgraph);     ylog.addClickHandler(new AdjustYRangeCheckOnClick(ylog, yrange));     y2log.addClickHandler(new AdjustYRangeCheckOnClick(y2log, y2range));     ylog.addClickHandler(refreshgraph);     y2log.addClickHandler(refreshgraph);     ylabel.addBlurHandler(refreshgraph);     ylabel.addKeyPressHandler(refreshgraph);     y2label.addBlurHandler(refreshgraph);     y2label.addKeyPressHandler(refreshgraph);     yformat.addBlurHandler(refreshgraph);     yformat.addKeyPressHandler(refreshgraph);     y2format.addBlurHandler(refreshgraph);     y2format.addKeyPressHandler(refreshgraph);     wxh.addBlurHandler(refreshgraph);     wxh.addKeyPressHandler(refreshgraph);     global_annotations.addBlurHandler(refreshgraph);     global_annotations.addKeyPressHandler(refreshgraph);     horizontalkey.addClickHandler(refreshgraph);     keybox.addClickHandler(refreshgraph);     nokey.addClickHandler(refreshgraph);     smooth.addClickHandler(refreshgraph);     styles.addChangeHandler(refreshgraph);      yrange.setValidationRegexp(""^(""                            // Nothing or                                + ""|\\[([-+.0-9eE]+|\\*)?""      // ""[start                                + "":([-+.0-9eE]+|\\*)?\\])$"");  //   :end]""     yrange.setVisibleLength(5);     yrange.setMaxLength(44);  // MAX=2^26=20 chars: ""[-$MAX:$MAX]""     yrange.setText(""[0:]"");      y2range.setValidationRegexp(""^(""                            // Nothing or                                 + ""|\\[([-+.0-9eE]+|\\*)?""      // ""[start                                 + "":([-+.0-9eE]+|\\*)?\\])$"");  //   :end]""     y2range.setVisibleLength(5);     y2range.setMaxLength(44);  // MAX=2^26=20 chars: ""[-$MAX:$MAX]""     y2range.setText(""[0:]"");     y2range.setEnabled(false);     y2log.setEnabled(false);      ylabel.setVisibleLength(10);     ylabel.setMaxLength(50);  // Arbitrary limit.     y2label.setVisibleLength(10);     y2label.setMaxLength(50);  // Arbitrary limit.     y2label.setEnabled(false);      yformat.setValidationRegexp(""^(|.*%..*)$"");  // Nothing or at least one %?     yformat.setVisibleLength(10);     yformat.setMaxLength(16);  // Arbitrary limit.     y2format.setValidationRegexp(""^(|.*%..*)$"");  // Nothing or at least one %?     y2format.setVisibleLength(10);     y2format.setMaxLength(16);  // Arbitrary limit.     y2format.setEnabled(false);      wxh.setValidationRegexp(""^[1-9][0-9]{2,}x[1-9][0-9]{2,}$"");  // 100x100     wxh.setVisibleLength(9);     wxh.setMaxLength(11);  // 99999x99999     wxh.setText((Window.getClientWidth() - 20) + ""x""                 + (Window.getClientHeight() * 4 / 5));      final FlexTable table = new FlexTable();     table.setText(0, 0, ""From"");     {       final HorizontalPanel hbox = new HorizontalPanel();       hbox.add(new InlineLabel(""To""));       final Anchor now = new Anchor(""(now)"");       now.addClickHandler(new ClickHandler() {         public void onClick(final ClickEvent event) {           end_datebox.setValue(new Date());           refreshGraph();         }       });       hbox.add(now);       hbox.add(autoreload);       hbox.setWidth(""100%"");       table.setWidget(0, 1, hbox);     }     autoreload.addValueChangeHandler(new ValueChangeHandler<Boolean>() {       @Override       public void onValueChange(final ValueChangeEvent<Boolean> event) {         if (autoreload.getValue()) {           final HorizontalPanel hbox = new HorizontalPanel();           hbox.setWidth(""100%"");           hbox.add(new InlineLabel(""Every:""));           hbox.add(autoreoload_interval);           hbox.add(new InlineLabel(""seconds""));           table.setWidget(1, 1, hbox);           if (autoreoload_interval.getValue().isEmpty()) {             autoreoload_interval.setValue(""15"");           }           autoreoload_interval.setFocus(true);           lastgraphuri = """";  // Force refreshGraph.           refreshGraph();     // Trigger the 1st auto-reload         } else {           table.setWidget(1, 1, end_datebox);         }       }     });     autoreoload_interval.setValidationRegexp(""^([5-9]|[1-9][0-9]+)$"");  // >=5s     autoreoload_interval.setMaxLength(4);     autoreoload_interval.setVisibleLength(8);      table.setWidget(1, 0, start_datebox);     table.setWidget(1, 1, end_datebox);     {       final HorizontalPanel hbox = new HorizontalPanel();       hbox.add(new InlineLabel(""WxH:""));       hbox.add(wxh);       table.setWidget(0, 3, hbox);     }     {       final HorizontalPanel hbox = new HorizontalPanel();       hbox.add(global_annotations);       table.setWidget(0, 4, hbox);     }     {       addMetricForm(""metric 1"", 0);       metrics.selectTab(0);       metrics.add(new InlineLabel(""Loading...""), ""+"");       metrics.addBeforeSelectionHandler(new BeforeSelectionHandler<Integer>() {         public void onBeforeSelection(final BeforeSelectionEvent<Integer> event) {           final int item = event.getItem();           final int nitems = metrics.getWidgetCount();           if (item == nitems - 1) {  // Last item: the ""+"" was clicked.             event.cancel();             final MetricForm metric = addMetricForm(""metric "" + nitems, item);             metrics.selectTab(item);             metric.setFocus(true);           }         }       });       table.setWidget(2, 0, metrics);     }     table.getFlexCellFormatter().setColSpan(2, 0, 2);     table.getFlexCellFormatter().setRowSpan(1, 3, 2);     final DecoratedTabPanel optpanel = new DecoratedTabPanel();     optpanel.add(makeAxesPanel(), ""Axes"");     optpanel.add(makeKeyPanel(), ""Key"");     optpanel.add(makeStylePanel(), ""Style"");     optpanel.selectTab(0);     table.setWidget(1, 3, optpanel);     table.getFlexCellFormatter().setColSpan(1, 3, 2);      final DecoratorPanel decorator = new DecoratorPanel();     decorator.setWidget(table);     final VerticalPanel graphpanel = new VerticalPanel();     graphpanel.add(decorator);     {       final VerticalPanel graphvbox = new VerticalPanel();       graphvbox.add(graphstatus);        graph.setVisible(false);        // Put the graph image element and the zoombox elements inside the absolute panel       graphbox.add(graph, 0, 0);       zoom_box.setVisible(false);       graphbox.add(zoom_box, 0, 0);       graph.addMouseOverHandler(new MouseOverHandler() {         public void onMouseOver(final MouseOverEvent event) {           final Style style = graphbox.getElement().getStyle();           style.setCursor(Cursor.CROSSHAIR);         }       });       graph.addMouseOutHandler(new MouseOutHandler() {         public void onMouseOut(final MouseOutEvent event) {           final Style style = graphbox.getElement().getStyle();           style.setCursor(Cursor.AUTO);         }       });        graphvbox.add(graphbox);       graph.addErrorHandler(new ErrorHandler() {         public void onError(final ErrorEvent event) {           graphstatus.setText(""Oops, failed to load the graph."");         }       });       graph.addLoadHandler(new LoadHandler() {         public void onLoad(final LoadEvent event) {           graphbox.setWidth(graph.getWidth() + ""px"");           graphbox.setHeight(graph.getHeight() + ""px"");         }       });        graphpanel.add(graphvbox);     }     final DecoratedTabPanel mainpanel = new DecoratedTabPanel();     mainpanel.setWidth(""100%"");     mainpanel.add(graphpanel, ""Graph"");     mainpanel.add(stats_table, ""Stats"");     mainpanel.add(logs, ""Logs"");     mainpanel.add(build_data, ""Version"");     mainpanel.selectTab(0);     mainpanel.addBeforeSelectionHandler(new BeforeSelectionHandler<Integer>() {       public void onBeforeSelection(final BeforeSelectionEvent<Integer> event) {         clearError();         final int item = event.getItem();         switch (item) {           case 1: refreshStats(); return;           case 2: refreshLogs(); return;           case 3: refreshVersion(); return;         }       }     });     final VerticalPanel root = new VerticalPanel();     root.setWidth(""100%"");     root.add(current_error);     current_error.setVisible(false);     current_error.addStyleName(""dateBoxFormatError"");     root.add(mainpanel);     RootPanel.get(""queryuimain"").add(root);     // Must be done at the end, once all the widgets are attached.     ensureSameWidgetSize(optpanel);      History.addHistoryListener(this);   }
public static AssociativeArray normalDistributionGetParams(FlatDataCollection flatDataCollection) {         AssociativeArray params = new AssociativeArray();         params.put(""mean"", Descriptives.mean(flatDataCollection));         params.put(""variance"", Descriptives.variance(flatDataCollection, true));         return params;     }
public EjbRelationshipRoleType<EjbRelationType<T>> getOrCreateEjbRelationshipRole()    {       List<Node> nodeList = childNode.get(""ejb-relationship-role"");       if (nodeList != null &&  nodeList.size() > 0)       {          return new EjbRelationshipRoleTypeImpl<EjbRelationType<T>>(this, ""ejb-relationship-role"", childNode, nodeList.get(0));       }       return createEjbRelationshipRole();    }
@Nullable     @Override     public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {         if (ACRA.DEV_LOGGING) ACRA.log.d(ACRA.LOG_TAG, ""Query: "" + uri);         final File file = getFileForUri(uri);         if (file == null) {             return null;         }         if (projection == null) {             projection = COLUMNS;         }         final Map<String, Object> columnValueMap = new LinkedHashMap<>();         for (String column : projection) {             if (column.equals(OpenableColumns.DISPLAY_NAME)) {                 columnValueMap.put(OpenableColumns.DISPLAY_NAME, file.getName());             } else if (column.equals(OpenableColumns.SIZE)) {                 columnValueMap.put(OpenableColumns.SIZE, file.length());             }         }         final MatrixCursor cursor = new MatrixCursor(columnValueMap.keySet().toArray(new String[columnValueMap.size()]), 1);         cursor.addRow(columnValueMap.values());         return cursor;     }
private ZealotKhala doNormal(String prefix, String field, Object value, String suffix, boolean match) {         if (match) {             SqlInfoBuilder.newInstace(this.source.setPrefix(prefix)).buildNormalSql(field, value, suffix);             this.source.resetPrefix();         }         return this;     }
public DocumentPath parent() {     if (pathElements.size() <= 1) {       return null;     }     return new DocumentPath(this.pathElements.subList(0, pathElements.size() - 1));   }
@Override     public Date parseRFC1123Time(String input) throws ParseException {         if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {             Tr.debug(tc, ""rfc1123 parsing ["" + input + ""]"");         }         Date d = attemptParse(getFormat().get1123Parse(), input);         if (null == d) {             throw new ParseException(""Unparseable ["" + input + ""]"", 0);         }         return d;     }
public String readStaticExportPublishedResourceParameters(CmsRequestContext context, String rfsName)     throws CmsException {          CmsDbContext dbc = m_dbContextFactory.getDbContext(context);         String result = null;         try {             result = m_driverManager.readStaticExportPublishedResourceParameters(dbc, rfsName);         } catch (Exception e) {             dbc.report(                 null,                 Messages.get().container(Messages.ERR_READ_STATEXP_PUBLISHED_RESOURCE_PARAMS_1, rfsName),                 e);         } finally {             dbc.clear();         }         return result;     }
public Parser<?> phrase(String... tokenNames) {     Parser<?>[] wordParsers = new Parser<?>[tokenNames.length];     for (int i = 0; i < tokenNames.length; i++) {       wordParsers[i] = token(tokenNames[i]);     }     String phrase = Strings.join("" "", tokenNames);     return Parsers.sequence(wordParsers).atomic().retn(phrase).label(phrase);   }
public final EObject ruleConditionalBranch() throws RecognitionException {         EObject current = null;          Token otherlv_2=null;         Token otherlv_4=null;         EObject this_UnorderedGroup_0 = null;          EObject lv_guardCondition_3_0 = null;          EObject lv_elements_5_0 = null;             enterRule();          try {             // InternalXtext.g:1048:2: ( (this_UnorderedGroup_0= ruleUnorderedGroup | ( () otherlv_2= '<' ( (lv_guardCondition_3_0= ruleDisjunction ) ) otherlv_4= '>' ( (lv_elements_5_0= ruleAbstractToken ) )+ ) ) )             // InternalXtext.g:1049:2: (this_UnorderedGroup_0= ruleUnorderedGroup | ( () otherlv_2= '<' ( (lv_guardCondition_3_0= ruleDisjunction ) ) otherlv_4= '>' ( (lv_elements_5_0= ruleAbstractToken ) )+ ) )             {             // InternalXtext.g:1049:2: (this_UnorderedGroup_0= ruleUnorderedGroup | ( () otherlv_2= '<' ( (lv_guardCondition_3_0= ruleDisjunction ) ) otherlv_4= '>' ( (lv_elements_5_0= ruleAbstractToken ) )+ ) )             int alt28=2;             int LA28_0 = input.LA(1);              if ( ((LA28_0>=RULE_STRING && LA28_0<=RULE_ID)||LA28_0==15||LA28_0==34||(LA28_0>=39 && LA28_0<=40)||(LA28_0>=42 && LA28_0<=43)) ) {                 alt28=1;             }             else if ( (LA28_0==27) ) {                 alt28=2;             }             else {                 NoViableAltException nvae =                     new NoViableAltException("""", 28, 0, input);                  throw nvae;             }             switch (alt28) {                 case 1 :                     // InternalXtext.g:1050:3: this_UnorderedGroup_0= ruleUnorderedGroup                     {                         newCompositeNode(grammarAccess.getConditionalBranchAccess().getUnorderedGroupParserRuleCall_0());                                            pushFollow(FollowSets000.FOLLOW_2);                     this_UnorderedGroup_0=ruleUnorderedGroup();                      state._fsp--;                          current = this_UnorderedGroup_0;                        afterParserOrEnumRuleCall();                                             }                     break;                 case 2 :                     // InternalXtext.g:1059:3: ( () otherlv_2= '<' ( (lv_guardCondition_3_0= ruleDisjunction ) ) otherlv_4= '>' ( (lv_elements_5_0= ruleAbstractToken ) )+ )                     {                     // InternalXtext.g:1059:3: ( () otherlv_2= '<' ( (lv_guardCondition_3_0= ruleDisjunction ) ) otherlv_4= '>' ( (lv_elements_5_0= ruleAbstractToken ) )+ )                     // InternalXtext.g:1060:4: () otherlv_2= '<' ( (lv_guardCondition_3_0= ruleDisjunction ) ) otherlv_4= '>' ( (lv_elements_5_0= ruleAbstractToken ) )+                     {                     // InternalXtext.g:1060:4: ()                     // InternalXtext.g:1061:5:                      {                           current = forceCreateModelElement(                           grammarAccess.getConditionalBranchAccess().getGroupAction_1_0(),                           current);                                               }                      otherlv_2=(Token)match(input,27,FollowSets000.FOLLOW_26);                           newLeafNode(otherlv_2, grammarAccess.getConditionalBranchAccess().getLessThanSignKeyword_1_1());                                             // InternalXtext.g:1071:4: ( (lv_guardCondition_3_0= ruleDisjunction ) )                     // InternalXtext.g:1072:5: (lv_guardCondition_3_0= ruleDisjunction )                     {                     // InternalXtext.g:1072:5: (lv_guardCondition_3_0= ruleDisjunction )                     // InternalXtext.g:1073:6: lv_guardCondition_3_0= ruleDisjunction                     {                            newCompositeNode(grammarAccess.getConditionalBranchAccess().getGuardConditionDisjunctionParserRuleCall_1_2_0());                                               pushFollow(FollowSets000.FOLLOW_27);                     lv_guardCondition_3_0=ruleDisjunction();                      state._fsp--;                             if (current==null) {                            current = createModelElementForParent(grammarAccess.getConditionalBranchRule());                           }                           set(                            current,                            ""guardCondition"",                            lv_guardCondition_3_0,                            ""org.eclipse.xtext.Xtext.Disjunction"");                           afterParserOrEnumRuleCall();                                                }                       }                      otherlv_4=(Token)match(input,28,FollowSets000.FOLLOW_28);                           newLeafNode(otherlv_4, grammarAccess.getConditionalBranchAccess().getGreaterThanSignKeyword_1_3());                                             // InternalXtext.g:1094:4: ( (lv_elements_5_0= ruleAbstractToken ) )+                     int cnt27=0;                     loop27:                     do {                         int alt27=2;                         int LA27_0 = input.LA(1);                          if ( ((LA27_0>=RULE_STRING && LA27_0<=RULE_ID)||LA27_0==15||LA27_0==34||(LA27_0>=39 && LA27_0<=40)||(LA27_0>=42 && LA27_0<=43)) ) {                             alt27=1;                         }                           switch (alt27) {                      case 1 :                          // InternalXtext.g:1095:5: (lv_elements_5_0= ruleAbstractToken )                          {                          // InternalXtext.g:1095:5: (lv_elements_5_0= ruleAbstractToken )                          // InternalXtext.g:1096:6: lv_elements_5_0= ruleAbstractToken                          {                                 newCompositeNode(grammarAccess.getConditionalBranchAccess().getElementsAbstractTokenParserRuleCall_1_4_0());                                                         pushFollow(FollowSets000.FOLLOW_29);                          lv_elements_5_0=ruleAbstractToken();                           state._fsp--;                                  if (current==null) {                                 current = createModelElementForParent(grammarAccess.getConditionalBranchRule());                                }                                add(                                 current,                                 ""elements"",                                 lv_elements_5_0,                                 ""org.eclipse.xtext.Xtext.AbstractToken"");                                afterParserOrEnumRuleCall();                                                          }                            }                          break;                       default :                          if ( cnt27 >= 1 ) break loop27;                                 EarlyExitException eee =                                     new EarlyExitException(27, input);                                 throw eee;                         }                         cnt27++;                     } while (true);                       }                       }                     break;              }               }                leaveRule();          }              catch (RecognitionException re) {                 recover(input,re);                 appendSkippedTokens();             }         finally {         }         return current;     }
public static LocalDate adjustToFirstDayOfWeek(LocalDate date, DayOfWeek firstDayOfWeek) {         LocalDate newDate = date.with(DAY_OF_WEEK, firstDayOfWeek.getValue());         if (newDate.isAfter(date)) {             newDate = newDate.minusWeeks(1);         }          return newDate;     }
public TableDescription createTable(ProvisionedThroughput throughput) {         final CreateTableRequest request = mapper.generateCreateTableRequest(model.targetType());         request.setProvisionedThroughput(throughput);         if (request.getGlobalSecondaryIndexes() != null) {             for (final GlobalSecondaryIndex gsi : request.getGlobalSecondaryIndexes()) {                 gsi.setProvisionedThroughput(throughput);             }         }         return db.createTable(request).getTableDescription();     }
private void addColumn(String label, int width, Column<CmsHistoryResourceBean, ?> col) {          addColumn(col, label);         setColumnWidth(col, width, Unit.PX);     }
public boolean accept(ItemData item)     {        QPathEntry itemEntry = item.getQPath().getEntries()[item.getQPath().getDepth()];        return entry.equals(itemEntry);     }
public void readImage() {     if (ifd.containsTagId(TiffTags.getTagId(""StripOffsets""))         || ifd.containsTagId(TiffTags.getTagId(""StripBYTECount""))) {       readStrips();     }     if (ifd.containsTagId(TiffTags.getTagId(""TileOffsets""))         || ifd.containsTagId(TiffTags.getTagId(""TileBYTECounts""))) {       readTiles();     }   }
@Override   public OperationFuture<CASResponse>   asyncCAS(String key, long casId, Object value) {     return asyncCAS(key, casId, value, transcoder);   }
@Override  protected String applyLink( String text, String linkId ) {    String link;   if( this.options.containsKey( DocConstants.OPTION_HTML_EXPLODED ))    link = ""components/"" + linkId + "".html"".replace( "" "", ""%20"" );   else    link = ""#"" + createId( linkId );    return text.replaceAll( Pattern.quote( text ), ""<a href=\"""" + link + ""\"">"" + text + ""</a>"" );  }
private static Method searchCandidates(List<Method> candidateMethods, Method bridgeMethod) {   if (candidateMethods.isEmpty()) {    return null;   }   Map<TypeVariable, Type> typeParameterMap = GenericTypeResolver.getTypeVariableMap(bridgeMethod.getDeclaringClass());   Method previousMethod = null;   boolean sameSig = true;   for (Method candidateMethod : candidateMethods) {    if (isBridgeMethodFor(bridgeMethod, candidateMethod, typeParameterMap)) {     return candidateMethod;    }    else if (previousMethod != null) {     sameSig = sameSig &&       Arrays.equals(candidateMethod.getGenericParameterTypes(), previousMethod.getGenericParameterTypes());    }    previousMethod = candidateMethod;   }   return (sameSig ? candidateMethods.get(0) : null);  }
@Override     public VirtualResource expand( final Resource resource )         throws TransferException     {         List<Location> locations;         if ( resource instanceof VirtualResource )         {             final List<ConcreteResource> concrete = ( (VirtualResource) resource ).toConcreteResources();             final List<ConcreteResource> result = new ArrayList<ConcreteResource>();             for ( final ConcreteResource cr : concrete )             {                 final List<Location> expanded = expand( cr.getLocation() );                 for ( final Location location : expanded )                 {                     result.add( new ConcreteResource( location, cr.getPath() ) );                 }             }              return new VirtualResource( result );         }         else         {             final ConcreteResource cr = (ConcreteResource) resource;             locations = expand( cr.getLocation() );              return new VirtualResource( locations, cr.getPath() );         }     }
public void registerFlushDelay (Class<?> objclass, long delay)     {         _delays.put(objclass, Long.valueOf(delay));     }
public Signature appendArg(String name, Class<?> type) {         String[] newArgNames = new String[argNames.length + 1];         System.arraycopy(argNames, 0, newArgNames, 0, argNames.length);         newArgNames[argNames.length] = name;         MethodType newMethodType = methodType.appendParameterTypes(type);         return new Signature(newMethodType, newArgNames);     }
@XmlElementDecl(namespace = ""http://www.opengis.net/gml"", name = ""File"")     public JAXBElement<FileType> createFile(FileType value) {         return new JAXBElement<FileType>(_File_QNAME, FileType.class, null, value);     }
public Task poll() {      Task result=null;      if(activeIndex==0)      {       result=taskList[0].poll();       if(result!=null)        result.removeFromQueue0();            }      else      {       result=taskList[1].poll();       if(result!=null)        result.removeFromQueue1();      }            return result;                }
public void play(int position) {         checkState();         ArrayList<SoundCloudTrack> tracks = mPlayerPlaylist.getPlaylist().getTracks();         if (position >= 0 && position < tracks.size()) {             SoundCloudTrack trackToPlay = tracks.get(position);             mPlayerPlaylist.setPlayingTrack(position);             PlaybackService.play(getContext(), mClientKey, trackToPlay);         }      }
public com.google.api.ads.adwords.axis.v201809.cm.SharedSetType getType() {         return type;     }
public static current_hostname modify(nitro_service client, current_hostname resource) throws Exception   {    resource.validate(""modify"");    return ((current_hostname[]) resource.update_resource(client))[0];   }
@Override  public void read(DataInputView in) throws IOException {   final boolean isNotNull = in.readBoolean();   if (isNotNull) {    final String scheme = StringUtils.readNullableString(in);    final String userInfo = StringUtils.readNullableString(in);    final String host = StringUtils.readNullableString(in);    final int port = in.readInt();    final String path = StringUtils.readNullableString(in);    final String query = StringUtils.readNullableString(in);    final String fragment = StringUtils.readNullableString(in);     try {     uri = new URI(scheme, userInfo, host, port, path, query, fragment);    } catch (URISyntaxException e) {     throw new IOException(""Error reconstructing URI"", e);    }   }  }
@RequestMapping(method = RequestMethod.POST, params = ""action=removeByFName"")     public ModelAndView removeByFName(             HttpServletRequest request,             HttpServletResponse response,             @RequestParam(value = ""fname"") String fname)             throws IOException {          IUserInstance ui = userInstanceManager.getUserInstance(request);          UserPreferencesManager upm = (UserPreferencesManager) ui.getPreferencesManager();         IUserLayoutManager ulm = upm.getUserLayoutManager();          try {             String elementId =                     ulm.getUserLayout().findNodeId(new PortletSubscribeIdResolver(fname));             if (elementId != null) {                 // Delete the requested element node.  This code is the same for                 // all node types, so we can just have a generic action.                 if (!ulm.deleteNode(elementId)) {                     logger.info(                             ""Failed to remove element ID {} from layout root folder ID {}, delete node returned false"",                             elementId,                             ulm.getRootFolderId());                     response.setStatus(HttpServletResponse.SC_FORBIDDEN);                     return new ModelAndView(                             ""jsonView"",                             Collections.singletonMap(                                     ""error"",                                     getMessage(                                             ""error.element.update"",                                             ""Unable to update element"",                                             RequestContextUtils.getLocale(request))));                 }             } else {                 response.sendError(HttpServletResponse.SC_BAD_REQUEST);                 return null;             }              ulm.saveUserLayout();              return new ModelAndView(""jsonView"", Collections.emptyMap());          } catch (PortalException e) {             return handlePersistError(request, response, e);         }     }
@Override  public void caseILexLocation(ILexLocation node) throws AnalysisException  {   AstLocation location = new AstLocation(current, node);   if (reference.contains(node.getStartOffset(), node.getEndOffset(), node.getFile()))// we need to do set some                        // upper limit on the                        // precision here. e.g. an                        // operation may match but                        // it has a body that may                        // contain a better match   {    throw new LocationFound(location);   } else if(reference.canMatch(node.getFile()))   {    closest = getClosest(reference, location);   }  }
public static ServerWebExchangeMatcher pathMatchers(HttpMethod method, String... patterns) {   List<ServerWebExchangeMatcher> matchers = new ArrayList<>(patterns.length);   for (String pattern : patterns) {    matchers.add(new PathPatternParserServerWebExchangeMatcher(pattern, method));   }   return new OrServerWebExchangeMatcher(matchers);  }
public Matrix4x3d rotation(double angle, Vector3dc axis) {         return rotation(angle, axis.x(), axis.y(), axis.z());     }
public KeyAreaInfo setKeyArea(String strKeyName)     {         KeyAreaInfo keyArea = null;         if (strKeyName == null)             strKeyName = Constants.PRIMARY_KEY;         for (m_iDefaultOrder = Constants.MAIN_KEY_AREA; m_iDefaultOrder < this.getKeyAreaCount() - Constants.MAIN_KEY_AREA; m_iDefaultOrder++)         {             keyArea = this.getKeyArea(m_iDefaultOrder);             if (keyArea.getKeyName().equals(strKeyName))                 return keyArea;     // Found key area         }         if (Constants.PRIMARY_KEY.equals(strKeyName))         {             m_iDefaultOrder = Constants.MAIN_KEY_AREA;  // Set to default.             return this.getKeyArea(m_iDefaultOrder);         }         m_iDefaultOrder = Constants.MAIN_KEY_AREA;  // Not found!!! Set to default.         return null;     }
public void marshall(GetDeploymentStatusRequest getDeploymentStatusRequest, ProtocolMarshaller protocolMarshaller) {          if (getDeploymentStatusRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(getDeploymentStatusRequest.getDeploymentId(), DEPLOYMENTID_BINDING);             protocolMarshaller.marshall(getDeploymentStatusRequest.getGroupId(), GROUPID_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public String pipelineWrite(String key, DataGenerator dataGenerator, int max_pipe_keys, int min_pipe_keys)             throws Exception {         // Create a random key between [0,MAX_PIPE_KEYS]         int pipe_keys = randomGenerator.nextInt(max_pipe_keys);          // Make sure that the number of keys in the pipeline are at least         // MIN_PIPE_KEYS         pipe_keys = Math.max(min_pipe_keys, pipe_keys);          DynoJedisPipeline pipeline = this.jedisClient.get().pipelined();         Map<String, Response<String>> responses = new HashMap<>();          /**          * writeSingle returns a single string, so we want to create a          * StringBuilder to append all the keys in the form ""key_n"". This is          * just used to return a single string          */         StringBuilder sb = new StringBuilder();         // Iterate across the number of keys in the pipeline and set         for (int n = 0; n < pipe_keys; ++n) {             String nth_key = key + ""_"" + n;             sb.append(nth_key);             Response<String> resp = pipeline.set(key, key + dataGenerator.getRandomValue() + key);             responses.put(nth_key, resp);         }         pipeline.sync();          return sb.toString();     }
private String getUserAccessId(String userName) {          try {             SecurityService securityService = securityServiceRef.getService();             UserRegistryService userRegistryService = securityService.getUserRegistryService();             UserRegistry userRegistry = userRegistryService.getUserRegistry();             String realm = userRegistry.getRealm();             String uniqueId = userRegistry.getUniqueUserId(userName);             return AccessIdUtil.createAccessId(AccessIdUtil.TYPE_USER, realm, uniqueId);         } catch (EntryNotFoundException e) {             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                 Tr.debug(tc, ""Caught exception getting the access id for ""                              + userName + "": "" + e);             }         } catch (RegistryException e) {             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                 Tr.debug(tc, ""Caught exception getting the access id for ""                              + userName + "": "" + e);             }         }         return null;     }
public void print(String s) throws IOException   {     if (_startLine)       printIndent();      if (s == null) {       _lastCr = false;       _os.print(""null"");        return;     }      int len = s.length();     for (int i = 0; i < len; i++) {       int ch = s.charAt(i);        if (ch == '\n' && !_lastCr)         _destLine++;       else if (ch == '\r')         _destLine++;        _lastCr = ch == '\r';        _os.print((char) ch);     }   }
public static <T> Map<Key<T>, Class<? extends T>> associateInterfaceToImplementations(Class<T> anInterface,             Collection<Class<? extends T>> implementations, boolean overridingMode) {         return BindingUtils.resolveBindingDefinitions(anInterface, implementations.stream()                 .filter(overridingMode ? isOverridingImplementation() : isOverridingImplementation().negate())                 .collect(Collectors.toList()));     }
public static WeldContainer current() {         List<String> ids = WeldContainer.getRunningContainerIds();         if (ids.size() == 1) {             return WeldContainer.instance(ids.get(0));         } else {             // if there is either no container or multiple containers we want to throw exception             // in this case Weld cannot determine which container is ""current""             throw WeldSELogger.LOG.zeroOrMoreThanOneContainerRunning();         }     }
@NonNull     public Expression notEqualTo(@NonNull Expression expression) {         if (expression == null) {             throw new IllegalArgumentException(""expression cannot be null."");         }         return new BinaryExpression(this, expression, BinaryExpression.OpType.NotEqualTo);     }
public void cleanTemp() {     CommandLine dumpcommand = adbCommand(""shell"", ""rm"", ""-r"",         ""/data/local/tmp/local/tmp/dump.xml"");     executeCommandQuietly(dumpcommand);     try {       // give it a second to recover from the activity start       Thread.sleep(1000);     } catch (InterruptedException ie) {       throw new RuntimeException(ie);     }      CommandLine qiancommand = adbCommand(""shell"", ""rm"", ""-r"",         ""/data/local/tmp/local/tmp/qian.xml"");     String output = executeCommandQuietly(qiancommand);     log.debug(""Delete file qian.xml: {}"", output);     try {       // give it a second to recover from the activity start       Thread.sleep(1000);     } catch (InterruptedException ie) {       throw new RuntimeException(ie);     }      CommandLine command = adbCommand(""shell"", ""rm"", ""-r"",         ""/data/local/tmp/uidump.xml"");     executeCommandQuietly(command);     try {       // give it a second to recover from the activity start       Thread.sleep(1000);     } catch (InterruptedException ie) {       throw new RuntimeException(ie);     }   }
@ConditionalOnClass(name = {""io.grpc.netty.shaded.io.netty.channel.Channel"",             ""io.grpc.netty.shaded.io.grpc.netty.NettyServerBuilder""})     @Bean     public ShadedNettyGrpcServerFactory shadedNettyGrpcServerFactory(final GrpcServerProperties properties,             final GrpcServiceDiscoverer serviceDiscoverer, final List<GrpcServerConfigurer> serverConfigurers) {         final ShadedNettyGrpcServerFactory factory = new ShadedNettyGrpcServerFactory(properties, serverConfigurers);         for (final GrpcServiceDefinition service : serviceDiscoverer.findGrpcServices()) {             factory.addService(service);         }         return factory;     }
final byte[] decodeChecked(CharSequence chars)       throws DecodingException {     chars = trimTrailingPadding(chars);     byte[] tmp = new byte[maxDecodedSize(chars.length())];     int len = decodeTo(tmp, chars);     return extract(tmp, len);   }
public String userActionItem(String action, String uid, String iid,       Map<String, Object> properties, DateTime eventTime)       throws ExecutionException, InterruptedException, IOException {     return createEvent(userActionItemAsFuture(action, uid, iid, properties, eventTime));   }
public void slcount(final String keyspace, final String uid) {         slcount(SafeEncoder.encode(keyspace), SafeEncoder.encode(uid));     }
@Override  public boolean eIsSet(int featureID) {   switch (featureID) {    case AfplibPackage.FNNRG2__TSID_LEN:     return TSID_LEN_EDEFAULT == null ? tsidLen != null : !TSID_LEN_EDEFAULT.equals(tsidLen);    case AfplibPackage.FNNRG2__TSID:     return TSID_EDEFAULT == null ? tsid != null : !TSID_EDEFAULT.equals(tsid);   }   return super.eIsSet(featureID);  }
protected int getColor(Context ctx) {         int color;         if (this.isEnabled()) {             color = ColorHolder.color(getTextColor(), ctx, R.attr.material_drawer_primary_text, R.color.material_drawer_primary_text);         } else {             color = ColorHolder.color(getDisabledTextColor(), ctx, R.attr.material_drawer_hint_text, R.color.material_drawer_hint_text);         }         return color;     }
protected ByteBuffer inputStreamToByteBuffer() throws IOException {         return byteBuffer == null ? byteBuffer = ByteBuffer.wrap(inputStreamToByteArray()) : byteBuffer;     }
protected void sendClientResponse(PendingOpsRequest request) {         byte statusCode = ClientResponse.SUCCESS;         String statusString = null;         /*          * It is possible not to receive a table response if a feature is not enabled          */         // All of the null/empty table handling/detecting/generation sucks.  Just making it         // work for now, not making it pretty. --izzy         VoltTable responseTables[] = request.aggregateTables;         if (responseTables == null || responseTables.length == 0) {             responseTables = new VoltTable[0];             statusCode = ClientResponse.GRACEFUL_FAILURE;             statusString =                 ""Requested info \"""" + request.subselector +                 ""\"" is not yet available or not supported in the current configuration."";         }          ClientResponseImpl response =             new ClientResponseImpl(statusCode, ClientResponse.UNINITIALIZED_APP_STATUS_CODE, null,                     responseTables, statusString);         response.setClientHandle(request.clientData);         ByteBuffer buf = ByteBuffer.allocate(response.getSerializedSize() + 4);         buf.putInt(buf.capacity() - 4);         response.flattenToBuffer(buf).flip();         request.c.writeStream().enqueue(buf);     }
static boolean matchValue(FacesContext ctx,                               UIComponent component,                               Object value,                               Iterator<SelectItem> items,                               Converter converter) {          while (items.hasNext()) {             SelectItem item = items.next();             if (item instanceof SelectItemGroup) {                 SelectItem subitems[] =                       ((SelectItemGroup) item).getSelectItems();                 if ((subitems != null) && (subitems.length > 0)) {                     if (matchValue(ctx, component, value, new ArrayIterator(subitems), converter)) {                         return (true);                     }                 }             } else {                 Object compareValue = null;                                  try {                     compareValue = doConversion(ctx, component, item, value,                         converter);                 } catch (IllegalStateException ise) {                     continue;                 }                                  if (null == compareValue && null == value) {                     return true;                 }                  if (value.equals(compareValue)) {                     return (true);                 }             }         }         return (false);      }
private Node getNode(Node nodeStart, String key, CreateMode createMode, boolean bReturnTextNode)     {         if (key.indexOf('/') != -1)         {             String strKeyParent = key.substring(0, key.indexOf('/'));             CreateMode createModeParent = createMode;             if (createModeParent == CreateMode.CREATE_NEW_NODE)                 createModeParent = CreateMode.CREATE_IF_NOT_FOUND;  // Only create a duplicate node at the leaf level.             nodeStart = this.getNode(nodeStart, strKeyParent, createModeParent, false);             if (nodeStart == null)                 return null;             key = key.substring(key.indexOf('/') + 1);             return this.getNode(nodeStart, key, createMode, bReturnTextNode);         }         if (nodeStart == null)             nodeStart = this.getNode(true);          int iIndex = Integer.MAX_VALUE;         if (key.indexOf('[') != -1)         {             iIndex = Integer.parseInt(key.substring(key.indexOf('[') + 1, key.indexOf(']')));             key = key.substring(0, key.indexOf('['));         }         key = Util.fixDOMElementName(key);         Node node = null;         NodeList nodeList = ((Element)nodeStart).getElementsByTagName(key);         if (nodeList != null)         {             for (int i = 0; i < nodeList.getLength(); i++)             {                 if (nodeList.item(i).getParentNode() == nodeStart)                 {                     node = nodeList.item(i);    // Get the last child.                     if (iIndex != Integer.MAX_VALUE)                     {                         if (--iIndex == 0)                             break;  // This is the correct node                         node = null;    // If you are looking for a specific node, and it doesn't exist, return null.                     }                 }             }         }         if (((node == null) && (createMode != CreateMode.DONT_CREATE))                 || (createMode == CreateMode.CREATE_NEW_NODE))         {          Document doc = null;          if (m_data instanceof Document)           doc = (Document)m_data;          if (doc == null)           doc = ((Node)m_data).getOwnerDocument();             node = doc.createElement(key);             if (bReturnTextNode)             {                 if (createMode != CreateMode.CREATE_CDATA_NODE)                     node.appendChild(doc.createTextNode(Constant.BLANK));                 else                     node.appendChild(doc.createCDATASection(Constant.BLANK));             }             nodeStart.appendChild(node);         }         if (node != null)             if (bReturnTextNode)                 node = node.getFirstChild();         return node;    // Return new node or null.     }
@When(""^I double click on the element on index '(\\d+?)'$"")     public void seleniumDoubleClick(Integer index) throws InterruptedException {         Actions action = new Actions(commonspec.getDriver());         try {             assertThat(this.commonspec, commonspec.getPreviousWebElements()).as(""There are less found elements than required"")                     .hasAtLeast(index);             action.doubleClick(commonspec.getPreviousWebElements().getPreviousWebElements().get(index)).perform();          } catch (AssertionError e) {             Thread.sleep(1000);             assertThat(this.commonspec, commonspec.getPreviousWebElements()).as(""There are less found elements than required"")                     .hasAtLeast(index);             action.doubleClick(commonspec.getPreviousWebElements().getPreviousWebElements().get(index)).perform();         }     }
public static DateTime toDateAdvanced(Object o, TimeZone timeZone, DateTime defaultValue) {  if (o instanceof DateTime) return (DateTime) o;  else if (o instanceof Date) return new DateTimeImpl((Date) o);  else if (o instanceof Castable) {      return ((Castable) o).castToDateTime(defaultValue);  }  else if (o instanceof String) return toDateAdvanced(o.toString(), timeZone, defaultValue);  else if (o instanceof Number) return util.toDateTime(((Number) o).doubleValue());  else if (o instanceof Calendar) {      return new DateTimeImpl((Calendar) o);  }  else if (o instanceof ObjectWrap) return toDateAdvanced(((ObjectWrap) o).getEmbededObject(defaultValue), timeZone, defaultValue);  return defaultValue;     }
public void setStreams(java.util.Collection<StreamSummary> streams) {         if (streams == null) {             this.streams = null;             return;         }          this.streams = new java.util.ArrayList<StreamSummary>(streams);     }
@NotNull      public static String computeSessionId(@NotNull final String aString) {          final byte[] byteData = DigestUtils.sha256(aString.getBytes());          final StringBuilder sb = new StringBuilder(""SQLQuery:"");            for (final byte aByteData : byteData) {              final String hex = Integer.toHexString(0xFF & aByteData);              if (hex.length() == 1) {                  sb.append('0');              }              sb.append(hex);          }          return sb.toString();      }
public void setCookies(List<HttpCookie> cookies) {          if (cookies.isEmpty()) {              setHeader(HttpHeader.COOKIE, null);          }            StringBuilder sbData = new StringBuilder();            for (HttpCookie c : cookies) {              sbData.append(c.getName());              sbData.append('=');              sbData.append(c.getValue());              sbData.append(""; "");          }            if (sbData.length() <= 3) {              setHeader(HttpHeader.COOKIE, null);              return;          }            final String data = sbData.substring(0, sbData.length() - 2);          setHeader(HttpHeader.COOKIE, data);      }
private static void assertXpathEquality(String controlXpath,                                             Document controlDocument,                                             String testXpath,                                             Document testDocument,                                             boolean equal)         throws XpathException {         XpathEngine xpath = XMLUnit.newXpathEngine();         Diff diff = new Diff(asXpathResultDocument(XMLUnit.newControlParser(),                                                    xpath.getMatchingNodes(controlXpath,                                                                           controlDocument)),                              asXpathResultDocument(XMLUnit.newTestParser(),                                                    xpath.getMatchingNodes(testXpath,                                                                           testDocument)));         assertXMLEqual(diff, equal);     }
@Override     public void play(final String uri) {         Log.d(TAG, ""Start playing ""+uri);         notifyVideoUnavailable(REASON_BUFFERING);         isWeb = false;         TvInputPlayer.Callback callback = new TvInputPlayer.Callback() {             @Override             public void onPrepared() {                 notifyVideoAvailable();                 setOverlayEnabled(false);             }              @Override             public void onPlayerStateChanged(boolean playWhenReady, int state) {              }              @Override             public void onPlayWhenReadyCommitted() {              }              @Override             public void onPlayerError(ExoPlaybackException e) {                 Log.e(TAG, e.getMessage()+"""");                 if(e.getMessage().contains(""Extractor"")) {                     Log.d(TAG, ""Cannot play the stream, try loading it as a website"");                     Log.d(TAG, ""Open ""+uri);                     //Pretend this is a website                     loadUrl(uri);                     isWeb = true;                     setOverlayEnabled(false);                     notifyVideoAvailable();                     isWeb = true;                     setOverlayEnabled(false);                     setOverlayEnabled(true);                     isWeb = true;                 }             }              @Override             public void onDrawnToSurface(Surface surface) {              }              @Override             public void onText(String text) {              }         };         try {             tvInputPlayer.removeCallback(callback);         } catch(NullPointerException e) {             Log.w(TAG, ""exoplayer.removeCallback error ""+e.getMessage());         }         tvInputPlayer.addCallback(callback);         tvInputPlayer.setSurface(mSurface);         Log.d(TAG, ""Play ""+uri+""; ""+uri.indexOf(""file:///""));         if(uri.contains(""file:///"")) {             Log.i(TAG, ""Is a local file"");             //Find appropriate extractor              DataSource dataSource=new DefaultUriDataSource(getApplicationContext(), TvInputPlayer.getUserAgent(getApplicationContext()));             ExtractorSampleSource extractorSampleSource=new ExtractorSampleSource(Uri.parse(uri),dataSource,                     new DefaultAllocator(TvInputPlayer.BUFFER_SEGMENT_SIZE), TvInputPlayer.BUFFER_SEGMENTS * TvInputPlayer.BUFFER_SEGMENT_SIZE,                     new Mp4Extractor(), new Mp3Extractor());             TrackRenderer audio=new MediaCodecAudioTrackRenderer(extractorSampleSource, MediaCodecSelector.DEFAULT);             TrackRenderer video=new MediaCodecVideoTrackRenderer(getApplicationContext(),extractorSampleSource, MediaCodecSelector.DEFAULT, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING);             tvInputPlayer.prepare(audio, video, new DummyTrackRenderer());         } else {             try {                 tvInputPlayer.prepare(getApplicationContext(), Uri.parse(uri), TvInputPlayer.SOURCE_TYPE_HLS);             } catch (Exception e) {                 e.printStackTrace();             }         }         tvInputPlayer.setPlayWhenReady(true);     }
public static File compress(File sourceFile, String algorithm, boolean deleteSourceFileAfterCompressed) throws FileAlreadyExistsException, IOException {         return compress(sourceFile, sourceFile.getParentFile(), algorithm, deleteSourceFileAfterCompressed);     }
protected void processField(Row row, String fieldIDColumn, String entityIDColumn, Object value)    {       processField(row, fieldIDColumn, row.getInteger(entityIDColumn), value);    }
public Observable<ServerTableAuditingPolicyInner> createOrUpdateAsync(String resourceGroupName, String serverName, ServerTableAuditingPolicyInner parameters) {         return createOrUpdateWithServiceResponseAsync(resourceGroupName, serverName, parameters).map(new Func1<ServiceResponse<ServerTableAuditingPolicyInner>, ServerTableAuditingPolicyInner>() {             @Override             public ServerTableAuditingPolicyInner call(ServiceResponse<ServerTableAuditingPolicyInner> response) {                 return response.body();             }         });     }
public Range<T> reset() {    lock.lock();    try {     this.current = this.start;     this.index = 0;    } finally {     lock.unlock();    }    return this;   }
protected boolean isCore(Dependency left, Dependency right) {         final String leftName = left.getFileName().toLowerCase();         final String rightName = right.getFileName().toLowerCase();          final boolean returnVal;         //TODO - should we get rid of this merging? It removes a true BOM...          if (left.isVirtual() && !right.isVirtual()) {             returnVal = true;         } else if (!left.isVirtual() && right.isVirtual()) {             returnVal = false;         } else if ((!rightName.matches("".*\\.(tar|tgz|gz|zip|ear|war).+"") && leftName.matches("".*\\.(tar|tgz|gz|zip|ear|war).+""))                 || (rightName.contains(""core"") && !leftName.contains(""core""))                 || (rightName.contains(""kernel"") && !leftName.contains(""kernel""))                 || (rightName.contains(""akka-stream"") && !leftName.contains(""akka-stream""))                 || (rightName.contains(""netty-transport"") && !leftName.contains(""netty-transport""))) {             returnVal = false;         } else if ((rightName.matches("".*\\.(tar|tgz|gz|zip|ear|war).+"") && !leftName.matches("".*\\.(tar|tgz|gz|zip|ear|war).+""))                 || (!rightName.contains(""core"") && leftName.contains(""core""))                 || (!rightName.contains(""kernel"") && leftName.contains(""kernel""))                 || (!rightName.contains(""akka-stream"") && leftName.contains(""akka-stream""))                 || (!rightName.contains(""netty-transport"") && leftName.contains(""netty-transport""))) {             returnVal = true;         } else {             /*              * considered splitting the names up and comparing the components,              * but decided that the file name length should be sufficient as the              * ""core"" component, if this follows a normal naming protocol should              * be shorter:              * axis2-saaj-1.4.1.jar              * axis2-1.4.1.jar       <-----              * axis2-kernel-1.4.1.jar              */             returnVal = leftName.length() <= rightName.length();         }         LOGGER.debug(""IsCore={} ({}, {})"", returnVal, left.getFileName(), right.getFileName());         return returnVal;     }
public static <K, V> AbstractGroupExpression<Pair<K, V>, SortedMap<K, V>> sortedMap(Expression<K> key,                                                                                         Expression<V> value,                                                                                         Comparator<? super K> comparator) {         return GMap.createSorted(QPair.create(key, value), comparator);     }
public synchronized short getCommandCompletionCode(int expectedSegmentType)    {       if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, ""getCommandCompletionCode"",                                            new Object[] {""""+expectedSegmentType});        checkReleased();        short result = -1;       if (receivedData != null)       {          // First see what the segment returned was          int receivedDataSegmentType = getReceivedDataSegmentType();           // If it matches what we expect, the there was no exception          if (receivedDataSegmentType == expectedSegmentType)          {             result = CommsConstants.SI_NO_EXCEPTION;          }          else if (receivedDataSegmentType == JFapChannelConstants.SEG_EXCEPTION)          {             getShort();                     // Skip over the exception count             result = getShort();              // Ensure we rewind the buffer (as we are only peeking a look here)             receivedBuffer.rewind();          }          else          {             // Get the segment types in decimal and hex for ease of use             String expected = expectedSegmentType + "" (0x"" + Integer.toHexString(expectedSegmentType).toUpperCase() + "")"";             String actual = receivedDataSegmentType + "" (0x"" + Integer.toHexString(receivedDataSegmentType).toUpperCase() + "")"";              throw new SIErrorException(                TraceNLS.getFormattedMessage(CommsConstants.MSG_BUNDLE,                                             ""JFAP_SEG_MISMATCH_EXCEPTION_SICO1006"",                                             new Object[] {expected, actual}, null)             );          }       }        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, ""getCommandCompletionCode"", """"+result);       return result;    }
@SuppressWarnings(""unchecked"")     private static <D extends Number> D getJavaMaxInclusive(Class < D > clazz,             int totalDigits, int fractionDigits) {         int dec = totalDigits - fractionDigits;         char[] decPart = new char[dec];         Arrays.fill(decPart, '9');         StringBuilder sb = new StringBuilder();         sb.append(decPart);         if (clazz.equals(Short.class)) {             return (D) (dec > 4 ? Short.valueOf(Short.MAX_VALUE) : Short                     .valueOf(sb.toString()));         } else if (clazz.equals(Integer.class)) {             return (D) (dec > 9 ? Integer.valueOf(Integer.MAX_VALUE) : Integer                     .valueOf(sb.toString()));         } else if (clazz.equals(Long.class)) {             return (D) (dec > 18 ? Long.valueOf(Long.MAX_VALUE) : Long                     .valueOf(sb.toString()));         } else if (clazz.equals(BigInteger.class)) {             return (D) new BigInteger(sb.toString());         } else if (clazz.equals(BigDecimal.class)) {             if (fractionDigits > 0) {                 sb.append(JAVA_DECIMAL_POINT);                 char[] fracPart = new char[fractionDigits];                 Arrays.fill(fracPart, '9');                 sb.append(fracPart);             }             return (D) new BigDecimal(sb.toString());          } else {             throw new IllegalArgumentException(""Unsupported java type "" + clazz);         }      }
public static com.liferay.commerce.model.CommerceOrderNote createCommerceOrderNote(   long commerceOrderNoteId) {   return getService().createCommerceOrderNote(commerceOrderNoteId);  }
public Observable<Page<RegistryInner>> listAsync() {         return listWithServiceResponseAsync()             .map(new Func1<ServiceResponse<Page<RegistryInner>>, Page<RegistryInner>>() {                 @Override                 public Page<RegistryInner> call(ServiceResponse<Page<RegistryInner>> response) {                     return response.body();                 }             });     }
public com.google.api.ads.adwords.axis.v201809.cm.Money getRequiredBudget() {         return requiredBudget;     }
public B addHttpHeader(CharSequence name, Object value) {         requireNonNull(name, ""name"");         requireNonNull(value, ""value"");         httpHeaders.addObject(HttpHeaderNames.of(name), value);         return self();     }
public int getRequestCount() {          synchronized (mapPluginStats) {              int count = requestCount + getAnalyser().getRequestCount();              for (PluginStats stats : mapPluginStats.values()) {                  count += stats.getMessageCount();              }              return count;          }      }
private void writeObject(java.io.ObjectOutputStream out)                     throws IOException     {         out.defaultWriteObject();         out.write(frciEyecatcher);         out.writeShort(frciPlatform);         out.writeShort(frciVersionID);     }
@SuppressWarnings(""unchecked"")   public EList<String> getPrefixTitles() {    return (EList<String>) eGet(Ifc2x3tc1Package.Literals.IFC_PERSON__PREFIX_TITLES, true);   }
private void addPostParams(final Request request) {         if (friendlyName != null) {             request.addPostParam(""FriendlyName"", friendlyName);         }          if (certificate != null) {             request.addPostParam(""Certificate"", certificate);         }          if (privateKey != null) {             request.addPostParam(""PrivateKey"", privateKey);         }          if (sandbox != null) {             request.addPostParam(""Sandbox"", sandbox.toString());         }          if (apiKey != null) {             request.addPostParam(""ApiKey"", apiKey);         }          if (secret != null) {             request.addPostParam(""Secret"", secret);         }     }
static public String getServiceSpecial(String path) {     String ss = null;     if (path.startsWith(""/dqcServlet""))       ss = ""dqcServlet"";     else if (path.startsWith(""/cdmvalidator""))       ss = ""cdmvalidator"";     return ss;   }
public boolean getBit(int index)     {         assertValidIndex(index);         int word = index / WORD_LENGTH;         int offset = index % WORD_LENGTH;         return (data[word] & (1 << offset)) != 0;     }
public void setPriority(SessionPriority prio) throws IOException {     if (failException != null) {       throw failException;     }      sessionInfo.priority = prio;      SessionInfo newInfo = new SessionInfo(sessionInfo);     cmNotifier.addCall(         new ClusterManagerService.sessionUpdateInfo_args(sessionId, newInfo));   }
public void insert(Widget widget, String tabText, int beforeIndex) {         insert(widget, tabText, false, beforeIndex);     }
public static Response options(String path, Map<String, ?> pathParams) {         return given().options(path, pathParams);     }
@XmlElementDecl(namespace = ""http://www.opengis.net/gml"", name = ""minutes"")     public JAXBElement<Integer> createMinutes(Integer value) {         return new JAXBElement<Integer>(_Minutes_QNAME, Integer.class, null, value);     }
public void checkCanSetDeleteOption(String option) {     if (isOptColor() || isOptNoColor() || isOptA() || isOptVerbose() || isOptMerged() ||          isOptNoMerged() || (null != getOptContains()) || isOptTrack() || isOptNoTrack() ||          isOptL() || isOptF() || isOptMLower() || isOptMUpper()) {       throw new IllegalArgumentException(ExceptionMessageMap.getMessage(""000120"") + option +        "" should be used with branch(es), to delete the branch(es)."");     }   }
public void setSql(String sql) {    if (StringUtils.isNotEmpty(sql)) {     this.sql = sql.trim();     this.comment = parseComment(sql);     this.digest = MessageDigestUtils.MD5(sql);          String sqlStatement = this.sql.toLowerCase();     if (sqlStatement != null) {      this.select = sqlStatement.startsWith(""select"");      this.procedure = sqlStatement.startsWith(""call"");     }    }   }
void open() {          initParams();          int state = properties.getDBModified();          switch (state) {              case HsqlDatabaseProperties.FILES_MODIFIED :                 deleteNewAndOldFiles();                 restoreBackup();                 processScript();                 processDataFile();                 processLog();                 close(false);                  if (cache != null) {                     cache.open(filesReadOnly);                 }                  reopenAllTextCaches();                 break;              case HsqlDatabaseProperties.FILES_NEW :                 try {                     deleteBackup();                     backupData();                     renameNewBackup();                     renameNewScript();                     deleteLog();                     properties.setDBModified(                         HsqlDatabaseProperties.FILES_NOT_MODIFIED);                 } catch (IOException e) {                     database.logger.appLog.logContext(e, null);                 }              // continue as non-modified files             // $FALL-THROUGH$             case HsqlDatabaseProperties.FILES_NOT_MODIFIED :                  /**                  * if startup is after a SHUTDOWN SCRIPT and there are CACHED                  * or TEXT tables, perform a checkpoint so that the .script                  * file no longer contains CACHED or TEXT table rows.                  */                 processScript();                  if (isAnyCacheModified()) {                     properties.setDBModified(                         HsqlDatabaseProperties.FILES_MODIFIED);                     close(false);                      if (cache != null) {                         cache.open(filesReadOnly);                     }                      reopenAllTextCaches();                 }                 break;         }          openLog();          if (!filesReadOnly) {             properties.setDBModified(HsqlDatabaseProperties.FILES_MODIFIED);         }     }
public static void writePharmacophoreDefinition(PharmacophoreQuery[] queries, OutputStream out) throws IOException {         Element root = new Element(""pharmacophoreContainer"");         root.addAttribute(new Attribute(""version"", ""1.0""));         for (PharmacophoreQuery query : queries) {             Element pcore = new Element(""pharmacophore"");              Object description = query.getProperty(""description"");             if (description != null) pcore.addAttribute(new Attribute(""description"", (String) description));              Object name = query.getTitle();             if (name != null) pcore.addAttribute(new Attribute(""name"", (String) name));              // we add the pcore groups for this query as local to the group             for (IAtom atom : query.atoms()) {                 Element group = new Element(""group"");                 group.addAttribute(new Attribute(""id"", atom.getSymbol()));                 group.appendChild(((PharmacophoreQueryAtom) atom).getSmarts());                 pcore.appendChild(group);             }              // now add the constraints             for (IBond bond : query.bonds()) {                 Element elem = null;                 if (bond instanceof PharmacophoreQueryBond) {                     PharmacophoreQueryBond dbond = (PharmacophoreQueryBond) bond;                     elem = new Element(""distanceConstraint"");                     elem.addAttribute(new Attribute(""lower"", String.valueOf(dbond.getLower())));                     elem.addAttribute(new Attribute(""upper"", String.valueOf(dbond.getUpper())));                     elem.addAttribute(new Attribute(""units"", ""A""));                 } else if (bond instanceof PharmacophoreQueryAngleBond) {                     PharmacophoreQueryAngleBond dbond = (PharmacophoreQueryAngleBond) bond;                     elem = new Element(""angleConstraint"");                     elem.addAttribute(new Attribute(""lower"", String.valueOf(dbond.getLower())));                     elem.addAttribute(new Attribute(""upper"", String.valueOf(dbond.getUpper())));                     elem.addAttribute(new Attribute(""units"", ""degrees""));                 }                  // now add the group associated with this constraint                 for (IAtom iAtom : bond.atoms()) {                     PharmacophoreQueryAtom atom = (PharmacophoreQueryAtom) iAtom;                     Element gelem = new Element(""groupRef"");                     gelem.addAttribute(new Attribute(""id"", atom.getSymbol()));                     if (elem != null) {                         elem.appendChild(gelem);                     }                 }                 pcore.appendChild(elem);             }             root.appendChild(pcore);         }         Document doc = new Document(root);         Serializer serializer = new Serializer(out, ""ISO-8859-1"");         serializer.setIndent(4);         serializer.setMaxLength(128);         serializer.write(doc);     }
public void propagateActions( InternalWorkingMemory workingMemory ) {         final PropagationQueueingNodeMemory memory = workingMemory.getNodeMemory( this );          // first we clear up the action queued flag         memory.isQueued().compareAndSet( true,                                          false );          // we limit the propagation to avoid a hang when this queue is never empty         Action next;         for ( int counter = 0; counter < PROPAGATION_SLICE_LIMIT; counter++ ) {             next = memory.getNextAction();             if ( next != null ) {                 next.execute( this.sink,                         workingMemory );             } else {                 break;             }         }          if ( memory.hasNextAction() && memory.isQueued().compareAndSet( false,                                                                         true ) ) {             // add action to the queue again.             workingMemory.queueWorkingMemoryAction( this.action );         }     }
@Override     public FastStr toUpperCase(Locale locale) {         String s = toString();         return unsafeOf(s.toUpperCase(locale));     }
@Override  public Action getAction(String name, String nodeID) {   Strategy<ActionEndpoint> strategy = null;   long stamp = lock.tryOptimisticRead();   if (stamp != 0) {    try {     strategy = strategies.get(name);    } catch (Exception modified) {     stamp = 0;    }   }   if (!lock.validate(stamp) || stamp == 0) {    stamp = lock.readLock();    try {     strategy = strategies.get(name);    } finally {     lock.unlockRead(stamp);    }   }   if (strategy == null) {    throw new ServiceNotFoundError(nodeID, name);   }   ActionEndpoint endpoint = strategy.getEndpoint(nodeID);   if (endpoint == null) {    throw new ServiceNotAvailableError(nodeID, name);   }   return endpoint;  }
public Metric updateMetric(String metricName) {     // [START updateMetric]     MetricInfo metricInfo =         MetricInfo.newBuilder(metricName, ""severity>=ERROR"")             .setDescription(""new description"")             .build();     Metric metric = logging.update(metricInfo);     // [END updateMetric]     return metric;   }
public STATUS getStatus() {   if (featureContent.isLoaded()) {    return STATUS.LOADED;   }   if (deferred == null) {    return STATUS.EMPTY;   }   return STATUS.LOADING;  }
public Node findOrCreateChild( Node parent,                                    String name,                                    String nodeType ) throws RepositoryException {         return findOrCreateNode(parent, name, nodeType, nodeType);     }
public SslContextBuilder keyManager(KeyManagerFactory keyManagerFactory) {         if (forServer) {             checkNotNull(keyManagerFactory, ""keyManagerFactory required for servers"");         }         keyCertChain = null;         key = null;         keyPassword = null;         this.keyManagerFactory = keyManagerFactory;         return this;     }
public Map getMapFromReference(final Reference ref, final Map defaults) {          if (TraceComponent.isAnyTracingEnabled() && TRACE.isEntryEnabled()) {             SibTr.entry(this, TRACE, ""getMapFromReference"", new Object[] {ref,defaults});         }          Map extractedProps = null;          // Extract a Map of the properties from the Reference         synchronized (ref) {              Enumeration propsList = ref.getAll();              // This will be set up to contain a map representing all the             // information that was previously stored in the Reference.             final Map<String,String> encodedMap = new HashMap<String,String>();              // Look at each property in turn.             while (propsList.hasMoreElements()) {                  // Get the coded version of the name. This will start with one                 // of the prefix values. The codedName must have been non-null.                 StringRefAddr refAddr = (StringRefAddr) propsList.nextElement();                 String codedName = refAddr.getType();                 String val = (String) refAddr.getContent();                  // Store the coded information in the map.                 encodedMap.put(codedName, val);              }//while              // Decode the encoded map.             extractedProps = getStringDecodedMap(encodedMap, defaults);          }//sync          if (TraceComponent.isAnyTracingEnabled() && TRACE.isEntryEnabled()) {             SibTr.exit(this, TRACE, ""getMapFromReference"", extractedProps);         }         return extractedProps;      }
public synchronized void remove(SocketBox sb) {          int status = ((ManagedSocketBox) sb).getStatus();          if (!allSockets.containsKey(sb)) {             throw new IllegalArgumentException(""This socket does not seem to exist in the socket pool."");         }          allSockets.remove(sb);          if (status == ManagedSocketBox.FREE) {             if (!freeSockets.containsKey(sb)) {                 throw new IllegalArgumentException(""This socket is marked free, but does not exist in the pool of free sockets."");             }             freeSockets.remove(sb);          } else {             if (!busySockets.containsKey(sb)) {                 throw new IllegalArgumentException(""This socket is marked busy, but does not exist in the pool of busy sockets."");             }             busySockets.remove(sb);         }     }
public int[] getTags() {         int[] tags = new int[fieldIndex.size()];         Enumeration e = fieldIndex.keys();         int i = 0;                  while (e.hasMoreElements()) {             tags[i++] = ((Integer)e.nextElement()).intValue();         }                  return tags;     }
public void registerHanders(String packageString) {   List<String> list = AnnotationDetector.scanAsList(ExceptionHandler.class, packageString);   for (String handler : list) { //   System.out.println(handler);          JKExceptionHandler<? extends Throwable> newInstance = JKObjectUtil.newInstance(handler);    Class<? extends Throwable> clas = JKObjectUtil.getGenericParamter(handler);    setHandler(clas, newInstance);   }  }
public final List<SequenceLabel> getSequencesFromSpans(final String[] tokens,       final Span[] seqSpans) {     final List<SequenceLabel> sequences = new ArrayList<SequenceLabel>();     for (final Span seqSpan : seqSpans) {       final String seqString = seqSpan.getCoveredText(tokens);       final String seqType = seqSpan.getType();       final SequenceLabel sequence = this.sequenceFactory           .createSequence(seqString, seqType, seqSpan);       sequences.add(sequence);     }     return sequences;   }
public static String remove(final String string, final char ch) {   int stringLen = string.length();   char[] result = new char[stringLen];   int offset = 0;    for (int i = 0; i < stringLen; i++) {    char c = string.charAt(i);     if (c == ch) {     continue;    }     result[offset] = c;    offset++;   }    if (offset == stringLen) {    return string; // no changes   }    return new String(result, 0, offset);  }
protected synchronized void createAgent (int agentId)     {         Subscriber<AgentObject> delegator = new Subscriber<AgentObject>() {             public void objectAvailable (AgentObject agentObject) {                 BureauDirector.this.objectAvailable(agentObject);             }             public void requestFailed (int oid, ObjectAccessException cause) {                 BureauDirector.this.requestFailed(oid, cause);             }         };          log.info(""Subscribing to object "" + agentId);          SafeSubscriber<AgentObject> subscriber =             new SafeSubscriber<AgentObject>(agentId, delegator);         _subscribers.put(agentId, subscriber);         subscriber.subscribe(_ctx.getDObjectManager());     }
private void applyMax(Dimension dim) {   if (getMaxHeight() > 0) {     dim.height = Math.min(dim.height, getMaxHeight());   }   if (getMaxWidth() > 0) {     dim.width = Math.min(dim.width, getMaxWidth());   }    }
public int compare(final ParentStep p1, final ParentStep p2) {         return p1.getParent().getLine().compareTo(p2.getParent().getLine());     }
public Locomotive waitForWindow(String regex) {         Set<String> windows = driver.getWindowHandles();          for (String window : windows) {             try {                 driver.switchTo().window(window);                  p = Pattern.compile(regex);                 m = p.matcher(driver.getCurrentUrl());                  if (m.find()) {                     attempts = 0;                     return switchToWindow(regex);                 }                 else {                     // try for title                     m = p.matcher(driver.getTitle());                      if (m.find()) {                         attempts = 0;                         return switchToWindow(regex);                     }                 }             } catch(NoSuchWindowException e) {                 if (attempts <= MAX_ATTEMPTS) {                     attempts++;                      try {Thread.sleep(1000);}catch(Exception x) { x.printStackTrace(); }                      return waitForWindow(regex);                 } else {                     fail(""Window with url|title: "" + regex + "" did not appear after "" + MAX_ATTEMPTS + "" tries. Exiting."");                 }             }         }          // when we reach this point, that means no window exists with that title..         if (attempts == MAX_ATTEMPTS) {             fail(""Window with title: "" + regex + "" did not appear after "" + MAX_ATTEMPTS + "" tries. Exiting."");             return this;         } else {             System.out.println(""#waitForWindow() : Window doesn't exist yet. ["" + regex + ""] Trying again. "" + (attempts+1) + ""/"" + MAX_ATTEMPTS);             attempts++;             try {Thread.sleep(1000);}catch(Exception x) { x.printStackTrace(); }             return waitForWindow(regex);         }     }
private Channel getConnection()     {         stateCheck(State.RUNNING, State.HEALTH_CHECKING);         boolean acquired = false;         if (blockOnMaxConnections)         {             try             {                 logger.debug(""Attempting to acquire channel permit"");                  if (!permits.tryAcquire())                 {                     logger.info(""All connections in use for {}; had to wait for one."",                                 remoteAddress);                     permits.acquire();                 }                 acquired = true;             }             catch (InterruptedException ex)             {                 // no-op, don't care             }             catch (BlockingOperationException ex)             {                 logger.error(""Netty interrupted waiting for connection permit to be available; {}"",                              remoteAddress);             }         }         else         {             logger.debug(""Attempting to acquire channel permit"");             acquired = permits.tryAcquire();         }          Channel channel = null;         if (acquired)         {             try             {                 channel = doGetConnection(true);                 channel.closeFuture().removeListener(inAvailableCloseListener);             }             catch (ConnectionFailedException ex)             {                 permits.release();             }             catch (UnknownHostException ex)             {                 permits.release();                 logger.error(""Unknown host encountered while trying to open connection; {}"", ex);             }         }         return channel;     }
public static boolean areMappedObjects(Class<?> dClass,Class<?> sClass,XML xml){    return isMapped(dClass,xml) || isMapped(sClass,xml);   }
public DescribeSpotPriceHistoryRequest withProductDescriptions(String... productDescriptions) {         if (this.productDescriptions == null) {             setProductDescriptions(new com.amazonaws.internal.SdkInternalList<String>(productDescriptions.length));         }         for (String ele : productDescriptions) {             this.productDescriptions.add(ele);         }         return this;     }
public DecimalFormatProperties getDecimalFormat(QName name)   {      if (null == m_DecimalFormatDeclarations)       return null;      int n = getDecimalFormatCount();      for (int i = (n - 1); i >= 0; i++)     {       DecimalFormatProperties dfp = getDecimalFormat(i);        if (dfp.getName().equals(name))         return dfp;     }      return null;   }
public boolean isSingleton(String exceptionName) {         if (size != 1) {             return false;         }         ObjectType e = iterator().next();         return e.toString().equals(exceptionName);      }
public <T> boolean isDependentScopedStrict(final Class<T> type) {         Bean<T> bean = resolveStrict(manager, type);         if (bean != null) {             return Dependent.class.equals(bean.getScope());         }         return false;     }
public void marshall(CreateRemoteAccessSessionRequest createRemoteAccessSessionRequest, ProtocolMarshaller protocolMarshaller) {          if (createRemoteAccessSessionRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(createRemoteAccessSessionRequest.getProjectArn(), PROJECTARN_BINDING);             protocolMarshaller.marshall(createRemoteAccessSessionRequest.getDeviceArn(), DEVICEARN_BINDING);             protocolMarshaller.marshall(createRemoteAccessSessionRequest.getInstanceArn(), INSTANCEARN_BINDING);             protocolMarshaller.marshall(createRemoteAccessSessionRequest.getSshPublicKey(), SSHPUBLICKEY_BINDING);             protocolMarshaller.marshall(createRemoteAccessSessionRequest.getRemoteDebugEnabled(), REMOTEDEBUGENABLED_BINDING);             protocolMarshaller.marshall(createRemoteAccessSessionRequest.getRemoteRecordEnabled(), REMOTERECORDENABLED_BINDING);             protocolMarshaller.marshall(createRemoteAccessSessionRequest.getRemoteRecordAppArn(), REMOTERECORDAPPARN_BINDING);             protocolMarshaller.marshall(createRemoteAccessSessionRequest.getName(), NAME_BINDING);             protocolMarshaller.marshall(createRemoteAccessSessionRequest.getClientId(), CLIENTID_BINDING);             protocolMarshaller.marshall(createRemoteAccessSessionRequest.getConfiguration(), CONFIGURATION_BINDING);             protocolMarshaller.marshall(createRemoteAccessSessionRequest.getInteractionMode(), INTERACTIONMODE_BINDING);             protocolMarshaller.marshall(createRemoteAccessSessionRequest.getSkipAppResign(), SKIPAPPRESIGN_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
protected UserDetails loadUserByAssertion(final Assertion assertion) {   final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken(     assertion, """");   return this.authenticationUserDetailsService.loadUserDetails(token);  }
public void setAsDefault(SetAsDefaultRequest request) {     call(       new PostRequest(path(""set_as_default""))         .setParam(""id"", request.getId())         .setParam(""organization"", request.getOrganization())         .setMediaType(MediaTypes.JSON)     ).content();   }
public static String generateRandomId() {          StringBuffer buffer = new StringBuffer();         int base = 36;         for (int i = 0; i < 16; i++) {             buffer.append(Integer.toString(RANDOM.nextInt(base), base));         }         return buffer.toString();     }
void deferBoundaryCallbacks(final boolean deferEmpty,             final boolean deferBegin, final boolean deferEnd) {         if (mBoundaryCallback == null) {             throw new IllegalStateException(""Can't defer BoundaryCallback, no instance"");         }          /*          * If lowest/highest haven't been initialized, set them to storage size,          * since placeholders must already be computed by this point.          *          * This is just a minor optimization so that BoundaryCallback callbacks are sent immediately          * if the initial load size is smaller than the prefetch window (see          * TiledPagedListTest#boundaryCallback_immediate())          */         if (mLowestIndexAccessed == Integer.MAX_VALUE) {             mLowestIndexAccessed = mStorage.size();         }         if (mHighestIndexAccessed == Integer.MIN_VALUE) {             mHighestIndexAccessed = 0;         }          if (deferEmpty || deferBegin || deferEnd) {             // Post to the main thread, since we may be on creation thread currently             mMainThreadExecutor.execute(new Runnable() {                 @Override                 public void run() {                     // on is dispatched immediately, since items won't be accessed                     //noinspection ConstantConditions                     if (deferEmpty) {                         mBoundaryCallback.onZeroItemsLoaded();                     }                      // for other callbacks, mark deferred, and only dispatch if loadAround                     // has been called near to the position                     if (deferBegin) {                         mBoundaryCallbackBeginDeferred = true;                     }                     if (deferEnd) {                         mBoundaryCallbackEndDeferred = true;                     }                     tryDispatchBoundaryCallbacks(false);                 }             });         }     }
@Override     public GetRelationalDatabasesResult getRelationalDatabases(GetRelationalDatabasesRequest request) {         request = beforeClientExecution(request);         return executeGetRelationalDatabases(request);     }
public List<NumericColumn<?>> numericColumns(String ... columnNames) {         List<NumericColumn<?>> cols = new ArrayList<>();         for (String name : columnNames) {             cols.add(numberColumn(name));         }          return cols;     }
public java.util.List<RoleDetail> getRoleDetailList() {         if (roleDetailList == null) {             roleDetailList = new com.amazonaws.internal.SdkInternalList<RoleDetail>();         }         return roleDetailList;     }
static <T> PojoSerializerSnapshotData<T> createFrom(    Class<T> pojoClass,    Field[] fields,    TypeSerializerSnapshot<?>[] existingFieldSerializerSnapshots,    LinkedHashMap<Class<?>, TypeSerializerSnapshot<?>> existingRegisteredSubclassSerializerSnapshots,    Map<Class<?>, TypeSerializerSnapshot<?>> existingNonRegisteredSubclassSerializerSnapshots) {    final LinkedOptionalMap<Field, TypeSerializerSnapshot<?>> fieldSerializerSnapshots = new LinkedOptionalMap<>(fields.length);   for (int i = 0; i < fields.length; i++) {    Field field = fields[i];    String fieldName = (field == null) ? getDummyNameForMissingField(i) : field.getName();    fieldSerializerSnapshots.put(fieldName, field, existingFieldSerializerSnapshots[i]);   }    return new PojoSerializerSnapshotData<>(    pojoClass,    fieldSerializerSnapshots,    optionalMapOf(existingRegisteredSubclassSerializerSnapshots, Class::getName),    optionalMapOf(existingNonRegisteredSubclassSerializerSnapshots, Class::getName));  }
private SortedSet<Date> calculateDates() {          if (null == m_allDates) {             SortedSet<Date> result = new TreeSet<>();             if (isAnyDatePossible()) {                 Calendar date = getFirstDate();                 int previousOccurrences = 0;                 while (showMoreEntries(date, previousOccurrences)) {                     result.add(date.getTime());                     toNextDate(date);                     previousOccurrences++;                 }             }             m_allDates = result;         }         return m_allDates;     }
private boolean setupEphemeralRSAKeys(boolean export) {         KeyPair kp = sslContext.getEphemeralKeyManager().                         getRSAKeyPair(export, sslContext.getSecureRandom());         if (kp == null) {             return false;         } else {             tempPublicKey = kp.getPublic();             tempPrivateKey = kp.getPrivate();             return true;         }     }
public String format(Object qty, int minDecimals, int... fractionGroups) {         return format(qty, new StringBuffer(), new FieldPosition(0), minDecimals, boxAsList(fractionGroups)).toString();     }
public synchronized static JMX reconnect()  {   try   {      ClientCache cache = null;          cache = ClientCacheFactory.getAnyInstance();           if(cache != null && !cache.isClosed())     {       cache.close();     }   }   catch (Exception e)   {     System.out.println(""Cache was closed"");   }      if(jmx != null)   {        jmx.dispose();    jmx = null;   }         return getJmx();  }
@SuppressWarnings({ ""unchecked"", ""rawtypes"" })      public void deserialize(Input input) throws IOException {          log.debug(""deserialize"");          name = Deserializer.deserialize(input, String.class);          log.trace(""Name: {}"", name);          persistent = true;          Map<String, Object> map = Deserializer.<Map> deserialize(input, Map.class);          if (log.isTraceEnabled()) {              log.trace(""Attributes: {}"", map);          }          super.setAttributes(map);          ownerMessage.setName(name);          ownerMessage.setPersistent(persistent);      }
@Override     public final void exceptionCaught(NextFilter nextFilter, IoSession session,             Throwable cause) {         if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {             IoFilterEvent event = new IoFilterEvent(nextFilter,                 IoEventType.EXCEPTION_CAUGHT, session, cause);              fireEvent(event);         } else {             nextFilter.exceptionCaught(session, cause);         }     }
public void set(final T paramOrigin, final T paramDestination, final boolean paramBool) {         assert paramOrigin != null;         assert paramDestination != null;         if (!mMap.containsKey(paramOrigin)) {             mMap.put(paramOrigin, new IdentityHashMap<T, Boolean>());         }          mMap.get(paramOrigin).put(paramDestination, paramBool);     }
public static final String createXPATHWarning(String msgKey, Object args[])  //throws Exception   {       // BEGIN android-changed       //     don't localize exception messages       return createXPATHMsg(XPATHBundle, msgKey, args);       // END android-changed   }
@Nullable   private static <T> TreePath findEnclosingMethodOrLambdaOrInitializer(TreePath path) {     while (path != null) {       if (path.getLeaf() instanceof MethodTree) {         return path;       }       TreePath parent = path.getParentPath();       if (parent != null) {         if (parent.getLeaf() instanceof ClassTree) {           if (path.getLeaf() instanceof BlockTree) {             // this is a class or instance initializer block             return path;           }           if (path.getLeaf() instanceof VariableTree               && ((VariableTree) path.getLeaf()).getInitializer() != null) {             // this is a field with an inline initializer             return path;           }         }         if (parent.getLeaf() instanceof LambdaExpressionTree) {           return parent;         }       }       path = parent;     }     return null;   }
@ManagedOperation(description = ""Sets the maximum allowed number of threads."")  @ManagedOperationParameters({ @ManagedOperationParameter(name = ""maximumPoolSize"", description = ""the new maximum"") })  @Override  public void setMaximumPoolSize(final int maximumPoolSize) {   super.setMaximumPoolSize(maximumPoolSize);  }
private boolean isANeighboorsInAnAtomContainer(List<IAtom> neighs, IAtomContainer ac) {         boolean isIn = false;         int count = 0;         for (IAtom neigh : neighs) {             if (ac.contains(neigh)) {                 count += 1;             }         }         if (count > 0) {             isIn = true;         }         return isIn;     }
public Subclass withIAMMaxRetry(int retryCount) {         this.iamMaxRetry = retryCount;          if ((retryCount > 0) &&           (this.credentials.getCredentials() instanceof IBMOAuthCredentials) &&           ((IBMOAuthCredentials)this.credentials.getCredentials()).getTokenManager() instanceof DefaultTokenManager){            ((DefaultTokenManager)((IBMOAuthCredentials)this.credentials.getCredentials()).getTokenManager()).setIamMaxRetry(iamMaxRetry);         }         return getSubclass();     }
@SuppressWarnings(""resource"")  public static InputStream getZipContentsRecursive(final String file) throws IOException {   // return local file directly   int pos = file.indexOf('!');   if (pos == -1) {    if (!new File(file).exists()) {     throw new IOException(""File "" + file + "" does not exist"");    }     try {     return new FileInputStream(file);    } catch (IOException e) {     // filter out locked errors     if (e.getMessage().contains(""because another process has locked"")) {      logger.warning(""Could not read file: "" + file + "" because it is locked."");       return new ByteArrayInputStream(new byte[] {});     }      throw e;    }   }    String zip = file.substring(0, pos);   String subfile = file.substring(pos + 1);   if (logger.isLoggable(Level.FINE)) {    logger.fine(""Trying to read zipfile: "" + zip + "" subfile: "" + subfile);   }    // open original zip   if (!new File(zip).exists() || !new File(zip).isFile() || !new File(zip).canRead() || new File(zip).length() == 0) {    throw new IOException(""ZIP file: "" + zip + "" does not exist or is empty or not a readable file."");   }    ZipFile zipfile = new ZipFile(zip);   // is the target file in yet another ZIP file?   pos = subfile.indexOf('!');   if (pos != -1) {    // find out first ZIP file and remainder    String remainder = subfile.substring(pos + 1);     File subzipfile = File.createTempFile(""ZipUtils"", "".zip"");    try {     readToTemporaryFile(pos, zip, subfile, zipfile, subzipfile);      // start another recursion with the temporary file and the remainder     return new DeleteOnCloseInputStream(       new ZipFileCloseInputStream(getZipContentsRecursive(subzipfile.getAbsolutePath() + ZIP_DELIMITER + remainder), zipfile),       subzipfile);    } catch (IOException e) {     // need to close the zipfile here as we do not put it into a ZipFileCloseInputStream     zipfile.close();      throw e;    } finally {     if (!subzipfile.delete()) {      logger.warning(""Could not delete file "" + subzipfile);     }    }   }    ZipEntry entry = zipfile.getEntry(subfile);   return new ZipFileCloseInputStream(zipfile.getInputStream(entry), zipfile);  }
@Override   public EClass getIfcSwitchingDevice() {    if (ifcSwitchingDeviceEClass == null) {     ifcSwitchingDeviceEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)       .getEClassifiers().get(689);    }    return ifcSwitchingDeviceEClass;   }
public static <T> List<T> unmodifiableList(List<? extends T> list) {         return (list instanceof RandomAccess ?                 new UnmodifiableRandomAccessList<>(list) :                 new UnmodifiableList<>(list));     }
public void setTlsCertificateSummaries(java.util.Collection<LoadBalancerTlsCertificateSummary> tlsCertificateSummaries) {         if (tlsCertificateSummaries == null) {             this.tlsCertificateSummaries = null;             return;         }          this.tlsCertificateSummaries = new java.util.ArrayList<LoadBalancerTlsCertificateSummary>(tlsCertificateSummaries);     }
public StringType addPrefixElement() {//2         StringType t = new StringType();        if (this.prefix == null)          this.prefix = new ArrayList<StringType>();        this.prefix.add(t);        return t;      }
@Override     public Request<CancelCapacityReservationRequest> getDryRunRequest() {         Request<CancelCapacityReservationRequest> request = new CancelCapacityReservationRequestMarshaller().marshall(this);         request.addParameter(""DryRun"", Boolean.toString(true));         return request;     }
public int setString(String strSource, boolean bDisplayOption, int iMoveMode)               // init this field override for other value     {         int iErrorReturn = FirstMLastConverter.nameToParts(strSource, bDisplayOption, iMoveMode, m_recThis, m_iNamePrefix, m_iNameFirst, m_iNameMiddle, m_iNameSur, m_iNameSuffix, m_iNameTitle);         if (iErrorReturn == DBConstants.NORMAL_RETURN)             if (this.getNextConverter() != null)                 iErrorReturn = super.setString(strSource, bDisplayOption, iMoveMode);         return iErrorReturn;     }
public HtmlPolicyBuilder allowElements(       ElementPolicy policy, String... elementNames) {     invalidateCompiledState();     for (String elementName : elementNames) {       elementName = HtmlLexer.canonicalName(elementName);       ElementPolicy newPolicy = ElementPolicy.Util.join(           elPolicies.get(elementName), policy);       // Don't remove if newPolicy is the always reject policy since we want       // that to infect later allowElement calls for this particular element       // name.  rejects should have higher priority than allows.       elPolicies.put(elementName, newPolicy);       if (!textContainers.containsKey(elementName)) {         if (METADATA.canContainPlainText(METADATA.indexForName(elementName))) {           textContainers.put(elementName, true);         }       }     }     return this;   }
public String getItemValue(String id) {         Item item = getItem(id);         if (item != null)             return item.getValue();         return null;     }
private static void generateParseOnXmlAttributes(BindTypeContext context, MethodSpec.Builder methodBuilder,    BindEntity entity) {   BindTransform bindTransform;    int count = 0;   // count property to manage   {    // for each elements    for (BindProperty property : entity.getCollection()) {     if (property.xmlInfo.xmlType != XmlType.ATTRIBUTE)      continue;      count++;    }   }    if (count > 0) {    // @formatter:off    methodBuilder.addCode(""\n// attributes \n"");    methodBuilder.addStatement(""String attributeName = null"");    // methodBuilder.addStatement(""String attributeValue = null"");     methodBuilder.addStatement(""int attributesCount = xmlParser.getAttributeCount();"");    methodBuilder.beginControlFlow(      ""for (int attributeIndex = 0; attributeIndex < attributesCount; attributeIndex++)"");    methodBuilder.addStatement(""attributeName = xmlParser.getAttributeName(attributeIndex)"");    // methodBuilder.addStatement(""attributeValue =    // $T.unescapeXml(xmlParser.getAttributeValue(attributeIndex))"",    // StringEscapeUtils.class);    methodBuilder.beginControlFlow(""switch(attributeName)$>"");     for (BindProperty property : entity.getCollection()) {     if (property.xmlInfo.xmlType != XmlType.ATTRIBUTE)      continue;      methodBuilder.addCode(""case $S:\n$>"", BindProperty.xmlName(property));      bindTransform = BindTransformer.lookup(property);     methodBuilder.addCode(""// field $L (mapped by $S)\n"", property.getName(),       BindProperty.xmlName(property));     bindTransform.generateParseOnXml(context, methodBuilder, ""xmlParser"",       property.getPropertyType().getTypeName(), ""instance"", property);      methodBuilder.addStatement(""$<break"");    }     methodBuilder.addCode(""default:\n$>"");    methodBuilder.addStatement(""$<break$<"");    methodBuilder.endControlFlow();     methodBuilder.endControlFlow();    // @formatter:on   } else {    methodBuilder.addCode(""// No attributes found\n"");   }  }
public int insertOrUpdate(Entity record, String... keys) throws SQLException {    Connection conn = null;    try {     conn = this.getConnection();     return runner.insertOrUpdate(conn, record, keys);    } catch (SQLException e) {     throw e;    } finally {     this.closeConnection(conn);    }   }
public void stop()    throws MojoExecutionException, IOException, InstanceNotFoundException {   try {    this.connection.invoke(this.objectName, ""shutdown"", null, null);   }   catch (ReflectionException ex) {    throw new MojoExecutionException(""Shutdown failed"", ex.getCause());   }   catch (MBeanException ex) {    throw new MojoExecutionException(""Could not invoke shutdown operation"", ex);   }  }
public static <IN, OUT> CompletableFuture<OUT> thenApplyAsyncIfNotDone(   CompletableFuture<IN> completableFuture,   Executor executor,   Function<? super IN, ? extends OUT> applyFun) {   return completableFuture.isDone() ?    completableFuture.thenApply(applyFun) :    completableFuture.thenApplyAsync(applyFun, executor);  }
static void putTarget(final int targetTypeAndInfo, final ByteVector output) {     switch (targetTypeAndInfo >>> 24) {       case CLASS_TYPE_PARAMETER:       case METHOD_TYPE_PARAMETER:       case METHOD_FORMAL_PARAMETER:         output.putShort(targetTypeAndInfo >>> 16);         break;       case FIELD:       case METHOD_RETURN:       case METHOD_RECEIVER:         output.putByte(targetTypeAndInfo >>> 24);         break;       case CAST:       case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:       case METHOD_INVOCATION_TYPE_ARGUMENT:       case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:       case METHOD_REFERENCE_TYPE_ARGUMENT:         output.putInt(targetTypeAndInfo);         break;       case CLASS_EXTENDS:       case CLASS_TYPE_PARAMETER_BOUND:       case METHOD_TYPE_PARAMETER_BOUND:       case THROWS:       case EXCEPTION_PARAMETER:       case INSTANCEOF:       case NEW:       case CONSTRUCTOR_REFERENCE:       case METHOD_REFERENCE:         output.put12(targetTypeAndInfo >>> 24, (targetTypeAndInfo & 0xFFFF00) >> 8);         break;       default:         throw new IllegalArgumentException();     }   }
public void connect(ConnectionProperties cp, ClientComponentHandshake cch)       throws SIResourceException, SIAuthenticationException    {       if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, ""connect"", new Object[] {cp, cch});        ClientConnectionManager conMan = null;        if (cp == null)       {          // The caller of this method passed in a null for the connection properties. This is          // bad as we kinda need those so we know where to connect to.          SIErrorException e = new SIErrorException(             nls.getFormattedMessage(""NULL_CONNECTION_PROPERTIES_SICO1039"", null, null)          );           FFDCFilter.processException(e, CLASS_NAME + "".connect"",                                      CommsConstants.CLIENTSIDECONNECTION_CONNECT_04, this);           throw e;       }        if (cch == null)       {          // The caller of this method passed in null for the client component handshake. We need          // this so we can call back to them to inform them to handshake.          SIErrorException e = new SIErrorException(             nls.getFormattedMessage(""NULL_CCH_SICO1040"", null, null)          );           FFDCFilter.processException(e, CLASS_NAME + "".connect"",                                      CommsConstants.CLIENTSIDECONNECTION_CONNECT_05, this);           throw e;       }        // Use the JFAP Channel to connect to the server       Conversation con = null;       boolean handshakeCompletedOk = false;        try       {          ClientConnectionManager.initialise();          conMan = ClientConnectionManager.getRef();           // Establish a connection using details passed in via TRM.          // These details can either be a hostname / port or a WLM          // end point.          if (cp.getMode() == ConnectionProperties.PropertiesType.HOST_PORT)          {             final String host = cp.getEndPoint().getHost();             final int port = cp.getEndPoint().getPort().intValue();             final String chainName = cp.getChainName();              connectionInfo = host + "":"" + port + "" - "" + chainName;             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) SibTr.debug(this, tc, ""Connecting to: "" + connectionInfo);              final InetSocketAddress addr = AccessController.doPrivileged(new PrivilegedAction<InetSocketAddress>() {                @Override                public InetSocketAddress run() {                   return new InetSocketAddress(host, port);                }             });             con = conMan.connect(addr, new ProxyReceiveListener(), chainName);          }          else if (cp.getMode() == ConnectionProperties.PropertiesType.WLM_EP)          {             Object wlmEndpointData = cp.getWLMEndPointData();              connectionInfo = wlmEndpointData.toString();             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) SibTr.debug(this, tc, ""Connecting to: "" + connectionInfo);              con = conMan.connect(wlmEndpointData,                                  new ProxyReceiveListener());          }          else // cp.getMode() == ConnectionProperties.Z_TCP_PROXY          {             connectionInfo = ""tcp bridge service"";             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) SibTr.debug(this, tc, ""Connecting via: ""+connectionInfo);             con = conMan.connect(new ProxyReceiveListener(), ConversationUsageType.JFAP);          }           // Store the Conversation reference          setConversation(con);          // We need to store Conversation state for each conversation so now          // seems a good time to create the state storage object          createConversationState();           // Store away the ClientSideConnection associated with this conversation          this.setCommsConnection(this);           // Start F247845          // Check and see the multicast parameters passed into us by TRM          Map trmProperties = cp.getClientConnectionPropertyMap();          if (trmProperties != null)          {             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) SibTr.debug(this, tc, ""Client properties: "", trmProperties);              // Work out if Multicast is infact enabled             String subProtocol = (String) trmProperties.get(SibTrmConstants.SUBSCRIPTION_PROTOCOL);             if (subProtocol != null)             {                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) SibTr.debug(this, tc, ""Subscription protocol:"", subProtocol);                 if (subProtocol.equals(SibTrmConstants.SUBSCRIPTION_PROTOCOL_MULTICAST))                {                   // TODO: fix this up!                   throw new SIErrorException(""This shouldn't happen!"");                }             }          }           // We only need to do Comms and MFP handshaking if the connection was made          // using a brand new socket          if (con.isFirst())          {             // Set the connection closed listener             con.addConnectionClosedListener(this, ConversationUsageType.JFAP);              initiateCommsHandshaking();              if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) SibTr.debug(this, tc, ""Comms handshake completed successfully"");                          // Get hold of product version             int productVersion = getConversation().getHandshakeProperties().getMajorVersion();              try             {                // Get hold of MFP and drive it to handshake                CompHandshake ch = (CompHandshake) CompHandshakeFactory.getInstance();                ch.compStartHandshake(this,productVersion);             }             catch (Exception e1)             {                FFDCFilter.processException(e1, CLASS_NAME + "".connect"",                                           CommsConstants.CLIENTSIDECONNECTION_CONNECT_03, this);                 if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) SibTr.debug(this, tc, ""MFP unable to create CompHandshake Singleton"", e1);                 String message = nls.getFormattedMessage(                   ""MFP_HANDSHAKE_FAILED_SICO1005"", new Object[] { e1 }, null                );                 SIResourceException ce = new SIResourceException(message, e1);                throw ce;             }          }           // Now call TRM to do its handshaking          if (!cch.connect(this))          {             // If TRM returned false here, we need to throw an exception             // to cancel the proceedings. This may be a TRM failure or more             // likely an authorisation problem. No matter what though, we             // just indicate this to TRM and let them figure out why             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) SibTr.debug(this, tc, ""TRM connection returned false - connection will be aborted"");  //d179741              // The caller of this method passed in null for the client component handshake. We need             // this so we can call back to them to inform them to handshake.             SIResourceException e = new SIResourceException(                nls.getFormattedMessage(""TRM_HANDSHAKE_FAILED_SICO1037"", null, null)             );              FFDCFilter.processException(e, CLASS_NAME + "".connect"",                                         CommsConstants.CLIENTSIDECONNECTION_CONNECT_06, this);              throw e;          }                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) SibTr.debug(this, tc, ""TRM handshake completed successfully""); // D223615          handshakeCompletedOk = true;       }       catch (SIException e)       {          // No FFDC code needed           // We don't FFDC here as being unable to connect is not necessarily a problem. In the case of bootstraping clients          // each bootstrap triplet will be tried since being unable to connect to some targets is to be expected - particularly          // in fail over scenarios. We have also discovered that a FFDC during a fail over can slow the fail over process. Instead          // we just throw the exception back to our caller and let the layers above which know the bigger picture decide whether          // to FFDC or not.           if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) SibTr.debug(this, tc, ""Unable to make initial connection"", e);           SIResourceException ce = new SIResourceException(             nls.getFormattedMessage(""CONNECT_FAILED_SICO1001"", new Object[] { e }, null)          );           ce.initCause(e);          if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, ""connect"", ce);          throw ce;       }       finally       {          // Ensure we always call this - as even if we fail we don't want to block everyone          // else out from starting a conversation          if (con != null)          {             if (handshakeCompletedOk)             {                con.handshakeComplete();             }             else             {              // release any handshake waiters                   if (con != null)                    con.handshakeFailed();                                  // Start D273578                 // Ensure we close the conversation down ignoring any exceptions                 try                  {                    if (con != null)                       con.close();                 }                 catch (SIException e2)                 {                    // No FFDC Code Needed                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) SibTr.debug(this, tc, ""Failed to close connection: "" + e2);                 }                 // End D273578                                  con = null;             }          }       }        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, ""connect"");    }
public static OutputStream getOutputStream(Socket socket, long timeout)        throws IOException {     return (socket.getChannel() == null) ?          socket.getOutputStream() : new SocketOutputStream(socket, timeout);               }
public BuildRecord removeBuildRecord(BuildRecord buildRecord) {         getBuildRecords().remove(buildRecord);         buildRecord.setUser(null);         return buildRecord;     }
public void enter(@NonNull View from, boolean withAnimation) {         if (GestureDebug.isDebugAnimator()) {             Log.d(TAG, ""Entering from view, with animation = "" + withAnimation);         }          enterInternal(withAnimation);         updateInternal(from);     }
public Specificity computeSpecificity() {      Specificity spec = new SpecificityImpl();      for(Selector s: list)     s.computeSpecificity(spec);       return spec;     }
private void addHeaders(HttpRequest request, Map<String, String> headers) {   for (Map.Entry<String, String> key : headers.entrySet()) {    request.addHeader(key.getKey(), key.getValue());   }  }
public boolean signatureCoversWholeDocument(String name) {         getSignatureNames();         name = getTranslatedFieldName(name);         if (!sigNames.containsKey(name))             return false;         return ((int[])sigNames.get(name))[0] == reader.getFileLength();     }
public Observable<Void> recognizeTextAsync(String url, TextRecognitionMode mode) {         return recognizeTextWithServiceResponseAsync(url, mode).map(new Func1<ServiceResponseWithHeaders<Void, RecognizeTextHeaders>, Void>() {             @Override             public Void call(ServiceResponseWithHeaders<Void, RecognizeTextHeaders> response) {                 return response.body();             }         });     }
protected <X> Specification<ENTITY> buildSpecification(Filter<X> filter, SingularAttribute<? super ENTITY, X>         field) {         if (filter.getEquals() != null) {             return equalsSpecification(field, filter.getEquals());         } else if (filter.getIn() != null) {             return valueIn(field, filter.getIn());         } else if (filter.getSpecified() != null) {             return byFieldSpecified(field, filter.getSpecified());         }         return null;     }
private void _appendCharacterEscape(char esc, char ch)             throws IOException, JsonGenerationException     {         if ((_outputTail + 1) >= _outputEnd) {             _flushBuffer();         }         _outputBuffer[_outputTail++] = esc;         _outputBuffer[_outputTail++] = ch;     }
@Override   public void write (@Nonnull final String sStr, final int nOfs, final int nLen)   {     m_aSB.append (sStr.substring (nOfs, nOfs + nLen));   }
protected boolean processTopicSourceUrls(final TopicSourceURLProvider topicSourceURLProvider, final SpecTopic specTopic,             final TopicWrapper topic) {         LOG.debug(""Processing topic source urls"");          boolean changed = false;         // Save the new Source Urls         final List<String> urls = specTopic.getSourceUrls(true);          if (urls != null && !urls.isEmpty()) {             final UpdateableCollectionWrapper<TopicSourceURLWrapper> sourceUrls = topic.getSourceURLs() == null ? topicSourceURLProvider                     .newTopicSourceURLCollection(topic) : topic.getSourceURLs();              // Iterate over the spec topic urls and add them             for (final String url : urls) {                 final TopicSourceURLWrapper sourceUrl = topicSourceURLProvider.newTopicSourceURL(topic);                 sourceUrl.setUrl(url);                  sourceUrls.addNewItem(sourceUrl);             }              topic.setSourceURLs(sourceUrls);             changed = true;         }          return changed;     }
private String[] augmentCommand(String[] args, Class<? extends Command> cmd,    boolean acceptsInputFile) {   OptionGroup<ID> options;   try {    if (acceptsInputFile) {     options = OptionIntrospector.introspect(cmd, InputFileCommand.class);    } else {     options = OptionIntrospector.introspect(cmd);    }   } catch (IntrospectionException e) {    //should never happen    throw new RuntimeException(e);   }      ShellContext sc = ShellContext.current();   for (Option<ID> o : options.getOptions()) {    if (o.getLongName().equals(""style"")) {     args = ArrayUtils.add(args, ""--style"");     args = ArrayUtils.add(args, sc.getStyle());    } else if (o.getLongName().equals(""locale"")) {     args = ArrayUtils.add(args, ""--locale"");     args = ArrayUtils.add(args, sc.getLocale());    } else if (o.getLongName().equals(""format"")) {     args = ArrayUtils.add(args, ""--format"");     args = ArrayUtils.add(args, sc.getFormat());    } else if (o.getLongName().equals(""input"") &&      sc.getInputFile() != null && !sc.getInputFile().isEmpty()) {     args = ArrayUtils.add(args, ""--input"");     args = ArrayUtils.add(args, sc.getInputFile());    }   }      return args;  }
public static void isNotEmpty( Iterator<?> argument,                                    String name ) {         isNotNull(argument, name);         if (!argument.hasNext()) {             throw new IllegalArgumentException(CommonI18n.argumentMayNotBeEmpty.text(name));         }     }
public static CommerceTierPriceEntry findByUuid_First(String uuid,   OrderByComparator<CommerceTierPriceEntry> orderByComparator)   throws com.liferay.commerce.price.list.exception.NoSuchTierPriceEntryException {   return getPersistence().findByUuid_First(uuid, orderByComparator);  }
public CompositeHandler withQueryHandler(final QueryHandler handler) {         if (handler == null) {             throw new IllegalArgumentException();         } // end of if          // ---          return new CompositeHandler(this.queryDetection,                                     handler,                                     this.updateHandler);              }
public static int getYAsOppositeTileFormat(int zoom, int y) {   int tilesPerSide = tilesPerSide(zoom);   int oppositeY = tilesPerSide - y - 1;   return oppositeY;  }
private void initReader(Object obj) {   if (obj instanceof WorkingDirectoryLocationAware) {    ((WorkingDirectoryLocationAware) obj).setWorkingDirectory(workingDirectory);   }   if (obj instanceof ServletContextAware) {    ((ServletContextAware) obj).setServletContext(servletContext);   }    if (obj instanceof ResourceBrowser) {    resourceInfoProviders.add(0, (ResourceBrowser) obj);   }  }
public final void reset(boolean resetChunkSize)     {         firstChunk = null;         lastChunk = null;         totalCharsInList = 0;         totalCharsInDynamicChunks = -1;         sizeAtLeast = -1;         if (resetChunkSize)         {             chunkSize = firstChunkSize;             totalChunkSize = 0;         }         allocBuffer = new AllocatedBuffer(chunkSize);         dynamicChunkMap = new HashMap<StreamCharBufferKey, StreamCharBufferSubChunk>();     }
public static void addFile(State state, String file) {     state.setProp(ADD_FILES, state.getProp(ADD_FILES, """") + "","" + file);   }
public static String chop(String target) {   if (isEmpty(target)) { return EMPTY; }   int len = target.length(), lastIdx = -1;   if (len >= 2 && target.charAt(len - 1) == LF && target.charAt(len - 2) == CR) {    if (len == 2) { return EMPTY; } lastIdx = -2;    }   return replace(target).afters(lastIdx).byNone().last();  }
private Entry<V> computeIfAbsent(K key) {     Entry<V> v = map.get(key);     if (v == null) {       Entry<V> tmp = entryGetter.apply(key);       v = map.putIfAbsent(key, tmp);       if (v == null) {         v = tmp;       }     }     return v;   }
protected void generateTitleBand() {   log.debug(""Generating title band..."");   JRDesignBand band = (JRDesignBand) getDesign().getPageHeader();   int yOffset = 0;    //If title is not present then subtitle will be ignored   if (getReport().getTitle() == null)    return;    if (band != null && !getDesign().isTitleNewPage()){    //Title and subtitle comes afer the page header    yOffset = band.getHeight();    } else {    band = (JRDesignBand) getDesign().getTitle();    if (band == null){     band = new JRDesignBand();     getDesign().setTitle(band);    }   }    JRDesignExpression printWhenExpression = new JRDesignExpression();   printWhenExpression.setValueClass(Boolean.class);   printWhenExpression.setText(EXPRESSION_TRUE_WHEN_FIRST_PAGE);    JRDesignTextField title = new JRDesignTextField();   JRDesignExpression exp = new JRDesignExpression();   if (getReport().isTitleIsJrExpression()){    exp.setText(getReport().getTitle());   }else {    exp.setText(""\"""" + Utils.escapeTextForExpression( getReport().getTitle()) + ""\"""");   }   exp.setValueClass(String.class);   title.setExpression(exp);   title.setWidth(getReport().getOptions().getPrintableWidth());   title.setHeight(getReport().getOptions().getTitleHeight());   title.setY(yOffset);   title.setPrintWhenExpression(printWhenExpression);   title.setRemoveLineWhenBlank(true);   applyStyleToElement(getReport().getTitleStyle(), title);   title.setStretchType( StretchTypeEnum.NO_STRETCH );   band.addElement(title);    JRDesignTextField subtitle = new JRDesignTextField();   if (getReport().getSubtitle() != null) {    JRDesignExpression exp2 = new JRDesignExpression();    exp2.setText(""\"""" + getReport().getSubtitle() + ""\"""");    exp2.setValueClass(String.class);    subtitle.setExpression(exp2);    subtitle.setWidth(getReport().getOptions().getPrintableWidth());    subtitle.setHeight(getReport().getOptions().getSubtitleHeight());    subtitle.setY(title.getY() + title.getHeight());    subtitle.setPrintWhenExpression(printWhenExpression);    subtitle.setRemoveLineWhenBlank(true);    applyStyleToElement(getReport().getSubtitleStyle(), subtitle);    title.setStretchType( StretchTypeEnum.NO_STRETCH );    band.addElement(subtitle);   }    }
protected boolean isArrayJsonStenoEvent(@Nullable final Marker marker) {         return marker != null && marker.contains(StenoMarker.ARRAY_JSON_MARKER);     }
protected void addRequestHeaders(final HttpServletRequest httpServletRequest, final Map<String, List<Object>> attributes) {         for (final Map.Entry<String, Set<String>> headerAttributeEntry : this.headerAttributeMapping.entrySet()) {             final String headerName = headerAttributeEntry.getKey();             final String value = httpServletRequest.getHeader(headerName);              if (value != null) {                 for (final String attributeName : headerAttributeEntry.getValue()) {                     attributes.put(attributeName,                             headersToIgnoreSemicolons.contains(headerName) ?                                     list(value)                                     : splitOnSemiColonHandlingBackslashEscaping(value));                 }             }         }     }
public static lbvserver get(nitro_service service, String name) throws Exception{   lbvserver obj = new lbvserver();   obj.set_name(name);   lbvserver response = (lbvserver) obj.get_resource(service);   return response;  }
private static AlluxioFuseOptions parseOptions(String[] args, AlluxioConfiguration alluxioConf) {     final Options opts = new Options();     final Option mntPoint = Option.builder(""m"")         .hasArg()         .required(true)         .longOpt(""mount-point"")         .desc(""Desired local mount point for alluxio-fuse."")         .build();      final Option alluxioRoot = Option.builder(""r"")         .hasArg()         .required(true)         .longOpt(""alluxio-root"")         .desc(""Path within alluxio that will be used as the root of the FUSE mount ""             + ""(e.g., /users/foo; defaults to /)"")         .build();      final Option help = Option.builder(""h"")         .required(false)         .desc(""Print this help"")         .build();      final Option fuseOption = Option.builder(""o"")         .valueSeparator(',')         .required(false)         .hasArgs()         .desc(""FUSE mount options"")         .build();      opts.addOption(mntPoint);     opts.addOption(alluxioRoot);     opts.addOption(help);     opts.addOption(fuseOption);      final CommandLineParser parser = new DefaultParser();     try {       CommandLine cli = parser.parse(opts, args);        if (cli.hasOption(""h"")) {         final HelpFormatter fmt = new HelpFormatter();         fmt.printHelp(AlluxioFuse.class.getName(), opts);         return null;       }        String mntPointValue = cli.getOptionValue(""m"");       String alluxioRootValue = cli.getOptionValue(""r"");        List<String> fuseOpts = new ArrayList<>();       boolean noUserMaxWrite = true;       if (cli.hasOption(""o"")) {         String[] fopts = cli.getOptionValues(""o"");         // keep the -o         for (final String fopt: fopts) {           fuseOpts.add(""-o"" + fopt);           if (noUserMaxWrite && fopt.startsWith(""max_write"")) {             noUserMaxWrite = false;           }         }       }       // check if the user has specified his own max_write, otherwise get it       // from conf       if (noUserMaxWrite) {         final long maxWrite = alluxioConf.getBytes(PropertyKey.FUSE_MAXWRITE_BYTES);         fuseOpts.add(String.format(""-omax_write=%d"", maxWrite));       }        final boolean fuseDebug = alluxioConf.getBoolean(PropertyKey.FUSE_DEBUG_ENABLED);        return new AlluxioFuseOptions(mntPointValue, alluxioRootValue, fuseDebug, fuseOpts);     } catch (ParseException e) {       System.err.println(""Error while parsing CLI: "" + e.getMessage());       final HelpFormatter fmt = new HelpFormatter();       fmt.printHelp(AlluxioFuse.class.getName(), opts);       return null;     }   }
@NotNull     public Map<Object, Object> getPoolConfiguration() {         return ConfigurationConverter.getMap(configuration.subset(GenericObjectPoolConfig.class.getName()));     }
@Override     public SimplePath[] interconnect(KamNode[] sources) {         if (sources == null || sources.length < 2) {             throw new InvalidArgument(                     ""Source kam nodes cannot be null and must contain at least two source nodes."");         }          // build out target set, check that each node is in the KAM         final Set<KamNode> targetSet = new HashSet<KamNode>(sources.length);         for (int i = 0; i < sources.length; i++) {             final KamNode source = sources[i];              if (!kam.contains(source)) {                 throw new InvalidArgument(""Source does not exist in KAM."");             }              targetSet.add(source);         }          final List<SimplePath> pathsFound = new ArrayList<SimplePath>();         for (final KamNode source : sources) {             // remove source from target before search to prevent search the same             // paths twice in the bidirectional search             targetSet.remove(source);             pathsFound.addAll(runDepthFirstSearch(kam, source, targetSet));         }         return pathsFound.toArray(new SimplePath[pathsFound.size()]);     }
List<I_CmsSimpleContextMenuEntry<Set<String>>> getMenuEntries() {          if (m_menuEntries == null) {             m_menuEntries = new ArrayList<I_CmsSimpleContextMenuEntry<Set<String>>>();             m_menuEntries.add(new EntryResources());             m_menuEntries.add(new EntryDelete());         }         return m_menuEntries;     }
public LineString toLineString(List<LatLng> latLngs, boolean hasZ,                                    boolean hasM) {          LineString lineString = new LineString(hasZ, hasM);          populateLineString(lineString, latLngs);          return lineString;     }
public TransactionInfo queryTransactionByID(Peer peer, String txID) throws ProposalException, InvalidArgumentException {         return queryTransactionByID(Collections.singleton(peer), txID, client.getUserContext());     }
public String get(String key) {     if (properties.get(key) != null) {       return properties.get(key);     } else {       return getConfigurationValue(key);     }   }
public static DoubleToLongFunction doubleToLongFunction(CheckedDoubleToLongFunction function, Consumer<Throwable> handler) {         return t -> {             try {                 return function.applyAsLong(t);             }             catch (Throwable e) {                 handler.accept(e);                  throw new IllegalStateException(""Exception handler must throw a RuntimeException"", e);             }         };     }
public static Searcher get(String variant) {         final Searcher searcher = instances.get(variant);         if (searcher == null) {             throw new IllegalStateException(Errors.SEARCHER_GET_BEFORE_CREATE);         }         return searcher;     }
@SuppressWarnings(""unchecked"")   @Override   public EList<IfcTimePeriod> getTimePeriods() {    return (EList<IfcTimePeriod>) eGet(Ifc4Package.Literals.IFC_RECURRENCE_PATTERN__TIME_PERIODS, true);   }
protected void threadStart() {          // Has the background thread already been started?         if (thread != null) {             return;         }          // Start the background thread         threadDone = false;         thread = new Thread(this, threadName);         thread.setDaemon(true);         thread.start();      }
public final AnalyzeEntitySentimentResponse analyzeEntitySentiment(       Document document, EncodingType encodingType) {      AnalyzeEntitySentimentRequest request =         AnalyzeEntitySentimentRequest.newBuilder()             .setDocument(document)             .setEncodingType(encodingType)             .build();     return analyzeEntitySentiment(request);   }
@RobeService(group = ""User"", description = ""Updates a single User matches with the given id."")     @PATCH     @UnitOfWork     @Path(""{id}"")     public User merge(@RobeAuth Credentials credentials, @PathParam(""id"") String id, User model) {         if (!id.equals(model.getOid()))             throw new WebApplicationException(Response.status(412).build());         User dest = userDao.findById(id);         if (dest == null) {             throw new WebApplicationException(Response.status(404).build());         }         Fields.mergeRight(model, dest);         return userDao.update(dest);     }
@Override     public InetAddress getLocalAddress() {         InetAddress address = null;          if (udpNetworkLayer != null) {             address = udpNetworkLayer.getDatagramSocket().getLocalAddress();             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                 if (address == null) {                     Tr.debug(tc, ""getLocalAddress == null"");                 }             }         } else {             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                 Tr.debug(tc, ""getLocalAddress; udpNetworkLayer == null"");             }         }         return address;     }
protected String encodeCookie(SerializableHttpCookie cookie) {         if (cookie == null)             return null;         ByteArrayOutputStream os = new ByteArrayOutputStream();         try {             ObjectOutputStream outputStream = new ObjectOutputStream(os);             outputStream.writeObject(cookie);         } catch (IOException e) {             Util.log(""IOException in encodeCookie"", e);             return null;         }          return byteArrayToHexString(os.toByteArray());     }
public String getMenuName(HttpServletRequest request, String overrideName) {   if (!StringUtils.isEmpty(overrideName)) {    return overrideName;   }   String name = request.getRequestURI().replaceFirst(AdminTool.ROOTCONTEXT, """");   if (!StringUtils.isEmpty(request.getContextPath())) {    name = name.replaceFirst(request.getContextPath(), """");   }   if (name.startsWith(""/"")) {    name = name.substring(1, name.length());   }   return name;  }
@Override     protected Long callInternal() throws Exception {         return portletRenderer.doServeResource(                 portletWindowId, request, response, new ResourcePortletOutputHandler(response));     }
public JobScheduleGetOptions withIfUnmodifiedSince(DateTime ifUnmodifiedSince) {         if (ifUnmodifiedSince == null) {             this.ifUnmodifiedSince = null;         } else {             this.ifUnmodifiedSince = new DateTimeRfc1123(ifUnmodifiedSince);         }         return this;     }
protected String matchAxisTypeAndDimension(NetcdfDataset ds, AxisType type, final Dimension outer, final Dimension inner) {      Variable var = CoordSysEvaluator.findCoordByType(ds, type, new CoordSysEvaluator.Predicate() {        @Override        public boolean match(CoordinateAxis axis) {          return ((axis.getRank() == 2) && outer.equals(axis.getDimension(0)) && inner.equals(axis.getDimension(1)));        }      });      if (var == null) return null;      return var.getShortName();    }
public IfcLampTypeEnum createIfcLampTypeEnumFromString(EDataType eDataType, String initialValue) {    IfcLampTypeEnum result = IfcLampTypeEnum.get(initialValue);    if (result == null)     throw new IllegalArgumentException(       ""The value '"" + initialValue + ""' is not a valid enumerator of '"" + eDataType.getName() + ""'"");    return result;   }
public void withFollowings(boolean followings) {     if (followings) {       addQueryParameter(Constants.WITH_PARAM, Constants.WITH_FOLLOWINGS);     } else {       removeQueryParameter(Constants.WITH_PARAM);     }   }
@Override     public void setMaxFieldSize(int max) throws SQLException {         if (statement != null) {             statement.setMaxFieldSize(max);         } else {             tag.setMaxFieldSize(true);             prop.setMaxFieldSize(max);         }     }
protected void process(HttpServletRequest request, HttpServletResponse response, String fileName)             throws IOException {         // TODO put this html code in a template         response.setContentType(""text/html"");         response.setCharacterEncoding(""UTF-8"");         response.setStatus(200);         FileBackedStringBuffer buffer = new FileBackedStringBuffer();          buffer.append(""<html><head><title>"");         buffer.append(request.getRemoteHost());         buffer.append(""</title><script type=text/javascript>"");         buffer.append(""function submitform() { document.myform.submit(); } </script>"");         buffer.append(""</head><body><H1>View Logs on - "");         buffer.append(request.getRemoteHost()).append(""</H1>"");          if (isLogsDirectoryEmpty()) {             buffer.append(""<br>No Logs available.</br></body></html>"");             dumpStringToStream(buffer, response.getOutputStream());             return;         }         buffer.append(appendMoreLogsLink(fileName, request.getRequestURL().toString()));         buffer.append(renderLogFileContents(fileName));         buffer.append(""</body></html>"");         dumpStringToStream(buffer, response.getOutputStream());     }
private String parseAttributeValue(String watch) throws JasperException {  Mark start = reader.mark();  Mark stop = reader.skipUntilIgnoreEsc(watch);  if (stop == null) {      err.jspError(start, ""jsp.error.attribute.unterminated"", watch);  }   String ret = parseQuoted(reader.getText(start, stop));  if (watch.length() == 1) // quote      return ret;   // putback delimiter '<%=' and '%>', since they are needed if the  // attribute does not allow RTexpression.  return ""<%="" + ret + ""%>"";     }
private void auditStatusWhenQualityGateDetailsFound(Map condition, CodeQualityAuditResponse codeQualityAuditResponse) {         if (StringUtils.equalsIgnoreCase(condition.get(""metric"").toString(), CodeQualityMetricType.BLOCKER_VIOLATIONS.getType())) {             codeQualityAuditResponse.addAuditStatus(CodeQualityAuditStatus.CODE_QUALITY_THRESHOLD_BLOCKER_FOUND);             if (!StringUtils.equalsIgnoreCase(condition.get(""level"").toString(), ""ERROR"")) {                 codeQualityAuditResponse.addAuditStatus(CodeQualityAuditStatus.CODE_QUALITY_THRESHOLD_BLOCKER_MET);             }         } else if (StringUtils.equalsIgnoreCase(condition.get(""metric"").toString(), CodeQualityMetricType.CRITICAL_VIOLATIONS.getType())) {             codeQualityAuditResponse.addAuditStatus(CodeQualityAuditStatus.CODE_QUALITY_THRESHOLD_CRITICAL_FOUND);             if (!StringUtils.equalsIgnoreCase(condition.get(""level"").toString(), ""ERROR"")) {                 codeQualityAuditResponse.addAuditStatus(CodeQualityAuditStatus.CODE_QUALITY_THRESHOLD_CRITICAL_MET);             }         } else if (StringUtils.equalsIgnoreCase(condition.get(""metric"").toString(), CodeQualityMetricType.UNIT_TEST.getType())) {             codeQualityAuditResponse.addAuditStatus(CodeQualityAuditStatus.CODE_QUALITY_THRESHOLD_UNIT_TEST_FOUND);             if (!StringUtils.equalsIgnoreCase(condition.get(""level"").toString(), ""ERROR"")) {                 codeQualityAuditResponse.addAuditStatus(CodeQualityAuditStatus.CODE_QUALITY_THRESHOLD_UNIT_TEST_MET);             }         } else if (StringUtils.equalsIgnoreCase(condition.get(""metric"").toString(), CodeQualityMetricType.NEW_COVERAGE.getType())                 || StringUtils.equalsIgnoreCase(condition.get(""metric"").toString(), CodeQualityMetricType.COVERAGE.getType())) {             codeQualityAuditResponse.addAuditStatus(CodeQualityAuditStatus.CODE_QUALITY_THRESHOLD_CODE_COVERAGE_FOUND);             if (!StringUtils.equalsIgnoreCase(condition.get(""level"").toString(), ""ERROR"")) {                 codeQualityAuditResponse.addAuditStatus(CodeQualityAuditStatus.CODE_QUALITY_THRESHOLD_CODE_COVERAGE_MET);             }         }     }
public void callback(final Callback callback)     {         Runnable runnable = new Runnable()         {             @Override             public void run()             {                 try                 {                     callback.result(queryId, awaitResult());                 }                 catch (Exception e)                 {                     callback.error(queryId, e);                 }             }         };         EXECUTOR_SERVICE.submit(runnable);     }
@Override  public List<CommerceCurrency> getCommerceCurrenciesByUuidAndCompanyId(   String uuid, long companyId, int start, int end,   OrderByComparator<CommerceCurrency> orderByComparator) {   return commerceCurrencyPersistence.findByUuid_C(uuid, companyId, start,    end, orderByComparator);  }
public CacheConfigurationBuilder<K, V> withLoaderWriter(Class<CacheLoaderWriter<K, V>> loaderWriterClass, Object... arguments) {     return addOrReplaceConfiguration(new DefaultCacheLoaderWriterConfiguration(requireNonNull(loaderWriterClass, ""Null loaderWriterClass""), arguments));   }
@Override  public void cacheResult(   CommerceTaxFixedRateAddressRel commerceTaxFixedRateAddressRel) {   entityCache.putResult(CommerceTaxFixedRateAddressRelModelImpl.ENTITY_CACHE_ENABLED,    CommerceTaxFixedRateAddressRelImpl.class,    commerceTaxFixedRateAddressRel.getPrimaryKey(),    commerceTaxFixedRateAddressRel);    commerceTaxFixedRateAddressRel.resetOriginalValues();  }
public static Date getLastNDay(Date d, int n, int unitType) {      Calendar cal = Calendar.getInstance();         cal.setTime(d);          cal.add(unitType, -n);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         return cal.getTime();     }
public DescribeSecretResult withVersionIdsToStages(java.util.Map<String, java.util.List<String>> versionIdsToStages) {         setVersionIdsToStages(versionIdsToStages);         return this;     }
public Boolean assignRoleToUser(long id, List<Long> roleIds) throws OAuthSystemException, OAuthProblemException, URISyntaxException {   cleanError();   prepareToken();    OneloginURLConnectionClient httpClient = new OneloginURLConnectionClient();   OAuthClient oAuthClient = new OAuthClient(httpClient);    URIBuilder url = new URIBuilder(settings.getURL(Constants.ADD_ROLE_TO_USER_URL, Long.toString(id)));   OAuthClientRequest bearerRequest = new OAuthBearerClientRequest(url.toString())    .buildHeaderMessage();    Map<String, String> headers = getAuthorizedHeader();   bearerRequest.setHeaders(headers);    HashMap<String, Object> params = new HashMap<String, Object>();   params.put(""role_id_array"", roleIds);    String body = JSONUtils.buildJSON(params);   bearerRequest.setBody(body);    Boolean success = true;   OneloginOAuthJSONResourceResponse oAuthResponse = oAuthClient.resource(bearerRequest, OAuth.HttpMethod.PUT, OneloginOAuthJSONResourceResponse.class);   if (oAuthResponse.getResponseCode() != 200) {    success = false;    error = oAuthResponse.getError();    errorDescription = oAuthResponse.getErrorDescription();    errorAttribute = oAuthResponse.getErrorAttribute();   }    return success;  }
public final void putCharLittleEndian(int index, char value) {   if (LITTLE_ENDIAN) {    putChar(index, value);   } else {    putChar(index, Character.reverseBytes(value));   }  }
public static byte[] decode(InputStream in) {         try {             return IOUtils.toByteArray(decodeToStream(in));         } catch (IOException e) {             e.printStackTrace();             return null;         }     }
@Beta   public final Predicate<T> equivalentTo(@Nullable T target) {     return new EquivalentToPredicate<T>(this, target);   }
public static String getPackageName(Elements elementUtils, Types typeUtils, TypeMirror type) {   TypeVisitor<DeclaredType, Object> tv = new SimpleTypeVisitor6<DeclaredType, Object>() {     @Override    public DeclaredType visitDeclared(DeclaredType t, Object p) {     return t;    }   };   DeclaredType dt = type.accept(tv, null);   if (dt != null) {    ElementVisitor<TypeElement, Object> ev =      new SimpleElementVisitor6<TypeElement, Object>() {        @Override       public TypeElement visitType(TypeElement e, Object p) {        return e;       }      };    TypeElement el = typeUtils.asElement(dt).accept(ev, null);    if (el != null && el.getNestingKind() != NestingKind.TOP_LEVEL) {     return AptUtil.getPackageName(elementUtils, el);    }   }   return AptUtil.getPackageNameSub(type);  }
private static boolean validateTermWithStartValue(BytesRef term,       ComponentTermVector termVector) {     if (termVector.startValue == null) {       return true;     } else if (termVector.subComponentFunction.sortType         .equals(CodecUtil.SORT_TERM)) {       if (term.length > termVector.startValue.length) {         byte[] zeroBytes = (new BytesRef(""\u0000"")).bytes;         int n = (int) (Math             .ceil(((double) (term.length - termVector.startValue.length))                 / zeroBytes.length));         byte[] newBytes = new byte[termVector.startValue.length             + n * zeroBytes.length];         System.arraycopy(termVector.startValue.bytes, 0, newBytes, 0,             termVector.startValue.length);         for (int i = 0; i < n; i++) {           System.arraycopy(zeroBytes, 0, newBytes,               termVector.startValue.length + i * zeroBytes.length,               zeroBytes.length);         }         termVector.startValue = new BytesRef(newBytes);       }       if ((termVector.subComponentFunction.sortDirection.equals(           CodecUtil.SORT_ASC) && (termVector.startValue.compareTo(term) < 0))           || (termVector.subComponentFunction.sortDirection               .equals(CodecUtil.SORT_DESC)               && (termVector.startValue.compareTo(term) > 0))) {         return true;       }     }     return false;   }
@Override     public String getConnectionInfo() throws Exception     {         Connection connection = ds.getConnection();          String info =  String.format(""Connected to database: %s using driver: %s as user :%s"",                              connection.getMetaData().getDatabaseProductName(),                              connection.getMetaData().getDriverName(),                              connection.getMetaData().getUserName());          connection.close();          return info;     }
public static FormModelFragment getFormModelFragment(FragmentActivity enclosing) {         // find the retained fragment on activity restarts         FragmentManager fm = enclosing.getSupportFragmentManager();         FormModelFragment formModelFragment = (FormModelFragment) fm.findFragmentByTag(FormModelFragment.TAG);          if (formModelFragment == null) {             // create the retained fragment and data the first time             formModelFragment = new FormModelFragment();             fm.beginTransaction().add(formModelFragment, FormModelFragment.TAG).commit();             formModelFragment.setModel(new MapFormModel());         }          return formModelFragment;     }
public static boolean isConsolePrintable(int cp) {         return (cp >= 0x20 && cp < 0x7F) ||  // main printable ascii                Character.isDefined(cp) &&                !((cp < 0x0020 && cp != '\n') ||                  (0x007F <= cp && cp <  0x00A0) ||                  Character.isIdentifierIgnorable(cp) ||                  (0x07e8 <= cp && cp <= 0x07f3) ||                  (0x07f6 <= cp && cp <= 0x0900) ||                  cp == 0x0ac6 ||                  (0x0bfc <= cp && cp <= 0x0d01) ||                  cp == 0x0f8c ||                  cp == 0x10cd ||                  cp == 0x10fd || cp == 0x10fe || cp == 0x10ff ||                  (0x1a20 <= cp && cp <= 0x1cff) ||                  cp == 0x1680 ||                  (0x1701 <= cp && cp <= 0x1711) ||                  (0x1740 <= cp && cp <= 0x1770) ||                  cp == 0x1772 || cp == 0x1773 ||                  (0x1800 <= cp && cp <= 0x18af) ||                  (0x1900 <= cp && cp <= 0x194f) ||                  (0x1980 <= cp && cp <= 0x19df) ||                  cp == 0x1dcd || cp == 0x1dce ||                  cp == 0x1dd0 ||                  cp == 0x2028 ||                  cp == 0x2c22 ||                  cp == 0x2c2b || cp == 0x2c2c || cp == 0x2c2d ||                  cp == 0x2c52 ||                  cp == 0x2c5b || cp == 0x2c5c || cp == 0x2c5d ||                  (0x2cb2 <= cp && cp <= 0x2cbf) ||                  (0x2cc2 <= cp && cp <= 0x2cc7) ||                  (0x2ccc <= cp && cp <= 0x2ce3) ||                  (0x2ceb <= cp && cp <= 0x2cee) ||                  (0x2cf0 <= cp && cp <= 0x2cfc) ||                  cp == 0x2d70 ||                  (0xa000 <= cp && cp <= 0xa4cf) ||                  (0xa674 <= cp && cp <= 0xa67b) ||                  (0xa698 <= cp && cp <= 0xa6ff) ||                  cp == 0xa754 || cp == 0xa755 ||                  cp == 0xa758 || cp == 0xa759 ||                  (0xa75c <= cp && cp <= 0xa763) ||                  (0xa76a <= cp && cp <= 0xa76d) ||                  (0xa771 <= cp && cp <= 0xa778) ||                  (0xa800 <= cp && cp <= 0xa8df) ||                  (0xa930 <= cp && cp <= 0xa95f) ||                  (0xa97d <= cp && cp <= 0xaa5e) ||                  (0xaa7c <= cp && cp <= 0xaaff) ||                  (0xab30 <= cp && cp <= 0xabff) ||                  (0xd7fc <= cp && cp <= 0xdfff) ||                  (0xe47f <= cp && cp <= 0xe48a) ||                  (0xe4c5 <= cp && cp <= 0xe4ff) ||                  cp == 0xe506 ||                  (0xe50b <= cp && cp <= 0xe50e) ||                  cp == 0xe52d ||                  (0xe534 <= cp && cp <= 0xe547) ||                  cp == 0xe55d ||                  (0xe560 <= cp && cp <= 0xe56f) ||                  cp == 0xe576 || cp == 0xe577 ||                  (0xe57d <= cp && cp <= 0xe583) ||                  (0xe588 <= cp && cp <= 0xe58c) ||                  cp == 0xe591 || cp == 0xe592 ||                  (0xe598 <= cp && cp <= 0xe67f) ||                  (0xe6a4 <= cp && cp <= 0xee68 &&                   cp != 0xec0b &&                   cp != 0xec96 && cp != 0xec97 &&                   cp != 0xec99 &&                   cp != 0xec9d) ||                  (0xee94 <= cp && cp <= 0xeeff) ||                  (0xef1a <= cp && cp <= 0xefec) ||                   (0xfd40 <= cp && cp <= 0xfdff)                );     }
public FileModel getChildFile(ArchiveModel archiveModel, String filePath)     {         filePath = FilenameUtils.separatorsToUnix(filePath);         StringTokenizer stk = new StringTokenizer(filePath, ""/"");          FileModel currentFileModel = archiveModel;         while (stk.hasMoreTokens() && currentFileModel != null)         {             String pathElement = stk.nextToken();              currentFileModel = findFileModel(currentFileModel, pathElement);         }         return currentFileModel;     }
public static void startup(final String _bootstrapPath,                                final String _bootstrapFile)         throws StartupException     {         // evaluate bootstrap path         final File bsPath;         if (_bootstrapPath != null) {             bsPath = new File(_bootstrapPath);         } else {             final String envPath = System.getenv(StartupDatabaseConnection.ENV_PATH);             if (envPath != null) {                 bsPath = new File(envPath);             } else {                 bsPath = new File(System.getProperty(""user.home""), StartupDatabaseConnection.DEFAULT_BOOTSTRAP_PATH);             }         }         // evaluate bootstrap file         final String bsFile;         File bootstrap = null;         if (_bootstrapFile != null) {             bsFile = _bootstrapFile;         } else {             final String envFile = System.getenv(StartupDatabaseConnection.ENV_FILE);             if (envFile != null) {                 bsFile = envFile;             } else {                 bsFile = StartupDatabaseConnection.DEFAULT_BOOTSTRAP_FILE;             }         }         bootstrap = new File(bsFile);         if (bootstrap == null || !bootstrap.exists()) {             bootstrap = new File(bsPath, bsFile);         }          // read bootstrap file         final Properties props = new Properties();         try {             props.loadFromXML(new FileInputStream(bootstrap));         } catch (final FileNotFoundException e) {             throw new StartupException(""bootstrap file "" + bootstrap + "" not found"", e);         } catch (final IOException e) {             throw new StartupException(""bootstrap file "" + bootstrap + "" could not be read"", e);         }          // and startup         final Map<String, String> eFapsProps;         if (props.containsKey(StartupDatabaseConnection.PROP_CONFIGPROP)) {             eFapsProps = StartupDatabaseConnection.convertToMap(props                             .getProperty(StartupDatabaseConnection.PROP_CONFIGPROP));         } else {             eFapsProps = new HashMap<>();         }         StartupDatabaseConnection.startup(props.getProperty(StartupDatabaseConnection.PROP_DBTYPE_CLASS),                         props.getProperty(StartupDatabaseConnection.PROP_DBFACTORY_CLASS),                         props.getProperty(StartupDatabaseConnection.PROP_DBCONNECTION),                         props.getProperty(StartupDatabaseConnection.PROP_TM_CLASS),                         null,                         eFapsProps);     }
private void initializeBeamSearchChart(List<Object> terminals, BeamSearchCfgParseChart chart,       long[] treeEncodingOffsets) {     Variable terminalListValue = terminalVar.getOnlyVariable();      // Adding this to a tree key indicates that the tree is a terminal.     long terminalSignal = ((long) chart.chartSize()) * (treeEncodingOffsets[3] + treeEncodingOffsets[2]);      for (int i = 0; i < terminals.size(); i++) {       for (int j = i; j < terminals.size(); j++) {         if (terminalListValue.canTakeValue(terminals.subList(i, j + 1))) {           Assignment assignment = terminalVar.outcomeArrayToAssignment(terminals.subList(i, j + 1));           Iterator<Outcome> iterator = terminalDistribution.outcomePrefixIterator(assignment);            while (iterator.hasNext()) {             Outcome bestOutcome = iterator.next();             int root = nonterminalVariableType.getValueIndex(bestOutcome.getAssignment().getValue(parentVar.getOnlyVariableNum()));             int ruleType = ruleVariableType.getValueIndex(bestOutcome.getAssignment().getValue(ruleTypeVar.getOnlyVariableNum()));             long partialKeyNum = (root * treeEncodingOffsets[4]) + (ruleType * treeEncodingOffsets[5]);             chart.addParseTreeKeyForSpan(i, j, terminalSignal + partialKeyNum,                 bestOutcome.getProbability());           }           // System.out.println(i + ""."" + j + "": "" + assignment + "" : "" +           // chart.getParseTreesForSpan(i, j));         }       }     }   }
public void marshall(AffectedEntity affectedEntity, ProtocolMarshaller protocolMarshaller) {          if (affectedEntity == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(affectedEntity.getEntityArn(), ENTITYARN_BINDING);             protocolMarshaller.marshall(affectedEntity.getEventArn(), EVENTARN_BINDING);             protocolMarshaller.marshall(affectedEntity.getEntityValue(), ENTITYVALUE_BINDING);             protocolMarshaller.marshall(affectedEntity.getEntityUrl(), ENTITYURL_BINDING);             protocolMarshaller.marshall(affectedEntity.getAwsAccountId(), AWSACCOUNTID_BINDING);             protocolMarshaller.marshall(affectedEntity.getLastUpdatedTime(), LASTUPDATEDTIME_BINDING);             protocolMarshaller.marshall(affectedEntity.getStatusCode(), STATUSCODE_BINDING);             protocolMarshaller.marshall(affectedEntity.getTags(), TAGS_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public void setPermission(Path p, FsPermission permission       ) throws IOException {     dfs.setPermission(getPathName(p), permission);   }
public FieldList setHandle(Object bookmark, int iHandleType) throws DBException     {         if (this.doSetHandle(bookmark, iHandleType))             return this.getRecord();         else             return null;     }
@Override     public String getParameter(String name) {         String value = wrapped.getParameter(name);         if (value == null) {             final String[] multipleValue = parameters.get(name);             if ((multipleValue != null) && (multipleValue.length > 0)) {                 value = multipleValue[0];             }         }         return value;     }
public void setPins(Map<String, String> pins) {   Assert.notNull(pins, ""pins cannot be null"");   this.pins = pins;   updateHpkpHeaderValue();  }
public GetOpenIDConnectProviderResult withClientIDList(String... clientIDList) {         if (this.clientIDList == null) {             setClientIDList(new com.amazonaws.internal.SdkInternalList<String>(clientIDList.length));         }         for (String ele : clientIDList) {             this.clientIDList.add(ele);         }         return this;     }
public void removeConnectionPool(URL url) {         RequestBuilder req = new RequestBuilder();         req.host = url.getHost();         req.port = url.getPort() < 0 ? url.getDefaultPort() : url.getPort();         removePool(req);     }
public static List<PathOperation> toPathOperationsList(String path, Path pathModel) {         List<PathOperation> pathOperations = new ArrayList<>();         getOperationMap(pathModel).forEach((httpMethod, operation) ->                 pathOperations.add(new PathOperation(httpMethod, path, operation)));         return pathOperations;     }
public static <A, B, C, R> Stream<R> zip(final A[] a, final B[] b, final C[] c, final TriFunction<? super A, ? super B, ? super C, R> zipFunction) {          return zip(ObjIteratorEx.of(a), ObjIteratorEx.of(b), ObjIteratorEx.of(c), zipFunction);      }
private static InputStream findFileInClasspath(String fileName) {    InputStream is = null;    try {     ClassLoader classLoader = Thread.currentThread().getContextClassLoader();    is = classLoader.getResourceAsStream(fileName);    return is;    } catch (Exception ex) {     log.error(String.format(""Error while reading file '%s' from classpath"", fileName), ex);    return null;   }   }
protected void createContentsTable(CmsSetupDb dbCon) throws SQLException {          System.out.println(new Exception().getStackTrace()[0].toString());         if (!dbCon.hasTableOrColumn(TABLE_CMS_CONTENTS, null)) {             String query = readQuery(QUERY_CREATE_CMS_CONTENTS_TABLE);             dbCon.updateSqlStatement(query, null, null);         } else {             System.out.println(""table "" + TABLE_CMS_CONTENTS + "" already exists"");         }     }
protected File getGeneratedResourcesDirectory() {     if (generatedResourcesFolder == null) {       String generatedResourcesFolderAbsolutePath = this.project.getBuild().getDirectory() + ""/"" + getGeneratedResourcesDirectoryPath();       generatedResourcesFolder = new File(generatedResourcesFolderAbsolutePath);       if (!generatedResourcesFolder.exists()) {         generatedResourcesFolder.mkdirs();       }     }     return generatedResourcesFolder;   }
public static boolean haveBackend() {     for (DeepWaterParameters.Backend b : DeepWaterParameters.Backend.values()) {       if (DeepwaterMojoModel.createDeepWaterBackend(b.toString()) != null) return true;     }     return false;   }
public long currentTimeInMicros() {          if (!this.isRunning()) {             Moment m = this.currentTime();              return (                 m.getPosixTime() * MIO                 + m.getNanosecond() / 1000             );         }          long micros = SystemClock.MONOTONIC.currentTimeInMicros();         return (micros + this.getLastOffset(micros));      }
static String getPathInfo(RequestLog requestLog) {     String uri = requestLog.path();     if (!StringUtils.hasText(uri)) return ""/"";     return uri.replaceAll(""//+"", ""/"")       .replaceAll(""/$"", """");   }
@FFDCIgnore(Exception.class)     public static <T> StaticValue<T> createStaticValue(Callable<T> initializer) {         if (multiplex) {             return new Multiplexed<T>(initializer);         }         try {             return new FinalSingleton<T>(initializer == null ? null : initializer.call());         } catch (Exception e) {             throw new RuntimeException(e);         }     }
@SuppressWarnings(""unchecked"")   protected <E> EventDispatcher<E> getEventDispatcherRequired(Class<E> eventType) {      return getEventDispatcher(eventType, true);   }
public static <T extends ImageBase<T>> void boundImage(T input , double min , double max ) {   if( input instanceof ImageGray ) {    if (GrayU8.class == input.getClass()) {     PixelMath.boundImage((GrayU8) input, (int) min, (int) max);    } else if (GrayS8.class == input.getClass()) {     PixelMath.boundImage((GrayS8) input, (int) min, (int) max);    } else if (GrayU16.class == input.getClass()) {     PixelMath.boundImage((GrayU16) input, (int) min, (int) max);    } else if (GrayS16.class == input.getClass()) {     PixelMath.boundImage((GrayS16) input, (int) min, (int) max);    } else if (GrayS32.class == input.getClass()) {     PixelMath.boundImage((GrayS32) input, (int) min, (int) max);    } else if (GrayS64.class == input.getClass()) {     PixelMath.boundImage((GrayS64) input, (long) min, (long) max);    } else if (GrayF32.class == input.getClass()) {     PixelMath.boundImage((GrayF32) input, (float) min, (float) max);    } else if (GrayF64.class == input.getClass()) {     PixelMath.boundImage((GrayF64) input, min, max);    } else {     throw new IllegalArgumentException(""Unknown image Type: "" + input.getClass().getSimpleName());    }   } else if( input instanceof Planar ) {    Planar in = (Planar)input;     for (int i = 0; i < in.getNumBands(); i++) {     boundImage( in.getBand(i), min, max);    }   }  }
private final void closeRAF() throws LockFile.UnexpectedFileIOException {          if (raf != null) {             try {                 raf.close();             } catch (IOException ex) {                 throw new UnexpectedFileIOException(this, ""closeRAF"", ex);             } finally {                 raf = null;             }         }     }
private static void setupBindInfoPackage() {    String nsuri = ""http://www.hibernate.org/xsd/orm/hbm"";    String packageInfoClassName = ""org.hibernate.boot.jaxb.hbm.spi.package-info"";    try {     final Class<?> packageInfoClass = Class       .forName(packageInfoClassName);     final XmlSchema xmlSchema = packageInfoClass       .getAnnotation(XmlSchema.class);     if (xmlSchema == null) {      LOG.warn(MessageFormat.format(        ""Class [{0}] is missing the [{1}] annotation. Processing bindings will probably fail."",        packageInfoClassName, XmlSchema.class.getName()));     } else {      final String namespace = xmlSchema.namespace();      if (nsuri.equals(namespace)) {       LOG.warn(MessageFormat.format(         ""Namespace of the [{0}] annotation does not match [{1}]. Processing bindings will probably fail."",         XmlSchema.class.getName(), nsuri));      }     }    } catch (ClassNotFoundException cnfex) {     LOG.warn(MessageFormat.format(       ""Class [{0}] could not be found. Processing bindings will probably fail."",       packageInfoClassName), cnfex);    }   }
public ExternalID getTVExternalIDs(int tvID, String language) throws MovieDbException {         return tmdbTv.getTVExternalIDs(tvID, language);     }
public EventBus emit(String event, Object... args) {         return _emitWithOnceBus(eventContext(event, args));     }
public boolean check() throws Exception {         // we need to create a copy of the file, because the container file         // might be at the end of the stream.         File fileCopy = File.createTempFile(""modeshape-sequencer-epub"", "".tmp"");         IoUtil.write(in, new BufferedOutputStream(new FileOutputStream(fileCopy)));          List<String> rootfiles = new ArrayList<>();         try (ZipInputStream zipStream =                 new ZipInputStream(new FileInputStream(fileCopy))) {             rootfiles = getRootfiles(zipStream);         }          if (!rootfiles.isEmpty()) {             try (ZipInputStream zipStream =                     new ZipInputStream(new FileInputStream(fileCopy))) {                 ZipEntry entry = null;                 while ((entry = zipStream.getNextEntry()) != null) {                     String entryName = entry.getName();                     if (rootfiles.contains(entryName)) {                         checkRootfile(zipStream, entry);                     }                 }             }         } else {             throw new IllegalArgumentException(""No rootfile package found in given EPUB file."");         }          // try to delete the file immediately or on JVM exit         boolean deleted = false;         try {             deleted = fileCopy.delete();         } catch (SecurityException e) {             // ignore         }         if (!deleted) {             fileCopy.deleteOnExit();         }          return true;     }
public Hessian2Output createHessian2Output(OutputStream os)     {         Hessian2Output out = createHessian2Output();          out.init(os);          return out;     }
private static void setPermissions(DataFormatDefinition dformatDefinition) {         // Use Java Reflection to get the method setPermissions. This is done to allow compatibility between fuse 6.3 and fuse 6.2.1         // The xstream library differs on version between the 6.2.1 and 6.3 version of fuse.         Method setPermissions = null;         try {             setPermissions = dformatDefinition.getClass().getMethod(""setPermissions"", String.class);         } catch (Exception e) {         }          if (setPermissions != null) {             try {                 setPermissions.invoke(dformatDefinition, ""+*"");             } catch (Exception e) {             }         }     }
public static <T, U> ToIntBiFunction<T, U> toIntBiFunction(CheckedToIntBiFunction<T, U> function) {         return Unchecked.toIntBiFunction(function, Unchecked.RETHROW_ALL);     }
public static Latency copyOf(AbstractLatency instance) {     if (instance instanceof Latency) {       return (Latency) instance;     }     return Latency.builder()         .from(instance)         .build();   }
@Override     public WorkspaceStorageConnection openConnection(boolean readOnly) throws RepositoryException     {        try        {           if (this.containerConfig.dbStructureType.isMultiDatabase())           {              return new PostgreMultiDbJDBCConnection(getJdbcConnection(readOnly), readOnly, containerConfig);           }             return new PostgreSingleDbJDBCConnection(getJdbcConnection(readOnly), readOnly, containerConfig);        }        catch (SQLException e)        {           throw new RepositoryException(e);        }     }
@NotNull     @ObjectiveCName(""getTypingWithUid:"")     public ValueModel<Boolean> getTyping(int uid) {         return modules.getTypingModule().getTyping(uid).getTyping();     }
public Object next()     {         _current1.reset();         if (_last1.key() == null)             findFirst(_dstack);         else         {             findNext(_dstack);             if (_current1.key() == null)                 _eof = true;         }          if (_current1.key() != null)             _last1.setLocation(_current1);          return _current1.key();     }
public final <K> Ix<T> distinctUntilChanged(IxFunction<? super T, K> keySelector) {         return new IxDistinctUntilChanged<T, K>(this, keySelector, EqualityHelper.INSTANCE);     }
@Override     public boolean isSynchronous() {         if (canBeSynchronous()) {             if (this.canBeAsynchronous()) {                 String attr = this.getAttributeValue(PROP_SYNCHRONOUS_RESPONSE);                 return (attr!=null && attr.equalsIgnoreCase(""true""));             } else return true;         } else return false;     }
public void exit() {         if (exiting()) {             logger.debug(""Another thread is shutting down"");             return;         }         final long start = System.currentTimeMillis();         //noinspection finally         File exitingSignal = getSignal(""exiting"");         try {             logger.info(banner(""Unloading the main component {}"", this.mainComponent));             FileUtils.touch(exitingSignal);             environment.unload(this.mainComponent);             logger.info(banner(""Unloaded  the main component {}"", this.mainComponent));         } catch (Exception ex) {             logger.error(ex.getMessage(), ex);         } finally {             FileUtils.deleteQuietly(exitingSignal);             //启动一个额外的线程停止自身             new Thread(""Stopper"") {                 @Override                 public void run() {                     logger.info(banner(""System stops took {}"", formatDurationHMS(System.currentTimeMillis() - start)));                     System.exit(0);                 }             }.start();         }     }
protected CompletionStage<Result> onAuthFailure(final DeadboltHandler deadboltHandler,                                                     final Optional<String> content,                                                     final Http.RequestHeader request)     {         LOGGER.info(""Deadbolt: Access failure on [{}]"",                     request.uri());          CompletionStage<Result> result;         try         {             result = deadboltHandler.onAuthFailure(request,                                                    content);         }         catch (Exception e)         {             LOGGER.warn(""Deadbolt: Exception when invoking onAuthFailure"",                         e);             result = CompletableFuture.completedFuture(Results.internalServerError());         }         return result;     }
public Collection<String> getLoadBalancerGroups() {     final String requestUri = String.format(LOAD_BALANCER_FORMAT, getBaseUrl());     return getCollection(requestUri, ""load balancer groups"", STRING_COLLECTION);   }
public final DeviceRegistry createDeviceRegistry(       LocationName parent, DeviceRegistry deviceRegistry) {      CreateDeviceRegistryRequest request =         CreateDeviceRegistryRequest.newBuilder()             .setParent(parent == null ? null : parent.toString())             .setDeviceRegistry(deviceRegistry)             .build();     return createDeviceRegistry(request);   }
public TreeNode<String> expand(final Map<String, Tree<String, ?>> variables) {   return expand(variables, Function.identity());  }
public static int latitudeToTileY(double latitude, byte zoomLevel) {         return pixelYToTileY(latitudeToPixelY(latitude, zoomLevel, DUMMY_TILE_SIZE), zoomLevel, DUMMY_TILE_SIZE);     }
public synchronized String simonToString() {   return ""Simon Counter: counter="" + counter +    "", max="" + SimonUtils.presentMinMaxCount(max) +    "", min="" + SimonUtils.presentMinMaxCount(min) +    simonToStringCommon();  }
public HttpSession getSelectedSession() {    final int selectedRow = this.sessionsTable.getSelectedRow();    if (selectedRow == -1) {     // No row selected     return null;    }    final int rowIndex = sessionsTable.convertRowIndexToModel(selectedRow);    return this.sessionsModel.getHttpSessionAt(rowIndex);   }
public String getHost() {   String host = getAsNullableString(""host"");   host = host != null ? host : getAsNullableString(""ip"");   return host;  }
public static Stream<Map.Entry<String, Object>> fieldsAndGetters(Object obj) {   return fieldsAndGetters(obj, Predicates.alwaysTrue());  }
private String getName(CommandContext ctx, boolean failInBatch) throws CommandLineException {         final ParsedCommandLine args = ctx.getParsedCommandLine();         final String name = this.name.getValue(args, true);         if (name == null) {             throw new CommandFormatException(this.name + "" is missing value."");         }         if (!ctx.isBatchMode() || failInBatch) {             if (!Util.isValidPath(ctx.getModelControllerClient(), Util.DEPLOYMENT_OVERLAY, name)) {                 throw new CommandFormatException(""Deployment overlay "" + name + "" does not exist."");             }         }         return name;     }
void patchGlobalScope(TypedScope globalScope, Node scriptRoot) {     // Preconditions: This is supposed to be called only on (named) SCRIPT nodes     // and a global typed scope should have been generated already.     checkState(scriptRoot.isScript());     checkNotNull(globalScope);     checkState(globalScope.isGlobal());      String scriptName = NodeUtil.getSourceName(scriptRoot);     checkNotNull(scriptName);      Predicate<Node> inScript = n -> scriptName.equals(NodeUtil.getSourceName(n));     escapedVarNames.removeIf(var -> inScript.test(var.getScopeRoot()));     assignedVarNames.removeIf(var -> inScript.test(var.getScopeRoot()));     functionsWithNonEmptyReturns.removeIf(inScript);      new FirstOrderFunctionAnalyzer().process(null, scriptRoot);      // TODO(bashir): Variable declaration is not the only side effect of last     // global scope generation but here we only wipe that part off.      // Remove all variables that were previously declared in this scripts.     // First find all vars to remove then remove them because of iterator.     List<TypedVar> varsToRemove = new ArrayList<>();     for (TypedVar oldVar : globalScope.getVarIterable()) {       if (scriptName.equals(oldVar.getInputName())) {         varsToRemove.add(oldVar);       }     }     for (TypedVar var : varsToRemove) {       // By removing the type here, we're potentially invalidating any files that contain       // references to this type. Those files will need to be recompiled. Ideally, this       // was handled by the compiler (see b/29121507), but in the meantime users of incremental       // compilation will need to manage it themselves (e.g., by recompiling dependent files       // based on the dep graph).       String typeName = var.getName();       globalScope.undeclare(var);       globalScope.getTypeOfThis().toObjectType().removeProperty(typeName);       if (typeRegistry.getType(globalScope, typeName) != null) {         typeRegistry.removeType(globalScope, typeName);       }     }      // Now re-traverse the given script.     NormalScopeBuilder scopeBuilder = new NormalScopeBuilder(globalScope, null);     NodeTraversal.traverse(compiler, scriptRoot, scopeBuilder);   }
@Requires(""label != null"")   protected static boolean labelIsResolved(Label label) {     try {       label.getOffset();     } catch (IllegalStateException e) {       return false;     }     return true;   }
public SSLEngine buildServerSSLEngine(SSLContext sslContext) {         SSLEngine engine = sslContext.createSSLEngine();         engine.setUseClientMode(false);         if (needClientAuth) {             engine.setNeedClientAuth(true);         } else if (wantClientAuth) {             engine.setWantClientAuth(true);         }         return addCommonConfigs(engine);     }
public Resource addPath(String path)         throws IOException,MalformedURLException     {         if (path==null)             return null;          path = URI.canonicalPath(path);          return newResource(URI.addPaths(_url.toExternalForm(),path));     }
@RequestMapping(value = ""builds/{buildId}/links"", method = RequestMethod.GET)     public Form getBuildLinkForm(@PathVariable ID buildId) {         // Gets the form values         List<BuildLinkFormItem> items = structureService.getBuildLinksFrom(structureService.getBuild(buildId))                 .stream()                 .map(build -> new BuildLinkFormItem(build.getProject().getName(), build.getName()))                 .collect(Collectors.toList());         // Creates the form         return Form.create()                 .with(                         MultiForm.of(                                 ""links"",                                 Form.create()                                         .with(Text.of(""project"").label(""Project name""))                                         .with(Text.of(""build"").label(""Build name""))                         )                                 .label(""Links"")                                 .value(items)                 );     }
@Override      public void dispatchEvent(IEvent e) {          if (e instanceof ISharedObjectMessage || e.getType() == IEvent.Type.SHARED_OBJECT) {              ISharedObjectMessage msg = (ISharedObjectMessage) e;              if (msg.hasSource()) {                  beginUpdate(msg.getSource());              } else {                  beginUpdate();              }              try {                  for (ISharedObjectEvent event : msg.getEvents()) {                      final String key = event.getKey();                      switch (event.getType()) {                          case SERVER_CONNECT:                              if (!isConnectionAllowed()) {                                  so.returnError(SO_NO_READ_ACCESS);                              } else if (msg.hasSource()) {                                  IEventListener source = msg.getSource();                                  if (source instanceof BaseConnection) {                                      ((BaseConnection) source).registerBasicScope(this);                                  } else {                                      addEventListener(source);                                  }                              }                              break;                          case SERVER_DISCONNECT:                              if (msg.hasSource()) {                                  IEventListener source = msg.getSource();                                  if (source instanceof BaseConnection) {                                      ((BaseConnection) source).unregisterBasicScope(this);                                  } else {                                      removeEventListener(source);                                  }                              }                              break;                          case SERVER_SET_ATTRIBUTE:                              final Object value = event.getValue();                              if (!isWriteAllowed(key, value)) {                                  so.returnAttributeValue(key);                                  so.returnError(SO_NO_WRITE_ACCESS);                              } else {                                  setAttribute(key, value);                              }                              break;                          case SERVER_DELETE_ATTRIBUTE:                              if (!isDeleteAllowed(key)) {                                  so.returnAttributeValue(key);                                  so.returnError(SO_NO_WRITE_ACCESS);                              } else {                                  removeAttribute(key);                              }                              break;                          case SERVER_SEND_MESSAGE:                              final List<?> arguments = (List<?>) event.getValue();                              // Ignore request silently if not allowed                              if (isSendAllowed(key, arguments)) {                                  sendMessage(key, arguments);                              } else {                                  log.debug(""Send is not allowed for {}"", key);                              }                              break;                          default:                              log.warn(""Unknown SO event: {}"", event.getType());                      }                  }              } catch (Exception ex) {                  log.warn(""Exception on dispatchEvent"", ex);              } finally {                  endUpdate();              }          } else {              // don't know how to handle this event.              super.dispatchEvent(e);          }      }
private void readToTmp(int length, boolean expectEnd) throws IOException {     tmpBuffer.clear();     tmpBuffer.limit(length);     int read = read(tmpBuffer);     if (read == -1 && expectEnd) {       throw new NoSuchElementException();     }     if (read != length) {       throw new CorruptDataException(""Premature end of file was expecting at least: ""           + length + "" but found only: "" + read);     }     offset += read;     tmpBuffer.flip();   }
protected Set<CacheEntryTag> getTags(Element element) {         final Object key = element.getObjectKey();         if (key instanceof TaggedCacheEntry) {             return ((TaggedCacheEntry) key).getTags();         }          final Object value = element.getObjectValue();         if (value instanceof TaggedCacheEntry) {             return ((TaggedCacheEntry) value).getTags();         }          return null;     }
@Deprecated   public static final String formatProductSetName(       String project, String location, String productSet) {     return PRODUCT_SET_PATH_TEMPLATE.instantiate(         ""project"", project,         ""location"", location,         ""product_set"", productSet);   }
@Override     public Iterable<T> findAll() {         return inTransaction(new Callable<Iterable<T>>() {             @Override             public Iterable<T> call() throws Exception {                 CriteriaQuery<T> cq = entityManager.getCriteriaBuilder().createQuery(entity);                 Root<T> pet = cq.from(entity);                 cq.select(pet);                 return entityManager.createQuery(cq).getResultList();             }         });     }
private static String privateBase64Decoder(String decode, int flags) {    if (flags == -1) {     flags = Base64.DEFAULT;    }      byte[] data1 = Base64.decode(decode, flags);    String decodedBase64 = null;    try {     decodedBase64 = new String(data1, ""UTF-8"");    } catch (UnsupportedEncodingException e) {     e.printStackTrace();    }      return decodedBase64;   }
public void sendNotification(final Notification notification) {      ContextAwareTimer.Context timer = this.notificationTimer.time();     if(!this.notificationTargets.isEmpty()) {         for (final Map.Entry<UUID, Function<Notification, Void>> entry : this.notificationTargets.entrySet()) {           try {             entry.getValue().apply(notification);           } catch (RuntimeException exception) {             LOG.warn(""RuntimeException when running notification target. Skipping."", exception);           }         }     }      if(getParent().isPresent()) {       getParent().get().sendNotification(notification);     }     timer.stop();   }
@SuppressWarnings(""unchecked"")     public static void setProperty(Object object, String name, String text) throws NoSuchFieldException {         try {             // need to get to the field for any typeinfo annotation, so here we go ...             int length = name.lastIndexOf('.');             if (length > 0) {                 object = getProperty(object, name.substring(0, length));                 name = name.substring(length + 1);             }             length = name.length();              Matcher matcher = ARRAY_INDEX.matcher(name);             for (Matcher m = matcher; m.matches(); m = ARRAY_INDEX.matcher(name)) {                 name = m.group(1);             }             Field field = Beans.getKnownField(object.getClass(), name);              if (name.length() != length) {                 int index = Integer.parseInt(matcher.group(2));                 object = getProperty(object, matcher.group(1));                 if (object.getClass().isArray()) {                     Array.set(object, index, new ValueOf(object.getClass().getComponentType(), field.getAnnotation(typeinfo.class)).invoke(text));                 } else {                     ((List)object).set(index, new ValueOf(field.getAnnotation(typeinfo.class).value()[0]).invoke(text));                 }             } else {                 field.set(object, new ValueOf(field.getType(), field.getAnnotation(typeinfo.class)).invoke(text));             }         } catch (NoSuchFieldException x) {             throw x;         } catch (Exception x) {             throw new IllegalArgumentException(x.getMessage() + "": "" + name, x);         }     }
public void read(final Connection conn, final Readline readline) {         // Just call readline and get a callback when line is openBlocking         Prompt prompt = new Prompt(new TerminalString(""[aesh@rules]$ "",                         new TerminalColor(Color.GREEN, Color.DEFAULT, Color.Intensity.BRIGHT)));          //suspend reader asap since we're creating commands in a new thread         //this is not needed when running single threaded, eg as examples.Example        readline.readline(conn, prompt, line -> {             //we got eof or quit             if (line == null) {                 conn.close();                 return;             }              //LOGGER.info(""got: "" + line);              Matcher matcher = splitter.matcher(line);             if (matcher.find()) {                 String cmd = matcher.group();                  /*                 if(cmd.equals(""exit"")) {                     conn.write(""exiting...\n"").close();                     return;                 }                 */                  // Gather args                 List<String> args = new ArrayList<>();                 while (matcher.find()) {                     args.add(matcher.group());                 }                  try {                     new Task(conn, readline, Command.valueOf(cmd), args).start();                     return;                 } catch (IllegalArgumentException e) {                     conn.write(line + "": command not found\n"");                 }             }             read(conn, readline);         }, getCompletions());     }
public void populateArtifactDetails(final SoftwareModule softwareModule) {         if (softwareModule == null) {             populateArtifactDetails(null, null);         } else {             populateArtifactDetails(softwareModule.getId(),                     HawkbitCommonUtil.getFormattedNameVersion(softwareModule.getName(), softwareModule.getVersion()));         }     }
private boolean isTypedTimeFullyLegal() {         if (mIs24HourMode) {             // For 24-hour mode, the time is legal if the hours and minutes are each legal. Note:             // getEnteredTime() will ONLY call isTypedTimeFullyLegal() when NOT in 24hour mode.             Boolean[] enteredZeros = {false, false, false};             int[] values = getEnteredTime(enteredZeros);             return (values[0] >= 0 && values[1] >= 0 && values[1] < 60 && values[2] >= 0 && values[2] < 60);         } else {             // For AM/PM mode, the time is legal if it contains an AM or PM, as those can only be             // legally added at specific times based on the tree's algorithm.             return (mTypedTimes.contains(getAmOrPmKeyCode(AM)) ||                     mTypedTimes.contains(getAmOrPmKeyCode(PM)));         }     }
void writeEntry(int position, int offset, int value) throws ArrayIndexOutOfBoundsException   {     /*     try     {       fastArray[( position*slotsize)+offset] = value;     }     catch(ArrayIndexOutOfBoundsException aioobe)     */     {       if (offset >= slotsize)         throw new ArrayIndexOutOfBoundsException(XMLMessages.createXMLMessage(XMLErrorResources.ER_OFFSET_BIGGER_THAN_SLOT, null)); //""Offset bigger than slot"");       position*=slotsize;       int chunkpos = position >> lowbits;       int slotpos = position & lowmask;       int[] chunk = chunks.elementAt(chunkpos);       chunk[slotpos + offset] = value; // ATOMIC!     }   }
public static void divide( DMatrix2x2 a , double alpha ) {         a.a11 /= alpha; a.a12 /= alpha;         a.a21 /= alpha; a.a22 /= alpha;     }
@Override  public void dispose() {   super.dispose();   if (fields != null) {    Iterator<FieldEditor> e = fields.iterator();    while (e.hasNext()) {     FieldEditor pe = e.next();     pe.setPage(null);     pe.setPropertyChangeListener(null);     pe.setPreferenceStore(null);    }   }  }
public void setDoctype(String doctypeSystem, String doctypePublic)     {         setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctypeSystem);         setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctypePublic);     }
public void writeChar(int pChar) throws IOException {          out.write(pChar & 0xFF);          out.write((pChar >>> 8) & 0xFF);          bytesWritten += 2;      }
private KeyStoreFactoryBean keyStoreFromSystemProperties(String property) {     if (System.getProperty(property) == null) return null;     KeyStoreFactoryBean keyStore = new KeyStoreFactoryBean();     keyStore.setLocation(locationFromSystemProperty(property));     keyStore.setProvider(System.getProperty(property + ""Provider""));     keyStore.setPassword(System.getProperty(property + ""Password""));     keyStore.setType(System.getProperty(property + ""Type""));     return keyStore;   }
protected static int getBytesPerPixel(Bitmap.Config config) {         if (config == Bitmap.Config.ARGB_8888) {             return 4;         } else if (config == Bitmap.Config.RGB_565) {             return 2;         } else if (config == Bitmap.Config.ARGB_4444) {             return 2;         } else if (config == Bitmap.Config.ALPHA_8) {             return 1;         }         return 1;     }
@SuppressWarnings(   { ""unchecked"", ""rawtypes"" })   public static void makeCopies(Collection<Copier> aFrom, Collection<Copier> aTo)   {    if (aFrom == null || aTo == null)     return;      List<Copier> fromList = new ArrayList<Copier>(aFrom);    List<Copier> toList = new ArrayList<Copier>(aTo);    Collections.sort((List) fromList);    Collections.sort((List) toList);      Copier from = null;    Copier to = null;    Iterator<Copier> toIter = toList.iterator();    for (Iterator<Copier> i = fromList.iterator(); i.hasNext() && toIter.hasNext();)    {     from = (Copier) i.next();     to = (Copier) toIter.next();       // copy data     to.copy(from);    }   }
@Override     public void addPixels(int[] pixels, int offset, int count) {         for (int i = 0; i < count; i++) {             insertColor(pixels[i + offset]);             if (colors > reduceColors)                 reduceTree(reduceColors);         }     }
public static <C extends Comparable> boolean isLessThan(final Range<C> range, final C value) {         checkNotNull(range);         checkNotNull(value);          if (!range.hasUpperBound()) {             return false;         }         if (range.upperBoundType() == BoundType.OPEN && range.upperEndpoint().equals(value)) {             return true;         }         return range.upperEndpoint().compareTo(value) < 0;     }
List<MwDumpFile> mergeDumpLists(List<MwDumpFile> localDumps,    List<MwDumpFile> onlineDumps) {   List<MwDumpFile> result = new ArrayList<>(localDumps);    HashSet<String> localDateStamps = new HashSet<>();   for (MwDumpFile dumpFile : localDumps) {    localDateStamps.add(dumpFile.getDateStamp());   }   for (MwDumpFile dumpFile : onlineDumps) {    if (!localDateStamps.contains(dumpFile.getDateStamp())) {     result.add(dumpFile);    }   }   result.sort(Collections.reverseOrder(new MwDumpFile.DateComparator()));   return result;  }
public static String getJenkinsVersion(final HttpResponse response) {         final Header[] hdrs = response.getHeaders(""X-Jenkins"");         return hdrs.length == 0 ? """" : hdrs[0].getValue();     }
public void acquireLock(Object key, boolean exclusive) {       ReentrantReadWriteLock lock = getLock(key);       if (exclusive) {          lock.writeLock().lock();          if (trace) log.tracef(""WL acquired for '%s'"", key);       } else {          lock.readLock().lock();          if (trace) log.tracef(""RL acquired for '%s'"", key);       }    }
public String sign(String signatureBaseString) {     if (privateKey == null) {       throw new UnsupportedOperationException(""Cannot sign the base string: no private key supplied."");     }      try {       Signature signer = Signature.getInstance(""SHA1withRSA"");       signer.initSign(privateKey);       signer.update(signatureBaseString.getBytes(""UTF-8""));       byte[] signatureBytes = signer.sign();       signatureBytes = Base64.encodeBase64(signatureBytes);       return new String(signatureBytes, ""UTF-8"");     }     catch (NoSuchAlgorithmException e) {       throw new IllegalStateException(e);     }     catch (InvalidKeyException e) {       throw new IllegalStateException(e);     }     catch (SignatureException e) {       throw new IllegalStateException(e);     }     catch (UnsupportedEncodingException e) {       throw new RuntimeException(e);     }   }
public Swarm stop() throws Exception {          if (this.server == null) {             throw SwarmMessages.MESSAGES.containerNotStarted(""stop()"");         }          this.server.stop();         this.server = null;          Module module = Module.getBootModuleLoader().loadModule(CONTAINER_MODULE_NAME);         Class<?> shutdownClass = module.getClassLoader().loadClass(""org.wildfly.swarm.container.runtime.WeldShutdownImpl"");          WeldShutdown shutdown = (WeldShutdown) shutdownClass.newInstance();         shutdown.shutdown();          return this;     }
public static TaskManagerServicesConfiguration fromConfiguration(    Configuration configuration,    long maxJvmHeapMemory,    InetAddress remoteAddress,    boolean localCommunication) {   final String[] tmpDirs = ConfigurationUtils.parseTempDirectories(configuration);   String[] localStateRootDir = ConfigurationUtils.parseLocalStateDirectories(configuration);   if (localStateRootDir.length == 0) {    // default to temp dirs.    localStateRootDir = tmpDirs;   }    boolean localRecoveryMode = configuration.getBoolean(CheckpointingOptions.LOCAL_RECOVERY);    final NetworkEnvironmentConfiguration networkConfig = NetworkEnvironmentConfiguration.fromConfiguration(    configuration,    maxJvmHeapMemory,    localCommunication,    remoteAddress);    final QueryableStateConfiguration queryableStateConfig = QueryableStateConfiguration.fromConfiguration(configuration);    boolean preAllocateMemory = configuration.getBoolean(TaskManagerOptions.MANAGED_MEMORY_PRE_ALLOCATE);    long timerServiceShutdownTimeout = AkkaUtils.getTimeout(configuration).toMillis();    final RetryingRegistrationConfiguration retryingRegistrationConfiguration = RetryingRegistrationConfiguration.fromConfiguration(configuration);    return new TaskManagerServicesConfiguration(    remoteAddress,    tmpDirs,    localStateRootDir,    localRecoveryMode,    networkConfig,    queryableStateConfig,    ConfigurationParserUtils.getSlot(configuration),    ConfigurationParserUtils.getManagedMemorySize(configuration),    ConfigurationParserUtils.getMemoryType(configuration),    preAllocateMemory,    ConfigurationParserUtils.getManagedMemoryFraction(configuration),    timerServiceShutdownTimeout,    retryingRegistrationConfiguration,    ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration));  }
public static Furnace getInstance()    {       try       {          final BootstrapClassLoader loader = new BootstrapClassLoader(""bootpath"");          return getInstance(FurnaceFactory.class.getClassLoader(), loader);       }       catch (Exception e)       {          throw new RuntimeException(e);       }    }
@Override  public boolean includeUrl(String urlKey, String originalUrl) { //  return include(urlKey, originalUrl, true);   if (UrlOperations.urlToScheme(originalUrl) == null) {    originalUrl = UrlOperations.HTTP_SCHEME + originalUrl;   }    CaptureSearchResult resultTester = new FastCaptureSearchResult();   resultTester.setUrlKey(urlKey);   resultTester.setOriginalUrl(originalUrl);   // null captureTimestamp signifies per-URL access-check.   resultTester.setCaptureTimestamp(null);    return include(resultTester, true);  }
private static void trimPadding(List<Element> elements)     {         for (ListIterator<Element> it = elements.listIterator(elements.size()); it.hasPrevious();) {             Element element = it.previous();              if (element.compareTo(null) == 0) {                 it.remove();             } else {                 break;             }         }     }
@Override     public void accept( Visitor v ) {         v.visitTypedInstruction(this);         v.visitStackProducer(this);         v.visitStackConsumer(this);         v.visitConversionInstruction(this);     }
public static <T, CA extends Collection<T>, CR extends Collection<T>> Pair<CA, CR> partition(Iterable<T> values, Predicate<T> partitioner, Supplier<CA> acceptedCollectionProvider, Supplier<CR> refusedCollectionProvider) {         dbc.precondition(values != null, ""cannot partition a null iterable"");         return new PartitionBy<>(partitioner, acceptedCollectionProvider, refusedCollectionProvider).apply(values.iterator());     }
@Override   public void addTag(String tagName, double value)   {     addTag(tagName, String.valueOf(value));   }
private void onConnect(Connection con, String[] sqlCommands) throws SQLException {         final boolean trace = TraceComponent.isAnyTracingEnabled();          TransactionManager tm = connectorSvc.getTransactionManager();         Transaction suspendedTx = null;         String currentSQL = null;         Throwable failure = null;         try {             UOWCoordinator coord = tm == null ? null : ((UOWCurrent) tm).getUOWCoord();             if (coord != null && coord.isGlobal())                 suspendedTx = tm.suspend();              Statement stmt = con.createStatement();             for (String sql : sqlCommands) {                 currentSQL = sql;                 if (trace && tc.isDebugEnabled())                     Tr.debug(this, tc, ""execute onConnect SQL"", sql);                 stmt.execute(sql);             }             stmt.close();         } catch (Throwable x) {             failure = x;         }         if (suspendedTx != null) {             try {                 tm.resume(suspendedTx);             } catch (Throwable x) {                 failure = x;             }         }          if (failure != null) {             if (trace && tc.isDebugEnabled())                 Tr.debug(this, tc, ""failed"", AdapterUtil.stackTraceToString(failure));             throw new SQLNonTransientConnectionException(                 AdapterUtil.getNLSMessage(""DSRA4004.onconnect.sql"", currentSQL, dsConfig.get().id), ""08000"", 0, failure);         }     }
public static boolean isEqualSeq(final String first, final String second, final String delimiter) {     if (isNotEmpty(first) && isNotEmpty(second)) {       String[] firstWords = split(first, delimiter);       Set<String> firstSet = CollectUtils.newHashSet();       for (int i = 0; i < firstWords.length; i++) {         firstSet.add(firstWords[i]);       }       String[] secondWords = split(second, delimiter);       Set<String> secondSet = CollectUtils.newHashSet();       for (int i = 0; i < secondWords.length; i++) {         secondSet.add(secondWords[i]);       }       return firstSet.equals(secondSet);     } else {       return isEmpty(first) & isEmpty(second);     }   }
public boolean verify(String base64Signature, String content, String timestamp) throws Exception {         return verify(base64Signature, content, timestamp, keyName);     }
public Attribute getEntityAttribute(Class clazz, String fieldName)      {          if (entityTypes != null && entityTypes.containsKey(clazz))          {              EntityType entityType = entityTypes.get(clazz);              return entityType.getAttribute(fieldName);          }          throw new IllegalArgumentException(""No entity found: "" + clazz);      }
protected static void validateBool(String opName, SDVariable v) {         if (v == null)             return;         if (v.dataType() != DataType.BOOL)             throw new IllegalStateException(""Cannot apply operation \"""" + opName + ""\"" to variable \"""" + v.getVarName() + ""\"" with non-boolean point data type "" + v.dataType());     }
public void setRoundaboutAngle(@FloatRange(from = 60f, to = 300f) float roundaboutAngle) {     if (ROUNDABOUT_MANEUVER_TYPES.contains(maneuverType) && this.roundaboutAngle != roundaboutAngle) {       updateRoundaboutAngle(roundaboutAngle);       invalidate();     }   }
@Subscribe   public void onZones(ZoneList.SuccessEvent event) {     String durationEvent = getString(R.string.list_duration, event.duration);     Toast.makeText(this, durationEvent, LENGTH_SHORT).show();   }
static AjaxOperation registerContainer(final String triggerId, final String containerId,    final List<String> containerContentIds) {   AjaxOperation operation = new AjaxOperation(triggerId, containerContentIds);   operation.setTargetContainerId(containerId);   operation.setAction(AjaxOperation.AjaxAction.REPLACE_CONTENT);   registerAjaxOperation(operation);   return operation;  }
@SuppressWarnings(""fallthrough"")     protected DCReference reference(boolean allowMember) throws ParseException {         int pos = bp;         int depth = 0;          // scan to find the end of the signature, by looking for the first         // whitespace not enclosed in () or <>, or the end of the tag         loop:         while (bp < buflen) {             switch (ch) {                 case '\n': case '\r': case '\f':                     newline = true;                     // fallthrough                  case ' ': case '\t':                     if (depth == 0)                         break loop;                     break;                  case '(':                 case '<':                     newline = false;                     depth++;                     break;                  case ')':                 case '>':                     newline = false;                     --depth;                     break;                  case '}':                     if (bp == pos)                         return null;                     newline = false;                     break loop;                  case '@':                     if (newline)                         break loop;                     // fallthrough                  default:                     newline = false;              }             nextChar();         }          if (depth != 0)             throw new ParseException(""dc.unterminated.signature"");          String sig = newString(pos, bp);          // Break sig apart into qualifiedExpr member paramTypes.         JCTree qualExpr;         Name member;         List<JCTree> paramTypes;          Log.DeferredDiagnosticHandler deferredDiagnosticHandler                 = new Log.DeferredDiagnosticHandler(fac.log);          try {             int hash = sig.indexOf(""#"");             int lparen = sig.indexOf(""("", hash + 1);             if (hash == -1) {                 if (lparen == -1) {                     qualExpr = parseType(sig);                     member = null;                 } else {                     qualExpr = null;                     member = parseMember(sig.substring(0, lparen));                 }             } else {                 qualExpr = (hash == 0) ? null : parseType(sig.substring(0, hash));                 if (lparen == -1)                     member = parseMember(sig.substring(hash + 1));                 else                     member = parseMember(sig.substring(hash + 1, lparen));             }              if (lparen < 0) {                 paramTypes = null;             } else {                 int rparen = sig.indexOf("")"", lparen);                 if (rparen != sig.length() - 1)                     throw new ParseException(""dc.ref.bad.parens"");                 paramTypes = parseParams(sig.substring(lparen + 1, rparen));             }              if (!deferredDiagnosticHandler.getDiagnostics().isEmpty())                 throw new ParseException(""dc.ref.syntax.error"");          } finally {             fac.log.popDiagnosticHandler(deferredDiagnosticHandler);         }          return m.at(pos).newReferenceTree(sig, qualExpr, member, paramTypes).setEndPos(bp);     }
@Override  public Properties getProperties(final String key) {   String[] keyValuePairs = getStringArray(key);    Properties props = new Properties();    for (String pair : keyValuePairs) {    int index = pair.indexOf('=');     if (index < 1) {     throw new IllegalArgumentException(""Malformed property: "" + pair);    }     props.put(pair.substring(0, index), pair.substring(index + 1, pair.length()));   }    return props;  }
public XObject operate(XObject right) throws javax.xml.transform.TransformerException   {      if (XObject.CLASS_BOOLEAN == right.getType())       return right;     else       return right.bool() ? XBoolean.S_TRUE : XBoolean.S_FALSE;   }
public String getRelativePathToBenchmarkReportDirectory(File file) {         String benchmarkReportDirectoryPath = plannerBenchmarkResult.getBenchmarkReportDirectory().getAbsoluteFile().toURI().getPath();         String filePath = file.getAbsoluteFile().toURI().getPath();         if (!filePath.startsWith(benchmarkReportDirectoryPath)) {             throw new IllegalArgumentException(""The filePath ("" + filePath                     + "") does not start with the benchmarkReportDirectoryPath ("" + benchmarkReportDirectoryPath + "")."");         }         String relativePath = filePath.substring(benchmarkReportDirectoryPath.length());         if (relativePath.startsWith(""/"")) {             relativePath = relativePath.substring(1);         }         return relativePath;     }
public void destroy() {         try {             ctx.close();         }         catch (javax.naming.NamingException e) {             LOG.warn(""Error when closing"", e);         }     }
public static IccProfileCreator getIccProfile(int identifier) {     IccProfileCreator icc = null;     try {       if (instance == null)         getIccProfileCreators();       if (creatorsMap.containsKey(identifier))         icc = creatorsMap.get(identifier);     } catch (ReadIccConfigIOException e) {      }     return icc;   }
private Set<org.eclipse.aether.graph.DependencyNode> levelTraverseVerboseTreeList(         Set<org.eclipse.aether.graph.DependencyNode>  nodeList,          List <org.eclipse.aether.graph.DependencyNode> aggDepNodeList,         org.eclipse.aether.graph.DependencyNode rootNode) throws MojoExecutionException   {     // First remove duplicates in nodeList     aggDepNodeList.removeAll(nodeList);      aggDepNodeList.addAll(nodeList);          Set<org.eclipse.aether.graph.DependencyNode> NodeChildList =          new LinkedHashSet<org.eclipse.aether.graph.DependencyNode>();          for (org.eclipse.aether.graph.DependencyNode node : nodeList) {       if (nodeArtifactsMatch(rootNode, node)){         throw new MojoExecutionException(""Circular dependency detected in project: "" + getMavenProject().toString());       }       if ( (node != null) && (node.getChildren() != null) ) {         NodeChildList.addAll(node.getChildren());       }     }      return NodeChildList;   }
public static ResourceSnippet createResourceSnippet(InputStream is, int startChar, int endChar, String charset) {   return createResourceSnippet(getContents(is, charset), startChar, endChar);     }
static String unescape(final String text, final XmlEscapeSymbols symbols) {          if (text == null) {             return null;         }          StringBuilder strBuilder = null;          final int offset = 0;         final int max = text.length();          int readOffset = offset;         int referenceOffset = offset;          for (int i = offset; i < max; i++) {              final char c = text.charAt(i);              /*              * Check the need for an unescape operation at this point              */              if (c != REFERENCE_PREFIX || (i + 1) >= max) {                 continue;             }              int codepoint = 0;              if (c == REFERENCE_PREFIX) {                  final char c1 = text.charAt(i + 1);                  if (c1 == '\u0020' || // SPACE                         c1 == '\n' ||     // LF                         c1 == '\u0009' || // TAB                         c1 == '\u000C' || // FF                         c1 == '\u003C' || // LES-THAN SIGN                         c1 == '\u0026') { // AMPERSAND                     // Not a character references. No characters are consumed, and nothing is returned.                     continue;                  } else if (c1 == REFERENCE_NUMERIC_PREFIX2) {                      if (i + 2 >= max) {                         // No reference possible                         continue;                     }                      final char c2 = text.charAt(i + 2);                      if (c2 == REFERENCE_HEXA_PREFIX3 && (i + 3) < max) {                         // This is a hexadecimal reference                          int f = i + 3;                         while (f < max) {                             final char cf = text.charAt(f);                             if (!((cf >= '0' && cf <= '9') || (cf >= 'A' && cf <= 'F') || (cf >= 'a' && cf <= 'f'))) {                                 break;                             }                             f++;                         }                          if ((f - (i + 3)) <= 0) {                             // We weren't able to consume any hexa chars                             continue;                         }                          if ((f >= max) || text.charAt(f) != REFERENCE_SUFFIX) {                             continue;                         }                          f++; // Count the REFERENCE_SUFFIX (semi-colon)                          codepoint = parseIntFromReference(text, i + 3, f - 1, 16);                         referenceOffset = f - 1;                          // Don't continue here, just let the unescape code below do its job                      } else if (c2 >= '0' && c2 <= '9') {                         // This is a decimal reference                          int f = i + 2;                         while (f < max) {                             final char cf = text.charAt(f);                             if (!(cf >= '0' && cf <= '9')) {                                 break;                             }                             f++;                         }                          if ((f - (i + 2)) <= 0) {                             // We weren't able to consume any decimal chars                             continue;                         }                          if ((f >= max) || text.charAt(f) != REFERENCE_SUFFIX) {                             continue;                         }                          f++; // Count the REFERENCE_SUFFIX (semi-colon)                          codepoint = parseIntFromReference(text, i + 2, f - 1, 10);                         referenceOffset = f - 1;                          // Don't continue here, just let the unescape code below do its job                      } else {                         // This is not a valid reference, just discard                         continue;                     }                   } else {                      // This is a named reference, must be comprised only of ALPHABETIC chars                      int f = i + 1;                     while (f < max) {                         final char cf = text.charAt(f);                         if (!((cf >= 'a' && cf <= 'z') || (cf >= 'A' && cf <= 'Z') || (cf >= '0' && cf <= '9'))) {                             break;                         }                         f++;                     }                      if ((f - (i + 1)) <= 0) {                         // We weren't able to consume any alphanumeric                         continue;                     }                      if ((f < max) && text.charAt(f) == REFERENCE_SUFFIX) {                         f++;                     }                      final int ncrPosition = XmlEscapeSymbols.binarySearch(symbols.SORTED_CERS, text, i, f);                     if (ncrPosition >= 0) {                         codepoint = symbols.SORTED_CODEPOINTS_BY_CER[ncrPosition];                     } else {                         // Not found! Just ignore our efforts to find a match.                         continue;                     }                      referenceOffset = f - 1;                  }              }               /*              * At this point we know for sure we will need some kind of unescape, so we              * can increase the offset and initialize the string builder if needed, along with              * copying to it all the contents pending up to this point.              */              if (strBuilder == null) {                 strBuilder = new StringBuilder(max + 5);             }              if (i - readOffset > 0) {                 strBuilder.append(text, readOffset, i);             }              i = referenceOffset;             readOffset = i + 1;              /*              * --------------------------              *              * Perform the real unescape              *              * --------------------------              */              if (codepoint > '\uFFFF') {                 strBuilder.append(Character.toChars(codepoint));             } else {                 strBuilder.append((char)codepoint);             }          }           /*          * -----------------------------------------------------------------------------------------------          * Final cleaning: return the original String object if no unescape was actually needed. Otherwise          *                 append the remaining escaped text to the string builder and return.          * -----------------------------------------------------------------------------------------------          */          if (strBuilder == null) {             return text;         }          if (max - readOffset > 0) {             strBuilder.append(text, readOffset, max);         }          return strBuilder.toString();      }
public static String encode(byte[] bytes) {  String retorno = """";  if (bytes == null || bytes.length == 0) {      return retorno;  }  for (int i = 0; i < bytes.length; i++) {      byte valor = bytes[i];      int d1 = valor & 0xF;      d1 += (d1 < 10) ? 48 : 55;      int d2 = (valor & 0xF0) >> 4;      d2 += (d2 < 10) ? 48 : 55;      retorno = retorno + (char) d2 + (char) d1;  }  return retorno;     }
PorterDuffColorFilter updateTintFilter(PorterDuffColorFilter tintFilter, ColorStateList tint,                                            PorterDuff.Mode tintMode) {         if (tint == null || tintMode == null) {             return null;         }          final int color = tint.getColorForState(getState(), Color.TRANSPARENT);         if (tintFilter == null) {             return new PorterDuffColorFilter(color, tintMode);         }          //tintFilter.setColor(color);         //tintFilter.setMode(tintMode);         try {             //noinspection unchecked             Class<PorterDuffColorFilter> tClass = (Class<PorterDuffColorFilter>) tintFilter.getClass();             Method method = tClass.getMethod(""setColor"", Integer.class);             method.invoke(tintFilter, color);              method = tClass.getMethod(""setMode"", PorterDuff.Mode.class);             method.invoke(tintFilter, tintMode);             return tintFilter;         } catch (Exception e) {             return new PorterDuffColorFilter(color, tintMode);         }     }
public static ParameterizedN1qlQuery parameterized(Statement statement, JsonArray positionalParams) {         return new ParameterizedN1qlQuery(statement, positionalParams, null);     }
public synchronized SlabAllocation attachAndAllocate(SlabRef slab, PeekingIterator<Integer> eventSizes) {         attach(slab);         return allocate(eventSizes);     }
public void addPages(DialogPage[] pages) {   for (int i = 0; i < pages.length; i++) {    addPage(pages[i]);   }  }
public static HSQLInterface loadHsqldb(ParameterStateManager psMgr) {         // Specifically set the timezone to UTC to avoid the default usage local timezone in HSQL.         // This ensures that all VoltDB data paths use the same timezone for representing time.         TimeZone.setDefault(TimeZone.getTimeZone(""GMT+0""));          String name = ""hsqldbinstance-"" + String.valueOf(instanceId) + ""-"" + String.valueOf(System.currentTimeMillis());         instanceId++;          HsqlProperties props = new HsqlProperties();         try {             Session sessionProxy = DatabaseManager.newSession(DatabaseURL.S_MEM, name, ""SA"", """", props, 0);             // make HSQL case insensitive             sessionProxy.executeDirectStatement(""SET IGNORECASE TRUE;"");             sessionProxy.setParameterStateManager(psMgr);             return new HSQLInterface(sessionProxy);         }         catch (HsqlException caught) {             m_logger.warn(""Unexpected error initializing the SQL parser"",                     caught);             caught.printStackTrace();             throw caught;         }     }
public void complete()     {         completeTree();          StageManager.getStage(Stage.ANTI_ENTROPY).execute(this);          if (logger.isDebugEnabled())         {             // log distribution of rows in tree             logger.debug(""Validated {} partitions for {}.  Partitions per leaf are:"", validated, desc.sessionId);             tree.histogramOfRowCountPerLeaf().log(logger);             logger.debug(""Validated {} partitions for {}.  Partition sizes are:"", validated, desc.sessionId);             tree.histogramOfRowSizePerLeaf().log(logger);         }     }
public int compare(T o1, T o2) {  if(o1 == o2)   return 0;  String str1 = (o1 == null) ? ""null"" : o1.toString();   String str2 = (o2 == null) ? ""null"" : o2.toString();  return str1.compareTo(str2);     }
public String build()     {         this.message_string  = ""{"";              if( this.recipient_id != null ){                 this.message_string += ""\""recipient\"": {\""id\"": \"""" + this.recipient_id + ""\""},"";             }              if( (this.message_text != null) && !(this.message_text.equals("""")) && !(this.buttons.isEmpty()) ){                 this.message_string += ""\""message\"": {"";                     this.message_string += ""\""attachment\"": {"";                         this.message_string += ""\""type\"": \""template\"","";                         this.message_string += ""\""payload\"": {"";                             this.message_string += ""\""template_type\"": \""button\"","";                             this.message_string += ""\""text\"": \"""" + this.message_text + ""\"","";                             this.message_string += ""\""buttons\"":["";                                 for ( int j = 0 ; j < this.buttons.size(); j++ ) {                                     HashMap<String, String> button = this.buttons.get(j);                                     this.message_string += ""{"";                                     if( !button.get(""type"").equals("""") ){                                         this.message_string += ""\""type\"":\"""" + button.get(""type"") + ""\"","";                                     }                                     if( !button.get(""title"").equals("""") ){                                         this.message_string += ""\""title\"":\"""" + button.get(""title"") + ""\"","";                                     }                                     if( !button.get(""url"").equals("""") ){                                         this.message_string += ""\""url\"":\"""" + button.get(""url"") + ""\"","";                                     }                                     if( !button.get(""payload"").equals("""") ){                                         this.message_string += ""\""payload\"":\"""" + button.get(""payload"") + ""\"","";                                     }                                     this.message_string = this.message_string.replaceAll("",$"", """");                                     this.message_string += ""},"";                                 }                                 this.message_string = this.message_string.replaceAll("",$"", """");                             this.message_string += ""]"";                         this.message_string += ""}"";                     this.message_string += ""}"";                 this.message_string += ""}"";             }              this.message_string = this.message_string.replaceAll("",$"", """");          this.message_string += ""}"";          return this.message_string;     }
@NotNull     public DoubleStream filter(@NotNull final DoublePredicate predicate) {         return new DoubleStream(params, new DoubleFilter(iterator, predicate));     }
public A_CmsTab getTab(GalleryTabId tabId) {          for (A_CmsTab tab : m_tabbedPanel) {             if (tabId == GalleryTabId.valueOf(tab.getTabId())) {                 return tab;             }         }         return null;     }
private boolean skipInterface(NetworkInterface ni) throws SocketException {         boolean skipInterface = !ni.isUp() || ni.isVirtual() || ni.isLoopback();         if (skipInterface && logger.isFineEnabled()) {             logger.fine(""Skipping NetworkInterface '"" + ni.getName() + ""': isUp="" + ni.isUp() + "", isVirtual="" + ni.isVirtual()                     + "", isLoopback="" + ni.isLoopback());         }         return skipInterface;     }
public void addSchemaSource(Source s) {         sources.add(s);         validator.setSchemaSources(sources.toArray(new Source[0]));     }
public static ComposedValueConverter getInstance() {      if (instance == null) {       synchronized (DefaultComposedValueConverter.class) {         if (instance == null) {           DefaultComposedValueConverter impl = new DefaultComposedValueConverter();           impl.initialize();           instance = impl;         }       }     }     return instance;   }
public static boolean getOptionalBooleanParameter(Map<String, String> parameters,                                                       String parameterName,                                                       boolean defaultValue)             throws JournalException {         validateParameters(parameters);         validateParameterName(parameterName);          String string = parameters.get(parameterName);         if (string == null) {             return defaultValue;         } else if (string.equals(VALUE_FALSE)) {             return false;         } else if (string.equals(VALUE_TRUE)) {             return true;         } else {             throw new JournalException(""'"" + parameterName                     + ""' parameter must be '"" + VALUE_FALSE + ""'(default) or '""                     + VALUE_TRUE + ""'"");         }      }
public void setContentHandler(ContentHandler handler)   {      if (handler == null)     {       throw new NullPointerException(XSLMessages.createMessage(XSLTErrorResources.ER_NULL_CONTENT_HANDLER, null)); //""Null content handler"");     }     else     {       m_outputContentHandler = handler;        if (null == m_serializationHandler)       {         ToXMLSAXHandler h = new ToXMLSAXHandler();         h.setContentHandler(handler);         h.setTransformer(this);                  m_serializationHandler = h;       }       else         m_serializationHandler.setContentHandler(handler);     }   }
@Override   public void doUpdates(MetricsContext unused) {     synchronized (this) {       for (MetricsBase m : registry.getMetricsList()) {         m.pushMetric(metricsRecord);       }     }     metricsRecord.update();   }
private Object asList(Object value) {         Class<?> componentClass = value.getClass().getComponentType();         if (componentClass.isPrimitive()) {             if (componentClass.equals(int.class)) {                 return asIntList(value);             } else if (componentClass.equals(long.class)) {                 return asLongList(value);             } else if (componentClass.equals(boolean.class)) {                 return asBooleanList(value);             } else if (componentClass.equals(short.class)) {                 return asShortList(value);             } else if (componentClass.equals(byte.class)) {                 return asByteList(value);             } else {                 return asCharList(value);             }         } else {             return asList(value, componentClass);         }     }
private void loadInsn(final Type type, final int index) {         mv.visitVarInsn(type.getOpcode(Opcodes.ILOAD), index);     }
public static CreateRequest create() throws IOException {         String uri = uri(""coupon_sets"");         return new CreateRequest(Method.POST, uri);     }
public void updated(Dictionary<String, ?> config) throws ConfigurationException {         if (config != null) {             Integer filterPriority = (Integer) config.get(FILTER_PRIORITY);             String applicationName = (String) config.get(APPLICATION_NAME);             setPriority(filterPriority);             setApplicationName(applicationName);         }         synchronized (this) {             filterFactoryServiceRegistration.setProperties(config);         }     }
public final void setApplicationName(String applicationName) {         synchronized (lock) {             if (applicationName == null) {                 serviceProperties.remove(APPLICATION_NAME);                 bundleAnalysingComponentInstantiationListener = null;             } else {                 serviceProperties.put(APPLICATION_NAME, applicationName);                 bundleAnalysingComponentInstantiationListener =                     new BundleAnalysingComponentInstantiationListener(bundleContext, injectionSource, factoryTracker);             }              if (serviceRegistration != null) {                 serviceRegistration.setProperties(serviceProperties);             }         }     }
private static URI normalizePortNumbersInUri(final URI uri) throws URISyntaxException {         int port = uri.getPort();         final String scheme = uri.getScheme();          if (SCHEME_HTTP.equals(scheme) && port == DEFAULT_HTTP_PORT) {             port = -1;         }         if (SCHEME_HTTPS.equals(scheme) && port == DEFAULT_HTTPS_PORT) {             port = -1;         }                  final URI result = new URI(scheme, uri.getUserInfo(), uri.getHost(), port, uri.getPath(), uri.getQuery(), uri.getFragment());         return result;     }
@Deprecated     protected String validateValue(String name, String value) {         return validateAttributeValue(name, value);     }
public Integer delete(CMAAsset asset) {     final String assetId = getResourceIdOrThrow(asset, ""asset"");     final String spaceId = getSpaceIdOrThrow(asset, ""asset"");     final String environmentId = asset.getEnvironmentId();      return service.delete(spaceId, environmentId, assetId).blockingFirst().code();   }
public static <T> T getTagValue(Tag<?> t, Class<? extends T> clazz) {         Object o = toTagValue(t);         if (o == null) {             return null;         }         try {             return clazz.cast(o);         } catch (ClassCastException e) {             return null;         }     }
@Override  public void eUnset(int featureID)  {   switch (featureID)   {    case XbasePackage.XIF_EXPRESSION__IF:     setIf((XExpression)null);     return;    case XbasePackage.XIF_EXPRESSION__THEN:     setThen((XExpression)null);     return;    case XbasePackage.XIF_EXPRESSION__ELSE:     setElse((XExpression)null);     return;    case XbasePackage.XIF_EXPRESSION__CONDITIONAL_EXPRESSION:     setConditionalExpression(CONDITIONAL_EXPRESSION_EDEFAULT);     return;   }   super.eUnset(featureID);  }
public JSONObject saveObject(JSONObject object, String objectID, @Nullable RequestOptions requestOptions) throws AlgoliaException {         try {             return client.putRequest(""/1/indexes/"" + encodedIndexName + ""/"" + URLEncoder.encode(objectID, ""UTF-8""), /* urlParameters: */ null, object.toString(), requestOptions);         } catch (UnsupportedEncodingException e) {             throw new RuntimeException(e);         }     }
public void addField(String fieldName, SortDirection sortDirection) {         if (sortFields == null) sortFields = new HashMap<>();          sortFields.put(fieldName, sortDirection);     }
@SuppressWarnings(""unchecked"")     static <T> Node<T> emptyNode(StreamShape shape) {         switch (shape) {             case REFERENCE:    return (Node<T>) EMPTY_NODE;             case INT_VALUE:    return (Node<T>) EMPTY_INT_NODE;             case LONG_VALUE:   return (Node<T>) EMPTY_LONG_NODE;             case DOUBLE_VALUE: return (Node<T>) EMPTY_DOUBLE_NODE;             default:                 throw new IllegalStateException(""Unknown shape "" + shape);         }     }
public static URL getResourceUrl(FacesContext ctx, String path) throws MalformedURLException     {         final ExternalContext externalContext = ctx.getExternalContext();         URL url = externalContext.getResource(path);         if (log.isLoggable(Level.FINE))         {             log.fine(""Resource-Url from external context: "" + url);         }         if (url == null)         {             // This might happen on Servlet container which doesnot return             // anything             // for getResource() (like weblogic 8.1 for packaged wars) we             // are trying             // to use an own URL protocol in order to use             // ServletContext.getResourceAsStream()             // when opening the url             if (resourceExist(externalContext, path))             {                 url = getUrlForResourceAsStream(externalContext, path);             }         }         return url;     }
public static IAtomContainer removeNonChiralHydrogens(IAtomContainer org) {          Map<IAtom, IAtom> map = new HashMap<IAtom, IAtom>(); // maps original atoms to clones.         List<IAtom> remove = new ArrayList<IAtom>(); // lists removed Hs.          // Clone atoms except those to be removed.         IAtomContainer cpy = org.getBuilder().newInstance(IAtomContainer.class);         int count = org.getAtomCount();          for (int i = 0; i < count; i++) {              // Clone/remove this atom?             IAtom atom = org.getAtom(i);             boolean addToRemove = false;             if (suppressibleHydrogen(org, atom)) {                 // test whether connected to a single hetero atom only, otherwise keep                 if (org.getConnectedAtomsList(atom).size() == 1) {                     IAtom neighbour = org.getConnectedAtomsList(atom).get(0);                     // keep if the neighbouring hetero atom has stereo information, otherwise continue checking                     Integer stereoParity = neighbour.getStereoParity();                     if (stereoParity == null || stereoParity == 0) {                         addToRemove = true;                         // keep if any of the bonds of the hetero atom have stereo information                         for (IBond bond : org.getConnectedBondsList(neighbour)) {                             IBond.Stereo bondStereo = bond.getStereo();                             if (bondStereo != null && bondStereo != IBond.Stereo.NONE) addToRemove = false;                             IAtom neighboursNeighbour = bond.getOther(neighbour);                             // remove in any case if the hetero atom is connected to more than one hydrogen                             if (neighboursNeighbour.getSymbol().equals(""H"") && !neighboursNeighbour.equals(atom)) {                                 addToRemove = true;                                 break;                             }                         }                     }                 }             }              if (addToRemove)                 remove.add(atom);             else                 addClone(atom, cpy, map);         }          // rescue any false positives, i.e., hydrogens that are stereo-relevant         // the use of IStereoElement is not fully integrated yet to describe stereo information         for (IStereoElement stereoElement : org.stereoElements()) {             if (stereoElement instanceof ITetrahedralChirality) {                 ITetrahedralChirality tetChirality = (ITetrahedralChirality) stereoElement;                 for (IAtom atom : tetChirality.getLigands()) {                     if (atom.getSymbol().equals(""H"") && remove.contains(atom)) {                         remove.remove(atom);                         addClone(atom, cpy, map);                     }                 }             } else if (stereoElement instanceof IDoubleBondStereochemistry) {                 IDoubleBondStereochemistry dbs = (IDoubleBondStereochemistry) stereoElement;                 IBond stereoBond = dbs.getStereoBond();                 for (IAtom neighbor : org.getConnectedAtomsList(stereoBond.getBegin())) {                     if (remove.remove(neighbor)) addClone(neighbor, cpy, map);                 }                 for (IAtom neighbor : org.getConnectedAtomsList(stereoBond.getEnd())) {                     if (remove.remove(neighbor)) addClone(neighbor, cpy, map);                 }             }         }          // Clone bonds except those involving removed atoms.         count = org.getBondCount();         for (int i = 0; i < count; i++) {             // Check bond.             final IBond bond = org.getBond(i);             boolean removedBond = false;             final int length = bond.getAtomCount();             for (int k = 0; k < length; k++) {                 if (remove.contains(bond.getAtom(k))) {                     removedBond = true;                     break;                 }             }              // Clone/remove this bond?             if (!removedBond) {                 IBond clone = null;                 try {                     clone = (IBond) org.getBond(i).clone();                 } catch (CloneNotSupportedException e) {                     e.printStackTrace();                 }                 assert clone != null;                 clone.setAtoms(new IAtom[]{map.get(bond.getBegin()), map.get(bond.getEnd())});                 cpy.addBond(clone);             }         }          // Recompute hydrogen counts of neighbours of removed Hydrogens.         for (IAtom aRemove : remove) {             // Process neighbours.             for (IAtom iAtom : org.getConnectedAtomsList(aRemove)) {                 final IAtom neighb = map.get(iAtom);                 if (neighb == null) continue; // since for the case of H2, neight H has a heavy atom neighbor                 neighb.setImplicitHydrogenCount((neighb.getImplicitHydrogenCount() == null ? 0 : neighb                         .getImplicitHydrogenCount()) + 1);             }         }         for (IAtom atom : cpy.atoms()) {             if (atom.getImplicitHydrogenCount() == null) atom.setImplicitHydrogenCount(0);         }         cpy.addProperties(org.getProperties());         cpy.setFlags(org.getFlags());          return (cpy);     }
private synchronized void initResourceType(         I_CmsResourceType resourceType,         CmsResourceManagerConfiguration configuration) {          // add the loader to the internal list of loaders         configuration.addResourceType(resourceType);         if (CmsLog.INIT.isInfoEnabled()) {             CmsLog.INIT.info(                 Messages.get().getBundle().key(                     Messages.INIT_ADD_RESTYPE_3,                     resourceType.getTypeName(),                     new Integer(resourceType.getTypeId()),                     resourceType.getClass().getName()));         }          // add the mappings         List<String> mappings = resourceType.getConfiguredMappings();         Iterator<String> i = mappings.iterator();         while (i.hasNext()) {             String mapping = i.next();             // only add this mapping if a mapping with this file extension does not             // exist already             if (!configuration.m_extensionMappings.containsKey(mapping)) {                 configuration.m_extensionMappings.put(mapping, resourceType.getTypeName());                 if (CmsLog.INIT.isInfoEnabled()) {                     CmsLog.INIT.info(                         Messages.get().getBundle().key(                             Messages.INIT_MAP_RESTYPE_2,                             mapping,                             resourceType.getTypeName()));                 }             }         }     }
@Override     public GetRelationalDatabaseSnapshotResult getRelationalDatabaseSnapshot(GetRelationalDatabaseSnapshotRequest request) {         request = beforeClientExecution(request);         return executeGetRelationalDatabaseSnapshot(request);     }
@Override     public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {         int len = 0;          if ((callbacks == null) || ((len = callbacks.length) == 0)) {             return;         }          if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {             StringBuffer sb = new StringBuffer();             sb.append(""{ "");             for (int i = 0; i < len; i++) {                 sb.append(callbacks[i].getClass().getName());                 if (i < (len - 1)) {                     sb.append("", "");                 }             }             sb.append("" }"");             Tr.debug(tc, ""handle(callbacks = \"""" + sb.toString() + ""\"")"");         }          for (int i = 0; i < len; i++) {             Callback c = callbacks[i];              if (c instanceof javax.security.auth.callback.NameCallback) {                 ((javax.security.auth.callback.NameCallback) c).setName(userName);             } else if (c instanceof javax.security.auth.callback.PasswordCallback) {                 ((javax.security.auth.callback.PasswordCallback) c).setPassword((password == null) ? null : password.toCharArray());             } else if (c instanceof WSCredTokenCallbackImpl) {                 ((WSCredTokenCallbackImpl) c).setCredToken(credToken);             } else if (c instanceof WSRealmNameCallbackImpl) {                 ((WSRealmNameCallbackImpl) c).setRealmName(realm);             } else if (c instanceof WSAppContextCallback) {                 ((WSAppContextCallback) c).setContext(appContext);             } else {                 if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                     Tr.debug(tc, ""Un-use handle(callbacks = \"""" + callbacks[i].getClass().getName() + ""\"")"");                 }             }         }     }
public void callService(String url, String templateName, Object model, XmlHttpResponse result, Map<String, Object> headers) {         doHttpPost(url, templateName, model, result, headers, XmlHttpResponse.CONTENT_TYPE_XML_TEXT_UTF8);         setContext(result);     }
public void encode(AsnOutputStream aos) throws EncodeException {          if (invokeId == null)             throw new EncodeException(""No Invoke ID set."");          try {             aos.writeTag(Tag.CLASS_CONTEXT_SPECIFIC, false, _TAG);             int pos = aos.StartContentDefiniteLength();              aos.writeInteger(this.invokeId);              if (this.operationCode != null && this.parameter != null) {                 aos.writeTag(Tag.CLASS_UNIVERSAL, false, Tag.SEQUENCE);                 int pos2 = aos.StartContentDefiniteLength();                 this.operationCode.encode(aos);                 this.parameter.encode(aos);                 aos.FinalizeContent(pos2);             }              aos.FinalizeContent(pos);          } catch (IOException e) {             throw new EncodeException(""IOException while encoding ReturnResult: "" + e.getMessage(), e);         } catch (AsnException e) {             throw new EncodeException(""AsnException while encoding ReturnResult: "" + e.getMessage(), e);         }     }
protected Map<FaxActionType,String> initializeFaxActionType2ResourceMap()     {         //get resources         Map<FaxActionType,String> map=new HashMap<FaxActionType,String>();         FaxActionType[] faxActionTypes=new FaxActionType[]{FaxActionType.SUBMIT_FAX_JOB,                                                            FaxActionType.SUSPEND_FAX_JOB,                                                            FaxActionType.RESUME_FAX_JOB,                                                            FaxActionType.CANCEL_FAX_JOB,                                                            FaxActionType.GET_FAX_JOB_STATUS};         Enum<?>[] keys=new Enum<?>[]{FaxClientSpiConfigurationConstants.SUBMIT_HTTP_RESOURCE_PROPERTY_KEY,                                      FaxClientSpiConfigurationConstants.SUSPEND_HTTP_RESOURCE_PROPERTY_KEY,                                      FaxClientSpiConfigurationConstants.RESUME_HTTP_RESOURCE_PROPERTY_KEY,                                      FaxClientSpiConfigurationConstants.CANCEL_HTTP_RESOURCE_PROPERTY_KEY,                                      FaxClientSpiConfigurationConstants.GET_STATUS_HTTP_RESOURCE_PROPERTY_KEY};         String resource=null;         for(int index=0;index<faxActionTypes.length;index++)         {             //get next resource             resource=this.getConfigurationValue(keys[index]);             if(resource!=null)             {                 map.put(faxActionTypes[index],resource);             }         }                  return map;     }
public synchronized void seek(long position) throws IOException {     if (position < 0 || position >= count) {       throw new IOException(""cannot seek position "" + position + "" as it is out of bounds"");     }     pos = (int) position;   }
@Override   public EClass getIfcInventory() {    if (ifcInventoryEClass == null) {     ifcInventoryEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI).getEClassifiers()       .get(327);    }    return ifcInventoryEClass;   }
public static <P> DirectMetaProperty<P> ofReadOnlyBuildable(              MetaBean metaBean, String propertyName, Class<?> declaringType, Class<P> propertyType) {          Field field = findField(metaBean, propertyName);          return new DirectMetaProperty<>(metaBean, propertyName, declaringType, propertyType, PropertyStyle.READ_ONLY_BUILDABLE, field);      }
public static <D extends Comparable> DateTimeExpression<D> addMinutes(DateTimeExpression<D> date, int minutes) {         return Expressions.dateTimeOperation(date.getType(), Ops.DateTimeOps.ADD_MINUTES, date, ConstantImpl.create(minutes));     }
public Result json() {         setContentType(MimeTypes.JSON);         charset = Charsets.UTF_8;         // If we already have a String content, we must set the type.         // The renderable object checks whether or not the given String is a valid JSON string,         // or if a transformation is required.         if (getRenderable() instanceof RenderableString) {             ((RenderableString) getRenderable()).setType(MimeTypes.JSON);         }         return this;     }
Node<E> back() {             Node<E> f = predecessor();             return (f == null || f.isSpecial()) ? null : f;         }
public Term term(DecoratedKey partitionKey) {         String serializedKey = ByteBufferUtils.toString(partitionKey.getKey());         return new Term(FIELD_NAME, serializedKey);     }
public static base_responses delete(nitro_service client, String ciphergroupname[]) throws Exception {   base_responses result = null;   if (ciphergroupname != null && ciphergroupname.length > 0) {    sslcipher deleteresources[] = new sslcipher[ciphergroupname.length];    for (int i=0;i<ciphergroupname.length;i++){     deleteresources[i] = new sslcipher();     deleteresources[i].ciphergroupname = ciphergroupname[i];    }    result = delete_bulk_request(client, deleteresources);   }   return result;  }
@CanIgnoreReturnValue   public final double getAndAdd(int i, double delta) {     while (true) {       long current = longs.get(i);       double currentVal = longBitsToDouble(current);       double nextVal = currentVal + delta;       long next = doubleToRawLongBits(nextVal);       if (longs.compareAndSet(i, current, next)) {         return currentVal;       }     }   }
HttpRedirectionValidator getRedirectionValidator() {          if (redirectionValidator == null) {              redirectionValidator = redirection -> {                  if (!nodeInScope(redirection.getEscapedURI())) {                      if (log.isDebugEnabled()) {                          log.debug(""Skipping redirection out of scan's scope: "" + redirection);                      }                      return false;                  }                  return true;              };          }          return redirectionValidator;      }
@XmlElementDecl(namespace = ""http://belframework.org/schema/1.0/xbel"", name = ""copyright"")     public             JAXBElement<String> createCopyright(String value) {         return new JAXBElement<String>(_Copyright_QNAME, String.class, null,                 value);     }
public String getArgs(){   int count = (this.tokenPosition==0)?1:this.tokenPosition+1;   String[] ar = StringUtils.split(this.line, null, count);   if(ar!=null && ar.length>(this.tokenPosition)){    return StringUtils.trim(ar[this.tokenPosition]);   }   return null;  }
@SuppressWarnings(""unchecked"")   private void initialize(int capacity) {     // Find a power of 2 >= capacity     int tableLength = 16;     while (tableLength < capacity) {       tableLength <<= 1;     }     // Allocates hash table.     _entries = new EntryImpl[tableLength];     _mask = tableLength - 1;     _capacity = capacity;     _size = 0;     // Allocates views.     _values = new Values();     _entrySet = new EntrySet();     _keySet = new KeySet();     // Resets pointers.     _poolFirst = null;     _mapFirst = null;     _mapLast = null;     // Allocates entries.     for (int i = 0; i < capacity; i++) {       EntryImpl<K, V> entry = new EntryImpl<K, V>();       entry._after = _poolFirst;       _poolFirst = entry;     }   }
protected void doPostForm(String path, MultivaluedMap<String, String> formParams) throws ClientException {         doPostForm(path, formParams, null);     }
public void exists(final String path, Watcher watcher, StatCallback cb,             Object ctx) {         verbotenThreadCheck();         final String clientPath = path;         PathUtils.validatePath(clientPath);          // the watch contains the un-chroot path         WatchRegistration wcb = null;         if (watcher != null) {             wcb = new ExistsWatchRegistration(watcher, clientPath);         }          final String serverPath = prependChroot(clientPath);          RequestHeader h = new RequestHeader();         h.setType(ZooDefs.OpCode.exists);         ExistsRequest request = new ExistsRequest();         request.setPath(serverPath);         request.setWatch(watcher != null);         SetDataResponse response = new SetDataResponse();         cnxn.queuePacket(h, new ReplyHeader(), request, response, cb,                 clientPath, serverPath, ctx, wcb);     }
public byte[] getRecipientInitialsImage(String accountId, String envelopeId, String recipientId) throws ApiException {     return getRecipientInitialsImage(accountId, envelopeId, recipientId, null);   }
static public Field findFieldInAnyParentOrMyself(             final ICmdLineArg<?> arg,             final Class<?> targetClass,             final String errMsg)                     throws ParseException     {         Field field = null;         try         {             field = targetClass.getDeclaredField(arg.getVariable());         } catch (final SecurityException e)         {             throw new ParseException(""SecurityException "" + errMsg, -1);         } catch (final NoSuchFieldException e)         {             if (targetClass.getSuperclass() == null)                 throw new ParseException(""NoSuchFieldException "" + errMsg, -1);             /*              * recursive from here              */             return findFieldInAnyParentOrMyself(arg, targetClass.getSuperclass(), errMsg);         }         return field;     }
public Object execute(String method, Vector params)    throws XmlRpcClientExecutorException {         LOGGER.debug(""executing method {} , with params {}"", method, params);    try {    return client.execute(method, params);   }   catch (XmlRpcException ex) {    throw new XmlRpcClientExecutorException(CALL_FAILED, ex);   }   catch (IOException ex) {    throw new XmlRpcClientExecutorException(CONFIGURATION_ERROR, ex);   }  }
public static final short getMode(CharSequence perms)      {          if (perms.length() != 10)          {              throw new IllegalArgumentException(perms+"" not permission"");          }          short mode = 0;          for (int ii=0;ii<10;ii++)          {              int shift = 9-ii;              switch (perms.charAt(ii))              {                  case 'c':   // character device                      if (ii != 0)                      {                          throw new IllegalArgumentException(perms+"" illegal"");                      }                      mode |= 0020000;                      break;                  case 'b':   // block device                      if (ii != 0)                      {                          throw new IllegalArgumentException(perms+"" illegal"");                      }                      mode |= 0060000;                      break;                  case 'p':   // FIFO (pipe)                      if (ii != 0)                      {                          throw new IllegalArgumentException(perms+"" illegal"");                      }                      mode |= 0010000;                      break;                  case 'l':                      if (ii != 0)                      {                          throw new IllegalArgumentException(perms+"" illegal"");                      }                      mode |= 0120000;                      break;                  case 'd':                      if (ii != 0)                      {                          throw new IllegalArgumentException(perms+"" illegal"");                      }                      mode |= 0040000;                      break;                  case '-':                      if (ii == 0)                      {                          mode |= 0100000;                      }                      break;                  case 'r':                      switch (ii)                      {                          case 7:                          case 4:                          case 1:                              mode |= (1<<shift);                              break;                          default:                              throw new IllegalArgumentException(perms+"" illegal"");                      }                      break;                  case 'w':                      switch (ii)                      {                          case 8:                          case 5:                          case 2:                              mode |= (1<<shift);                              break;                          default:                              throw new IllegalArgumentException(perms+"" illegal"");                      }                      break;                  case 'x':                      switch (ii)                      {                          case 9:                          case 6:                          case 3:                              mode |= (1<<shift);                              break;                          default:                              throw new IllegalArgumentException(perms+"" illegal"");                      }                      break;                  case 's':                      switch (ii)                      {                          case 0:                              mode |= 0140000;                              break;                          case 6:                              mode |= 0002000;                              mode |= (1<<shift);                              break;                          case 3:                              mode |= 0004000;                              mode |= (1<<shift);                              break;                          default:                              throw new IllegalArgumentException(perms+"" illegal"");                      }                      break;                  case 't':                      switch (ii)                      {                          case 9:                              mode |= 0001001;                              break;                          default:                              throw new IllegalArgumentException(perms+"" illegal"");                      }                      break;                  case 'T':                      switch (ii)                      {                          case 9:                              mode |= 0001000;                              break;                          default:                              throw new IllegalArgumentException(perms+"" illegal"");                      }                      break;              }          }          return mode;      }
public static TLVElement create(int type, byte[] value) throws TLVParserException {         TLVElement element = create(type);         element.setContent(value);         return element;     }
private void initializeListView() {     placesListView.setAdapter(placesAdapter);     placesListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {       @Override       public void onItemClick(AdapterView<?> adapterView, View view, int position, long id) {         lastLoadedPlacePosition = position;         showPlace(position);       }     });   }
public Account withSupportedLicenses(String... supportedLicenses) {         if (this.supportedLicenses == null) {             setSupportedLicenses(new java.util.ArrayList<String>(supportedLicenses.length));         }         for (String ele : supportedLicenses) {             this.supportedLicenses.add(ele);         }         return this;     }
public Observable<Void> updateAsync(String jobId, String taskId, TaskConstraints constraints, TaskUpdateOptions taskUpdateOptions) {         return updateWithServiceResponseAsync(jobId, taskId, constraints, taskUpdateOptions).map(new Func1<ServiceResponseWithHeaders<Void, TaskUpdateHeaders>, Void>() {             @Override             public Void call(ServiceResponseWithHeaders<Void, TaskUpdateHeaders> response) {                 return response.body();             }         });     }
@Override     public Iterable<T> delete(final Iterable<T> entities) {         return inTransaction(new Callable<Iterable<T>>() {             @Override             public Iterable<T> call() throws Exception {                 for (T object : entities) {                     T attached = getAttached(object);                     if (attached != null) {                         entityManager.remove(attached);                     }                 }                 return entities;             }         });     }
@Override     public ListAssociationVersionsResult listAssociationVersions(ListAssociationVersionsRequest request) {         request = beforeClientExecution(request);         return executeListAssociationVersions(request);     }
public static void assertIsEndArrayJsonToken(final JsonParser parser) throws JsonParseException {         if (!(parser.getCurrentToken() == JsonToken.END_ARRAY)) {             throw new JsonParseException(SR.EXPECTED_END_ARRAY, parser.getCurrentLocation());         }     }
public void commit() {         if (getBulk().numberOfActions() > 0) {             BulkResponse response = getBulk().execute().actionGet();             if (response.hasFailures()) {                 for (BulkItemResponse itemResponse : response.getItems()) {                     if (!itemResponse.isFailed()) {                         continue;                     }                      if (itemResponse.getFailure().getStatus() == RestStatus.NOT_FOUND) {                         logger.error(itemResponse.getFailureMessage());                     } else {                         throw new RuntimeException(""ES sync commit error"" + itemResponse.getFailureMessage());                     }                 }             }         }     }
private synchronized void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {         in.defaultReadObject();          // the transient _nameMap is null after an instance of         // NameService has been serialized.         if (_nameMap == null) {             _nameMap = new HashMap();         }     }
public Map<String, Class<?>> getPayloadPropertyNames(Map<String,Class<?>> mapPropertyNames)     {         mapPropertyNames = super.getPayloadPropertyNames(mapPropertyNames);         if ((this.getKeyInformation() & STANDARD_PARAM) != 0)         {   // Add this name and class to the map of property names             if (mapPropertyNames == null)                 mapPropertyNames = new HashMap<String, Class<?>>();             mapPropertyNames.put(this.getFullKey(null), this.getRawClassType());         }         return mapPropertyNames;     }
public Observable<RouteInner> beginCreateOrUpdateAsync(String resourceGroupName, String routeTableName, String routeName, RouteInner routeParameters) {         return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, routeTableName, routeName, routeParameters).map(new Func1<ServiceResponse<RouteInner>, RouteInner>() {             @Override             public RouteInner call(ServiceResponse<RouteInner> response) {                 return response.body();             }         });     }
public static double pow(double d, int e) {          if (e == 0) {             return 1.0;         } else if (e < 0) {             e = -e;             d = 1.0 / d;         }          // split d as two 26 bits numbers         // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties         final int splitFactor = 0x8000001;         final double cd       = splitFactor * d;         final double d1High   = cd - (cd - d);         final double d1Low    = d - d1High;          // prepare result         double resultHigh = 1;         double resultLow  = 0;          // d^(2p)         double d2p     = d;         double d2pHigh = d1High;         double d2pLow  = d1Low;          while (e != 0) {              if ((e & 0x1) != 0) {                 // accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm                 // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties                 final double tmpHigh = resultHigh * d2p;                 final double cRH     = splitFactor * resultHigh;                 final double rHH     = cRH - (cRH - resultHigh);                 final double rHL     = resultHigh - rHH;                 final double tmpLow  = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow);                 resultHigh = tmpHigh;                 resultLow  = resultLow * d2p + tmpLow;             }              // accurate squaring d^(2(p+1)) = d^(2p) * d^(2p) using Veltkamp TwoProduct algorithm             // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties             final double tmpHigh = d2pHigh * d2p;             final double cD2pH   = splitFactor * d2pHigh;             final double d2pHH   = cD2pH - (cD2pH - d2pHigh);             final double d2pHL   = d2pHigh - d2pHH;             final double tmpLow  = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);             final double cTmpH   = splitFactor * tmpHigh;             d2pHigh = cTmpH - (cTmpH - tmpHigh);             d2pLow  = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);             d2p     = d2pHigh + d2pLow;              e = e >> 1;          }          return resultHigh + resultLow;      }
public GroupName getGroupName(@NonNull List<String> prefixPath, @NonNull Map<String, MetricValue> extraTags) {         final Stream<String> suffixPath = data.entrySet().stream()                 .filter(entry -> entry.getKey().getLeft().isPresent()) // Only retain int keys.                 .sorted(Comparator.comparing(entry -> entry.getKey().getLeft().get())) // Sort by int key.                 .map(Map.Entry::getValue)                 .map(value -> value.mapCombine(b -> b.toString(), i -> i.toString(), Function.identity()));          final SimpleGroupPath path = SimpleGroupPath.valueOf(Stream.concat(prefixPath.stream(), suffixPath).collect(Collectors.toList()));         final Map<String, MetricValue> tags = data.entrySet().stream()                 .filter(entry -> entry.getKey().getRight().isPresent()) // Only retain string keys.                 .collect(Collectors.toMap(entry -> entry.getKey().getRight().get(), entry -> entry.getValue().mapCombine(MetricValue::fromBoolean, MetricValue::fromIntValue, MetricValue::fromStrValue)));         tags.putAll(extraTags);         return GroupName.valueOf(path, tags);     }
public List<org.nd4j.linalg.api.buffer.DataType> calculateOutputDataTypes(List<org.nd4j.linalg.api.buffer.DataType> dataTypes){         throw new UnsupportedOperationException(""calculateOutputDataTypes() has not been implemented for "" + getClass().getName());     }
public BaseMessage createReplyMessage(BaseMessage messageIn)     {         //ProductRequest productRequest = (ProductRequest)messageIn.getMessageDataDesc(null);         BaseMessage replyMessage = (BaseMessage)this.getMessageProcessInfo().createReplyMessage(messageIn);                  //BaseProductResponse responseMessage = (BaseProductResponse)replyMessage.getMessageDataDesc(null);         //responseMessage.moveRequestInfoToReply(productRequest);         if (replyMessage == null)             replyMessage = new TreeMessage(null, null);         if (replyMessage.getExternalMessage() == null)             new ExternalMapTrxMessageIn(replyMessage, null);         return replyMessage;    // Override this!     }
public Coupon getCoupon(final String couponCode) {         if (couponCode == null || couponCode.isEmpty())             throw new RuntimeException(""couponCode cannot be empty!"");          return doGET(Coupon.COUPON_RESOURCE + ""/"" + couponCode, Coupon.class);     }
public void process(InputStream input) throws IOException, ConverterException {         while (0 != input.available()) {             Tag tag = ParserUtils.parseTag(input);             TagHandler handler = getHandler(tag);             if (null == handler) {                 skipHandler.handle(tag, input);             } else {                 handler.handle(tag, input);             }         }     }
protected Set<String> countComponentContainPaxWicketBeanAnnotatedFieldsHierachical(Class<?> component) {         Set<String> foundAnnotation = new HashSet<String>();         Class<?> clazz = component;         while (clazz != null && !isBoundaryClass(clazz)) {             for (Field field : clazz.getDeclaredFields()) {                 if (field.isAnnotationPresent(Inject.class)) {                     foundAnnotation.add(field.toGenericString());                 }             }             clazz = clazz.getSuperclass();         }         return foundAnnotation;     }
@Override     public String invoke(Object connection, String request, int timeout, Map<String,String> metainfo)     throws ConnectionException, AdapterException {         String response;         try{             if (timeout<=0) timeout = DEFAULT_TIMEOUT;             SoccomClient client = (SoccomClient)connection;             client.putreq(request);             response = client.getresp(timeout);         } catch (SoccomException ex){             if (ex.getErrorCode()==SoccomException.POLL_TIMEOUT)                 throw new ConnectionException(ConnectionException.CONNECTION_DOWN, ex.getMessage(), ex);             else throw new AdapterException(-1, ex.getMessage(), ex);         }         return response;     }
public void elementDecl(String name, String model) throws SAXException   {      if (DEBUG)       System.out.println(""TransformerHandlerImpl#elementDecl: "" + name + "", ""                          + model);      if (null != m_declHandler)     {       m_declHandler.elementDecl(name, model);     }   }
public static <E> E first(E[] array) {         return new FirstElement<E>().apply(new ArrayIterator<>(array));     }
public ArrayList<Long> serviceName_modem_availableWLANChannel_GET(String serviceName, OvhWLANFrequencyEnum frequency) throws IOException {   String qPath = ""/xdsl/{serviceName}/modem/availableWLANChannel"";   StringBuilder sb = path(qPath, serviceName);   query(sb, ""frequency"", frequency);   String resp = exec(qPath, ""GET"", sb.toString(), null);   return convertTo(resp, t15);  }
@Override     public StreamT<W,T> sorted(final Comparator<? super T> c) {          return (StreamT<W,T>) FoldableTransformerSeq.super.sorted(c);     }
public GraphQLResult processGraphQLMultipart(String graphQLRequest, File file) throws ApiException {     Object localVarPostBody = null;          // verify the required parameter 'graphQLRequest' is set     if (graphQLRequest == null) {       throw new ApiException(400, ""Missing the required parameter 'graphQLRequest' when calling processGraphQLMultipart"");     }          // verify the required parameter 'file' is set     if (file == null) {       throw new ApiException(400, ""Missing the required parameter 'file' when calling processGraphQLMultipart"");     }          // create path and map variables     String localVarPath = ""/graphql/upload"".replaceAll(""\\{format\\}"",""json"");      // query params     List<Pair> localVarQueryParams = new ArrayList<Pair>();     Map<String, String> localVarHeaderParams = new HashMap<String, String>();     Map<String, Object> localVarFormParams = new HashMap<String, Object>();            if (graphQLRequest != null)       localVarFormParams.put(""graphQLRequest"", graphQLRequest); if (file != null)       localVarFormParams.put(""file"", file);      final String[] localVarAccepts = {       ""application/json""     };     final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);      final String[] localVarContentTypes = {       ""multipart/form-data""     };     final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);      String[] localVarAuthNames = new String[] { ""token"" };      GenericType<GraphQLResult> localVarReturnType = new GenericType<GraphQLResult>() {};     return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);       }
public boolean isMetBy(Ordering otherOrdering) {   if (otherOrdering == null || this.indexes.size() > otherOrdering.indexes.size()) {    return false;   }      for (int i = 0; i < this.indexes.size(); i++) {    if (this.indexes.get(i) != otherOrdering.indexes.get(i)) {     return false;    }        // if this one request no order, everything is good    if (this.orders.get(i) != Order.NONE) {     if (this.orders.get(i) == Order.ANY) {      // if any order is requested, any not NONE order is good      if (otherOrdering.orders.get(i) == Order.NONE) {       return false;      }     } else if (otherOrdering.orders.get(i) != this.orders.get(i)) {      // the orders must be equal      return false;     }    }   }   return true;  }
public void addCondition(Condition condition) throws WebDAVException {         // a Resource URI can only be specified once in a Precondition         Enumeration conditions = getConditions();         if (condition.getResourceURI() != null) {             while (conditions.hasMoreElements()) {                 Condition existingCondition = (Condition) conditions.nextElement();                 if (existingCondition.getResourceURI() != null && existingCondition.getResourceURI().equals(condition.getResourceURI()))                     throw new WebDAVException(IResponse.SC_BAD_REQUEST, Policy.bind(""error.parseMultipleSpecification"", condition.getResourceURI())); //$NON-NLS-1$             }         }         this.conditions.addElement(condition);     }
public void replace(File file, boolean preserveExternalFileName, String text) {     String path = entries.containsKey(file) ? entries.remove(file) : zipPathFor(file, preserveExternalFileName);     entries.put(text, path);   }
@Override     public void renderHead(final Component _component,                            final IHeaderResponse _response)     {         super.renderHead(_component, _response);         _response.render(AbstractEFapsHeaderItem.forJavaScript(AjaxFieldUpdateBehavior.JS));     }
int at(int n) throws       IOException   {     Mark mark = mark();     List<Integer> cbuf = Lists.newArrayList();     for (int i = 0; i < n; i++)     {       cbuf.add(next());       if (curChar == -1)       {         break;       }     }     unread(cbuf, mark);     return cbuf.get(cbuf.size() - 1);   }
private static CowFace getCowFace(final CommandLine commandLine) {   CowFace cowFace;   cowFace = new CowFace();   if (commandLine.hasOption(CowsayCli.Opt.EYES.toString())) {    cowFace.setEyes(commandLine.getOptionValue(CowsayCli.Opt.EYES.toString()));   }   if (commandLine.hasOption(CowsayCli.Opt.TONGUE.toString())) {    cowFace.setTongue(commandLine.getOptionValue(CowsayCli.Opt.TONGUE.toString()));   }   return cowFace;  }
public XcapResponse get(URI uri, Header[] additionalRequestHeaders,     Credentials credentials) throws IOException {      if (log.isDebugEnabled()) {     log.debug(""get(uri="" + uri + "" , additionalRequestHeaders = ( ""       + Arrays.toString(additionalRequestHeaders) + "" ) )"");    }      return execute(new HttpGet(uri), additionalRequestHeaders, credentials);   }
private void prepareMessages(final List<MessageCenterListItem> originalItems) {   assertMainThread();    listItems.clear();   unsentMessagesCount = 0;   // Loop through each message item retrieved from database   for (MessageCenterListItem item : originalItems) {    if (item instanceof ApptentiveMessage) {     ApptentiveMessage apptentiveMessage = (ApptentiveMessage) item;     Double createdAt = apptentiveMessage.getCreatedAt();     if (apptentiveMessage.isOutgoingMessage() && createdAt == null) {      unsentMessagesCount++;     }      /*      * Find proper location to insert into the listItems list of the listview.      */     ListIterator<MessageCenterListItem> listIterator = listItems.listIterator();     ApptentiveMessage next = null;     while (listIterator.hasNext()) {      next = (ApptentiveMessage) listIterator.next();      Double nextCreatedAt = next.getCreatedAt();      // For unsent and dropped message, move the iterator to the end, and append there      if (createdAt == null || createdAt <= Double.MIN_VALUE) {       continue;      }      // next message has not received by server or received, but has a later created_at time      if (nextCreatedAt == null || nextCreatedAt > createdAt) {       break;      }     }      if (next == null || next.getCreatedAt() == null || createdAt == null || next.getCreatedAt() <= createdAt ||      createdAt <= Double.MIN_VALUE) {      listIterator.add(item);     } else {      // Add in front of the message that has later created_at time      listIterator.set(item);      listIterator.add(next);     }    }   }   messagingActionHandler.sendEmptyMessage(MSG_ADD_GREETING);  }
@NonNull   public static Term remainder(@NonNull Term left, @NonNull Term right) {     return new BinaryArithmeticTerm(ArithmeticOperator.REMAINDER, left, right);   }
public String compile(final DataProvider dataProvider,                           final String template,                           boolean replaceOptionals) {         final InputStream templateStream = this.getClass().getResourceAsStream(template);         return compile(dataProvider,                        templateStream);     }
public static String defaultIfEmpty(String str, String defaultStr) {         return str == null || str.length() == 0 ? defaultStr : str;     }
public static String[] splitUnescape(String input, char[] separators, char echar, char[] special) {         List<String> components = new ArrayList<>();         boolean done = false;         String remaining = input;         while (!done) {             Partial result = unescape(remaining, echar, special, separators);             if (result.getUnescaped() != null) {                 components.add(result.unescaped);             }             if (result.getRemaining() != null) {                 remaining = result.getRemaining();             } else {                 done = true;             }         }         return components.toArray(new String[components.size()]);      }
@Override     public Object readValue(final Attribute _attribute,                             final List<Object> _objectList)     {         final List<BigDecimal> ret = new ArrayList<>();         for (final Object object : _objectList) {             if (object instanceof BigDecimal) {                 ret.add((BigDecimal) object);             } else if (object != null) {                 ret.add(new BigDecimal(object.toString()));             }         }         return _objectList.size() > 0 ? ret.size() > 1 ? ret : ret.size() > 0 ? ret.get(0) : null : null;     }
@Override     protected void insertDefaults()         throws EFapsException     {         super.insertDefaults();         if (!getExist()[1] && getGeneralID() != null) {             try {                 final ConnectionResource res = Context.getThreadContext().getConnectionResource();                 Context.getDbType().newInsert(JDBCStoreResource.TABLENAME_STORE, ""ID"", false)                                 .column(""ID"", getGeneralID())                                 .execute(res);             } catch (final SQLException e) {                 throw new EFapsException(JDBCStoreResource.class, ""insertDefaults"", e);             }         }     }
public void setRange(double A, double B)     {         if(A == B)             throw new RuntimeException(""Values must be different"");         else if(B > A)         {             double tmp = A;             A = B;             B = tmp;         }         this.A = A;         this.B = B;     }
@SuppressWarnings({})     public synchronized void streamingPut(ByteArray key, Versioned<byte[]> value) {          if(MARKED_BAD) {             logger.error(""Cannot stream more entries since Recovery Callback Failed!"");             throw new VoldemortException(""Cannot stream more entries since Recovery Callback Failed!"");         }          for(String store: storeNames) {             streamingPut(key, value, store);         }      }
public <T> HystrixRequestVariable<T> getRequestVariable(final HystrixRequestVariableLifecycle<T> rv) {         return new HystrixLifecycleForwardingRequestVariable<T>(rv);     }
public void set(String fieldName, Object value) throws IOException {     getValueMarshaller(fieldName).setWritableObject(struct, value);     LOG.debug(""Set {}={}"", fieldName, value);   }
public List<ClassificationDataSet> trainC(ClassificationDataSet dataPoints, Set<Integer> options)     {         return trainC(dataPoints, options, false);     }
private void convertLink2Record(final Object iKey) {    if (status == MULTIVALUE_CONTENT_TYPE.ALL_RECORDS)     return;      final Object value;      if (iKey instanceof ORID)     value = iKey;    else     value = super.get(iKey);      if (value != null && value instanceof ORID) {     final ORID rid = (ORID) value;     marshalling = true;     try {      try {       // OVERWRITE IT       super.put(iKey, rid.getRecord());      } catch (ORecordNotFoundException e) {       // IGNORE THIS      }     } finally {      marshalling = false;     }    }   }
public ApiSuccessResponse logoutVoice(DndOnBody dndOnBody) throws ApiException {         ApiResponse<ApiSuccessResponse> resp = logoutVoiceWithHttpInfo(dndOnBody);         return resp.getData();     }
private void storeRecentList(final List recent) {   try {    if (recent == null) {     return;    }     // Only keep the last 8 entries.    while (recent.size() > 8) {     recent.remove(recent.size() - 1);    }     OutputStream out = new BufferedOutputStream(new FileOutputStream(      RECENT_FILE_NAME));    XMLEncoder e = new XMLEncoder(out);    e.writeObject(recent);    e.close();   } catch (IOException ex) {    LOG.error(""Unable to save recent list"", ex);   }  }
@Override     public void serialize(final DataOutput pOutput) throws TTIOException {         try {             pOutput.writeInt(IConstants.TEXT);             mDel.serialize(pOutput);             mStrucDel.serialize(pOutput);             mValDel.serialize(pOutput);         } catch (final IOException exc) {             throw new TTIOException(exc);         }     }
public Flowable<ReactiveSensorEvent> observeSensor(int sensorType, final int samplingPeriodInUs,       final Handler handler, final BackpressureStrategy strategy) {      if (!hasSensor(sensorType)) {       String format = ""Sensor with id = %d is not available on this device"";       String message = String.format(Locale.getDefault(), format, sensorType);       return Flowable.error(new SensorNotFoundException(message));     }      final Sensor sensor = sensorManager.getDefaultSensor(sensorType);     final SensorEventListenerWrapper wrapper = new SensorEventListenerWrapper();     final SensorEventListener listener = wrapper.create();      return Flowable.create(new FlowableOnSubscribe<ReactiveSensorEvent>() {       @Override public void subscribe(final FlowableEmitter<ReactiveSensorEvent> emitter)           throws Exception {          wrapper.setEmitter(emitter);          if (handler == null) {           sensorManager.registerListener(listener, sensor, samplingPeriodInUs);         } else {           sensorManager.registerListener(listener, sensor, samplingPeriodInUs, handler);         }       }     }, strategy).doOnCancel(new Action() {       @Override public void run() throws Exception {         sensorManager.unregisterListener(listener);       }     });   }
@Override public ValFrame apply(Env env, Env.StackHelp stk, AstRoot asts[]) {     Frame fr = stk.track(asts[1].exec(env)).getFrame(); // first argument is dataframe     int[] groupbycols = ((AstParameter)asts[2]).columns(fr.names());     int[] sortcols =((AstParameter)asts[3]).columns(fr.names());  // sort columns      int[] sortAsc;     if (asts[4] instanceof AstNumList)       sortAsc = ((AstNumList) asts[4]).expand4();     else       sortAsc = new int[]{(int) ((AstNum) asts[4]).getNum()};  // R client can send 1 element for some reason     String newcolname = asts[5].str();     Boolean sortColsOrder = ((AstNum) asts[6]).getNum()==1;          assert sortAsc.length==sortcols.length;     SortnGrouby sortgroupbyrank = new SortnGrouby(fr, groupbycols, sortcols, sortAsc, newcolname);     sortgroupbyrank.doAll(sortgroupbyrank._groupedSortedOut);  // sort and add rank column     RankGroups rankgroups = new RankGroups(sortgroupbyrank._groupedSortedOut, groupbycols,             sortcols, sortgroupbyrank._chunkFirstG, sortgroupbyrank._chunkLastG,             sortgroupbyrank._newRankCol).doAll(sortgroupbyrank._groupedSortedOut);      if (sortColsOrder)       return new ValFrame(rankgroups._finalResult.sort(sortcols, sortAsc));     else       return new ValFrame(rankgroups._finalResult);   }
@NonNull     public SourceParams setTypeRaw(@NonNull String typeRaw) {         mType = Source.asSourceType(typeRaw);         mTypeRaw = typeRaw;         return this;     }
private final Session getSession (final String targetName) throws NoSuchSessionException {          final Session session = sessions.get(targetName);          if (session != null) {             return session;         } else {             throw new NoSuchSessionException(""Session "" + targetName + "" not found!"");         }     }
public final char getSurrogateValue(char lead, char trail)     {         int offset = getSurrogateOffset(lead, trail);         if (offset > 0) {             return m_data_[offset];         }         return m_initialValue_;     }
private ModelAndView generateErrorView(final String code, final Object[] args, final HttpServletRequest request) {         val modelAndView = new ModelAndView(this.failureView);         modelAndView.addObject(""code"", StringEscapeUtils.escapeHtml4(code));         val desc = StringEscapeUtils.escapeHtml4(this.context.getMessage(code, args, code, request.getLocale()));         modelAndView.addObject(""description"", desc);         return modelAndView;     }
private void register(Kryo kryo, Class<?>[] types, Serializer<?> serializer, int id) {     Registration existing = kryo.getRegistration(id);     if (existing != null) {       boolean matches = false;       for (Class<?> type : types) {         if (existing.getType() == type) {           matches = true;           break;         }       }        if (!matches) {         LOGGER.error(""{}: Failed to register {} as {}, {} was already registered."",             friendlyName(), types, id, existing.getType());          throw new IllegalStateException(String.format(             ""Failed to register %s as %s, %s was already registered."",             Arrays.toString(types), id, existing.getType()));       }       // falling through to register call for now.       // Consider skipping, if there's reasonable       // way to compare serializer equivalence.     }      for (Class<?> type : types) {       Registration r = null;       if (serializer == null) {         r = kryo.register(type, id);       } else if (type.isInterface()) {         kryo.addDefaultSerializer(type, serializer);       } else {         r = kryo.register(type, serializer, id);       }       if (r != null) {         if (r.getId() != id) {           LOGGER.debug(""{}: {} already registered as {}. Skipping {}."",               friendlyName(), r.getType(), r.getId(), id);         }         LOGGER.trace(""{} registered as {}"", r.getType(), r.getId());       }     }   }
public static Rule getRule(final Stack stack) {     if (stack.size() < 1) {       throw new IllegalArgumentException(         ""Invalid EXISTS rule - expected one parameter but received ""         + stack.size());     }      return new ExistsRule(stack.pop().toString());   }
@Override     public void validate(ValidationHelper helper, Context context, String key, OAuthFlows t) {         if (t != null) {             if (t.getImplicit() != null) {                 OAuthFlow implicit = t.getImplicit();;                 if (StringUtils.isNotBlank(implicit.getTokenUrl())) {                     final String message = Tr.formatMessage(tc, ""nonApplicableFieldWithValue"", ""tokenUrl"", implicit.getTokenUrl(), ""OAuth Flow Object"", ""implicit"");                     helper.addValidationEvent(new ValidationEvent(ValidationEvent.Severity.WARNING, context.getLocation(), message));                 }                 ValidatorUtils.validateRequiredField(implicit.getAuthorizationUrl(), context, ""authorizationUrl"").ifPresent(helper::addValidationEvent);             }             if (t.getPassword() != null) {                 OAuthFlow password = t.getPassword();                 if (StringUtils.isNotBlank(password.getAuthorizationUrl())) {                     final String message = Tr.formatMessage(tc, ""nonApplicableFieldWithValue"", ""authorizationUrl"", password.getAuthorizationUrl(), ""OAuth Flow Object"", ""password"");                     helper.addValidationEvent(new ValidationEvent(ValidationEvent.Severity.WARNING, context.getLocation(), message));                 }                 ValidatorUtils.validateRequiredField(password.getTokenUrl(), context, ""tokenUrl"").ifPresent(helper::addValidationEvent);             }             if (t.getClientCredentials() != null) {                 OAuthFlow clientCred = t.getClientCredentials();                 if (StringUtils.isNotBlank(clientCred.getAuthorizationUrl())) {                     final String message = Tr.formatMessage(tc, ""nonApplicableFieldWithValue"", ""authorizationUrl"", clientCred.getAuthorizationUrl(), ""OAuth Flow Object"",                                                             ""clientCredentials"");                     helper.addValidationEvent(new ValidationEvent(ValidationEvent.Severity.WARNING, context.getLocation(), message));                 }                 ValidatorUtils.validateRequiredField(clientCred.getTokenUrl(), context, ""tokenUrl"").ifPresent(helper::addValidationEvent);             }             if (t.getAuthorizationCode() != null) {                 OAuthFlow authCode = t.getAuthorizationCode();                 ValidatorUtils.validateRequiredField(authCode.getTokenUrl(), context, ""tokenUrl"").ifPresent(helper::addValidationEvent);                 ValidatorUtils.validateRequiredField(authCode.getAuthorizationUrl(), context, ""authorizationUrl"").ifPresent(helper::addValidationEvent);             }         }     }
public double getCount(F first, S second) {         Counter<S> counter = maps.get(first);         if (counter == null)             return 0.0;          return counter.getCount(second);     }
@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> lastElement() {         return RxJavaPlugins.onAssembly(new FlowableLastMaybe<T>(this));     }
public GetSignatureResponse getSignature(String url) {         BeanUtil.requireNonNull(url, ""请传入当前网页的URL，不包含#及其后面部分"");         //当前时间的秒数         long timestame = System.currentTimeMillis() / 1000;         //使用UUID来当随机字符串         String nonceStr = UUID.randomUUID().toString().replaceAll(""-"", """");         return getSignature(nonceStr, timestame, url);     }
public int executeUpdate(String update) throws SQLException {   System.out.println(new LogEntry(""executing: "" + update));    //TODO time execution time   Connection conn = dataSource.getConnection();   Statement s = conn.createStatement();   int result = s.executeUpdate(update);   conn.close();   System.out.println(new LogEntry(result + "" rows affected""));   return result;  }
public Observable<ServiceResponse<KeyOperationResult>> encryptWithServiceResponseAsync(String vaultBaseUrl, String keyName, String keyVersion, JsonWebKeyEncryptionAlgorithm algorithm, byte[] value) {         if (vaultBaseUrl == null) {             throw new IllegalArgumentException(""Parameter vaultBaseUrl is required and cannot be null."");         }         if (keyName == null) {             throw new IllegalArgumentException(""Parameter keyName is required and cannot be null."");         }         if (keyVersion == null) {             throw new IllegalArgumentException(""Parameter keyVersion is required and cannot be null."");         }         if (this.apiVersion() == null) {             throw new IllegalArgumentException(""Parameter this.apiVersion() is required and cannot be null."");         }         if (algorithm == null) {             throw new IllegalArgumentException(""Parameter algorithm is required and cannot be null."");         }         if (value == null) {             throw new IllegalArgumentException(""Parameter value is required and cannot be null."");         }         KeyOperationsParameters parameters = new KeyOperationsParameters();         parameters.withAlgorithm(algorithm);         parameters.withValue(value);         String parameterizedHost = Joiner.on("", "").join(""{vaultBaseUrl}"", vaultBaseUrl);         return service.encrypt(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, parameterizedHost, this.userAgent())             .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<KeyOperationResult>>>() {                 @Override                 public Observable<ServiceResponse<KeyOperationResult>> call(Response<ResponseBody> response) {                     try {                         ServiceResponse<KeyOperationResult> clientResponse = encryptDelegate(response);                         return Observable.just(clientResponse);                     } catch (Throwable t) {                         return Observable.error(t);                     }                 }             });     }
protected void setupPivotInfo() {         for( int col = 0; col < numCols; col++ ) {             pivots[col] = col;             double c[] = dataQR[col];             double norm = 0;             for( int row = 0; row < numRows; row++ ) {                 double element = c[row];                 norm += element*element;             }             normsCol[col] = norm;         }     }
@PublicEvolving  static <T extends Writable> TypeInformation<T> getWritableTypeInfo(Class<T> typeClass) {   if (Writable.class.isAssignableFrom(typeClass) && !typeClass.equals(Writable.class)) {    return new WritableTypeInfo<T>(typeClass);   }   else {    throw new InvalidTypesException(""The given class is no subclass of "" + Writable.class.getName());   }  }
public long getLeastSignificantBits() {         long b;         b  = ((long)content[ 8] & 0xFF) << 56;         b |= ((long)content[ 9] & 0xFF) << 48;         b |= ((long)content[10] & 0xFF) << 40;         b |= ((long)content[11] & 0xFF) << 32;         b |= ((long)content[12] & 0xFF) << 24;         b |= ((long)content[13] & 0xFF) << 16;         b |= ((long)content[14] & 0xFF) << 8;         b |= ((long)content[15] & 0xFF);         return b;     }
public void setProperty(final String name, final String val) {     if (props == null) {       props = new Properties();     }      props.setProperty(name, val);   }
public static void debug(Object object, Object message) {         Class clazz = object.getClass();         debug(clazz, message);     }
protected void enableApiKeyInternal(final ObjectId id) {     final StitchAuthRequest.Builder reqBuilder = new StitchAuthRequest.Builder();     reqBuilder             .withMethod(Method.PUT)             .withPath(routes.getApiKeyEnableRouteForId(id.toHexString()))             .withRefreshToken();     getRequestClient().doAuthenticatedRequest(reqBuilder.build());   }
@Override     public <U> PropertyBinding<U> selectProperty(             Function<? super T, ? extends Property<U>> f) {         return EasyBind.selectProperty(delegate, f);     }
public double getCouponPayment(int periodIndex, AnalyticModel model) {    ForwardCurve forwardCurve = model.getForwardCurve(forwardCurveName);   if(forwardCurve == null && forwardCurveName != null && forwardCurveName.length() > 0) {    throw new IllegalArgumentException(""No forward curve with name '"" + forwardCurveName + ""' was found in the model:\n"" + model.toString());   }    double periodLength = schedule.getPeriodLength(periodIndex);   double couponPayment=fixedCoupon ;   if(forwardCurve != null ) {    couponPayment = floatingSpread+forwardCurve.getForward(model, schedule.getFixing(periodIndex));   }   return couponPayment*periodLength;  }
@Override     public boolean isDefaultNamespace(String namespaceURI) {         String namespace = this.getNamespaceURI();         String prefix = this.getPrefix();          if (prefix == null || prefix.length() == 0) {             if (namespaceURI == null) {                 return (namespace == namespaceURI);             }             return namespaceURI.equals(namespace);         }         if (this.hasAttributes()) {             Attr attr = this.getAttributeNodeNS(                 ""http://www.w3.org/2000/xmlns/"", ""xmlns"");             if (attr != null) {                 String value = attr.getNodeValue();                 if (namespaceURI == null) {                     return (namespace == value);                 }                 return namespaceURI.equals(value);             }         }          Node ancestor = getParentNode();         if (ancestor != null) {             short type = ancestor.getNodeType();             if (type == NodeKind.ELEM) {                 return ancestor.isDefaultNamespace(namespaceURI);             }             // otherwise, current node is root already         }         return false;     }
public static double fractionOfStringUppercase(String input)     {         if (input == null)         {             return 0;         }          double upperCasableCharacters = 0;         double upperCount = 0;         for (int i = 0; i < input.length(); i++)         {             char c = input.charAt(i);             char uc = Character.toUpperCase(c);             char lc = Character.toLowerCase(c);             // If both the upper and lowercase version of a character are the same, then the character has             // no distinct uppercase form (e.g., a digit or punctuation). Ignore these.             if (c == uc && c == lc)             {                 continue;             }              upperCasableCharacters++;             if (c == uc)             {                 upperCount++;             }         }          return upperCasableCharacters == 0 ? 0 : upperCount / upperCasableCharacters;     }
Collection<MBeanServer> getMBeanServers() {         Collection<MBeanServer> mbeanServers = new HashSet<MBeanServer>();         mbeanServers.add(ManagementFactory.getPlatformMBeanServer());         mbeanServers.addAll(MBeanServerFactory.findMBeanServer(null));         return mbeanServers;     }
private TimeUnit[] TimeEx(String tar,String timebase)   {    Matcher match;    int startline=-1,endline=-1;      String [] temp = new String[99];    int rpointer=0;    TimeUnit[] Time_Result = null;      match=patterns.matcher(tar);     boolean startmark=true;    while(match.find())    {     startline=match.start();     if (endline==startline)      {      rpointer--;      temp[rpointer]=temp[rpointer]+match.group();     }     else     {      if(!startmark)      {       rpointer--;       //System.out.println(temp[rpointer]);       rpointer++;       }       startmark=false;      temp[rpointer]=match.group();     }     endline=match.end();     rpointer++;    }    if(rpointer>0)    {     rpointer--;     //System.out.println(temp[rpointer]);     rpointer++;    }    Time_Result=new TimeUnit[rpointer];    // System.out.println(""Basic Data is "" + timebase);     for(int j=0;j<rpointer;j++)    {     Time_Result[j]=new TimeUnit(temp[j],this);     //System.out.println(result[j]);    }      return Time_Result;   }
@Override     public void flush()     {         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())             SibTr.entry(this, tc, ""flush"");         // Cleanup any pending NACK alarms.  Since we're flushing we don't         // care about these anymore.         synchronized (pendingAlarms)         {             for (Iterator i = getAlarms(this); i.hasNext();)             {                 NRTExpiryHandle next = (NRTExpiryHandle) i.next();                 next.timer.cancel();                 i.remove();             }         }          // SIB0115         // If nack alarms are cancelled then deregister the health state for detected gaps         getControlAdapter().getHealthState().deregister(HealthStateListener.GAP_DETECTED_STATE);          // We shouldn't be flushed if we have pending unacked data.  But         // just as a sanity check, throw an exception here if we have         // something undelivered.         if (oststream                         .containsState(                                        new TickRange(TickRange.Unknown, 0, RangeList.INFINITY),                                        TickRange.Value)             || oststream.containsState(                                        new TickRange(TickRange.Unknown, 0, RangeList.INFINITY),                                        TickRange.Uncommitted))         {             //TODO: throw some interesting exception         }         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())             SibTr.exit(tc, ""flush"");     }
public SIMPTopicSpaceControllable getTopicSpace()   {     if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())     {       SibTr.entry(tc, ""getTopicSpace"");       SibTr.exit(tc, ""getTopicSpace"", topicspaceControl);     }     return topicspaceControl;   }
protected long getLogFileSize()     {         if (Tracing.isAnyTracingEnabled() && trace.isEntryEnabled())             trace.entry(this, cclass                         , ""getLogFileSIze""                             );          long logFileSize = sectorValidatedInputStream.header.fileSize;          if (Tracing.isAnyTracingEnabled() && trace.isEntryEnabled())             trace.exit(this, cclass                        , ""getLogFileSize""                        , ""returns logFileSize="" + logFileSize + ""(long)""                             );         return logFileSize;     }
public static List<URL> getResources(String resource) {    final Enumeration<URL> resources;    try {     resources = ClassLoaderUtil.getClassLoader().getResources(resource);    } catch (IOException e) {     throw new IORuntimeException(e);    }    return CollectionUtil.newArrayList(resources);   }
public BigInteger getBytes(){         return value.multiply(unit.getFactor()).setScale(0, RoundingMode.CEILING).toBigIntegerExact();     }
private <T extends Enum<T>> T getEnumValue(Class<T> enumType, String name) {     T[] constants = enumType.getEnumConstants();     if (constants == null) {       throw new IllegalArgumentException(enumType.getName() + "" is not an enum type"");     }     for (T constant : constants) {       if (constant.name().equalsIgnoreCase(name.replace('-', '_'))) {         return constant;       }     }     // same error that's thrown by Enum.valueOf()     throw new IllegalArgumentException(         ""No enum constant "" + enumType.getCanonicalName() + ""."" + name);   }
private Path gotRightArrowPath(int width, int height) {         Path path = new Path();         RectF rectF;          // 左上角         int diameter = cornerSizeLeftTop * 2;         if (cornerSizeLeftTop > 0) {             // 左上角圆角起点             path.moveTo(0, cornerSizeLeftTop);             rectF = new RectF(0, 0, diameter, diameter);             path.arcTo(rectF, 180, 90);         } else {             path.moveTo(0, 0);         }          // 右上角         diameter = cornerSizeRightTop * 2;         if (cornerSizeRightTop > 0) {             // 右上角圆角起点             path.lineTo(width - cornerSizeRightTop - arrowHeight, 0);             rectF = new RectF(width - diameter - arrowHeight, 0, width - arrowHeight, diameter);             path.arcTo(rectF, -90, 90);         } else {             path.lineTo(width - arrowHeight, 0);         }          switch (arrowSide) {             case RIGHT_TOP:                 // 箭头起点                 path.lineTo(width - arrowHeight, arrowMargin);                 // 箭头顶点                 path.lineTo(width, arrowMargin + arrowWidth / 2);                 // 箭头结束点                 path.lineTo(width - arrowHeight, arrowMargin + arrowWidth);                 break;             case RIGHT_MIDDLE:                 path.lineTo(width - arrowHeight, height / 2 - arrowWidth / 2);                 path.lineTo(width, height / 2);                 path.lineTo(width - arrowHeight, height / 2 + arrowWidth / 2);                 break;             default:                 // 箭头起点                 path.lineTo(width - arrowHeight, height - arrowMargin - arrowWidth);                 // 箭头顶点                 path.lineTo(width, height - arrowMargin - arrowWidth / 2);                 // 箭头结束点                 path.lineTo(width - arrowHeight, height - arrowMargin);                 break;         }          // 右下角         diameter = cornerSizeRightBottom * 2;         if (cornerSizeRightBottom > 0) {             // 右下角圆角起点             path.lineTo(width - arrowHeight, height - cornerSizeRightBottom);             rectF = new RectF(width - arrowHeight - diameter, height - diameter, width - arrowHeight, height);             path.arcTo(rectF, 0, 90);         } else {             path.lineTo(width - arrowHeight, height);         }          // 左下角         diameter = cornerSizeLeftBottom * 2;         if (cornerSizeLeftBottom > 0) {             // 左下角圆角起点             path.lineTo(cornerSizeLeftBottom, height);             rectF = new RectF(0, height - diameter, diameter, height);             path.arcTo(rectF, 90, 90);         } else {             path.lineTo(0, height);         }         path.close();         return path;     }
@Override     protected void channelRead0(ChannelHandlerContext ctx, Response msg) throws Exception {         answer.add(msg);     }
private AccessPredicateConfigAttribute find(final Collection<ConfigAttribute> attributes) {         for (final ConfigAttribute attribute : attributes) {             if (attribute instanceof AccessPredicateConfigAttribute) {                 return (AccessPredicateConfigAttribute) attribute;             }         }         return null;     }
public static AbstractExpression eliminateDuplicates(Collection<AbstractExpression> exprList) {         // Eliminate duplicates by building the map of expression's ids, values.         Map<String, AbstractExpression> subExprMap = new HashMap<String, AbstractExpression>();         for (AbstractExpression subExpr : exprList) {             subExprMap.put(subExpr.m_id, subExpr);         }         // Now reconstruct the expression         return ExpressionUtil.combinePredicates(subExprMap.values());     }
public ListGroupVersionsResult withVersions(VersionInformation... versions) {         if (this.versions == null) {             setVersions(new java.util.ArrayList<VersionInformation>(versions.length));         }         for (VersionInformation ele : versions) {             this.versions.add(ele);         }         return this;     }
public EClass getBPF() {   if (bpfEClass == null) {    bpfEClass = (EClass)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(216);   }   return bpfEClass;  }
@Deprecated     protected Object readResolve() {         // If we get invalid state from the configuration, fallback to unknown         if (StringUtils.isBlank(name)) {             LOGGER.log(Level.WARNING, ""Read install state with blank name: ''{0}''. It will be ignored"", name);             return UNKNOWN;         }                  InstallState state = InstallState.valueOf(name);         if (state == null) {             LOGGER.log(Level.WARNING, ""Cannot locate an extension point for the state ''{0}''. It will be ignored"", name);             return UNKNOWN;         }                  // Otherwise we return the actual state         return state;     }
public static synchronized List<Class<?>> generateDataSerializerClasses(ClassLoader classLoader,             List<Class<?>> classList, String outputDir) throws CannotCompileException, InvalidClassException {         checkClassesValid(classList);          List<CtClass> dataSerializerClassList = new ArrayList<CtClass>();          // create new ClassPool for every method call         // 1) low memory consumption - any caches with internal data structures of created classes         // 2) any collision between methods called serially - all crated classes are forgotten         // 3) any references on created classes from this lib         ClassPool classPool = newClassPool(classLoader);          // #1: create dataSerializers with stubs toData/fromData         for (Class<?> clazz : classList) {             String serializerClsName = createDataSerializerClassNameForClass(clazz);              if (existsClass(serializerClsName, classLoader)) {                 logger.debug(""Serializer for class {} exists. Skipping generation"", clazz.getName());                 break;             }              // create class             CtClass cc = createClass(classPool, clazz, serializerClsName);              dataSerializerClassList.add(cc);                          // add static Register             addStaticConstruct(clazz, cc, serializerClsName);             // add methods             addMethodGetId(clazz, cc);             addMethodGetSupportedClasses(clazz, cc);             // add stub-methods toData/fromData             addMethodToDataStub(clazz, cc);             addMethodFromDataStub(clazz, cc);             // we need this for Javassist do some magic with CtClass             try {                 cc.toBytecode();             } catch (IOException e) {                 throw new CannotCompileException(                         ""Error during end of compilation phase #1 (call CtClass.toBytecode() for some Javassist-magic with CtClass) for ""                                 + cc.getName(), e);             } catch (CannotCompileException e) {                 throw new CannotCompileException(                         ""Error during end of compilation phase #1 (call CtClass.toBytecode() for some Javassist-magic with CtClass) for ""                                 + cc.getName(), e);             }         }          List<Class<?>> result = new ArrayList<Class<?>>();         // #2: change stubs toData/fromData in dataSerializers -> real methods         for (int k = 0; k < classList.size(); k++) {             Class<?> clazz = classList.get(k);             CtClass cc = dataSerializerClassList.get(k);             // make changing methods real: defrost CtClass             cc.defrost();             // change stub toData/fromData -> real methods             addMethodToData(clazz, cc);             addMethodFromData(clazz, cc);             // generate result             final Class<?> resultClass;             try {                 resultClass = cc.toClass(classLoader, null); // ProtectionDomain == null                 logger.info(""compiled data serializer for class: {}; id: {}; version: {}"",                         new Object[] { clazz, clazz.getAnnotation(AutoSerializable.class).dataSerializerID()                                 , clazz.getAnnotation(BeanVersion.class).value() });                 if ((outputDir != null) && (outputDir.length() > 0)) {                     try {                         cc.writeFile(outputDir);                     } catch (IOException e) {                         throw new RuntimeException(""couldn't save DataSerializer for class "" + clazz.getName(), e);                     }                 }             } catch (CannotCompileException e) {                 throw new CannotCompileException(                         ""Error during end of compilation phase #2 (call CtClass.toClass()) for "" + cc.getName()                                 + "". Probably you second time try generate and load DataSerializer class ""                                 + cc.getName() + "" for class "" + clazz.getName(), e);             }              // dump code to listener             if (listener != null) {                 listener.generated(clazz.getName(), cc.getName(), new ClassProcessor().process(new XClass(clazz), cc.getName()));             }              result.add(resultClass);         }          return result;     }
public boolean isEditable() {          if (m_request == null) {             return false;         }         CmsExplorerTypeSettings settings = OpenCms.getWorkplaceManager().getExplorerTypeSetting(getResourceTypeName());         if (settings != null) {             String rightSite = OpenCms.getSiteManager().getSiteRoot(getResource().getRootPath());             if (rightSite == null) {                 rightSite = """";             }             String currentSite = getCms().getRequestContext().getSiteRoot();             try {                 getCms().getRequestContext().setSiteRoot(rightSite);                 return settings.isEditable(getCms(), getResource());             } finally {                 getCms().getRequestContext().setSiteRoot(currentSite);             }         }         return false;     }
@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U extends Collection<? super T>> Observable<U> buffer(int count, Callable<U> bufferSupplier) {         return buffer(count, count, bufferSupplier);     }
@Override  public java.util.List<com.liferay.commerce.tax.model.CommerceTaxMethod> getCommerceTaxMethods(   int start, int end) {   return _commerceTaxMethodLocalService.getCommerceTaxMethods(start, end);  }
protected ImageDescriptor imageDescriptor(SarlAction element) {   final JvmOperation jvmElement = this.jvmModelAssociations.getDirectlyInferredOperation(element);   return this.images.forOperation(     element.getVisibility(),     this.adornments.get(jvmElement));  }
public void setup(float partialTick)  {   this.partialTick = partialTick;    currentTexture = null;   bindDefaultTexture();    GlStateManager.pushMatrix();   if (ignoreScale)   {    GlStateManager.scale(1F / scaleFactor, 1F / scaleFactor, 1);   }    setupGl();   startDrawing();  }
@SuppressWarnings(""unchecked"")     public <T> T pop(Class<T> declarationClass) {         Object declaration = declarationStack.pop();         if (declarationClass.isAssignableFrom(declaration.getClass())) {             return (T) declaration;         }         return fail(declaration, declarationClass);     }
public void randomize(Random random) {         for (int j = numInstances() - 1; j > 0; j--) {             swap(j, random.nextInt(j + 1));         }     }
public static <T> T min(final Iterable<T> iterable, Comparator<? super T> comparator) {   return IteratorExtensions.min(iterable.iterator(), comparator);  }
public static <T> Randomizer<T> aNewOptionalRandomizer(final Randomizer<T> delegate, final int optionalPercent) {         return new OptionalRandomizer<>(delegate, optionalPercent);     }
@Override  public List<Sequence<AminoAcidCompound>> createSequences(    Sequence<NucleotideCompound> originalSequence) {    List<List<AminoAcidCompound>> workingList = new ArrayList<List<AminoAcidCompound>>();    Iterable<SequenceView<NucleotideCompound>> iter = new WindowedSequence<NucleotideCompound>(     originalSequence, 3);    boolean first = true;    // If not waiting for a start codon, start translating immediately   boolean doTranslate = !waitForStartCodon;    for (SequenceView<NucleotideCompound> element : iter) {    AminoAcidCompound aminoAcid = null;     int i = 1;    Table.CaseInsensitiveTriplet triplet = new Table.CaseInsensitiveTriplet(      element.getCompoundAt(i++), element.getCompoundAt(i++),      element.getCompoundAt(i++));     Codon target = null;     target = quickLookup.get(triplet);     // Check for a start    if (!doTranslate && target.isStart()) {     doTranslate = true;    }     if (doTranslate) {     if (target != null)      aminoAcid = target.getAminoAcid();     if (aminoAcid == null && translateNCodons()) {      aminoAcid = unknownAminoAcidCompound;     } else {      if (first && initMetOnly && target.isStart()) {       aminoAcid = methionineAminoAcidCompound;      }     }      addCompoundsToList(Arrays.asList(aminoAcid), workingList);    }     if (doTranslate && stopAtStopCodons && target.isStop()) {     // Check if we need to stop, but dont stop until started!     break;    }     first = false;   }   postProcessCompoundLists(workingList);    return workingListToSequences(workingList);  }
@Override  public CPAttachmentFileEntry findByLtD_S_Last(Date displayDate, int status,   OrderByComparator<CPAttachmentFileEntry> orderByComparator)   throws NoSuchCPAttachmentFileEntryException {   CPAttachmentFileEntry cpAttachmentFileEntry = fetchByLtD_S_Last(displayDate,     status, orderByComparator);    if (cpAttachmentFileEntry != null) {    return cpAttachmentFileEntry;   }    StringBundler msg = new StringBundler(6);    msg.append(_NO_SUCH_ENTITY_WITH_KEY);    msg.append(""displayDate="");   msg.append(displayDate);    msg.append("", status="");   msg.append(status);    msg.append(""}"");    throw new NoSuchCPAttachmentFileEntryException(msg.toString());  }
public void clear() {         mPackedAxisBits = 0;          x = 0;         y = 0;         pressure = 0;         size = 0;         touchMajor = 0;         touchMinor = 0;         toolMajor = 0;         toolMinor = 0;         orientation = 0;     }
@Nullable     public static <T extends Parcelable> T optParcelable(@Nullable Bundle bundle, @Nullable String key, @Nullable T fallback) {         if (bundle == null) {             return fallback;         }         return bundle.getParcelable(key);     }
public void serializePrimitive(S rec, String fieldName, long value) {         serializePrimitive(rec, fieldName, Long.valueOf(value));     }
public static Number calStats(String statsString,             DoubleStream numberStream) {         return StatsField.valueOfAlias(statsString).calStats(numberStream);     }
private void overrideConfigFromFile(Configuration config) throws IOException {     String configFile = GCS_CONFIG_OVERRIDE_FILE.get(config, config::get);     if (configFile != null) {       config.addResource(new FileInputStream(configFile));     }   }
public static Result preconditionRequired(Path content, String filename) {     return preconditionRequired(content, filename, StaticFileMimeTypes.fileMimeTypes());   }
public boolean isConstantResponse() {     double m = Double.NaN;     for( int b=0; b<_bins.length; b++ ) {       if( _bins[b] == 0 ) continue;       if( var(b) > 1e-14 ) return false;       double mean = mean(b);       if( mean != m )         if( Double.isNaN(m) ) m=mean;         else if(Math.abs(m - mean) > 1e-6) return false;     }     return true;   }
private Map getUsers() throws NamingException {          String filter = ""("" + roleNameRDN + ""=*)"";          HashMap users = new HashMap();          NamingEnumeration results = this.search(roleBase, filter, new String[]{roleMemberRDN});         while (results != null && results.hasMore()) {              SearchResult roleResult = (SearchResult) results.next();              String roleResultName = roleResult.getName();             if ("""".equals(roleResultName)) {                 continue;             }              String roleResultValue = (roleResultName.split(""=""))[1];              Attributes roleAttrs = roleResult.getAttributes();              Attribute roleAttr = roleAttrs.get(roleMemberRDN);             NamingEnumeration valueEnum = roleAttr.getAll();             while (valueEnum != null && valueEnum.hasMore()) {                 String value = (String) valueEnum.next();                  String name;                 if (value.endsWith("","" + userBase)) {                     name = value.substring(0, value.length() - userBase.length() - 1);                     name = name.split(""="")[1];                 } else {                     log.debug(""found unrecognized DN: "" + value);                     continue;                 }                  if (users.containsKey(name)) {                     HashSet roles = (HashSet) users.get(name);                     roles.add(roleResultValue);                 } else {                     HashSet roles = new HashSet();                     roles.add(roleResultValue);                     users.put(name, roles);                 }             }         }         return users;      }
public void marshall(Job job, ProtocolMarshaller protocolMarshaller) {          if (job == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(job.getJobArn(), JOBARN_BINDING);             protocolMarshaller.marshall(job.getJobId(), JOBID_BINDING);             protocolMarshaller.marshall(job.getTargetSelection(), TARGETSELECTION_BINDING);             protocolMarshaller.marshall(job.getStatus(), STATUS_BINDING);             protocolMarshaller.marshall(job.getForceCanceled(), FORCECANCELED_BINDING);             protocolMarshaller.marshall(job.getReasonCode(), REASONCODE_BINDING);             protocolMarshaller.marshall(job.getComment(), COMMENT_BINDING);             protocolMarshaller.marshall(job.getTargets(), TARGETS_BINDING);             protocolMarshaller.marshall(job.getDescription(), DESCRIPTION_BINDING);             protocolMarshaller.marshall(job.getPresignedUrlConfig(), PRESIGNEDURLCONFIG_BINDING);             protocolMarshaller.marshall(job.getJobExecutionsRolloutConfig(), JOBEXECUTIONSROLLOUTCONFIG_BINDING);             protocolMarshaller.marshall(job.getAbortConfig(), ABORTCONFIG_BINDING);             protocolMarshaller.marshall(job.getCreatedAt(), CREATEDAT_BINDING);             protocolMarshaller.marshall(job.getLastUpdatedAt(), LASTUPDATEDAT_BINDING);             protocolMarshaller.marshall(job.getCompletedAt(), COMPLETEDAT_BINDING);             protocolMarshaller.marshall(job.getJobProcessDetails(), JOBPROCESSDETAILS_BINDING);             protocolMarshaller.marshall(job.getTimeoutConfig(), TIMEOUTCONFIG_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public static Object invoke(final Object bean, Class clazz, final String name) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {         Method method = clazz.getDeclaredMethod(name);         method.setAccessible(true);         return method.invoke(bean);     }
public int readTag() throws IOException {     if (isAtEnd()) {       lastTag = 0;       return 0;     }      final int tag = readRawVarint32();     if (tag >>> WireFormat.TAG_TYPE_BITS == 0) {       // If we actually read zero, that's not a valid tag.       throw ProtobufException.invalidTag();     }     lastTag = tag;     return tag;   }
public BitmapFactory.Options getDataBounds() {         BitmapFactory.Options options = new BitmapFactory.Options();         options.inJustDecodeBounds = true;         byte[] data = getData();         BitmapFactory.decodeByteArray(data, 0, data.length, options);         return options;     }
public void setTypes(Class<K> keyType, Class<V> valueType) {     delegate.setTypes(keyType, valueType);   }
public Blob updateBlobWithMetageneration(String bucketName, String blobName) {     // [START updateBlobWithMetageneration]     Blob blob = storage.get(bucketName, blobName);     BlobInfo updatedInfo = blob.toBuilder().setContentType(""text/plain"").build();     storage.update(updatedInfo, BlobTargetOption.metagenerationMatch());     // [END updateBlobWithMetageneration]     return blob;   }
public static <T extends Model> T createIt(Object ... namesAndValues){         return ModelDelegate.createIt(Model.<T>modelClass(), namesAndValues);     }
public Packer setXLeftRelative(final boolean how) {         if (how == true) {             gc.gridx = GridBagConstraints.RELATIVE;         } else {             gc.gridx = 0;         }         setConstraints(comp, gc);         return this;     }
public Object run(File scriptFile, List list) throws CompilationFailedException, IOException {         String[] args = new String[list.size()];         return run(scriptFile, (String[]) list.toArray(args));     }
@Override     public void recover() {          // not revoverable         if (this.getCoreConnection() == null || !ImplementorUtils.isImplementationOf(getCoreConnection(), IXADataRecorderAware.class)) {             return;         }          IXADataRecorderAware con = ImplementorUtils.cast(getCoreConnection(), IXADataRecorderAware.class);          // the connection has to re establish the state of the message LOG         IXADataRecorder msgLogger = this.getXADataRecorder();         if (msgLogger.isEmpty()) {             return;         }         this.fireConnectionRecovering();         IDataRecordReplay dataRecordReplay = con.recoverReplayListener();          if( dataRecordReplay==null) {             throw new IllegalStateException(""IPhynixxConnection.recoverReplayListener() has to provide a IDataRecordReplay to be recovered"");         }          // msgLogger.recover();         msgLogger.replayRecords(dataRecordReplay);          this.fireConnectionRecovered();      }
public static MozuUrl getProductUrl(Boolean acceptVariantProductCode, Boolean allowInactive, String productCode, String purchaseLocation, Integer quantity, String responseFields, Boolean skipInventoryCheck, Boolean supressOutOfStock404, String variationProductCode, String variationProductCodeFilter)   {    UrlFormatter formatter = new UrlFormatter(""/api/commerce/catalog/storefront/products/{productCode}?variationProductCode={variationProductCode}&allowInactive={allowInactive}&skipInventoryCheck={skipInventoryCheck}&supressOutOfStock404={supressOutOfStock404}&quantity={quantity}&acceptVariantProductCode={acceptVariantProductCode}&purchaseLocation={purchaseLocation}&variationProductCodeFilter={variationProductCodeFilter}&responseFields={responseFields}"");    formatter.formatUrl(""acceptVariantProductCode"", acceptVariantProductCode);    formatter.formatUrl(""allowInactive"", allowInactive);    formatter.formatUrl(""productCode"", productCode);    formatter.formatUrl(""purchaseLocation"", purchaseLocation);    formatter.formatUrl(""quantity"", quantity);    formatter.formatUrl(""responseFields"", responseFields);    formatter.formatUrl(""skipInventoryCheck"", skipInventoryCheck);    formatter.formatUrl(""supressOutOfStock404"", supressOutOfStock404);    formatter.formatUrl(""variationProductCode"", variationProductCode);    formatter.formatUrl(""variationProductCodeFilter"", variationProductCodeFilter);    return new MozuUrl(formatter.getResourceUrl(), MozuUrl.UrlLocation.TENANT_POD) ;   }
public CmsListDefaultAction removeDefaultAction(String actionId) {          Iterator<CmsListDefaultAction> it = m_defaultActions.iterator();         while (it.hasNext()) {             CmsListDefaultAction action = it.next();             if (action.getId().equals(actionId)) {                 it.remove();                 return action;             }         }         return null;     }
public Retrofit build() {         checkState(baseUrl != null, ""baseUrl not set"");         final URI uri = URI.create(baseUrl);         final String fullUri = SessionProtocol.of(uri.getScheme()) + ""://"" + uri.getAuthority();         final HttpClient baseHttpClient = HttpClient.of(                 clientFactory, fullUri, configurator.apply(fullUri, new ClientOptionsBuilder()).build());         return retrofitBuilder.baseUrl(convertToOkHttpUrl(baseHttpClient, uri.getPath(), GROUP_PREFIX))                               .callFactory(new ArmeriaCallFactory(                                       baseHttpClient, clientFactory, configurator,                                       streaming ? SubscriberFactory.streaming(callbackExecutor)                                                 : SubscriberFactory.blocking()))                               .build();     }
public synchronized void deserialize(DataInputStream source,                                           ServerVersion sv,                                           StatusUI statusUI)              throws IOException, EOFException, DataReadException {          for (int i = 0; i < vals.length; i++) {              // create new variable from template              vals[i] = (BaseType) getTemplate().clone();              ((ClientIO) vals[i]).deserialize(source, sv, statusUI);              if (statusUI != null && statusUI.userCancelled())                  throw new DataReadException(""User cancelled"");          }      }
public static List<SVGPath> loadSVGIconFromUri(final String uri, final Class clazz) throws CouldNotPerformException {         try {              InputStream inputStream = clazz.getResourceAsStream(uri);             if (inputStream == null) {                 inputStream = clazz.getClassLoader().getResourceAsStream(uri);                 if (inputStream == null) {                     throw new NotAvailableException(uri);                 }             }             return generateSvgPathList(IOUtils.toString(inputStream, StandardCharsets.UTF_8));         } catch (final Exception ex) {             throw new CouldNotPerformException(""Could not load URI["" + uri + ""]"", ex);         }     }
public void setVariableOrder(final Variable... varOrder) {     this.kernel.setNumberOfVars(varOrder.length);     for (final Variable lit : varOrder) {       final int idx = this.var2idx.size();       this.var2idx.put(lit.variable(), idx);       this.idx2var.put(idx, lit.variable());     }   }
Attribute modify(             final AttributeDefinition definition,             final String completeName,             final String value,             final AttributeValueQuotes valueQuotes) {          return new Attribute(                 (definition == null? this.definition : definition),                 (completeName == null? this.completeName : completeName),                 this.operator,                 value, // This is not keepable                 (valueQuotes == null? this.valueQuotes : valueQuotes),                 this.templateName,                 this.line,                 this.col);     }
public ListUserGroupsResult withGroupList(Group... groupList) {         if (this.groupList == null) {             setGroupList(new java.util.ArrayList<Group>(groupList.length));         }         for (Group ele : groupList) {             this.groupList.add(ele);         }         return this;     }
public static HttpHeaders toArmeria(Http2Headers headers, boolean endOfStream) {         final HttpHeaders converted = new DefaultHttpHeaders(false, headers.size(), endOfStream);         StringJoiner cookieJoiner = null;         for (Entry<CharSequence, CharSequence> e : headers) {             final AsciiString name = HttpHeaderNames.of(e.getKey());             final CharSequence value = e.getValue();              // Cookies must be concatenated into a single octet string.             // https://tools.ietf.org/html/rfc7540#section-8.1.2.5             if (name.equals(HttpHeaderNames.COOKIE)) {                 if (cookieJoiner == null) {                     cookieJoiner = new StringJoiner(COOKIE_SEPARATOR);                 }                 COOKIE_SPLITTER.split(value).forEach(cookieJoiner::add);             } else {                 converted.add(name, convertHeaderValue(name, value));             }         }          if (cookieJoiner != null && cookieJoiner.length() != 0) {             converted.add(HttpHeaderNames.COOKIE, cookieJoiner.toString());         }          return converted;     }
private static String key2Str(Key k, byte type) {     String s = key2Str_impl(k, type);     Key x;     assert (x = str2Key_impl(s)).equals(k) : ""bijection fail "" + k + ""."" + (char) type + "" <-> "" + s + "" <-> "" + x;     return s;   }
@Override     public String readUTF() throws JMSException {         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())             SibTr.entry(this, tc, ""readUTF"");         String result;          try {             // Check that we are in read mode             checkBodyReadable(""readUTF"");             if (requiresInit)                 lazyInitForReading();              // Mark the current position, so we can return to it if there's an error             readStream.mark(8); // the argument appears to be ignored              result = readStream.readUTF();             if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())                 SibTr.exit(this, tc, ""readUTF"", result);             return result;         } catch (IOException e) {             try {                 readStream.reset(); // return to the marked position             } catch (IOException e2) {             }             JMSException jmse = (JMSException) JmsErrorUtils.newThrowable(                                                             MessageEOFException.class,                                                             ""END_BYTESMESSAGE_CWSIA0183"",                                                             null,                                                             tc);             jmse.initCause(e);             throw jmse;         }     }
public void finishMapJson(final JsonConvert convert, final Object... objs) {          this.contentType = this.jsonContentType;          if (this.recycleListener != null) this.output = objs;          finish(convert.convertMapTo(getBodyBufferSupplier(), objs));      }
private static void onePointCrossover(Program gp1, Program gp2, LGP manager, RandEngine randEngine) {       // Xianshun says:       // this implementation is derived from Algorithm 5.1 in Section 5.7.1 of Linear       // Genetic Programming        // length(gp1) <= length(gp2)       if (gp1.length() > gp2.length())       {          gp1 = gp2;          gp2 = gp1;       }        int max_distance_of_crossover_points = (gp1.length() - 1) < manager.getMaxDistanceOfCrossoverPoints() ? manager.getMaxDistanceOfCrossoverPoints() : (gp1.length() - 1);        int i1 = randEngine.nextInt(gp1.length());       int i2 = randEngine.nextInt(gp2.length());        int crossover_point_distance = (i1 > i2) ? (i1 - i2) : (i2 - i1);        int ls1 = gp1.length() - i1;       int ls2 = gp2.length() - i2;        // 1. assure abs(i1-i2) <= max_distance_of_crossover_points       // 2. assure l(s1) <= l(s2)       boolean not_feasible=true;       int count = 0;       while (not_feasible && count < 10) {          not_feasible = false;          // ensure that the maximum distance between two crossover points is not exceeded          if (crossover_point_distance > max_distance_of_crossover_points) {             not_feasible = true;             i1 = randEngine.nextInt(gp1.length());             i2 = randEngine.nextInt(gp2.length());             crossover_point_distance = (i1 > i2) ? (i1 - i2) : (i2 - i1);          }          else {             ls1 = gp1.length() - i1;             ls2 = gp2.length() - i2;             // assure than l(s1) <= l(s2)             if (ls1 > ls2) {                not_feasible = true;                i1 = randEngine.nextInt(gp1.length());                i2 = randEngine.nextInt(gp2.length());                crossover_point_distance = (i1 > i2) ? (i1 - i2) : (i2 - i1);             }             else {                // assure the length of the program after crossover do not exceed the maximum program length or below minimum program length                if ((gp2.length() - (ls2 - ls1)) < manager.getMinProgramLength() || (gp1.length() + (ls2 - ls1)) > manager.getMaxProgramLength()) {                   not_feasible = true;                   // when the length constraint is not satisfied, make the segments to be exchanged the same length                   if (gp1.length() >= gp2.length()) {                      i1 = i2;                   }                   else {                      i2 = i1;                   }                   crossover_point_distance = 0;                }                else {                   not_feasible = false;                }             }          }          count++;       }        List<Instruction> instructions1 = gp1.getInstructions();       List<Instruction> instructions2 = gp2.getInstructions();        List<Instruction> instructions1_1 = new ArrayList<>();       List<Instruction> instructions1_2 = new ArrayList<>();        List<Instruction> instructions2_1 = new ArrayList<>();       List<Instruction> instructions2_2 = new ArrayList<>();        for (int i = 0; i < i1; ++i)       {          instructions1_1.add(instructions1.get(i));       }       for (int i = i1; i < instructions1.size(); ++i)       {          instructions1_2.add(instructions1.get(i));       }        for (int i = 0; i < i2; ++i)       {          instructions2_1.add(instructions2.get(i));       }       for (int i = i2; i < instructions2.size(); ++i)       {          instructions2_2.add(instructions2.get(i));       }        instructions1.clear();       instructions2.clear();        for (int i = 0; i < i1; ++i)       {          instructions1.add(instructions1_1.get(i));       }       for (int i = 0; i < instructions2_2.size(); ++i)       {          instructions1.add(InstructionHelper.reassign2Program(instructions2_2.get(i), gp1));       }        for (int i = 0; i < i2; ++i)       {          instructions2.add(instructions2_1.get(i));       }        for (int i = 0; i < instructions1_2.size(); ++i)       {          instructions2.add(InstructionHelper.reassign2Program(instructions1_2.get(i), gp2));       }        gp1.invalidateCost();       gp2.invalidateCost();    }
public ValidationResult check(Entry entry) {   result = new ValidationResult();    if(entry == null || entry.getSequence() == null) {    return result;   }   // checks the CONTIG/CO line locations cover the sequence length   if (entry.getSequence().getContigs() != null && entry.getSequence().getContigs().size() != 0) {    result = checkContigLocation(entry);   }    //collect all sources   List<SourceFeature> sources = new ArrayList<SourceFeature>();   for (Feature feature : entry.getFeatures()) {    if (feature instanceof SourceFeature) {     sources.add((SourceFeature) feature);    }   }    if (sources.isEmpty()) {    return result;   }    //checks sequence   Sequence sequence = entry.getSequence();   if (sequence == null) {    return result;   }   Long sequenceSize = sequence.getLength();    //collection sources' locations   boolean hasTransgenic = false;   List<Location> sourceLocations = new ArrayList<>();   boolean isSourceFocuswithFullSequenceCoverage = false;   Origin firstSourceOrigin = sources.get(0).getOrigin();    for (SourceFeature source : sources) {    List<Location> locations = source.getLocations().getLocations();     if (!source.isTransgenic() && !source.isFocus()) {     if (!locations.isEmpty()) {      sourceLocations.add(locations.iterator().next());     }    } else {     if (hasTransgenic || isSourceFocuswithFullSequenceCoverage) {      reportError(source.getOrigin(), MESSAGE_ID_TRANSGENIC_FOCUS_OCCURRENCE);     }      if (source.isTransgenic()) {      hasTransgenic = true;      if(sequenceSize > source.getLength())       reportError(source.getOrigin(), MESSAGE_ID_TRANSGENIC_SEQUENCE_COVERAGE);     }      if (source.isFocus() && sequenceSize == source.getLength()) {      isSourceFocuswithFullSequenceCoverage = true;     }    }    }    if (sourceLocations.isEmpty() && !isSourceFocuswithFullSequenceCoverage) {    reportCoverageError(result, entry.getOrigin(), MESSAGE_ID_NO_LOCATIONS, 0, sequenceSize);    return result;   }    //sorts location so they will be checked in proper order   Collections.sort(sourceLocations, (o1, o2) -> o1.getBeginPosition().compareTo(o2.getBeginPosition()));    Iterator<Location> locationIter = sourceLocations.iterator();   Location location = locationIter.next();   Long[] firstLocation = checkLocation(location);    //checks first location   if (firstLocation[0] != 1 && !hasTransgenic) {    result.append(EntryValidations.createMessage(firstSourceOrigin, Severity.ERROR, MESSAGE_ID_FIRST_BASE_ERROR, firstLocation[0]));    return result;   }    Long[] lastLocationPositions = null;   if (sourceLocations.size() == 1) {    lastLocationPositions = firstLocation;   } else {    //check further locations    for (; locationIter.hasNext(); ) {     location = locationIter.next();     lastLocationPositions = checkLocation(location);      if ((firstLocation[1] + 1) != lastLocationPositions[0]) {//not contiguous      if ((firstLocation[1] + 1) > lastLocationPositions[0]) {       //there is an overlap, add error       reportCoverageError(result, firstSourceOrigin, MESSAGE_ID_LOCATIONS_OVERLAP, 0, sequenceSize);      } else if (!isSourceFocuswithFullSequenceCoverage && !hasTransgenic){       reportCoverageError(result, firstSourceOrigin, MESSAGE_ID_GAPS_IN_LOCATIONS, 0, sequenceSize);      }      return result;     }      firstLocation[1] = lastLocationPositions[1];    }    }    if(lastLocationPositions!= null && lastLocationPositions[0] != null && lastLocationPositions[1] != null) {    if (lastLocationPositions[1] > sequenceSize) {//longer than     reportCoverageError(result, firstSourceOrigin, MESSAGE_ID_LONG, firstLocation[1], sequenceSize);    } else if (lastLocationPositions[1] < sequenceSize && !hasTransgenic && !isSourceFocuswithFullSequenceCoverage) {     reportCoverageError(result, firstSourceOrigin, MESSAGE_ID_SHORT, firstLocation[1], sequenceSize);    }   }         return result;     }
public static Node getStrictCmml(String mathml) {         try {             // get ContentMathML to Strict ContentMathML and finally the abstract CD             CMMLInfo cmmlInfo = new CMMLInfo(mathml).toStrictCmml();              /*               Don't use:               Abstract2CD nicht benutzen! Sobald ein Knoten tatsächlich umbenannt               wird, verliert dieser Knoten alle Kinder! Stattdessen kann auf dem               späteren MathNode ein separater toAbstract aufruf erfolgen.              */              // and finally only get the first apply node of the ContentMathML             return getFirstApplyNode(cmmlInfo);         } catch (Exception e) {             logger.error(""failed to get apply node"", e);             return null;         }     }
private Matrix getThisSideMatrix(Matrix B)     {         if(this.canBeMutated())             return this.clone();         else//so far, only other option in JSAT is a dense matrix         {             DenseMatrix dm = new DenseMatrix(rows(), cols());             dm.mutableAdd(this);             return dm;         }     }
public String getProcessInstanceId() {     Execution execution = associationManager.getExecution();     return execution != null ? execution.getProcessInstanceId() : null;   }
public boolean handlePopBox(String deviceBrand) {     pushHandleGps2Device();     CommandLine exeCommand = null;     if (deviceBrand.contains(""HTC"")) {        exeCommand = adbCommand(""shell"", ""uiautomator"", ""runtest"",           ""/data/local/tmp/handlePopBox.jar"", ""-c"", ""com.test.device.gps.HTCGPSTest"");     } else if (deviceBrand.contains(""Meizu"")) {        exeCommand = adbCommand(""shell"", ""uiautomator"", ""runtest"",           ""/data/local/tmp/handlePopBox.jar"", ""-c"", ""com.test.device.gps.MeizuGPSTest"");     }      String output = executeCommandQuietly(exeCommand);     log.debug(""run test {}"", output);      try {       // give it a second to recover from the activity start       Thread.sleep(1000);     } catch (InterruptedException ie) {       throw new RuntimeException(ie);     }     return output.contains(""OK"");   }
public static boolean verifyPurchase(@NotNull String base64PublicKey, @NotNull String signedData, @NotNull String signature) {         if (TextUtils.isEmpty(signedData) || TextUtils.isEmpty(base64PublicKey)                 || TextUtils.isEmpty(signature)) {             Logger.e(""Purchase verification failed: missing data."");             return false;         }          PublicKey key = Security.generatePublicKey(base64PublicKey);         return Security.verify(key, signedData, signature);     }
@GwtIncompatible(""InputStream"")   static InputStream asInputStream(final ByteInput input) {     checkNotNull(input);     return new InputStream() {       @Override       public int read() throws IOException {         return input.read();       }        @Override       public int read(byte[] b, int off, int len) throws IOException {         checkNotNull(b);         checkPositionIndexes(off, off + len, b.length);         if (len == 0) {           return 0;         }         int firstByte = read();         if (firstByte == -1) {           return -1;         }         b[off] = (byte) firstByte;         for (int dst = 1; dst < len; dst++) {           int readByte = read();           if (readByte == -1) {             return dst;           }           b[off + dst] = (byte) readByte;         }         return len;       }        @Override       public void close() throws IOException {         input.close();       }     };   }
public void poll(int delta) {    if (!soundWorks) {     return;    }    if (paused) {     return;    }      if (music) {     if (mod != null) {      try {       mod.poll();      } catch (OpenALException e) {       Log.error(""Error with OpenGL MOD Player on this this platform"");       Log.error(e);       mod = null;      }     }     if (stream != null) {      try {       stream.update();      } catch (OpenALException e) {       Log.error(""Error with OpenGL Streaming Player on this this platform"");       Log.error(e);       mod = null;      }     }    }   }
public int getGroupForPrimary(long p) {         p >>= 16;         if(p < scriptStarts[1] || scriptStarts[scriptStarts.length - 1] <= p) {             return -1;         }         int index = 1;         while(p >= scriptStarts[index + 1]) { ++index; }         for(int i = 0; i < numScripts; ++i) {             if(scriptsIndex[i] == index) {                 return i;             }         }         for(int i = 0; i < MAX_NUM_SPECIAL_REORDER_CODES; ++i) {             if(scriptsIndex[numScripts + i] == index) {                 return Collator.ReorderCodes.FIRST + i;             }         }         return -1;     }
public OvhConfigurationItem cart_cartId_item_itemId_configuration_configurationId_GET(String cartId, Long itemId, Long configurationId) throws IOException {   String qPath = ""/order/cart/{cartId}/item/{itemId}/configuration/{configurationId}"";   StringBuilder sb = path(qPath, cartId, itemId, configurationId);   String resp = execN(qPath, ""GET"", sb.toString(), null);   return convertTo(resp, OvhConfigurationItem.class);  }
private void updateMeta(BundleMeta meta) {     final int cols = meta.size();     densecols = new NumberVector.Factory<?>[cols];     for(int i = 0; i < cols; i++) {       if(TypeUtil.SPARSE_VECTOR_VARIABLE_LENGTH.isAssignableFromType(meta.get(i))) {         throw new AbortException(""Filtering sparse vectors is not yet supported by this filter. Please contribute."");       }       if(TypeUtil.NUMBER_VECTOR_VARIABLE_LENGTH.isAssignableFromType(meta.get(i))) {         VectorFieldTypeInformation<?> vmeta = (VectorFieldTypeInformation<?>) meta.get(i);         densecols[i] = (NumberVector.Factory<?>) vmeta.getFactory();         continue;       }     }   }
public String getRegistryNumber() {     if (Chemical_Type.featOkTst && ((Chemical_Type)jcasType).casFeat_registryNumber == null)       jcasType.jcas.throwFeatMissing(""registryNumber"", ""de.julielab.jules.types.Chemical"");     return jcasType.ll_cas.ll_getStringValue(addr, ((Chemical_Type)jcasType).casFeatCode_registryNumber);}
private final boolean remove(DeliveryDelayableReference deliveryDelayableReference, boolean unlocked)     {         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())             SibTr.entry(this, tc, ""remove"",                         "" deliveryDelayableReference="" + deliveryDelayableReference + "" unlocked="" +                                         unlocked + "" deliveryDelayIndex="" + deliveryDelayIndex.size());          boolean reply = false;         // synchronize on the lockObject         synchronized (lockObject)         {             reply = deliveryDelayIndex.remove();         }         if (reply)         {             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())                 SibTr.debug(tc, ""Removed ("" + (unlocked ? ""unlocked"" : ""gone"") + "")"" + "" DDT="" + deliveryDelayableReference.getDeliveryDelayTime() + "" objId=""                                 + deliveryDelayableReference.getID() + "" DeliveryDelayIndexSize="" + deliveryDelayIndex.size());         }         else         {             // can happen if the element is already deleted             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())                 SibTr.debug(tc, ""Did not remove from index: "" + "" DDT="" + deliveryDelayableReference.getDeliveryDelayTime() + "" objId="" + deliveryDelayableReference.getID());         }         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())             SibTr.exit(this, tc, ""remove"", ""deliveryDelayIndex="" + deliveryDelayIndex.size() + "" reply="" + reply);          return reply;     }
public ServiceFuture<IssuerBundle> updateCertificateIssuerAsync(String vaultBaseUrl, String issuerName, final ServiceCallback<IssuerBundle> serviceCallback) {         return ServiceFuture.fromResponse(updateCertificateIssuerWithServiceResponseAsync(vaultBaseUrl, issuerName), serviceCallback);     }
public void mergeWith(ReturnPathType fact) {         if (fact.isTop()) {             // other fact is top: no change to this one             return;         } else if (this.isTop()) {             // this fact is top: copy other fact             this.copyFrom(fact);         } else {             // neither fact is top: as long as one of the two             // facts represents a (possible) normal return, then the result             // is a possible normal return             if (fact.type == CAN_RETURN_NORMALLY) {                 this.type = CAN_RETURN_NORMALLY;             }         }     }
void index(int indexToNavigateTo) {         this.index = 0;         this.offset = 0;         this.nextSplit = StringUtil.indexOf(path, '.', 0);         this.token = null;          for (int i = 1; i <= indexToNavigateTo; i++) {             if (!advanceToNextToken()) {                 throw new IndexOutOfBoundsException(""Index out of bound "" + indexToNavigateTo + "" in "" + path);             }         }     }
@Deprecated   public static Terminals caseInsensitive(String[] ops, String[] keywords) {     return operators(ops).words(Scanners.IDENTIFIER).caseInsensitiveKeywords(asList(keywords)).build();   }
public Object getColumnValue(String columnName) {   for ( int j = 0; j < columnNames.length; j++ ) {    if ( columnNames[j].equals( columnName ) ) {     return columnValues[j];    }   }   return null;  }
private int addView( DMatrixRMaj P , Point2D_F64 a , int index ) {    final double sx = stats.stdX, sy = stats.stdY; //  final double cx = stats.meanX, cy = stats.meanY;     // Easier to read the code when P is broken up this way   double r11 = P.data[0], r12 = P.data[1], r13 = P.data[2],  r14=P.data[3];   double r21 = P.data[4], r22 = P.data[5], r23 = P.data[6],  r24=P.data[7];   double r31 = P.data[8], r32 = P.data[9], r33 = P.data[10], r34=P.data[11];    // These rows are derived by applying the scaling matrix to pixels and camera matrix   // px = (a.x/sx - cx/sx)   // A[0,0] = a.x*r31 - r11            (before normalization)   // A[0,0] = px*r31 - (r11-cx*r31)/sx (after normalization)    // first row   A.data[index++] = (a.x*r31-r11)/sx;   A.data[index++] = (a.x*r32-r12)/sx;   A.data[index++] = (a.x*r33-r13)/sx;   A.data[index++] = (a.x*r34-r14)/sx;    // second row   A.data[index++] = (a.y*r31-r21)/sy;   A.data[index++] = (a.y*r32-r22)/sy;   A.data[index++] = (a.y*r33-r23)/sy;   A.data[index++] = (a.y*r34-r24)/sy;    return index;  }
@Override     public void close() throws Exception {                   if(webConnection_closeComplete){             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                 Tr.debug(tc, ""WebConnection close previously completed ...return "");             }             return;         }         else{             // this is for the case to avoid infinite loop if handler destroy end up calling webconnection close.               if(upgradeHandler_DestroyStarted){                 return;             }             synchronized(this) {                 //check it again                  if(webConnection_closeComplete || webConnection_closeOngoing){                     if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                         Tr.debug(tc, ""WebConnection close previously completed .....return "");                     }                     return;                 }                 webConnection_closeOngoing = true;                   //      Call UpgradeHandler destroy() API.                       //upgradeHandler_DestroyComplete  is needed if close is called again from complete , we do not call destroy again                 if (!upgradeHandler_DestroyComplete && _upgradeHandler != null) {                      /// call application handler class destroy                      try{                          if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                             Tr.debug(tc, ""call Handler destroy ""+ this._upgradeHandler);                                               }                          upgradeHandler_DestroyStarted= true;                         _upgradeHandler.destroy();                     }                     finally{                         upgradeHandler_DestroyComplete = true;                         upgradeHandler_DestroyStarted= false;                         if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                             Tr.debug(tc, ""Handler destroy successful""+ this._upgradeHandler);                                               }                     }                 }                            if(_in != null && (_in.getInputBufferHelper().get_tcpChannelCallback() != null)){                     if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                         Tr.debug(tc, "" input callback"");                     }                     inputCallback = true;                 }                  //close the streams , make sure even if one fails we close rest.                  try{                     if(_in!= null)                         _in.close();                 }catch(IOException ioe){                     if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                         Tr.debug(tc, "" closing of inputStream failed .."");                     }                     closeUpgradeException = ioe;                 }                  // now close output                 // close connection                 closeOutputandConnection();             }         }     }
public double[] transformToVector() throws Exception {    if (vectorLength > vladAggregator.getVectorLength() || vectorLength <= 0) {     throw new Exception(""Vector length should be between 1 and "" + vladAggregator.getVectorLength());    }      // the local features are extracted    double[][] features;    if (image == null) { // first the image is read if the image field is null     try { // first try reading with the default class      image = ImageIO.read(new File(imageFolder + imageFilename));     } catch (IllegalArgumentException e) {      // this exception is probably thrown because of a greyscale jpeg image      System.out.println(""Exception: "" + e.getMessage() + "" | Image: "" + imageFilename);      // retry with the modified class      image = ImageIOGreyScale.read(new File(imageFolder + imageFilename));     }    }      // next the image is scaled    ImageScaling scale = new ImageScaling(maxImageSizeInPixels);    try {     image = scale.maxPixelsScaling(image);    } catch (Exception e) {     throw new Exception(""Exception thrown when scaling the image!\n"" + e.getMessage());    }    // next the local features are extracted    features = featureExtractor.extractFeatures(image);      // next the features are aggregated    double[] vladVector = vladAggregator.aggregate(features);      if (vladVector.length == vectorLength) {     // no projection is needed     return vladVector;    } else {     // pca projection is applied     double[] projected = pcaProjector.sampleToEigenSpace(vladVector);     return projected;    }   }
@Override  public Class[] resolveTables() {   List<Class> classes = new ArrayList<>(tableNames.length);   String lastTableName = null;   resultColumns.clear();    for (int i = 0; i < tableNames.length; i++) {    String tableName = tableNames[i];    String columnName = columnNames[i];     if (tableName == null) {     // maybe JDBC driver does not support it     throw new DbOomException(dbOomQuery, ""Table name missing in meta-data"");    }     if ((!tableName.equals(lastTableName)) || (resultColumns.contains(columnName))) {     resultColumns.clear();     lastTableName = tableName;      DbEntityDescriptor ded = dbEntityManager.lookupTableName(tableName);     if (ded == null) {      throw new DbOomException(dbOomQuery, ""Table name not registered: "" + tableName);     }      classes.add(ded.getType());    }    resultColumns.add(columnName);   }   return classes.toArray(new Class[0]);  }
@Override   public boolean isValid(NcssGridParamsBean params, ConstraintValidatorContext constraintValidatorContext) {      constraintValidatorContext.disableDefaultConstraintViolation();     boolean isValid = true;      // lat/lon point     if (params.getLatitude() != null || params.getLongitude() != null) {       if (!params.hasLatLonPoint()) {         isValid = false;         constraintValidatorContext.buildConstraintViolationWithTemplate(""{thredds.server.ncSubset.validation.lat_or_lon_missing}"").addConstraintViolation();       }     }      // lat/lon bb     if (params.getNorth() != null || params.getSouth() != null || params.getEast() != null || params.getWest() != null) {       if (!params.hasLatLonBB()) {         isValid = false;         constraintValidatorContext.buildConstraintViolationWithTemplate(""{thredds.server.ncSubset.validation.wrong_bbox}"").addConstraintViolation();       }        if (params.getNorth() < params.getSouth()) {         isValid = false;         constraintValidatorContext.buildConstraintViolationWithTemplate(""{thredds.server.ncSubset.validation.north_south}"").addConstraintViolation();       }       if (params.getEast() < params.getWest()) {         isValid = false;         constraintValidatorContext.buildConstraintViolationWithTemplate(""{thredds.server.ncSubset.validation.east_west}"").addConstraintViolation();       }     }      // proj bb     if (params.getMaxx() != null || params.getMinx() != null || params.getMaxy() != null || params.getMiny() != null) {       if (!params.hasProjectionBB()) {         isValid = false;         constraintValidatorContext.buildConstraintViolationWithTemplate(""{thredds.server.ncSubset.validation.wrong_pbox}"").addConstraintViolation();       }        if (params.getMaxx() < params.getMinx()) {         isValid = false;         constraintValidatorContext.buildConstraintViolationWithTemplate(""{thredds.server.ncSubset.validation.rangex}"").addConstraintViolation();       }       if (params.getMaxy() < params.getMiny()) {         isValid = false;         constraintValidatorContext.buildConstraintViolationWithTemplate(""{thredds.server.ncSubset.validation.rangey}"").addConstraintViolation();       }     }      // runtime: latest, all, or time     if (params.getRuntime() != null) {       if (""latest"".equalsIgnoreCase(params.getRuntime())) {         params.setLatestRuntime(true);        } else if (""all"".equalsIgnoreCase(params.getRuntime())) {         params.setAllRuntime(true);        } else {         CalendarDate cd = TimeParamsValidator.validateISOString(params.getRuntime(), ""{thredds.server.ncSubset.validation.param.runtime}"", constraintValidatorContext);         if (cd != null)           params.setRuntimeDate(cd);       }     }      // timeOffset: first or double     if (params.getTimeOffset() != null) {       if (""first"".equalsIgnoreCase(params.getTimeOffset())) {         params.setFirstTimeOffset(true);        } else {         try {           double val = Double.parseDouble(params.getTimeOffset());           params.setTimeOffsetVal(val);         } catch (NumberFormatException e) {           constraintValidatorContext.buildConstraintViolationWithTemplate(""{thredds.server.ncSubset.validation.param.time_offset}"").addConstraintViolation();         }       }     }      return isValid;   }
public AddressBuilderSchemeSpecificPart set(CharSequence name, Object... values)     {        parent.set(name, values);        return this;     }
public static <K, V> ConcurrentMap<K, V> newConcurrentMap() {     return new MapMaker().<K, V>makeMap();   }
public void generateSchema(SchemaGenerator generator) throws UnsupportedTypeException {     if (inputs == null && outputs == null && inputTypes != null && outputTypes != null) {       // Generate both inputs and outputs before making this visible       Map<String, Set<Schema>> inputs = generateSchema(generator, inputTypes);       Map<String, Set<Schema>> outputs = generateSchema(generator, outputTypes);        this.inputs = inputs;       this.outputs = outputs;     }   }
public SDVariable onesLike(String name, @NonNull SDVariable input, @NonNull DataType dataType) {         SDVariable ret = f().onesLike(name, input, dataType);         return updateVariableNameAndReference(ret, name);     }
public static ThrowableProto serializeThrowable(Throwable t) {         final ThrowableProto.Builder builder = ThrowableProto.newBuilder();          if (t instanceof StatusCauseException) {             final StatusCauseException statusCause = (StatusCauseException) t;             builder.setOriginalClassName(statusCause.getOriginalClassName());             builder.setOriginalMessage(statusCause.getOriginalMessage());         } else {             builder.setOriginalClassName(t.getClass().getCanonicalName());             builder.setOriginalMessage(Strings.nullToEmpty(t.getMessage()));         }          for (StackTraceElement element : t.getStackTrace()) {             builder.addStackTrace(serializeStackTraceElement(element));         }          if (t.getCause() != null) {             builder.setCause(serializeThrowable(t.getCause()));         }         return builder.build();     }
public void getState(OutputStream ostream) throws Exception {         HashMap<K,V> copy=new HashMap<>();         for(Map.Entry<K,V> entry:entrySet()) {             K key=entry.getKey();             V val=entry.getValue();             copy.put(key, val);         }         try(ObjectOutputStream oos=new ObjectOutputStream(new BufferedOutputStream(ostream, 1024))) {             oos.writeObject(copy);         }     }
private void wrapText() {  if (getFont() == null || text == null) {    return;  }  FontMetrics fm = getFontMetrics(getFont());   StringBuilder tempText = new StringBuilder();  StringBuilder finalText = new StringBuilder(""<html>"");  finalText.append(""<STYLE type='text/css'>BODY { text-align: "");  finalText.append(align.name().toLowerCase());  finalText.append(""}</STYLE><BODY>"");   ArrayList<String> words = new ArrayList<String>();  text = text.replaceAll(""\n"", ""<BR>"");  String split[] = text.split(""<BR>"");  for (int i = 0; i < split.length; i++) {    if (split[i].length() > 0) {   String split2[] = split[i].split(""[ \\t\\x0B\\f\\r]+"");   for (int j = 0; j < split2.length; j++) {     if (split2[j].length() > 0) {    words.add(split2[j]);     }   }    }     if (i < split.length - 1) {   words.add(""<BR>"");    }  }   for (String word : words) {    if (word.equals(""<BR>"")) {   finalText.append(""<BR>"");   tempText.setLength(0);    } else {   tempText.append("" "");   tempText.append(word);    int tempWidth =    SwingUtilities.computeStringWidth(fm, tempText.toString().trim());   if ((wrapWidth > 0 && tempWidth > wrapWidth)) {      int wordSize = SwingUtilities.computeStringWidth(fm, word);     if (wordSize >= wrapWidth) {    finalText.append(""..."");    break;     }      finalText.append(""<BR>"");     tempText.setLength(0);     tempText.append(word);   }    if (tempText.length() > 0) {     finalText.append("" "");   }   finalText.append(word);    }   }   finalText.append(""</BODY></html>"");  super.setText(finalText.toString());   }
@Override   public synchronized void write(DataOutput out) throws IOException {     Text.writeString(out, name);     boolean distinctDisplayName = ! name.equals(displayName);     out.writeBoolean(distinctDisplayName);     if (distinctDisplayName) {       Text.writeString(out, displayName);     }     WritableUtils.writeVLong(out, value);   }
private File writeDotSourceToFile(String str) throws java.io.IOException,    GraphVizException  {   File temp;   try   {    temp = File.createTempFile(""graph_"", "".dot.tmp"");    FileWriter fout = new FileWriter(temp);    fout.write(str);    fout.close();   } catch (Exception e)   {    throw new GraphVizException(""Error: I/O error while writing the dot source to temp file!"");   }   return temp;  }
public static <K, V, NV> Map<K, NV> newFilteredChangedValueWithEntryMap(             Map<K, V> map, Predicate<Entry<K, V>> filter,             Function<Entry<K, V>, NV> changingValueFunction) {         return getEntryStreamWithFilter(map, filter).collect(                 toMap(Entry::getKey, changingValueFunction::apply));     }
@Override    public ConciseSet intersection(IntSet other)    {      if (isEmpty() || other == null || other.isEmpty()) {        return empty();      }      if (other == this) {        return clone();      }      return performOperation(convert(other), Operator.AND);    }
public void post(Notification event) {         for (Map.Entry<Object, List<SubscriberMethod>> entry : listeners.entrySet()) {             for (SubscriberMethod method : entry.getValue()) {                 if (method.eventTypeToInvokeOn.isInstance(event)) {                     try {                         method.methodToInvokeOnEvent.invoke(entry.getKey(), event);                     } catch (InvocationTargetException e) {                         // We log this exception and swallow it because we need to ensure we don't                         // prevent completion of notifications if one listener is badly behaved and                         // throws an exception of some kind.                         LOGGER.log(Level.SEVERE, ""Subscriber invocation failed for method \""""                                 + method.toString() + ""\"""", e);                     } catch (IllegalAccessException e) {                         throw new RuntimeException(EventBus.class.getName() + "" could not access "" +                                 ""subscriber "" + method.toString(), e);                     }                 }             }         }     }
private void catchUp(JournalStateMachine stateMachine, CopycatClient client)       throws TimeoutException, InterruptedException {     long startTime = System.currentTimeMillis();     // Wait for any outstanding snapshot to complete.     CommonUtils.waitFor(""snapshotting to finish"", () -> !stateMachine.isSnapshotting(),         WaitForOptions.defaults().setTimeoutMs(10 * Constants.MINUTE_MS));      // Loop until we lose leadership or convince ourselves that we are caught up and we are the only     // master serving. To convince ourselves of this, we need to accomplish three steps:     //     // 1. Write a unique ID to the copycat.     // 2. Wait for the ID to by applied to the state machine. This proves that we are     //    caught up since the copycat cannot apply commits from a previous term after applying     //    commits from a later term.     // 3. Wait for a quiet period to elapse without anything new being written to Copycat. This is a     //    heuristic to account for the time it takes for a node to realize it is no longer the     //    leader. If two nodes think they are leader at the same time, they will both write unique     //    IDs to the journal, but only the second one has a chance of becoming leader. The first     //    will see that an entry was written after its ID, and double check that it is still the     //    leader before trying again.     while (true) {       if (mPrimarySelector.getState() != PrimarySelector.State.PRIMARY) {         return;       }       long lastAppliedSN = stateMachine.getLastAppliedSequenceNumber();       long gainPrimacySN = ThreadLocalRandom.current().nextLong(Long.MIN_VALUE, 0);       LOG.info(""Performing catchup. Last applied SN: {}. Catchup ID: {}"",           lastAppliedSN, gainPrimacySN);       CompletableFuture<Void> future = client.submit(new JournalEntryCommand(           JournalEntry.newBuilder().setSequenceNumber(gainPrimacySN).build()));       try {         future.get(5, TimeUnit.SECONDS);       } catch (TimeoutException | ExecutionException e) {         LOG.info(""Exception submitting term start entry: {}"", e.toString());         continue;       }        try {         CommonUtils.waitFor(""term start entry "" + gainPrimacySN             + "" to be applied to state machine"", () ->             stateMachine.getLastPrimaryStartSequenceNumber() == gainPrimacySN,             WaitForOptions.defaults()                 .setInterval(Constants.SECOND_MS)                 .setTimeoutMs(5 * Constants.SECOND_MS));       } catch (TimeoutException e) {         LOG.info(e.toString());         continue;       }        // Wait 2 election timeouts so that this master and other masters have time to realize they       // are not leader.       CommonUtils.sleepMs(2 * mConf.getElectionTimeoutMs());       if (stateMachine.getLastAppliedSequenceNumber() != lastAppliedSN           || stateMachine.getLastPrimaryStartSequenceNumber() != gainPrimacySN) {         // Someone has committed a journal entry since we started trying to catch up.         // Restart the catchup process.         continue;       }       LOG.info(""Caught up in {}ms. Last sequence number from previous term: {}."",           System.currentTimeMillis() - startTime, stateMachine.getLastAppliedSequenceNumber());       return;     }   }
public static Builder at (long millis)     {         Calendar calendar = Calendar.getInstance();         calendar.setTimeInMillis(millis);         return with(calendar);     }
public final boolean abort()     {         boolean ret = false;          if (UserLoginModule.LOG.isDebugEnabled()) {             UserLoginModule.LOG.debug(""Abort of "" + this.principal);         }          // If our authentication was successful, just return false         if (this.principal != null) {              // Clean up if overall authentication failed             if (this.committed) {                 this.subject.getPrincipals().remove(this.principal);             }             this.committed = false;             this.principal = null;             ret = true;         }         return ret;     }
public static ConversionType getConversionType(final Field destination, final Field source){   return getConversionType(destination.getType(),source.getType());  }
@Deprecated   public static Terminals caseSensitive(       Parser<String> wordScanner, String[] ops, String[] keywords) {     return operators(ops)         .words(wordScanner)         .keywords(keywords)         .build();   }
public static MutableIntArrayND createSubArray(          MutableIntArrayND parent, IntTuple fromIndices, IntTuple toIndices)      {          return new MutableSubIntArrayND(              parent, fromIndices, toIndices);      }
public FloatBuffer get4x3(int index, FloatBuffer buffer) {         MemUtil.INSTANCE.put4x3(this, index, buffer);         return buffer;     }
public void serviceName_cron_id_PUT(String serviceName, Long id, OvhCron body) throws IOException {   String qPath = ""/hosting/web/{serviceName}/cron/{id}"";   StringBuilder sb = path(qPath, serviceName, id);   exec(qPath, ""PUT"", sb.toString(), body);  }
public static PrimitiveBuilder<PrimitiveType> required(PrimitiveTypeName type) {     return new PrimitiveBuilder<PrimitiveType>(PrimitiveType.class, type)         .repetition(Type.Repetition.REQUIRED);   }
@NonNull     @Override     public DeleteResult performDelete(@NonNull StorIOSQLite storIOSQLite, @NonNull T object) {         final DeleteQuery deleteQuery = mapToDeleteQuery(object);         final int numberOfRowsDeleted = storIOSQLite.lowLevel().delete(deleteQuery);         return DeleteResult.newInstance(numberOfRowsDeleted, deleteQuery.table(), deleteQuery.affectsTags());     }
@Override   public void cancelRepairRecord(final ORecordId rid) {     if (!active)       return;      if (rid.getClusterPosition() < -1)       // SKIP TRANSACTIONAL RIDS       return;      // REMOVE THE RECORD TO REPAIR     if (records.remove(rid) != null)       // REMOVED       recordCanceled.incrementAndGet();   }
public Observable<Page<AnalysisDefinitionInner>> listSiteAnalysesSlotAsync(final String resourceGroupName, final String siteName, final String diagnosticCategory, final String slot) {         return listSiteAnalysesSlotWithServiceResponseAsync(resourceGroupName, siteName, diagnosticCategory, slot)             .map(new Func1<ServiceResponse<Page<AnalysisDefinitionInner>>, Page<AnalysisDefinitionInner>>() {                 @Override                 public Page<AnalysisDefinitionInner> call(ServiceResponse<Page<AnalysisDefinitionInner>> response) {                     return response.body();                 }             });     }
public boolean isValidAssignment(Assignment assignment) {     Preconditions.checkArgument(containsAll(assignment.getVariableNumsArray()));     for (int varNum : assignment.getVariableNumsArray()) {       int index = getVariableIndex(varNum);       if (!vars[index].canTakeValue(assignment.getValue(varNum))) {         return false;       }     }     return true;   }
@Override     public String combine(String pattern1, String pattern2) {         if (!WebpipeUtils.hasText(pattern1) && !WebpipeUtils.hasText(pattern2)) {             return """";         } else if (!WebpipeUtils.hasText(pattern1)) {             return pattern2;         } else if (!WebpipeUtils.hasText(pattern2)) {             return pattern1;         }          boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1;         if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {             // /* + /hotel -> /hotel ; ""/*.*"" + ""/*.html"" -> /*.html             // However /user + /user -> /usr/user ; /{foo} + /bar -> /{foo}/bar             return pattern2;         } else if (pattern1.endsWith(""/*"")) {             if (pattern2.startsWith(""/"")) {                 // /hotels/* + /booking -> /hotels/booking                 return pattern1.substring(0, pattern1.length() - 1) + pattern2.substring(1);             } else {                 // /hotels/* + booking -> /hotels/booking                 return pattern1.substring(0, pattern1.length() - 1) + pattern2;             }         } else if (pattern1.endsWith(""/**"")) {             if (pattern2.startsWith(""/"")) {                 // /hotels/** + /booking -> /hotels/**/booking                 return pattern1 + pattern2;             } else {                 // /hotels/** + booking -> /hotels/**/booking                 return pattern1 + ""/"" + pattern2;             }         } else {             int dotPos1 = pattern1.indexOf('.');             if (dotPos1 == -1 || pattern1ContainsUriVar) {                 // simply concatenate the two patterns                 if (pattern1.endsWith(""/"") || pattern2.startsWith(""/"")) {                     return pattern1 + pattern2;                 } else {                     return pattern1 + ""/"" + pattern2;                 }             }             String fileName1 = pattern1.substring(0, dotPos1);             String extension1 = pattern1.substring(dotPos1);             String fileName2;             String extension2;             int dotPos2 = pattern2.indexOf('.');             if (dotPos2 != -1) {                 fileName2 = pattern2.substring(0, dotPos2);                 extension2 = pattern2.substring(dotPos2);             } else {                 fileName2 = pattern2;                 extension2 = """";             }             String fileName = fileName1.endsWith(""*"") ? fileName2 : fileName1;             String extension = extension1.startsWith(""*"") ? extension2 : extension1;              return fileName + extension;         }     }
public Matrix3x2d mul(Matrix3x2dc right, Matrix3x2d dest) {         double nm00 = m00 * right.m00() + m10 * right.m01();         double nm01 = m01 * right.m00() + m11 * right.m01();         double nm10 = m00 * right.m10() + m10 * right.m11();         double nm11 = m01 * right.m10() + m11 * right.m11();         double nm20 = m00 * right.m20() + m10 * right.m21() + m20;         double nm21 = m01 * right.m20() + m11 * right.m21() + m21;         dest.m00 = nm00;         dest.m01 = nm01;         dest.m10 = nm10;         dest.m11 = nm11;         dest.m20 = nm20;         dest.m21 = nm21;         return dest;     }
public void marshall(DisassociateDomainRequest disassociateDomainRequest, ProtocolMarshaller protocolMarshaller) {          if (disassociateDomainRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(disassociateDomainRequest.getFleetArn(), FLEETARN_BINDING);             protocolMarshaller.marshall(disassociateDomainRequest.getDomainName(), DOMAINNAME_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public static JsonObject getJsonQuery(URL url) throws MalformedURLException {         String query = url.getQuery();         JsonObject payload = new JsonObject();         JsonParser parser = new JsonParser();          if (query == null) {             return null;         }          for (String kv : query.split(""&"")) {             String[] parts = kv.split(""="");              if (parts.length != 2) {                 throw new MalformedURLException();             }              String optName = parts[0];             JsonElement optVal;             try {                 optVal = parser.parse(URLDecoder.decode(parts[1], ""UTF-8""));             } catch (UnsupportedEncodingException e) {                 throw new MalformedURLException();             }              payload.add(optName, optVal);         }         return payload;     }
public synchronized void add(@Nonnull String jobFullName, int n) throws IOException {         addWithoutSaving(jobFullName, n);         save();     }
public static byte[] hmacSha1(byte[] input, byte[] key) {   try {    SecretKey secretKey = new SecretKeySpec(key, HMACSHA1_ALG);    Mac mac = Mac.getInstance(HMACSHA1_ALG);    mac.init(secretKey);    return mac.doFinal(input);   } catch (GeneralSecurityException e) {    throw ExceptionUtil.unchecked(e);   }  }
public void config(Config config) throws ConfigException, HibernateException    {      log.trace(""config(Config)"");        // Hibernate configuration class is the session factory builder      Configuration configuration = null;        // Hibernate configuration resource is not null if config parameter is null - for zero-config, or provided by config      // parameter itself as attribute      String configResource = config != null ? config.getAttribute(""config"") : DEFAULT_CONFIG;      if(configResource != null) {        log.debug(""Configure Hibernate from configuration resource |%s|."", configResource);        configuration = new Configuration();        configuration.configure(configResource);      }      else {        // at this point config parameter is not null        log.debug(""Configure Hibernate from j(s)-lib configuration object."");        configuration = hibernateConfiguration(config);      }        String timeout = configuration.getProperty(""hibernate.transaction.timeout"");      this.transactionTimeout = timeout != null ? Integer.parseInt(timeout) : 0;        String driverClassName = configuration.getProperty(""hibernate.connection.driver_class"");      if(driverClassName == null) {        throw new ConfigException(""Missing driver class, e.g. property name='hibernate.connection.driver_class' and value 'com.mysql.jdbc.Driver'"");      }      log.debug(""Load database driver |%s|."", driverClassName);      Classes.forName(driverClassName);        log.debug(""Create Hibernate session factory."");      sessionFactory = configuration.buildSessionFactory();    }
public static String generateEntityQualifiedName(SQLiteDaoDefinition dao, SQLiteEntity entity) {   String entityName;   if (entity == null) {    M2MEntity m2mEntity = M2MEntity.extractEntityManagedByDAO(dao.getElement());    entityName = m2mEntity.getQualifiedName();   } else {    entityName = entity.getName().toString();   }   return entityName;  }
public static <T> T boxAllAs(Object src, Class<T> type) {         return (T) boxAll(type, src, 0, -1);     }
public void scrollListToLine(AbsListView absListView, int line){   if(config.commandLogging){    Log.d(config.commandLoggingTag, ""scrollListToLine(""+absListView+"", ""+line+"")"");   }      scroller.scrollListToLine(absListView, line);  }
public boolean isNextIn(Context context) {         return regex == null || regex.matcher(context.getSource().subToEnd()).lookingAt();     }
public void saveVCard(VCard vcard) throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {         // XEP-54 § 3.2 ""A user may publish or update his or her vCard by sending an IQ of type ""set"" with no 'to' address…""         vcard.setTo((Jid) null);         vcard.setType(IQ.Type.set);         // Also make sure to generate a new stanza id (the given vcard could be a vcard result), in which case we don't         // want to use the same stanza id again (although it wouldn't break if we did)         vcard.setStanzaId(StanzaIdUtil.newStanzaId());         connection().createStanzaCollectorAndSend(vcard).nextResultOrThrow();     }
public static void setUpExample(DatabaseClient client)     throws ResourceNotFoundException, ForbiddenUserException, FailedRequestException   {     XMLDocumentManager docMgr = client.newXMLDocumentManager();      StringHandle handle = new StringHandle();      docMgr.write(""/batch/read1.xml"",   handle.with(""<read1/>""));     DocumentMetadataHandle meta2 = new DocumentMetadataHandle();     meta2.getCollections().add(""/batch/collection2"");     docMgr.write(""/batch/read2.xml"",   meta2, handle.with(""<read2/>""));     docMgr.write(""/batch/delete1.xml"", handle.with(""<delete1/>""));   }
public static <S extends Sequence<C>, C extends Compound> List<SequencePair<S, C>> getAllPairsAlignments(    List<S> sequences, PairwiseSequenceAlignerType type, GapPenalty gapPenalty,    SubstitutionMatrix<C> subMatrix) {   return runPairwiseAligners(getAllPairsAligners(sequences, type, gapPenalty, subMatrix));  }
void iniStartView(CmsUserSettings settings) {          IndexedContainer container = getStartViewContainer(""caption"");         if (container.size() > 0) {             m_startview.setEnabled(true);             m_startview.setContainerDataSource(container);             m_startview.setItemCaptionPropertyId(""caption"");             m_startview.setNullSelectionAllowed(false);             m_startview.setNewItemsAllowed(false);             if (container.getItemIds().size() > 0) {                 m_startview.select(container.getItemIds().get(0));                 if (settings != null) {                     m_startview.select(settings.getStartView());                 }             }         } else {             m_startview.setEnabled(false);         }     }
@Override  public Object getData() {   BeanAndProviderBoundComponentModel model = getComponentModel();   Object data = model.getData();   String beanProperty = getBeanProperty();    if (beanProperty != null) {    Object sharedData = ((BeanAndProviderBoundComponentModel) getDefaultModel()).getData();     if (!isFlagSet(ComponentModel.USER_DATA_SET) && Util.equals(data, sharedData)) {     Object bean = getBean();      if (bean != null) {      data = getBeanValue();     }    }   }    return data;  }
protected void handleAppendResponseFailure(MemberState member, AppendRequest request, Throwable error) {     // Log the failed attempt to contact the member.     failAttempt(member, error);   }
public IndexFacesResult withFaceRecords(FaceRecord... faceRecords) {         if (this.faceRecords == null) {             setFaceRecords(new java.util.ArrayList<FaceRecord>(faceRecords.length));         }         for (FaceRecord ele : faceRecords) {             this.faceRecords.add(ele);         }         return this;     }
private JFreeChart addLineChartOverBar(JFreeChart jfreechart, Object[] lineCharts, String lineLegend) throws QueryException {   // first we read data for bar series, so we have to go back at the start of the result set   try {    result.getResultSet().beforeFirst();   } catch (SQLException e) {    // TODO Auto-generated catch block    e.printStackTrace();   }   isLineCombo = true;   lineBarDataset =  new DefaultCategoryDataset();         boolean hasLegend = false;   for (int i = 0; i < lineCharts.length; i++) {    String legend = """";    try {     legend = replaceParameters(lineLegend);    } catch (IndexOutOfBoundsException ex){     // no legend set    }    if ((legend != null) && !"""".equals(legend.trim())) {     hasLegend = true;    }          lineCharts[i] = legend;      }             int index = chart.getYColumns().size()-1;   CategoryPlot plot = jfreechart.getCategoryPlot();             final LineAndShapeRenderer renderer2 = new LineAndShapeRenderer();                plot.setRenderer(1, renderer2);         renderer2.setSeriesPaint(0, chart.getForegrounds().get(index));                                         final ValueAxis axis2 = new NumberAxis("""");           plot.setRangeAxis(1, axis2);      plot.setDataset(1, lineBarDataset);      plot.mapDatasetToRangeAxis(1, 1);      plot.setDatasetRenderingOrder(DatasetRenderingOrder.FORWARD);            boolean showValues = (chart.getShowYValuesOnChart() == null) ? false : chart.getShowYValuesOnChart();    DecimalFormat decimalFormat;    DecimalFormat percentageFormat;    if (chart.getYTooltipPattern() == null) {     decimalFormat = new DecimalFormat(""#"");     percentageFormat = new DecimalFormat(""0.00%"");    } else {     decimalFormat = new DecimalFormat(chart.getYTooltipPattern());     percentageFormat = decimalFormat;    }    if (showValues) {     renderer2.setSeriesItemLabelsVisible(0, true);      renderer2.setSeriesItemLabelGenerator(0, new StandardCategoryItemLabelGenerator(""{2}"", decimalFormat, percentageFormat));    // increase a little bit the range axis to view all item label values over points    plot.getRangeAxis(1).setUpperMargin(0.2);   }                               final HashMap<String, String> formatValues = createChart(chart.getYColumns().subList(index, index+1), plot.getRangeAxis(1), lineCharts);                                          isLineCombo = false;         return jfreechart;                 }
public static AccessCondition generateIfSequenceNumberLessThanCondition(long sequenceNumber) {         AccessCondition retCondition = new AccessCondition();         retCondition.ifSequenceNumberLessThan = sequenceNumber;         return retCondition;     }
public static String getDigest(String oid) {         String ret = (String)digestNames.get(oid);         if (ret == null)             return oid;         else             return ret;     }
@Override     public void configure(final HttpSecurity http) throws Exception {          http.sessionManagement().sessionCreationPolicy(NEVER)              // configure form login             .and().formLogin().disable()              // configure logout                 .logout().disable()                  .authorizeRequests()                 .antMatchers(HttpMethod.OPTIONS).permitAll() // Allow preflight CORS requests from browsers                 .antMatchers(""/"").access(""#oauth2.hasUidScopeAndAnyRealm('/employees', '/services')"")                 .antMatchers(""/api/**"").access(""#oauth2.hasUidScopeAndAnyRealm('/employees', '/services')"")                 .antMatchers(""/s3/**"").access(""#oauth2.hasUidScopeAndAnyRealm('/employees', '/services')"")                 .antMatchers(""/webjars/**"").permitAll()                 .antMatchers(""/swagger-resources"").permitAll()                 .antMatchers(""/api-docs"").permitAll();      }
public void deploy() throws MojoExecutionException {     stager.stage();      DeployConfiguration config =         configBuilder.buildDeployConfiguration(ImmutableList.of(deployMojo.getStagingDirectory()));      try {       deployMojo.getAppEngineFactory().deployment().deploy(config);     } catch (AppEngineException ex) {       throw new MojoExecutionException(""App Engine application deployment failed"", ex);     }   }
@Override     public void visitCode(final Code obj) {         try {             if (methodSignatureIsConstrained) {                 return;             }              if (obj.getCode() == null) {                 return;             }             Method m = getMethod();              if (m.isSynthetic()) {                 return;             }              if (m.getName().startsWith(""access$"")) {                 return;             }              methodIsStatic = m.isStatic();             parmCount = m.getArgumentTypes().length;              if (parmCount == 0) {                 return;             }              parameterDefiners.clear();             usedParameters.clear();             stack.resetForMethodEntry(this);              if (buildParameterDefiners()) {                 try {                     super.visitCode(obj);                     reportBugs();                 } catch (StopOpcodeParsingException e) {                     // no more possible parameter definers                 }             }         } catch (ClassNotFoundException cnfe) {             bugReporter.reportMissingClass(cnfe);         }     }
@Nonnull     public Query addAttribute(@Nonnull String attributeName) {         return addAttribute(new QueryAttribute(attributeName, null, null));     }
public static <OLD, NEW, EV> DataSet<Edge<NEW, EV>> translateEdgeIds(DataSet<Edge<OLD, EV>> edges, TranslateFunction<OLD, NEW> translator) {   return translateEdgeIds(edges, translator, PARALLELISM_DEFAULT);  }
public DescribeResourceGroupsResult withResourceGroups(ResourceGroup... resourceGroups) {         if (this.resourceGroups == null) {             setResourceGroups(new java.util.ArrayList<ResourceGroup>(resourceGroups.length));         }         for (ResourceGroup ele : resourceGroups) {             this.resourceGroups.add(ele);         }         return this;     }
private void splitDays(ProjectCalendar calendar, LinkedList<TimephasedWork> list)    {       LinkedList<TimephasedWork> result = new LinkedList<TimephasedWork>();       for (TimephasedWork assignment : list)       {          while (assignment != null)          {             Date startDay = DateHelper.getDayStartDate(assignment.getStart());             Date finishDay = DateHelper.getDayStartDate(assignment.getFinish());              // special case - when the finishday time is midnight, it's really the previous day...             if (assignment.getFinish().getTime() == finishDay.getTime())             {                finishDay = DateHelper.addDays(finishDay, -1);             }              if (startDay.getTime() == finishDay.getTime())             {                result.add(assignment);                break;             }              TimephasedWork[] split = splitFirstDay(calendar, assignment);             if (split[0] != null)             {                result.add(split[0]);             }             assignment = split[1];          }       }        list.clear();       list.addAll(result);    }
public final <T> UdpClient option(ChannelOption<T> key, T value) {   Objects.requireNonNull(key, ""key"");   Objects.requireNonNull(value, ""value"");   return bootstrap(b -> b.option(key, value));  }
private FileStatus[] getFileStatus(Path[] paths) throws IOException {     if (paths == null) {       return null;     }     ArrayList<FileStatus> results = new ArrayList<FileStatus>(paths.length);     for (int i = 0; i < paths.length; i++) {       try {         results.add(getFileStatus(paths[i]));       } catch (FileNotFoundException e) { // do nothing       }     }     return results.toArray(new FileStatus[results.size()]);   }
@Override     public Object invoke(ObjectName name, String operationName, Object[] params,                          String[] signature) throws InstanceNotFoundException, MBeanException, ReflectionException, IOException {         final String sourceMethod = ""invoke"";          try {             //Look for routing MBean             if (ClientProvider.CONNECTION_ROUTING_NAME.equals(name.getKeyProperty(""name"")) &&                 ClientProvider.CONNECTION_ROUTING_DOMAIN.equals(name.getDomain())) {                  //Handle server-level routing                 if (ClientProvider.CONNECTION_ROUTING_OPERATION_ASSIGN_SERVER.equals(operationName)) {                     if (params.length == 3) {                         //routing at server level                         this.mapRouting = new HashMap<String, Object>();                         this.mapRouting.put(ClientProvider.ROUTING_KEY_HOST_NAME, params[0]);                         this.mapRouting.put(ClientProvider.ROUTING_KEY_SERVER_USER_DIR, params[1]);                         this.mapRouting.put(ClientProvider.ROUTING_KEY_SERVER_NAME, params[2]);                         return Boolean.TRUE;                     }                      //Handle host-level routing                 } else if (ClientProvider.CONNECTION_ROUTING_OPERATION_ASSIGN_HOST.equals(operationName)) {                     if (params.length == 1) {                         //routing at host level                         this.mapRouting = new HashMap<String, Object>();                         this.mapRouting.put(ClientProvider.ROUTING_KEY_HOST_NAME, params[0]);                         return Boolean.TRUE;                     }                 }             }          } catch (Exception e) {             throw new MBeanException(e);         }          checkConnection();          //Special handling for file transfer MBean invocations         if (ClientProvider.FILE_TRANSFER_NAME.equals(name.getKeyProperty(""name"")) &&             ClientProvider.FILE_TRANSFER_DOMAIN.equals(name.getDomain())) {             return fileTransferClient.handleOperation(operationName, params);         }          URL invokeURL = null;         HttpsURLConnection connection = null;         JSONConverter converter = JSONConverter.getConverter();         try {             // Get URL for invoke operation             invokeURL = getOperationURL(name, operationName);              // Get connection to server             connection = getConnection(invokeURL, HttpMethod.POST);              // Create Invocation object             Invocation invocation = new Invocation();             invocation.params = params;             invocation.signature = signature;              // Write Invocation JSON to connection output stream             OutputStream output = connection.getOutputStream();             converter.writeInvocation(output, invocation);             output.flush();             output.close();         } catch (ConnectException ce) {             recoverConnection(ce);             // Server is down; not a client bug             throw ce;         } catch (IntrospectionException intro) {             throw getRequestErrorException(sourceMethod, intro, invokeURL);         } catch (IOException io) {             throw getRequestErrorException(sourceMethod, io, invokeURL);         } finally {             JSONConverter.returnConverter(converter);         }          // Check response code from server         int responseCode = 0;         try {             responseCode = connection.getResponseCode();         } catch (ConnectException ce) {             recoverConnection(ce);             // Server is down; not a client bug             throw ce;         }          switch (responseCode) {             case HttpURLConnection.HTTP_OK:                 converter = JSONConverter.getConverter();                 try {                     // Process and return server response, which should be a POJO                     return converter.readPOJO(connection.getInputStream());                 } catch (ClassNotFoundException cnf) {                     // Not a REST connector bug per se; not need to log this case                     throw new IOException(RESTClientMessagesUtil.getMessage(RESTClientMessagesUtil.SERVER_RESULT_EXCEPTION), cnf);                 } catch (Exception e) {                     throw getResponseErrorException(sourceMethod, e, invokeURL);                 } finally {                     JSONConverter.returnConverter(converter);                 }             case HttpURLConnection.HTTP_BAD_REQUEST:             case HttpURLConnection.HTTP_INTERNAL_ERROR:                 try {                     // Server response should be a serialized Throwable                     throw getServerThrowable(sourceMethod, connection);                 } catch (InstanceNotFoundException inf) {                     throw inf;                 } catch (RuntimeMBeanException rme) {                     throw rme;                 } catch (MBeanException me) {                     throw me;                 } catch (ReflectionException re) {                     throw re;                 } catch (IOException io) {                     throw io;                 } catch (Throwable t) {                     throw new IOException(RESTClientMessagesUtil.getMessage(RESTClientMessagesUtil.UNEXPECTED_SERVER_THROWABLE), t);                 }             case HttpURLConnection.HTTP_UNAUTHORIZED:             case HttpURLConnection.HTTP_FORBIDDEN:                 throw getBadCredentialsException(responseCode, connection);             case HttpURLConnection.HTTP_GONE:             case HttpURLConnection.HTTP_NOT_FOUND:                 IOException ioe = getResponseCodeErrorException(sourceMethod, responseCode, connection);                 recoverConnection(ioe);                 throw ioe;             default:                 IOException e = getResponseCodeErrorException(sourceMethod, responseCode, connection);                 throw e;         }     }
@CheckReturnValue     @NonNull     public static <T> ParallelFlowable<T> fromArray(@NonNull Publisher<T>... publishers) {         if (publishers.length == 0) {             throw new IllegalArgumentException(""Zero publishers not supported"");         }         return RxJavaPlugins.onAssembly(new ParallelFromArray<T>(publishers));     }
public void setGraph(MeasureCollection[] measures, MeasureCollection[] measureStds,             double[] variedParamValues, Color[] colors) {         this.measures = measures;         this.variedParamValues = variedParamValues;         ((GraphScatter) this.plotPanel).setGraph(measures, measureStds,                 variedParamValues, colors);         updateCanvas(false);     }
public Class<?> getActualFieldType(final String field) {                    final Object fieldValue = getFieldValue(field);          return fieldValue == null ? null : fieldValue.getClass();                }
protected Expression instantiate(Object oldInstance, Encoder out)     {         //         // An implementation instance is actually constructed at decode time by calling         // ControlBean.ensureControl on the parent bean.  This will create a new impl         // instance and run the impl initializer on it.         //         return new Expression(((XMLEncoder)out).getOwner(), ""ensureControl"", null);     }
protected EmbeddedChannel newContentCompressor(ChannelHandlerContext ctx, CharSequence contentEncoding)             throws Http2Exception {         if (GZIP.contentEqualsIgnoreCase(contentEncoding) || X_GZIP.contentEqualsIgnoreCase(contentEncoding)) {             return newCompressionChannel(ctx, ZlibWrapper.GZIP);         }         if (DEFLATE.contentEqualsIgnoreCase(contentEncoding) || X_DEFLATE.contentEqualsIgnoreCase(contentEncoding)) {             return newCompressionChannel(ctx, ZlibWrapper.ZLIB);         }         // 'identity' or unsupported         return null;     }
@Override     protected void loadPlugins() {   pickingPlugin = new PickingGraphMousePlugin<String,String>();   scalingPlugin = new ScalingGraphMousePlugin(new CrossoverScalingControl(), 0, in, out);   editingPlugin = new RoleGraphEditingPlugin();   add(scalingPlugin);   setMode(Mode.EDITING);  }
public void sendGrafanaDashboardAsync(final String classPathLocation) {   if (!corePlugin.isReportToElasticsearch()) {    return;   }    try {    final ObjectNode dashboard = getGrafanaDashboard(classPathLocation);    Map<String, Object> body = new HashMap<String, Object>();    body.put(""dashboard"", dashboard);    body.put(""overwrite"", true);    asyncGrafanaRequest(""POST"", ""/api/dashboards/db"", body);   } catch (IOException e) {    logger.warn(e.getMessage(), e);   }  }
public void draw(GraphicContext graphicContext) {         if (!this.visible) {             return;         }          if (this.mapViewDimension.getDimension() == null) {             return;         }          if (this.isRedrawNecessary()) {             redraw(this.mapScaleCanvas);             this.redrawNeeded = false;         }          int positionLeft = calculatePositionLeft(0, this.mapViewDimension.getDimension().width, this.mapScaleBitmap.getWidth());         int positionTop = calculatePositionTop(0, this.mapViewDimension.getDimension().height, this.mapScaleBitmap.getHeight());          graphicContext.drawBitmap(this.mapScaleBitmap, positionLeft, positionTop);     }
public ArrayList<String> serviceName_pca_pcaServiceName_sessions_sessionId_files_GET(String serviceName, String pcaServiceName, String sessionId, String name) throws IOException {   String qPath = ""/cloud/{serviceName}/pca/{pcaServiceName}/sessions/{sessionId}/files"";   StringBuilder sb = path(qPath, serviceName, pcaServiceName, sessionId);   query(sb, ""name"", name);   String resp = exec(qPath, ""GET"", sb.toString(), null);   return convertTo(resp, t1);  }
public VocabCache<T> buildMergedVocabulary(@NonNull VocabCache<T> vocabCache, boolean fetchLabels) {         if (cache == null)             cache = new AbstractCache.Builder<T>().build();         for (int t = 0; t < vocabCache.numWords(); t++) {             String label = vocabCache.wordAtIndex(t);             if (label == null)                 continue;             T element = vocabCache.wordFor(label);              // skip this element if it's a label, and user don't want labels to be merged             if (!fetchLabels && element.isLabel())                 continue;              //element.setIndex(t);             cache.addToken(element);             cache.addWordToIndex(element.getIndex(), element.getLabel());              // backward compatibility code             cache.putVocabWord(element.getLabel());         }          if (cache.numWords() == 0)             throw new IllegalStateException(""Source VocabCache has no indexes available, transfer is impossible"");          /*             Now, when we have transferred vocab, we should roll over iterator, and  gather labels, if any          */         log.info(""Vocab size before labels: "" + cache.numWords());          if (fetchLabels) {             for (VocabSource<T> source : sources) {                 SequenceIterator<T> iterator = source.getIterator();                 iterator.reset();                  while (iterator.hasMoreSequences()) {                     Sequence<T> sequence = iterator.nextSequence();                     seqCount.incrementAndGet();                      if (sequence.getSequenceLabels() != null)                         for (T label : sequence.getSequenceLabels()) {                             if (!cache.containsWord(label.getLabel())) {                                 label.markAsLabel(true);                                 label.setSpecial(true);                                  label.setIndex(cache.numWords());                                  cache.addToken(label);                                 cache.addWordToIndex(label.getIndex(), label.getLabel());                                  // backward compatibility code                                 cache.putVocabWord(label.getLabel());                                  //  log.info(""Adding label [""+label.getLabel()+""]: "" + cache.wordFor(label.getLabel()));                             } // else log.info(""Label [""+label.getLabel()+""] already exists: "" + cache.wordFor(label.getLabel()));                         }                 }             }         }          log.info(""Vocab size after labels: "" + cache.numWords());          return cache;     }
public String description(URI uri) {     SchemeProcessor reader = searchForSupportedProcessor(uri);      return reader.description(uri);   }
public static JCStatement generateNullCheck(JavacTreeMaker maker, JavacNode variable, JCVariableDecl varDecl, JavacNode source) {   NullCheckExceptionType exceptionType = source.getAst().readConfiguration(ConfigurationKeys.NON_NULL_EXCEPTION_TYPE);   if (exceptionType == null) exceptionType = NullCheckExceptionType.NULL_POINTER_EXCEPTION;      if (isPrimitive(varDecl.vartype)) return null;   Name fieldName = varDecl.name;      JCLiteral message = maker.Literal(exceptionType.toExceptionMessage(fieldName.toString()));   if (exceptionType == NullCheckExceptionType.ASSERTION) {    return maker.Assert(maker.Binary(CTC_NOT_EQUAL, maker.Ident(fieldName), maker.Literal(CTC_BOT, null)), message);   }      JCExpression exType = genTypeRef(variable, exceptionType.getExceptionType());   JCExpression exception = maker.NewClass(null, List.<JCExpression>nil(), exType, List.<JCExpression>of(message), null);   JCStatement throwStatement = maker.Throw(exception);   JCBlock throwBlock = maker.Block(0, List.of(throwStatement));   return maker.If(maker.Binary(CTC_EQUAL, maker.Ident(fieldName), maker.Literal(CTC_BOT, null)), throwBlock, null);  }
protected Vertx createVertx(VertxEndpointConfiguration endpointConfiguration) {         final Vertx[] vertx = new Vertx[1];         final Future loading = new FutureFactoryImpl().future();          Handler<AsyncResult<Vertx>> asyncLoadingHandler = new Handler<AsyncResult<Vertx>>() {             @Override             public void handle(AsyncResult<Vertx> event) {                 vertx[0] = event.result();                 loading.complete();                 log.info(""Vert.x instance started"");             }         };          if (endpointConfiguration.getPort() > 0) {             if (log.isDebugEnabled()) {                 log.debug(String.format(""Creating new Vert.x instance '%s:%s' ..."", endpointConfiguration.getHost(), endpointConfiguration.getPort()));             }             VertxOptions vertxOptions = new VertxOptions();             vertxOptions.setClusterPort(endpointConfiguration.getPort());             vertxOptions.setClusterHost(endpointConfiguration.getHost());             vertxFactory.clusteredVertx(vertxOptions, asyncLoadingHandler);         } else {             if (log.isDebugEnabled()) {                 log.debug(String.format(""Creating new Vert.x instance '%s:%s' ..."", endpointConfiguration.getHost(), 0L));             }             VertxOptions vertxOptions = new VertxOptions();             vertxOptions.setClusterPort(0);             vertxOptions.setClusterHost(endpointConfiguration.getHost());             vertxFactory.clusteredVertx(vertxOptions, asyncLoadingHandler);         }          // Wait for full loading         while (!loading.isComplete()) {             try {                 log.debug(""Waiting for Vert.x instance to startup"");                 Thread.sleep(250L);             } catch (InterruptedException e) {                 log.warn(""Interrupted while waiting for Vert.x instance startup"", e);             }         }          return vertx[0];     }
public void closeStream(IConnection conn, Number streamId) {          log.info(""closeStream  stream id: {} connection: {}"", streamId, conn.getSessionId());          if (conn instanceof IStreamCapableConnection) {              IStreamCapableConnection scConn = (IStreamCapableConnection) conn;              IClientStream stream = scConn.getStreamById(streamId);              if (stream != null) {                  if (stream instanceof IClientBroadcastStream) {                      // this is a broadcasting stream (from Flash Player to Red5)                      IClientBroadcastStream bs = (IClientBroadcastStream) stream;                      IBroadcastScope bsScope = getBroadcastScope(conn.getScope(), bs.getPublishedName());                      if (bsScope != null && conn instanceof BaseConnection) {                          ((BaseConnection) conn).unregisterBasicScope(bsScope);                      }                  }                  stream.close();                  scConn.deleteStreamById(streamId);                  // in case of broadcasting stream, status is sent automatically by Red5                  if (!(stream instanceof IClientBroadcastStream)) {                      StreamService.sendNetStreamStatus(conn, StatusCodes.NS_PLAY_STOP, ""Stream closed by server"", stream.getName(), Status.STATUS, streamId);                  }              } else {                  log.info(""Stream not found - streamId: {} connection: {}"", streamId, conn.getSessionId());              }          } else {              log.warn(""Connection is not instance of IStreamCapableConnection: {}"", conn);          }      }
public Contained lookup_id(java.lang.String search_id) {         LocalContained c = _lookup_id(search_id);          if (c == null)             return null;          return ContainedHelper.narrow(c.getReference());     }
@SuppressWarnings(""unchecked"")   public List<EventSubscriptionEntity> findConditionalStartEventSubscription() {     ListQueryParameterObject parameter = new ListQueryParameterObject();      configurParameterObject(parameter);     return getDbEntityManager().selectList(""selectConditionalStartEventSubscription"", parameter);   }
public String buildReport() throws JspException, ServletException, IOException {          List<String> lockedResources;         if (Boolean.valueOf(getParamShowownlocks()).booleanValue()) {             lockedResources = getLockedResources();         } else {             lockedResources = new ArrayList<String>(getBlockingLockedResources());         }         Collections.sort(lockedResources);         Map<String, String> lockParams = new HashMap<String, String>();         if (getParamResource() != null) {             lockParams.put(PARAM_RESOURCE, getParamResource());         }         if (getParamResourcelist() != null) {             lockParams.put(PARAM_RESOURCELIST, getParamResourcelist());         }         if (getParamShowownlocks() != null) {             lockParams.put(PARAM_SHOWOWNLOCKS, getParamShowownlocks());         }         if (getParamIncluderelated() != null) {             lockParams.put(PARAM_INCLUDERELATED, getParamIncluderelated());         }          CmsLockedResourcesList list = new CmsLockedResourcesList(             getJsp(),             lockedResources,             CmsResource.getParentFolder(getResourceList().get(0)),             lockParams);         list.actionDialog();         list.getList().setBoxed(false);          StringBuffer result = new StringBuffer(512);         result.append(""<input type='hidden' name='locks' value='"");         result.append(getLockedResources().size()).append(""'>\n"");         result.append(""<input type='hidden' name='blockinglocks' value='"");         result.append(getBlockingLockedResources().size()).append(""'>\n"");         result.append(CmsStringUtil.padLeft("""", 120 - result.length()));         result.append(CmsListExplorerColumn.getExplorerStyleDef());         result.append(""<div style='height:150px; overflow: auto;'>\n"");         result.append(list.getList().listHtml());         result.append(""</div>\n"");         return result.toString();     }
@Override     public StopWorkspacesResult stopWorkspaces(StopWorkspacesRequest request) {         request = beforeClientExecution(request);         return executeStopWorkspaces(request);     }
public void setGoogleAuthScratchCodes(final List<Integer> googleAuthScratchCodes) {   if (googleAuthScratchCodes != null) {    this.googleAuthScratchCodes = googleAuthScratchCodes.stream().collect(Collectors.toList());   }  }
public Set tokens() {         if (tokenSet == null) {             tokenSet = new AbstractSetView() {                 public long size() {                     return 0;                 }                  public Iterator iterator() {                     return new Iterator() {                          public boolean hasNext()                         {                             return false;                         } // hasNext().                          public Object next()                         {                             throw new java.util.NoSuchElementException();                         } // next().                          public boolean hasNext(Transaction transaction)                                         throws ObjectManagerException                         {                             throw new UnsupportedOperationException();                         } // hasNext().                          public Object next(Transaction transaction)                                         throws ObjectManagerException                         {                             throw new UnsupportedOperationException();                         } // next().                          public Object remove(Transaction transaction)                                         throws ObjectManagerException                         {                             throw new UnsupportedOperationException();                         } // remove().                      }; // new Iterator().                 } // iterator().               }; // new AbstractSetView().         } // if (tokenSet == null).          return tokenSet;     }
public static double eigen(Matrix A, double[] v, double p, double tol) {         return eigen(A, v, p, tol, Math.max(20, 2 * A.nrows()));     }
private static String get(Type type, Annotation annotation) {     type = boxIfPrimitive(type);     if (annotation == null && type instanceof Class && !((Class<?>) type).isArray()) {       return ((Class<?>) type).getName();     }     StringBuilder result = new StringBuilder();     if (annotation != null) {       result.append(annotation).append(""/"");     }     typeToString(type, result, true);     return result.toString();   }
public OvhTask serviceName_database_POST(String serviceName, OvhDatabaseCapabilitiesTypeEnum capabilitie, String password, OvhExtraSqlQuotaEnum quota, OvhDatabaseTypeEnum type, String user, OvhVersionEnum version) throws IOException {   String qPath = ""/hosting/web/{serviceName}/database"";   StringBuilder sb = path(qPath, serviceName);   HashMap<String, Object>o = new HashMap<String, Object>();   addBody(o, ""capabilitie"", capabilitie);   addBody(o, ""password"", password);   addBody(o, ""quota"", quota);   addBody(o, ""type"", type);   addBody(o, ""user"", user);   addBody(o, ""version"", version);   String resp = exec(qPath, ""POST"", sb.toString(), o);   return convertTo(resp, OvhTask.class);  }
protected static void addScope(String name, String criteria) {         ModelDelegate.addScope(modelClass().getName(), name, criteria);     }
public void setStep(java.lang.Object _step) {   getStateHelper().put(PropertyKeys.step, _step);  }
public void set(Segment1D<?, ?> segment, double curviline, double shift) {   assert segment != null : AssertMessages.notNullParameter(0);   segmentProperty().set(new WeakReference<>(segment));   xProperty().set(curviline);   yProperty().set(shift);  }
public Request searchDisjunctiveFacetingAsync(@NonNull Query query, @NonNull final Collection<String> disjunctiveFacets, @NonNull final Map<String, ? extends Collection<String>> refinements, @NonNull final CompletionHandler completionHandler) {         return searchDisjunctiveFacetingAsync(query, disjunctiveFacets, refinements, /* requestOptions: */ null, completionHandler);     }
@Override     void setLocation(int x, int y) {         if (x != nextX || y != nextY) {             nextX = x;             nextY = y;             MonocleWindowManager.getInstance().repaintAll();         }     }
public static com.google.gwt.dom.client.Element createIFrameElement(String name) {          return getDOMImpl().createIFrameElement(Document.get(), name);     }
public final Self bindings(play.api.inject.Binding<?>... bindings) {     return bindings(Guiceable.bindings(bindings));   }
public void merge(String parity, String source, String codecId, int[] checksums)      throws IOException {     if(FSNamesystem.LOG.isDebugEnabled()) {       FSNamesystem.LOG.debug(""merge "" + parity + "" to "" + source);     }     if (isInSafeMode()) {       throw new SafeModeException(""merge: cannot merge "" + parity + "" to ""                                    + source, safeMode);     }     // Verify parity and source      if (source == null || source.isEmpty() || parity == null || parity.isEmpty()) {       throw new IOException(           ""merge: source file name or parity file name is empty"");     }     // Verify checksums     if (checksums == null || checksums.length == 0) {       throw new IOException(""merge: checksum array is empty or null"");     }     // Verify codec     RaidCodec codec = RaidCodec.getCodec(codecId);     if (codec == null) {       throw new IOException(""merge: codec "" + codecId + "" doesn't exist"");     }          INode[] sourceINodes = dir.getExistingPathINodes(source);     INode[] parityINodes = dir.getExistingPathINodes(parity);     writeLock();     try {       // write permissions for the source       if (isPermissionEnabled) {         if (isPermissionCheckingEnabled(sourceINodes)) {           checkPathAccess(source, sourceINodes, FsAction.WRITE);          }         if (isPermissionCheckingEnabled(parityINodes)) {           checkPathAccess(parity, parityINodes, FsAction.READ); // read the file           checkParentAccess(parity, parityINodes, FsAction.WRITE); // for delete         }       }       INode sinode = sourceINodes[sourceINodes.length - 1];       INode pinode = parityINodes[parityINodes.length - 1];              if (sinode == null || pinode == null) {         throw new IOException(             ""merge: source file or parity file doesn't exist"");       }              if (sinode.isUnderConstruction() || pinode.isUnderConstruction()) {         throw new IOException(             ""merge: source file or parity file is under construction"");       }              if (sinode.isDirectory() || pinode.isDirectory()) {         throw new IOException(             ""merge: source file or parity file is a directory"");       }              if (sinode instanceof INodeHardLinkFile ||           pinode instanceof INodeHardLinkFile) {          throw new IOException(""merge: source file or parity file is hardlinked"");         }        INodeFile sourceINode = (INodeFile) sinode;       INodeFile parityINode = (INodeFile) pinode;        if (sourceINode.getStorageType() != StorageType.REGULAR_STORAGE           || parityINode.getStorageType() != StorageType.REGULAR_STORAGE) {         throw new IOException(             ""merge: source file or parity file doesn't support merge"");       }       if (sourceINode.getModificationTime() != parityINode.getModificationTime()) {         throw new IOException(             ""merge: source file and parity file doesn't have the same modification time"");       }       if (parityINode.getReplication() != codec.parityReplication) {         throw new IOException(             ""merge: parity file's replication doesn't match codec's parity replication"");       }              BlockInfo[] sourceBlks = sourceINode.getBlocks();       BlockInfo[] parityBlks = parityINode.getBlocks();              if (sourceBlks == null || sourceBlks.length == 0) {         throw new IOException(""merge: "" + source + "" is empty"");       }       if (parityBlks == null || parityBlks.length == 0) {         throw new IOException(""merge: "" + parity + "" is empty"");       }       if (checksums.length != sourceBlks.length) {         throw new IOException(""merge: checksum length "" + checksums.length +             "" doesn't match number of source blocks "" + sourceBlks.length);       }       int expectedParityBlocks = codec.getNumStripes(sourceBlks.length)            * codec.numParityBlocks;       if (expectedParityBlocks != parityBlks.length) {         throw new IOException(""merge: expect parity blocks "" +              expectedParityBlocks + "" doesn't match number of parity blocks "" +              parityBlks.length);       }        if(NameNode.stateChangeLog.isDebugEnabled()) {         NameNode.stateChangeLog.debug(""DIR* NameSystem.merge: "" +             parity + "" to "" + source);       }              dir.mergeInternal(parityINodes, sourceINodes, parity, source, codec,                         checksums);     } finally {       writeUnlock();     }     getEditLog().logSync();      if (auditLog.isInfoEnabled()) {       logAuditEvent(getCurrentUGI(),                     Server.getRemoteIp(),                     ""merge"", parity, source,                      getLastINode(sourceINodes));     }   }
void extractCalibration( Homography2D_F64 Hinv , CameraPinhole c ) {   CommonOps_DDF3.multTransA(Hinv,W0,tmp);   CommonOps_DDF3.mult(tmp,Hinv,Wi);    convertW(Wi,c);  }
protected void browseOnDesktopIfNeeds(final URI uri) {         if (!browseOnDesktop) {             return;         }         final java.awt.Desktop desktop = java.awt.Desktop.getDesktop();         try {             desktop.browse(uri);         } catch (IOException e) {             throw new IllegalStateException(""Failed to browse the URI: "" + uri, e);         }     }
public static boolean equalContents(int[][] xs, int[][] ys) {      if(xs ==null)        return ys == null;      if(ys == null)        return false;      if(xs.length != ys.length)        return false;      for(int i = xs.length-1; i >= 0; i--) {        if(! equalContents(xs[i],ys[i]))          return false;      }      return true;    }
private static BucketSizeType bucketSizeFromInterval(HistogramIntervalType interval) {         BucketSizeType bucketSize;         switch (interval) {         case minute:             bucketSize = BucketSizeType.Minute;             break;         case hour:             bucketSize = BucketSizeType.Hour;             break;         case day:             bucketSize = BucketSizeType.Day;             break;         case week:             bucketSize = BucketSizeType.Week;             break;         case month:             bucketSize = BucketSizeType.Month;             break;         default:             bucketSize = BucketSizeType.Day;             break;         }         return bucketSize;     }
public static String translate(String str) {  if (str == null) return """";  // TODO do-while machen  int index, last = 0, endIndex;  StringBuilder sb = null;  String tagName;  while ((index = str.indexOf('<', last)) != -1) {      // read tagname      int len = str.length();      char c;      for (endIndex = index + 1; endIndex < len; endIndex++) {   c = str.charAt(endIndex);   if ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z')) break;      }      tagName = str.substring(index + 1, endIndex);       if (compareTagName(tagName)) {   if (sb == null) {       sb = new StringBuilder();       last = 0;   }   sb.append(str.substring(last, index + 1));   sb.append(""invalidTag"");   last = endIndex;      }      else if (sb != null) {   sb.append(str.substring(last, index + 1));   last = index + 1;      }      else last = index + 1;   }  if (sb != null) {      if (last != str.length()) sb.append(str.substring(last));      return sb.toString();  }  return str;     }
@Override     public synchronized void onClose() {         super.onClose();         if (phoneStateListener != null)             telephonyManager.listen(phoneStateListener, PhoneStateListener.LISTEN_NONE);     }
public void error(String message) {    if (getLevel() > Level.ERROR.ordinal()) return;    logMessage(Level.ERROR, message, null);   }
public Optional<String> getAttribute(String theKey) {   Validate.notBlank(theKey);   if (myAttributes == null) {    return Optional.empty();   }   return Optional.ofNullable(myAttributes.get(theKey));  }
private boolean check(File fingerprintFile, TaskListener listener) {         try {             Fingerprint fp = loadFingerprint(fingerprintFile);             if (fp == null || !fp.isAlive()) {                 listener.getLogger().println(""deleting obsolete "" + fingerprintFile);                 fingerprintFile.delete();                 return true;             } else {                 // get the fingerprint in the official map so have the changes visible to Jenkins                 // otherwise the mutation made in FingerprintMap can override our trimming.                 fp = getFingerprint(fp);                 return fp.trim();             }         } catch (IOException e) {             Functions.printStackTrace(e, listener.error(""Failed to process "" + fingerprintFile));             return false;         }     }
protected final void setAlpha(final float alpha) {         Condition.INSTANCE.ensureAtLeast(alpha, 0, ""The alpha must be at least 0"");         Condition.INSTANCE.ensureAtMaximum(alpha, 1, ""The alpha must be at maximum 1"");         this.alpha = alpha;     }
public JTSLineStringExpression<LineString> interiorRingN(int idx) {         return JTSGeometryExpressions.lineStringOperation(SpatialOps.INTERIOR_RINGN, mixin, ConstantImpl.create(idx));     }
private static float computeLowestRoot(float a, float b, float c, float maxR) {         float determinant = b * b - 4.0f * a * c;         if (determinant < 0.0f)             return Float.POSITIVE_INFINITY;         float sqrtD = (float) Math.sqrt(determinant);         float r1 = (-b - sqrtD) / (2.0f * a);         float r2 = (-b + sqrtD) / (2.0f * a);         if (r1 > r2) {             float temp = r2;             r2 = r1;             r1 = temp;         }         if (r1 > 0.0f && r1 < maxR) {             return r1;         }         if (r2 > 0.0f && r2 < maxR) {             return r2;         }         return Float.POSITIVE_INFINITY;     }
public EClass getGeometryData() {    if (geometryDataEClass == null) {     geometryDataEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(GeometryPackage.eNS_URI).getEClassifiers().get(4);    }    return geometryDataEClass;   }
public String getFullPath() {          String path = m_resource.getRootPath();         if ((m_siteMode != SITE_MODE_ROOT) && (m_cms != null)) {             String site = getSite();             if (path.startsWith(site)) {                 path = path.substring(site.length());             }         }         return path;     }
public void send(PeerMessage message) throws IllegalStateException {     logger.trace(""Sending msg {} to {}"", message.getType(), this);     if (this.isConnected()) {       ByteBuffer data = message.getData();       data.rewind();       connectionManager.offerWrite(new WriteTask(socketChannel, data, new WriteListener() {         @Override         public void onWriteFailed(String message, Throwable e) {           if (e == null) {             logger.info(message);           } else if (e instanceof ConnectionClosedException){             logger.debug(message, e);             unbind(true);           } else {             LoggerUtils.warnAndDebugDetails(logger, message, e);           }          }          @Override         public void onWriteDone() {         }       }), 1, TimeUnit.SECONDS);     } else {       logger.trace(""Attempting to send a message to non-connected peer {}!"", this);       unbind(true);     }   }
public void stop() {     if (runnerThread == null) {       return;     }      runnerThread.interrupt();      nsLock.writeLock().lock();     try {       if (runnerThread == null) {         return;       }        this.cancel();       this.close();        while (runnerThread.isAlive()) {         runnerThread.interrupt();         try {           runnerThread.join(1000);         } catch (final Exception e) {           e.printStackTrace();           return;         }       }       runnerThread = null;     } catch (Exception e) {       e.printStackTrace();     } finally {       nsLock.writeLock().unlock();     }   }
private List<Pair<Integer, Integer>> doGenerateEdgesWithOmitList() {         final int numberOfNodes = getConfiguration().getNumberOfNodes();         final int numberOfEdges = getConfiguration().getNumberOfEdges();         final long maxEdges = numberOfNodes * (numberOfNodes - 1) / 2;          final List<Pair<Integer, Integer>> edges = new LinkedList<>();          for (Long index : edgeIndices(numberOfEdges, maxEdges)) {             edges.add(indexToEdgeBijection(index));         }          return edges;     }
@Override     public String tagKey(String key) {         String conventionKey = delegate.tagKey(key);          conventionKey = START_UNDERSCORE_PATTERN.matcher(conventionKey).replaceAll(""""); // 2         conventionKey = SF_PATTERN.matcher(conventionKey).replaceAll(""""); // 2          if (!START_LETTERS_PATTERN.matcher(conventionKey).matches()) { // 3             conventionKey = ""a"" + conventionKey;         }         return StringUtils.truncate(conventionKey, KEY_MAX_LENGTH); // 1     }
public PersonCreditList<CreditBasic> getPersonCombinedCredits(int personId, String language) throws MovieDbException {         TmdbParameters parameters = new TmdbParameters();         parameters.add(Param.ID, personId);         parameters.add(Param.LANGUAGE, language);          URL url = new ApiUrl(apiKey, MethodBase.PERSON).subMethod(MethodSub.COMBINED_CREDITS).buildUrl(parameters);         String webpage = httpTools.getRequest(url);          try {             ObjectMapper mapper = new ObjectMapper();             mapper.addMixIn(PersonCreditList.class, PersonCreditsMixIn.class);             TypeReference tr = new TypeReference<PersonCreditList<CreditBasic>>() {             };             return mapper.readValue(webpage, tr);         } catch (IOException ex) {             throw new MovieDbException(ApiExceptionType.MAPPING_FAILED, ""Failed to get person combined credits"", url, ex);         }     }
protected void removeExpiredPortletCookies(HttpServletRequest request) {         Map<String, SessionOnlyPortletCookieImpl> sessionOnlyCookies =                 getSessionOnlyPortletCookieMap(request);         for (Entry<String, SessionOnlyPortletCookieImpl> entry : sessionOnlyCookies.entrySet()) {             String key = entry.getKey();             SessionOnlyPortletCookieImpl sessionOnlyCookie = entry.getValue();             if (sessionOnlyCookie.getExpires().isBeforeNow()) {                 sessionOnlyCookies.remove(key);             }         }     }
public void printHtmlLogo(PrintWriter out, ResourceBundle reg)         throws DBException     {         char chMenubar = HBasePanel.getFirstToUpper(this.getProperty(DBParams.LOGOS), 'H');         if (chMenubar == 'H') if (((BasePanel)this.getScreenField()).isMainMenu())             chMenubar = 'Y';         if (chMenubar == 'Y')         {             String strNav = reg.getString(""htmlLogo"");             strNav = Utility.replaceResources(strNav, reg, null, null);             String strScreen = ((BasePanel)this.getScreenField()).getScreenURL();             strScreen = Utility.encodeXML(strScreen);             String strUserName = ((MainApplication)this.getTask().getApplication()).getUserName();             if (Utility.isNumeric(strUserName))                 strUserName = DBConstants.BLANK;             String strLanguage = this.getTask().getApplication().getLanguage(false);             strNav = Utility.replace(strNav, HtmlConstants.URL_TAG, strScreen);             strNav = Utility.replace(strNav, HtmlConstants.USER_NAME_TAG, strUserName);             strNav = Utility.replace(strNav, ""<language/>"", strLanguage);             this.writeHtmlString(strNav, out);         }     }
@Override     public void onBindViewHolder(ViewHolder viewHolder, final int position) {         final DeviceGuiElement device = ClientsGuiList.get().getClients().get(position);          viewHolder.identifierTextView.setText(device.getIdentifier());         viewHolder.logo.setImageDrawable(new IconicsDrawable(context)                 .icon(FontAwesome.Icon.faw_android)                 .color(context.getResources().getColor(R.color.red))                 .sizeDp(30));          viewHolder.setOnClickListener(new OnClickListener() {             @Override             public void onClick(View v) {                 itemClickListener.clientItemClicked(device);             }         });     }
void     note(Notes note)     {         assert (this.allnotes != null);         int gid = note.gid;         int id = note.id;         NoteSort sort = note.getSort();         Map<Long, Notes> sortnotes = this.allnotes.get(sort);         assert sortnotes != null;         switch (sort) {             case TYPE:             case GROUP:             case DIM:                 assert sortnotes.get(id) == null;                 sortnotes.put((long) id, note);                 break;             case VAR:                 long gv = Nc4Notes.getVarId((VarNotes) note);                 assert sortnotes.get(gv) == null;                 sortnotes.put(gv, note);                 break;         }     }
@Pure  public IntegerProperty depthProperty() {   if (this.depth == null) {    this.depth = new ReadOnlyIntegerWrapper(this, MathFXAttributeNames.DEPTH);    this.depth.bind(Bindings.subtract(maxZProperty(), minZProperty()));   }   return this.depth;  }
public static ExprDouble toExprDouble(Expression left, Expression right, int operation) {  return new OpDouble(left, right, operation);     }
public WebSocketPublisher toWS() {         return new WebSocketPublisher()             .coding(coding)             .facade(facade)             .hostName(hostName)             .port(port)             .urlPath(urlPath);     }
@SuppressWarnings(""unchecked"")   public EList<IfcLightDistributionData> getDistributionData() {    return (EList<IfcLightDistributionData>) eGet(      Ifc2x3tc1Package.Literals.IFC_LIGHT_INTENSITY_DISTRIBUTION__DISTRIBUTION_DATA, true);   }
public static MSColor valueOfKnownColor(final String name) {                    for(MSColor color : KNOWN_COLORS) {              if(color.name.equalsIgnoreCase(name)) {                  return color;                                } else if(color.getLocaleName() != null && color.getLocaleName().equalsIgnoreCase(name)) {                  return color;                                }                        }                    return null;                }
public void marshall(AddFacetToObjectRequest addFacetToObjectRequest, ProtocolMarshaller protocolMarshaller) {          if (addFacetToObjectRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(addFacetToObjectRequest.getDirectoryArn(), DIRECTORYARN_BINDING);             protocolMarshaller.marshall(addFacetToObjectRequest.getSchemaFacet(), SCHEMAFACET_BINDING);             protocolMarshaller.marshall(addFacetToObjectRequest.getObjectAttributeList(), OBJECTATTRIBUTELIST_BINDING);             protocolMarshaller.marshall(addFacetToObjectRequest.getObjectReference(), OBJECTREFERENCE_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public boolean send(PooledByteBuffer pooled) throws IOException {         if(isWritesShutdown()) {             throw UndertowMessages.MESSAGES.channelIsClosed();         }         boolean result = sendInternal(pooled);         if(result) {             flush();         }         return result;     }
private String parse(Matrix matrix) {   String transform = """";   if (matrix != null) {    double dx = matrix.getDx();    double dy = matrix.getDy();    if (matrix.getXx() != 0 && matrix.getYy() != 0 && matrix.getXx() != 1 && matrix.getYy() != 1) {     transform += ""scale("" + matrix.getXx() + "", "" + matrix.getYy() + "")""; // scale first     // no space between 'scale' and '(' !!!     dx /= matrix.getXx();     dy /= matrix.getYy();    }    transform += "" translate("" + (float) dx + "", "" + (float) dy + "")"";    // no space between 'translate' and '(' !!!   }   return transform;  }
public static void encodeDesc(Boolean value, byte[] dst, int dstOffset) {          if (value == null) {              dst[dstOffset] = NULL_BYTE_LOW;          } else {              dst[dstOffset] = value.booleanValue() ? (byte)127 : (byte)128;          }      }
public void updateExecutionStateAsynchronously(final ExecutionState newExecutionState,    final String optionalMessage) {    final Runnable command = new Runnable() {     /**     * {@inheritDoc}     */    @Override    public void run() {      updateExecutionState(newExecutionState, optionalMessage);    }   };    this.executionGraph.executeCommand(command);  }
private void registerInternal(final JobID id, final Path[] clientPaths) throws IOException {    final String[] cacheNames = new String[clientPaths.length];    for (int i = 0; i < clientPaths.length; ++i) {    final LibraryTranslationKey key = new LibraryTranslationKey(id, clientPaths[i]);    cacheNames[i] = this.clientPathToCacheName.get(key);    if (cacheNames[i] == null) {     throw new IOException(""Cannot map"" + clientPaths[i].toString() + "" to cache name"");    }   }    // Register as regular   registerInternal(id, cacheNames);  }
public void clearPassword() {   for (char pw[] : this.secrets) {    for (int i = 0; i < pw.length; i++) {     pw[i] = 0;    }   }    /* Now discard the list. */   this.secrets = new ArrayList<char []>();  }
public static String getPremadeWidgetHtml(String guildId, WidgetTheme theme, int width, int height)     {         Checks.notNull(guildId, ""GuildId"");         Checks.notNull(theme, ""WidgetTheme"");         Checks.notNegative(width, ""Width"");         Checks.notNegative(height, ""Height"");         return String.format(WIDGET_HTML, guildId, theme.name().toLowerCase(), width, height);     }
public HttpClientResponseBuilder withCookie(String cookieName, String cookieValue) {         Action lastAction = newRule.getLastAction();         CookieAction cookieAction = new CookieAction(lastAction, cookieName, cookieValue);         newRule.overrideLastAction(cookieAction);         return this;     }
@Override     public IRenderingElement generate(IAtomContainer container, RendererModel model) {         ElementGroup numbers = new ElementGroup();         if (!model.getParameter(WillDrawAtomNumbers.class).getValue()) return numbers;          Vector2d offset = new Vector2d(this.offset.getValue().x, -this.offset.getValue().y);         offset.scale(1 / model.getParameter(Scale.class).getValue());          int number = 1;         for (IAtom atom : container.atoms()) {             Point2d point = new Point2d(atom.getPoint2d());             point.add(offset);             numbers.add(new TextElement(point.x, point.y, String.valueOf(number), colorByType.getValue() ? atomColorer                     .getValue().getAtomColor(atom) : textColor.getValue()));             number++;         }         return numbers;     }
private List<DependencyNode> depLevelOrderList(DependencyNode rootNode)   {      // Create list to store aggregate list of all nodes in tree     List <DependencyNode> aggDepNodeList = new LinkedList<DependencyNode> ();          // Create list that stores current breadth     List <DependencyNode> nodeChildList = rootNode.getChildren();     //LevelOrderList.add(rootNode);      while (!nodeChildList.isEmpty()) {       nodeChildList = levelTraverseTreeList(nodeChildList, aggDepNodeList);     }          return aggDepNodeList;   }
public void setAuthentication(HttpURLConnection http) {      if(user == null || pass == null      || user.length() <= 0 || pass.length() <= 0) {    return;   }    String base64login = Base64.encode(user + "":"" + pass);    http.addRequestProperty(""Authorization"", ""Basic "" + base64login);     }
public static int getIntArg(CommandLine cl, Option option, int defaultValue) {     int arg = defaultValue;     if (cl.hasOption(option.getLongOpt())) {       String argOption = cl.getOptionValue(option.getLongOpt());       arg = Integer.parseInt(argOption);     }     return arg;   }
public Map<String, String> paramMap() {         Map<String, String> params = new HashMap<>();          if (getQuery() != null)             params.put(""q"", getQuery());         if (getMode() != null)             params.put(""mode"", getMode().toString());         if (getStatus() != null)             params.put(""status"", getStatus());         if (getAssignedTo() != null)             params.put(""assigned_to"", getAssignedTo());         if (getModifiedFrom() != null)             params.put(""modified_from"", getModifiedFrom());         if (getModifiedTo() != null)             params.put(""modified_to"", getModifiedTo());         if (getPublishedFrom() != null)             params.put(""published_from"", getPublishedFrom());         if (getPublishedTo() != null)             params.put(""published_to"", getPublishedTo());         if (getCount() != null)             params.put(""count"", getCount().toString());         if (getOffset() != null)             params.put(""offset"", getOffset().toString());         if (getOrderBy() != null)             params.put(""order"", getOrderBy());         if (getOutputType() != null)             params.put(""output_type"", getOutputType().toString());          return params;     }
public static Set<String> getFixedURLs(final ContentSpec contentSpec) {         final Set<String> fixedUrls = new HashSet<String>();          for (final Node childNode : contentSpec.getNodes()) {             if (childNode instanceof SpecNode) {                 final SpecNode specNode = ((SpecNode) childNode);                 if (!isNullOrEmpty(specNode.getFixedUrl())) {                     fixedUrls.add(specNode.getFixedUrl());                 }             }              if (childNode instanceof Level) {                 fixedUrls.addAll(getFixedURLs((Level) childNode));             }         }          fixedUrls.addAll(getFixedURLs(contentSpec.getBaseLevel()));          return fixedUrls;     }
public static BaseResult clear_quota(String component_access_token, String component_appid) {          String json = String.format(""{\""component_appid\"":\""%s\""}"", component_appid);          HttpUriRequest httpUriRequest = RequestBuilder.post()                  .setHeader(jsonHeader)                  .setUri(BASE_URI + ""/cgi-bin/component/clear_quota"")                  .addParameter(""component_access_token"", API.componentAccessToken(component_access_token))                  .setEntity(new StringEntity(json, Charset.forName(""utf-8"")))                  .build();          return LocalHttpClient.executeJsonResult(httpUriRequest, BaseResult.class);      }
@Override     public java.util.concurrent.Future<UpdateApplicationResult> updateApplicationAsync(             com.amazonaws.handlers.AsyncHandler<UpdateApplicationRequest, UpdateApplicationResult> asyncHandler) {          return updateApplicationAsync(new UpdateApplicationRequest(), asyncHandler);     }
public Attribute findAttribute(String fullNameEscaped) {     if (fullNameEscaped == null || fullNameEscaped.length() == 0) {       return null;     }      int posAtt = fullNameEscaped.indexOf('@');     if (posAtt < 0 || posAtt >= fullNameEscaped.length() - 1)       return null;     if (posAtt == 0) {       return findGlobalAttribute(fullNameEscaped.substring(1));     }      String path = fullNameEscaped.substring(0, posAtt);     String attName = fullNameEscaped.substring(posAtt + 1);      // find the group     Group g = rootGroup;     int pos = path.lastIndexOf('/');     String varName = (pos > 0 && pos < path.length() - 1) ? path.substring(pos + 1) : null;     if (pos >= 0) {       String groups = path.substring(0, pos);       StringTokenizer stoke = new StringTokenizer(groups, ""/"");       while (stoke.hasMoreTokens()) {         String token = NetcdfFile.makeNameUnescaped(stoke.nextToken());         g = g.findGroup(token);         if (g == null) return null;       }     }     if (varName == null) // group attribute       return g.findAttribute(attName);      // heres var.var - tokenize respecting the possible escaped '.'     List<String> snames = EscapeStrings.tokenizeEscapedName(varName);     if (snames.size() == 0) return null;      String varShortName = NetcdfFile.makeNameUnescaped(snames.get(0));     Variable v = g.findVariable(varShortName);     if (v == null) return null;      int memberCount = 1;     while (memberCount < snames.size()) {       if (!(v instanceof Structure)) return null;       String name = NetcdfFile.makeNameUnescaped(snames.get(memberCount++));       v = ((Structure) v).findVariable(name);       if (v == null) return null;     }      return v.findAttribute(attName);   }
@Override  public boolean createDataColumnsTable() {   verifyWritable();    boolean created = false;   DataColumnsDao dao = getDataColumnsDao();   try {    if (!dao.isTableExists()) {     created = tableCreator.createDataColumns() > 0;    }   } catch (SQLException e) {    throw new GeoPackageException(""Failed to check if ""      + DataColumns.class.getSimpleName()      + "" table exists and create it"", e);   }   return created;  }
public static StringBuilder elapsedAndSize(long startTimeNanos, long endTimeNanos, long size) {         final StringBuilder buf = new StringBuilder(16);         appendElapsedAndSize(buf, startTimeNanos, endTimeNanos, size);         return buf;     }
protected void addTypeParameters(ExecutableMemberDoc member, Content htmltree) {         Content typeParameters = getTypeParameters(member);         if (!typeParameters.isEmpty()) {             htmltree.addContent(typeParameters);             htmltree.addContent(writer.getSpace());         }     }
public void setDayFormatter(DayFormatter formatter) {     this.contentDescriptionFormatter = contentDescriptionFormatter == this.formatter ?                                        formatter : contentDescriptionFormatter;     this.formatter = formatter == null ? DayFormatter.DEFAULT : formatter;     CharSequence currentLabel = getText();     Object[] spans = null;     if (currentLabel instanceof Spanned) {       spans = ((Spanned) currentLabel).getSpans(0, currentLabel.length(), Object.class);     }     SpannableString newLabel = new SpannableString(getLabel());     if (spans != null) {       for (Object span : spans) {         newLabel.setSpan(span, 0, newLabel.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);       }     }     setText(newLabel);   }
public boolean checkObsolete(IGraphStore store, boolean isReorg, int lineNo, String fileName) {         if (type == RecordType.T) {             // Transaction boundaries are obsolete during reorg              return isReorg;         } else if (type == RecordType.L) {             // A log is always obsolete             return false;         } else if ((type != RecordType.V) && (type != RecordType.E)) {             throw new BitsyException(BitsyErrorCodes.INTERNAL_ERROR, ""Unhanded record type: "" + type);         }          // A V or E record         UUID id = null;         int version = -1;         String state = null;         JsonToken token;          try {             JsonParser parser = factory.createJsonParser(json);                          while ((token = parser.nextToken()) != JsonToken.END_OBJECT) {                 // Find the version                 if (token == JsonToken.FIELD_NAME) {                     if (parser.getCurrentName().equals(""id"")) {                         parser.nextToken();                         id = UUID.fromString(parser.getText());                         continue;                     }                      if (parser.getCurrentName().equals(""v"")) {                         parser.nextToken();                         version = parser.getIntValue();                         continue;                     }                      if (parser.getCurrentName().equals(""s"")) {                         parser.nextToken();                         state = parser.getText();                          // No need to proceed further                         break;                     }                 }             }              if ((id == null) || (version == -1) || (state == null)) {                 throw new BitsyException(BitsyErrorCodes.INTERNAL_ERROR, ""Unable to parse record '"" + json + ""' in file "" + fileName + "" at line "" + lineNo);             }              if (state.equals(""D"")) {                 // Deleted -- can be ignored only on re-orgs                 return isReorg;             } else {                 if (type == RecordType.V) {                     VertexBean curV = store.getVertex(id);                     if (curV == null) {                         // Doesn't exist anymore, probably deleted later                         return true;                     } else if (curV.getVersion() != version) {                         // Obsolete                         return true;                     } else {                         // Good to go                         return false;                     }                 } else {                     assert (type == RecordType.E);                      EdgeBean curE = store.getEdge(id);                     if (curE == null) {                         // Doesn't exist anymore, probably deleted later                         return true;                     } else if (curE.getVersion() != version) {                         // Obsolete                         return true;                     } else {                         // Good to go                         return false;                     }                 }             }         } catch (Exception e) {             throw new BitsyException(BitsyErrorCodes.INTERNAL_ERROR, ""Possible bug in code. Error serializing line '"" + json + ""' in file "" + fileName + "" at line "" + lineNo, e);         }     }
public <E extends Exception> boolean noneMatch(Try.DoublePredicate<E> filter) throws E {          return noneMatch(0, size(), filter);      }
static int binarySearch(final short[] a, final int fromIndex, final int toIndex, final short key) {          if (N.isNullOrEmpty(a)) {              return N.INDEX_NOT_FOUND;          }            return Arrays.binarySearch(a, fromIndex, toIndex, key);      }
public java.lang.String getServiceName() {     java.lang.Object ref = serviceName_;     if (ref instanceof java.lang.String) {       return (java.lang.String) ref;     } else {       com.google.protobuf.ByteString bs =            (com.google.protobuf.ByteString) ref;       java.lang.String s = bs.toStringUtf8();       serviceName_ = s;       return s;     }   }
@Override  public List<Connector> getSipConnectors() {   List<Connector> connectors = new ArrayList<Connector>();      Connector[] conns = service.findConnectors();      for (Connector conn : conns) {    if (conn.getProtocolHandler() instanceof SipProtocolHandler){     connectors.add(conn);    }   }      return connectors;  }
private Term evalDatatype(Function term) {   Term innerTerm = term.getTerm(0);   if (innerTerm instanceof Function) {    Function function = (Function) innerTerm;    return getDatatype(function);   }   return term;  }
@Override  public final void onCreate(SQLiteDatabase db) {   ConnectionSource cs = getConnectionSource();   /*    * The method is called by Android database helper's get-database calls when Android detects that we need to    * create or update the database. So we have to use the database argument and save a connection to it on the    * AndroidConnectionSource, otherwise it will go recursive if the subclass calls getConnectionSource().    */   DatabaseConnection conn = cs.getSpecialConnection(null);   boolean clearSpecial = false;   if (conn == null) {    conn = new AndroidDatabaseConnection(db, true, cancelQueriesEnabled);    try {     cs.saveSpecialConnection(conn);     clearSpecial = true;    } catch (SQLException e) {     throw new IllegalStateException(""Could not save special connection"", e);    }   }   try {    onCreate(db, cs);   } finally {    if (clearSpecial) {     cs.clearSpecialConnection(conn);    }   }  }
public static Filter inFilter(String column, Object operand) {       return new Filter(column, FilterOperator.IN, operand);     }
@CheckForNull     public static Boolean optBoolean(String name) {         String v = getString(name);         return v == null ? null : Boolean.parseBoolean(v);     }
public final void addProductToProductSet(String name, String product) {      AddProductToProductSetRequest request =         AddProductToProductSetRequest.newBuilder().setName(name).setProduct(product).build();     addProductToProductSet(request);   }
private static <K, V> void set(Map<K, Set<V>> map, K key, V value) {     Set<V> values = map.get(key);     if (values == null) {       values = new HashSet<>();       map.put(key, values);     }     values.add(value);   }
public Selects parse(String sql) throws SQLParserException {  columnIndex = 0;  ParserString raw = new ParserString(sql.trim());  Selects selects = new Selects();  Select select = new Select();   boolean runAgain = false;  do {       // select      if (!raw.forwardIfCurrentAndNoWordNumberAfter(""select"")) throw new SQLParserException(""missing select"");      raw.removeSpace();       // top      if (raw.forwardIfCurrentAndNoWordNumberAfter(""top"")) {   raw.removeSpace();   ValueNumber number = number(raw);   if (number == null) throw new SQLParserException(""missing top number"");   select.setTop(number);   raw.removeSpace();      }       // distinct      if (raw.forwardIfCurrentAndNoWordNumberAfter(""distinct"")) {   select.setDistinct(true);   raw.removeSpace();      }       // all      if (raw.forwardIfCurrentAndNoWordNumberAfter(""all"")) {   select.setDistinct(false);   raw.removeSpace();      }       // select expression      selectExpressions(raw, select);      raw.removeSpace();       // from      if (!raw.forwardIfCurrentAndNoWordNumberAfter(""from"")) throw new SQLParserException(""missing from"");      tableList(raw, select);      raw.removeSpace();       // where      if (raw.forwardIfCurrentAndNoWordNumberAfter(""where"")) whereExpressions(raw, select);      raw.removeSpace();       // group by      if (raw.forwardIfCurrentAndNoWordNumberAfter(""group by"")) {   groupByExpressions(raw, select);   raw.removeSpace();    // having   if (raw.forwardIfCurrentAndNoWordNumberAfter(""having"")) havingExpressions(raw, select);   raw.removeSpace();      }      selects.addSelect(select);       runAgain = false;      // union      if (raw.forwardIfCurrentAndNoWordNumberAfter(""union"")) {   select = new Select();   raw.removeSpace();   if (raw.forwardIfCurrentAndNoWordNumberAfter(""all"")) {       raw.removeSpace();       select.setUnionDistinct(false);   }   else if (raw.forwardIfCurrentAndNoWordNumberAfter(""distinct"")) {       raw.removeSpace();       select.setUnionDistinct(true);   }   else select.setDistinct(true);   raw.removeSpace();   runAgain = true;      }   }  while (runAgain);   // order by  if (raw.forwardIfCurrentAndNoWordNumberAfter(""order by"")) orderByExpressions(raw, selects);  raw.removeSpace();   if (raw.forwardIfCurrent(';')) raw.removeSpace();   if (!raw.isAfterLast()) throw new SQLParserException(""can not read the full sql statement (stop at:"" + raw.getCurrent() + "")"");  return selects;     }
public void waitUntilAllReceived(int timeout) throws ExternalFrameConfirmationException {         try {             byte flag = ExternalFrameConfirmationCheck.getConfirmation(ab, timeout);             assert (flag == ExternalFrameHandler.CONFIRM_READING_DONE);         } catch (TimeoutException ex) {             throw new ExternalFrameConfirmationException(""Timeout for confirmation exceeded!"");         } catch (InterruptedException e) {             throw new ExternalFrameConfirmationException(""Confirmation thread interrupted!"");         } catch (ExecutionException e) {             throw new ExternalFrameConfirmationException(""Confirmation failed!"");         }     }
@Override  public Object eGet(int featureID, boolean resolve, boolean coreType) {   switch (featureID) {    case AfplibPackage.SAMPLING_RATIOS_RG__HSAMPLE:     return getHSAMPLE();    case AfplibPackage.SAMPLING_RATIOS_RG__VSAMPLE:     return getVSAMPLE();   }   return super.eGet(featureID, resolve, coreType);  }
public static <T> Optional<T> of(T value) {         return value == null ? (Optional<T>) EMPTY : new Optional<>(value);     }
public static byte[] streamBytes(InputStream stream) throws IOException {    ByteArrayOutputStream bytes = new ByteArrayOutputStream();    copyStream(stream, bytes);    return bytes.toByteArray();  }
@Override     public RemoteObjectInstance getRemoteObjectInstance(JavaColonNamespace namespace, String name) throws NamingException {         RemoteObjectInstance roi = null;         InjectionBinding<?> binding = getInjectionBinding(namespace, name);         if (binding != null) {             Object bindingObject = binding.getRemoteObject();             if (bindingObject != null) {                 if (bindingObject instanceof IndirectReference) {                     bindingObject = resolveIndirectReferences(binding, (IndirectReference) bindingObject, 0);                 }                 if (bindingObject instanceof javax.naming.Reference) {                     SerializationContext sc = serializationService.createSerializationContext();                     ByteArrayOutputStream baos = new ByteArrayOutputStream();                     ObjectOutputStream oos = null;                     try {                         oos = sc.createObjectOutputStream(baos);                         oos.writeObject(bindingObject);                     } catch (IOException ex) {                         NamingException ne = new NamingException(""Unable to serialize naming reference: "" + bindingObject);                         ne.initCause(ex);                         throw ne;                     } finally {                         if (oos != null)                             try {                                 oos.close();                             } catch (IOException ex) {                             }                     }                     roi = roiFactory.create(baos.toByteArray());                 } else if (bindingObject instanceof Remote) {                     roi = roiFactory.create((Remote) bindingObject, binding.getInjectionClassTypeName());                 } else {                     roi = roiFactory.create(bindingObject);                 }             }         }         return roi;     }
public void invalidate() {         synchronized (mMeasuredChildren) {             Log.d(Log.SUBSYSTEM.LAYOUT, TAG, ""invalidate all [%d]"", mMeasuredChildren.size());             mMeasuredChildren.clear();         }     }
private String genCodeForFieldAccess(       ExprNode node, SoyType baseType, String containerExpr, String fieldName) {     if (baseType != null && baseType.getKind() == SoyType.Kind.PROTO) {       errorReporter.report(node.getSourceLocation(), PROTO_ACCESS_NOT_SUPPORTED);       return "".ERROR"";     }     return genCodeForLiteralKeyAccess(containerExpr, fieldName);   }
private Token eventuallyMatch(Token.Kind kind) {   checkNotEof();   Token token = tokens.get(index);   if (token.kind != kind) {    return null;   } else {    index = index + 1;    return token;   }  }
@SuppressWarnings(""unchecked"")  private <C extends SecurityConfigurerAdapter<DefaultSecurityFilterChain, HttpSecurity>> C getOrApply(    C configurer) throws Exception {   C existingConfig = (C) getConfigurer(configurer.getClass());   if (existingConfig != null) {    return existingConfig;   }   return apply(configurer);  }
public Generic onGenericArray(Generic genericArray) {                     return declaringType.isGenerified()                             ? new Generic.OfNonGenericType.Latent(genericArray.asErasure(), genericArray)                             : genericArray;                 }
@Check  public void checkSpaceUse(SarlSpace space) {   error(MessageFormat.format(     Messages.SARLValidator_0,     this.grammarAccess.getSpaceKeyword()),     space,     null);  }
public static <X> X runWithFile(InputStream stream, Function<File, X> function) throws IOException {   File f = File.createTempFile(""run-with-file"", null);   try {    try (FileOutputStream out = new FileOutputStream(f)) {     IOUtils.copy(stream, out);    }    return function.apply(f);   } finally {    f.delete();   }  }
public boolean isInClipArea(final long pX, final long pY) {         return pX > mXMin && pX < mXMax && pY > mYMin && pY < mYMax;     }
public static <T> void addExceptionCallback(ListenableFuture<T> future, Consumer<Throwable> exceptionCallback)     {         addExceptionCallback(future, exceptionCallback, directExecutor());     }
protected List<String> translateSarlFormalParametersForSyntheticOperation(JvmExecutable owner, JvmGenericType actionContainer,    boolean varargs, List<InferredStandardParameter> signature) {   final List<String> arguments = CollectionLiterals.newArrayList();   for (final InferredStandardParameter parameterSpec : signature) {    final JvmTypeReference paramType = parameterSpec.getType();    if (parameterSpec instanceof InferredValuedParameter) {     final StringBuilder argumentValue = new StringBuilder();     if (paramType.getType() instanceof JvmTypeParameter) {      argumentValue.append(""(""); //$NON-NLS-1$      argumentValue.append(paramType.getSimpleName());      argumentValue.append("") ""); //$NON-NLS-1$     }     argumentValue.append(this.sarlSignatureProvider.toJavaArgument(       actionContainer.getIdentifier(),       ((InferredValuedParameter) parameterSpec).getCallingArgument()));     arguments.add(argumentValue.toString());    } else {     final EObject param = parameterSpec.getParameter();     final String paramName = parameterSpec.getName();     if (!Strings.isNullOrEmpty(paramName) && paramType != null) {      final JvmFormalParameter lastParam = this.typesFactory.createJvmFormalParameter();      owner.getParameters().add(lastParam);      lastParam.setName(paramName);      if (owner instanceof JvmOperation) {       lastParam.setParameterType(cloneWithTypeParametersAndProxies(paramType, owner));      } else {       lastParam.setParameterType(this.typeBuilder.cloneWithProxies(paramType));      }      this.associator.associate(param, lastParam);      arguments.add(paramName);     }    }   }   return arguments;  }
protected void setupInitialRegistryPaths() throws IOException {         if (registryOperations instanceof RMRegistryOperationsService) {             RMRegistryOperationsService rmRegOperations =                     (RMRegistryOperationsService) registryOperations;             rmRegOperations.initUserRegistryAsync(RegistryUtils.currentUser());         }     }
public List<MessageBuffer> toBufferList()     {         try {             flush();         }         catch (IOException ex) {             // IOException must not happen because underlying ArrayBufferOutput never throws IOException             throw new RuntimeException(ex);         }         return getArrayBufferOut().toBufferList();     }
static float[] buildTemporaryUserVector(ALSServingModel model,                                           List<Pair<String,Double>> parsedPathSegments,                                           float[] Xu) throws OryxServingException {     boolean implicit = model.isImplicit();     Solver solver = model.getYTYSolver();     check(solver != null, Response.Status.SERVICE_UNAVAILABLE, ""No solver available for model yet"");     for (Pair<String,Double> itemValue : parsedPathSegments) {       float[] Yi = model.getItemVector(itemValue.getFirst());       // Given value is taken to be the fictitious current value of Qui = Xu * Yi^T       float[] newXu = ALSUtils.computeUpdatedXu(solver, itemValue.getSecond(), Xu, Yi, implicit);       if (newXu != null) {         Xu = newXu;       }     }     return Xu;   }
private void validateStandardLocations() throws MojoExecutionException     {         boolean hasNonStandardStructure = false;         if ( androidManifestFilePre4.exists() && !androidManifestFilePre4.equals( androidManifestFile ) )         {             getLog().warn( ""Non-standard location of AndroidManifest.xml file found, but not configured:\n ""                     + androidManifestFilePre4 + ""\nMove to the standard location src/main/AndroidManifest.xml\n""                     + ""Or configure androidManifestFile. \n"" );             hasNonStandardStructure = true;         }         if ( resourceDirectoryPre4.exists() && !resourceDirectoryPre4.equals( resourceDirectory ) )         {             getLog().warn( ""Non-standard location of Android res folder found, but not configured:\n ""                     + resourceDirectoryPre4 + ""\nMove to the standard location src/main/res/\n""                     + ""Or configure resourceDirectory. \n"" );             hasNonStandardStructure = true;         }         if ( assetsDirectoryPre4.exists() && !assetsDirectoryPre4.equals( assetsDirectory ) )         {             getLog().warn( ""Non-standard location assets folder found, but not configured:\n ""                     + assetsDirectoryPre4 + ""\nMove to the standard location src/main/assets/\n""                     + ""Or configure assetsDirectory. \n"" );             hasNonStandardStructure = true;         }         if ( nativeLibrariesDirectoryPre4.exists() && !nativeLibrariesDirectoryPre4.equals( nativeLibrariesDirectory ) )         {             getLog().warn( ""Non-standard location native libs folder found, but not configured:\n ""                     + nativeLibrariesDirectoryPre4 + ""\nMove to the standard location src/main/libs/\n""                     + ""Or configure nativeLibrariesDirectory. \n"" );             hasNonStandardStructure = true;         }          if ( hasNonStandardStructure && failOnNonStandardStructure )         {             throw new MojoExecutionException(                     ""\n\nFound files or folders in non-standard locations in the project!\n""                             + ""....This might be a side-effect of a migration to Android Maven Plugin 4+.\n""                             + ""....Please observe the warnings for specific files and folders above.\n""                             + ""....Ideally you should restructure your project.\n""                             + ""....Alternatively add explicit configuration overrides for files or folders.\n""                             + ""....Finally you could set failOnNonStandardStructure to false, potentially ""                             + ""resulting in other failures.\n\n\n""             );         }     }
@Override  public String parse(JsonPullParser parser, OnJsonObjectAddListener listener)    throws IOException, JsonFormatException {   if (parser == null) {    throw new IllegalArgumentException();   }    State state = parser.getEventType();    switch (state) {    case VALUE_NULL:     return null;    case VALUE_STRING:     return parser.getValueString();    default:     throw new IllegalStateException();   }  }
private static Observable<Bitmap> getThumbnailFromUri(final Context context, final Uri data) {     return getThumbnailFromUriWithSizeAndKind(context, data, 0, 0,         MediaStore.Images.Thumbnails.MINI_KIND);   }
public Message5WH_Builder setWhere(Object where, RecognitionException lineAndColumn){   if(where!=null && lineAndColumn!=null){    IsAntlrRuntimeObject iaro = IsAntlrRuntimeObject.create(lineAndColumn);    this.setWhere(where, iaro.getLine(), iaro.getColumn());   }   return this;  }
public byte[] toByteArray()  {   final byte[] r = new byte[size];   int off = 0;   final int n = arrays.size();   for(int k = 0; k < n; k++) {    byte[] src = (byte[])arrays.get(k);    System.arraycopy(src, 0, r, off, src.length);    off += src.length;   }   if(pos > 0) System.arraycopy(buffer, 0, r, off, pos);   return r;  }
@Managed     @ManagedDescription(""Index optimization "")     public void optimize()     {        if (handler instanceof SearchIndex)        {           try           {              if (isSuspended.get())              {                 resume();                   try                 {                    ((SearchIndex)handler).getIndex().optimize();                 }                 finally                 {                    suspend();                 }              }              else              {                 ((SearchIndex)handler).getIndex().optimize();              }           }           catch (IOException e)           {              LOG.error(e.getMessage(), e);           }           catch (ResumeException e)           {              LOG.error(e.getMessage(), e);           }           catch (SuspendException e)           {              LOG.error(e.getMessage(), e);           }        }        else        {           LOG.error(""This kind of QuerHandler class doesn't support index optimization."");        }     }
@PostMapping(path = SamlIdPConstants.ENDPOINT_SAML1_SOAP_ARTIFACT_RESOLUTION)     protected void handlePostRequest(final HttpServletResponse response,                                      final HttpServletRequest request) {         val ctx = decodeSoapRequest(request);         val artifactMsg = (ArtifactResolve) ctx.getMessage();         try {             val issuer = artifactMsg.getIssuer().getValue();             val service = verifySamlRegisteredService(issuer);             val adaptor = getSamlMetadataFacadeFor(service, artifactMsg);             if (adaptor.isEmpty()) {                 throw new UnauthorizedServiceException(UnauthorizedServiceException.CODE_UNAUTHZ_SERVICE, ""Cannot find metadata linked to "" + issuer);             }             val facade = adaptor.get();             verifyAuthenticationContextSignature(ctx, request, artifactMsg, facade);             val artifactId = artifactMsg.getArtifact().getArtifact();             val ticketId = getSamlProfileHandlerConfigurationContext().getArtifactTicketFactory().createTicketIdFor(artifactId);             val ticket = getSamlProfileHandlerConfigurationContext().getTicketRegistry().getTicket(ticketId, SamlArtifactTicket.class);              val issuerService = getSamlProfileHandlerConfigurationContext().getWebApplicationServiceFactory().createService(issuer);             val casAssertion = buildCasAssertion(ticket.getTicketGrantingTicket().getAuthentication(),                 issuerService, service,                 CollectionUtils.wrap(""artifact"", ticket));             getSamlProfileHandlerConfigurationContext().getResponseBuilder().build(artifactMsg, request, response, casAssertion,                 service, facade, SAMLConstants.SAML2_ARTIFACT_BINDING_URI, ctx);         } catch (final Exception e) {             LOGGER.error(e.getMessage(), e);             request.setAttribute(SamlIdPConstants.REQUEST_ATTRIBUTE_ERROR, e.getMessage());             getSamlProfileHandlerConfigurationContext().getSamlFaultResponseBuilder().build(artifactMsg, request, response,                 null, null, null, SAMLConstants.SAML2_ARTIFACT_BINDING_URI, ctx);         }     }
private boolean getCompoundKeyColumn(MetamodelImpl metamodel, EmbeddableType keyObj, StringBuilder builder,         boolean isPresent, CQLTranslator translator, String fieldName, String condition, List<Object> value,         boolean useInClause) {         fieldName = fieldName.substring(fieldName.indexOf(""."") + 1);          // If partition key part age given in query, i.e. restriction on         // id.compositekey.compositePartitionkey.partitionkeyColumn.         if (fieldName.indexOf(""."") > 0) {             String compositePartitionkeyName = fieldName.substring(0, fieldName.indexOf("".""));             AbstractAttribute attribute = (AbstractAttribute) keyObj.getAttribute(compositePartitionkeyName);             fieldName = fieldName.substring(fieldName.indexOf(""."") + 1);              EmbeddableType compositePartitionkey = metamodel.embeddable(attribute.getBindableJavaType());              attribute = (AbstractAttribute) compositePartitionkey.getAttribute(fieldName);              String columnName = attribute.getJPAColumnName();              isPresent = buildWhereClause(builder, isPresent, translator, condition, value, useInClause, attribute,                 columnName, false);         }         // if composite partition key object is given in query, i.e. restriction         // on id.compositekey.compositePartitionkey         else if (metamodel.isEmbeddable(((AbstractAttribute) keyObj.getAttribute(fieldName)).getBindableJavaType())) {             AbstractAttribute attribute = (AbstractAttribute) keyObj.getAttribute(fieldName);             Set<Attribute> attributes = metamodel.embeddable(attribute.getBindableJavaType()).getAttributes();              if (!useInClause) {                 // Iterating and appending each column of composite partition                 // key in query builder.                 for (Attribute nestedAttribute : attributes) {                     String columnName = ((AbstractAttribute) nestedAttribute).getJPAColumnName();                     Object valueObject = PropertyAccessorHelper.getObject(value.isEmpty() ? null : value.get(0),                         (Field) nestedAttribute.getJavaMember());                     translator.buildWhereClause(builder, nestedAttribute.getJavaType(), columnName, valueObject,                         condition, false);                 }             } else {                 throw new IllegalArgumentException(""In clause is not supported on first part of partition key."");             }             isPresent = true;         }         // if Not a composite partition key,         // id.compositekey.partitionkey/clusterKey.         else {             AbstractAttribute attribute = (AbstractAttribute) keyObj.getAttribute(fieldName);             String columnName = attribute.getJPAColumnName();             isPresent = buildWhereClause(builder, isPresent, translator, condition, value, useInClause, attribute,                 columnName, false);         }         return isPresent;     }
public final void entryRuleTerminalRule() throws RecognitionException {         try {             // InternalXtext.g:1096:1: ( ruleTerminalRule EOF )             // InternalXtext.g:1097:1: ruleTerminalRule EOF             {              before(grammarAccess.getTerminalRuleRule());              pushFollow(FollowSets000.FOLLOW_1);             ruleTerminalRule();              state._fsp--;               after(grammarAccess.getTerminalRuleRule());              match(input,EOF,FollowSets000.FOLLOW_2);               }          }         catch (RecognitionException re) {             reportError(re);             recover(input,re);         }         finally {         }         return ;     }
public void saveField(BaseField field)     {         String strFieldName = field.getFieldName();   // Fieldname only         String strData = field.getString();         this.setProperty(strFieldName, strData);     }
private Config loadConfigFileWithFlowNameOverrides(Path configFilePath) throws IOException {     Config flowConfig = this.pullFileLoader.loadPullFile(configFilePath, emptyConfig, false);     String flowName = FSSpecStore.getSpecName(configFilePath);     String flowGroup = FSSpecStore.getSpecGroup(configFilePath);      return flowConfig.withValue(ConfigurationKeys.FLOW_NAME_KEY, ConfigValueFactory.fromAnyRef(flowName))         .withValue(ConfigurationKeys.FLOW_GROUP_KEY, ConfigValueFactory.fromAnyRef(flowGroup));   }
public Thread start(Runnable target, String name)         throws NoThreadException, InterruptedException     {         try {             return start0(target, getTimeout(), name);         }         catch (NoThreadException e) {             e.fillInStackTrace();             throw e;         }     }
private void initialize() {          this.setTitle(Constant.messages.getString(""edit.find.title""));          this.infoLabel = new JLabel(Constant.messages.getString(""edit.find.label.notfound""));          this.infoLabel.setVisible(false);          this.setContentPane(getJPanel());          centreDialog();          txtFind.requestFocus();          this.getRootPane().setDefaultButton(btnFind);          pack();          this.setVisible(true);   }
public static boolean copy(File pFromFile, File pToFile, boolean pOverWrite) throws IOException {          // Copy all directory structure          if (pFromFile.isDirectory()) {              return copyDir(pFromFile, pToFile, pOverWrite);          }            // Check if destination is a directory          if (pToFile.isDirectory()) {              // Create a new file with same name as from              pToFile = new File(pToFile, pFromFile.getName());          }            // Check if file exists, and return false if overWrite is false          if (!pOverWrite && pToFile.exists()) {              return false;          }            InputStream in = null;          OutputStream out = null;            try {              // Use buffer size two times byte array, to avoid i/o bottleneck              in = new FileInputStream(pFromFile);              out = new FileOutputStream(pToFile);                // Copy from inputStream to outputStream              copy(in, out);          }          //Just pass any IOException on up the stack          finally {              close(in);              close(out);          }            return true;  // If we got here, everything is probably okay.. ;-)      }
@PostConstruct     public void init() {         log.debug(""Registering JVM gauges"");         metricRegistry.register(PROP_METRIC_REG_JVM_MEMORY, new MemoryUsageGaugeSet());         metricRegistry.register(PROP_METRIC_REG_JVM_GARBAGE, new GarbageCollectorMetricSet());         metricRegistry.register(PROP_METRIC_REG_JVM_THREADS, new ThreadStatesGaugeSet());         metricRegistry.register(PROP_METRIC_REG_JVM_FILES, new FileDescriptorRatioGauge());         metricRegistry.register(PROP_METRIC_REG_JVM_BUFFERS, new BufferPoolMetricSet(getPlatformMBeanServer()));         metricRegistry.register(PROP_METRIC_REG_JVM_ATTRIBUTE_SET, new JvmAttributeGaugeSet());         metricRegistry.register(PROP_METRIC_REG_OS, new OperatingSystemGaugeSet(getOperatingSystemMXBean()));          if (jhipsterProperties.getMetrics().getJmx().isEnabled()) {             log.debug(""Initializing Metrics JMX reporting"");             JmxReporter jmxReporter = JmxReporter.forRegistry(metricRegistry).build();             jmxReporter.start();         }         if (jhipsterProperties.getMetrics().getLogs().isEnabled()) {             log.info(""Initializing Metrics Log reporting"");             Marker metricsMarker = MarkerFactory.getMarker(""metrics"");             final Slf4jReporter reporter = Slf4jReporter.forRegistry(metricRegistry)                 .outputTo(LoggerFactory.getLogger(""metrics""))                 .markWith(metricsMarker)                 .convertRatesTo(TimeUnit.SECONDS)                 .convertDurationsTo(TimeUnit.MILLISECONDS)                 .build();             reporter.start(jhipsterProperties.getMetrics().getLogs().getReportFrequency(), TimeUnit.SECONDS);         }     }
public GetCelebrityInfoResult withUrls(String... urls) {         if (this.urls == null) {             setUrls(new java.util.ArrayList<String>(urls.length));         }         for (String ele : urls) {             this.urls.add(ele);         }         return this;     }
public Enumeration<String> getParameterNames() {   // JSR 289 Section 5.6.1 Parameters :   // For initial requests where a preloaded Route header specified the application to be invoked, the parameters are those of the SIP or SIPS URI in that Route header.   // For initial requests where the application is invoked the parameters are those present on the request URI,   // if this is a SIP or a SIPS URI. For other URI schemes, the parameter set is undefined.   // For subsequent requests in a dialog, the parameters presented to the application  are those that the application itself   // set on the Record-Route header for the initial request or response (see 10.4 Record-Route Parameters).   // These will typically be the URI parameters of the top Route header field but if the upstream SIP element is a   // ""strict router"" they may be returned in the request URI (see RFC 3261).   // It is the containers responsibility to recognize whether the upstream element is a strict router and determine the right parameter set accordingly.   Vector<String> retval = new Vector<String>();   if(this.getPoppedRoute() != null) {    Iterator<String> parameterNamesIt =  this.getPoppedRoute().getURI().getParameterNames();    while (parameterNamesIt.hasNext()) {     String parameterName = parameterNamesIt.next();     retval.add(parameterName);    }   } else {    Iterator<String> parameterNamesIt =  this.getRequestURI().getParameterNames();    while (parameterNamesIt.hasNext()) {     String parameterName = parameterNamesIt.next();     retval.add(parameterName);    }   }    return retval.elements();  }
private static String getLocalHostNameWithRecovery() throws UnknownHostException {         try {             return (InetAddress.getLocalHost()).getHostName();         } catch (UnknownHostException exception) {             String host = exception.getMessage(); // host = ""hostname: hostname""             if (host != null) {                 int colon = host.indexOf(':');                 if (colon > 0) {                     return host.substring(0, colon);                 }             }             throw exception;         }     }
@Override     public void fillOval(int x, int y, int width, int height) {         setOval(x, y, width, height);         fill(this.oval);     }
public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K, NV>> returnType) {   DataSet<Edge<K, NV>> mappedEdges = edges.map(    new MapFunction<Edge<K, EV>, Edge<K, NV>>() {     private Edge<K, NV> output = new Edge<>();      public Edge<K, NV> map(Edge<K, EV> value) throws Exception {      output.f0 = value.f0;      output.f1 = value.f1;      output.f2 = mapper.map(value);      return output;     }    })    .returns(returnType)    .withForwardedFields(""f0; f1"")     .name(""Map edges"");    return new Graph<>(this.vertices, mappedEdges, this.context);  }
public static nsrunningconfig[] get(nitro_service service, nsrunningconfig_args args) throws Exception{   nsrunningconfig obj = new nsrunningconfig();   options option = new options();   option.set_args(nitro_util.object_to_string_withoutquotes(args));   nsrunningconfig[] response = (nsrunningconfig[])obj.get_resources(service, option);   return response;  }
private List<String> filterSourcelist(List<String> sourceList) {         List<String> filteredList = new ArrayList<String>(sourceList);         filteredList.remove(CollectorConstants.TRACE_CONFIG_VAL);         filteredList.remove(CollectorConstants.MESSAGES_CONFIG_VAL);         return filteredList;     }
public int getColumn(int pos) {  int line = getLine(pos) - 1;  if (line == 0) return pos + 1;  return pos - lines[line - 1].intValue();     }
public void read(ByteCodeParser in)     throws IOException   {     int length = in.readInt();      if (length != 2)       throw new IOException(""expected length of 2 at "" + length);          int code = in.readShort();     _signature = in.getUTF8(code);   }
public void show(ViewGroup parent, boolean usePhoneLayout) {         MarginLayoutParams params = init(parent.getContext(), null, parent, usePhoneLayout);         updateLayoutParamsMargins(null, params);         showInternal(null, params, parent);     }
public boolean addKeyPart(String name, Basic_Field_Types type) throws IOException {         return addKeyPart(name, type.size);     }
public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)    throws IOException, ServletException {    HttpServletRequest request = (HttpServletRequest) req;   HttpServletResponse response = (HttpServletResponse) res;    if (!requiresAuthentication(request, response)) {    chain.doFilter(request, response);     return;   }    if (logger.isDebugEnabled()) {    logger.debug(""Request is to process authentication"");   }    Authentication authResult;    try {    authResult = attemptAuthentication(request, response);    if (authResult == null) {     // return immediately as subclass has indicated that it hasn't completed     // authentication     return;    }    sessionStrategy.onAuthentication(authResult, request, response);   }   catch (InternalAuthenticationServiceException failed) {    logger.error(      ""An internal error occurred while trying to authenticate the user."",      failed);    unsuccessfulAuthentication(request, response, failed);     return;   }   catch (AuthenticationException failed) {    // Authentication failed    unsuccessfulAuthentication(request, response, failed);     return;   }    // Authentication success   if (continueChainBeforeSuccessfulAuthentication) {    chain.doFilter(request, response);   }    successfulAuthentication(request, response, chain, authResult);  }
public CloseableResource<BlockMasterClient> acquireBlockMasterClientResource() {     return new CloseableResource<BlockMasterClient>(mBlockMasterClientPool.acquire()) {       @Override       public void close() {         mBlockMasterClientPool.release(get());       }     };   }
public static vpntrafficpolicy[] get_filtered(nitro_service service, String filter) throws Exception{   vpntrafficpolicy obj = new vpntrafficpolicy();   options option = new options();   option.set_filter(filter);   vpntrafficpolicy[] response = (vpntrafficpolicy[]) obj.getfiltered(service, option);   return response;  }
public GinLinkedBindingBuilder<V> addBinding(       Class<? extends javax.inject.Provider<? extends K>> keyProvider) {     return addBinding(TypeLiteral.get(keyProvider));   }
public static Pair<Grouper<RowBasedKey>, Accumulator<AggregateResult, Row>> createGrouperAccumulatorPair(       final GroupByQuery query,       final boolean isInputRaw,       final Map<String, ValueType> rawInputRowSignature,       final GroupByQueryConfig config,       final Supplier<ByteBuffer> bufferSupplier,       @Nullable final ReferenceCountingResourceHolder<ByteBuffer> combineBufferHolder,       final int concurrencyHint,       final LimitedTemporaryStorage temporaryStorage,       final ObjectMapper spillMapper,       final AggregatorFactory[] aggregatorFactories,       @Nullable final ListeningExecutorService grouperSorter,       final int priority,       final boolean hasQueryTimeout,       final long queryTimeoutAt,       final int mergeBufferSize   )   {     // concurrencyHint >= 1 for concurrent groupers, -1 for single-threaded     Preconditions.checkArgument(concurrencyHint >= 1 || concurrencyHint == -1, ""invalid concurrencyHint"");      final List<ValueType> valueTypes = DimensionHandlerUtils.getValueTypesFromDimensionSpecs(query.getDimensions());      final GroupByQueryConfig querySpecificConfig = config.withOverrides(query);     final boolean includeTimestamp = GroupByStrategyV2.getUniversalTimestamp(query) == null;      final ThreadLocal<Row> columnSelectorRow = new ThreadLocal<>();     final ColumnSelectorFactory columnSelectorFactory = query.getVirtualColumns().wrap(         RowBasedColumnSelectorFactory.create(             columnSelectorRow,             rawInputRowSignature         )     );      final boolean willApplyLimitPushDown = query.isApplyLimitPushDown();     final DefaultLimitSpec limitSpec = willApplyLimitPushDown ? (DefaultLimitSpec) query.getLimitSpec() : null;     boolean sortHasNonGroupingFields = false;     if (willApplyLimitPushDown) {       sortHasNonGroupingFields = DefaultLimitSpec.sortingOrderHasNonGroupingFields(           limitSpec,           query.getDimensions()       );     }      final Grouper.KeySerdeFactory<RowBasedKey> keySerdeFactory = new RowBasedKeySerdeFactory(         includeTimestamp,         query.getContextSortByDimsFirst(),         query.getDimensions(),         querySpecificConfig.getMaxMergingDictionarySize() / (concurrencyHint == -1 ? 1 : concurrencyHint),         valueTypes,         aggregatorFactories,         limitSpec     );      final Grouper<RowBasedKey> grouper;     if (concurrencyHint == -1) {       grouper = new SpillingGrouper<>(           bufferSupplier,           keySerdeFactory,           columnSelectorFactory,           aggregatorFactories,           querySpecificConfig.getBufferGrouperMaxSize(),           querySpecificConfig.getBufferGrouperMaxLoadFactor(),           querySpecificConfig.getBufferGrouperInitialBuckets(),           temporaryStorage,           spillMapper,           true,           limitSpec,           sortHasNonGroupingFields,           mergeBufferSize       );     } else {       final Grouper.KeySerdeFactory<RowBasedKey> combineKeySerdeFactory = new RowBasedKeySerdeFactory(           includeTimestamp,           query.getContextSortByDimsFirst(),           query.getDimensions(),           querySpecificConfig.getMaxMergingDictionarySize(), // use entire dictionary space for combining key serde           valueTypes,           aggregatorFactories,           limitSpec       );        grouper = new ConcurrentGrouper<>(           querySpecificConfig,           bufferSupplier,           combineBufferHolder,           keySerdeFactory,           combineKeySerdeFactory,           columnSelectorFactory,           aggregatorFactories,           temporaryStorage,           spillMapper,           concurrencyHint,           limitSpec,           sortHasNonGroupingFields,           grouperSorter,           priority,           hasQueryTimeout,           queryTimeoutAt       );     }      final int keySize = includeTimestamp ? query.getDimensions().size() + 1 : query.getDimensions().size();     final ValueExtractFunction valueExtractFn = makeValueExtractFunction(         query,         isInputRaw,         includeTimestamp,         columnSelectorFactory,         valueTypes     );      final Accumulator<AggregateResult, Row> accumulator = new Accumulator<AggregateResult, Row>()     {       @Override       public AggregateResult accumulate(           final AggregateResult priorResult,           final Row row       )       {         BaseQuery.checkInterrupted();          if (priorResult != null && !priorResult.isOk()) {           // Pass-through error returns without doing more work.           return priorResult;         }          if (!grouper.isInitialized()) {           grouper.init();         }          columnSelectorRow.set(row);          final Comparable[] key = new Comparable[keySize];         valueExtractFn.apply(row, key);          final AggregateResult aggregateResult = grouper.aggregate(new RowBasedKey(key));         columnSelectorRow.set(null);          return aggregateResult;       }     };      return new Pair<>(grouper, accumulator);   }
public static void changeSign( DMatrix2x2 a )     {         a.a11 = -a.a11; a.a12 = -a.a12;         a.a21 = -a.a21; a.a22 = -a.a22;     }
public JsMessage next() throws SIResourceException, SISessionDroppedException    {     if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())       SibTr.entry(tc, ""next"");          JsMessage msg = null;     Iterator<BrowseCursor> it = cursors.iterator();     while(it.hasNext() && msg==null)       msg = it.next().next();               if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())       SibTr.exit(tc, ""next"");          return msg;   }
private Object readResolve() throws ObjectStreamException {   try {    return create(hostname, cookieValue);   }   catch (final IOException | GeneralSecurityException e) {    throw new ObjectStreamException(e.getMessage()) {      /** Serialization index. **/     private static final long serialVersionUID = 1L;     };   }  }
public static TermWalker positionalPostfixWalker(PositionalTermVisitor visitor)     {         PositionalTermTraverser positionalTraverser = new PositionalTermTraverserImpl();         positionalTraverser.setContextChangeVisitor(visitor);         visitor.setPositionalTraverser(positionalTraverser);          return new TermWalker(new PostFixSearch<Term, Term>(), positionalTraverser, visitor);     }
public boolean addAll(LongArray items) {     ensureCapacity(size + items.size);     for (int i = 0; i < items.size; i++) {       elements[size++] = items.elements[i];     }     return items.size > 0;   }
public void show(Activity activity){         show((ViewGroup)activity.getWindow().findViewById(Window.ID_ANDROID_CONTENT));  }
Set<ExportsFlag> readExportsFlags(int flags) {         Set<ExportsFlag> set = EnumSet.noneOf(ExportsFlag.class);         for (ExportsFlag f: ExportsFlag.values()) {             if ((flags & f.value) != 0)                 set.add(f);         }         return set;     }
private int process(Buffer b, InputStream is) throws IOException {     int start = 0;     while (start < b.have) {       int matchPos = matcher.indexOf(b.buff, start, b.have - start);        // didnt find ""BUFR"" match       if (matchPos < 0) {         if (start == 0) // discard all but last 3 bytes           return b.have - 3;         else           return start; // indicates part of the buffer thats not processed       }        // do we have the length already read ??       if (matchPos + 6 >= b.have) {         return start; // this will save the end of the buffer and read more in.       }        // read BUFR message length       int b1 = (b.buff[matchPos + 4] & 0xff);       int b2 = (b.buff[matchPos + 5] & 0xff);       int b3 = (b.buff[matchPos + 6] & 0xff);       int messLen = b1 << 16 | b2 << 8 | b3;       // System.out.println(""match at="" + matchPos + "" len= "" + messLen);        // create a task for this message       //int headerLen = matchPos - start;       MessageTask task = new MessageTask(messLen);       task.header = extractHeader(start, matchPos, b);        // copy message bytes into it       int last = matchPos + messLen;       if (last > b.have) {         task.have = b.have - matchPos;         System.arraycopy(b.buff, matchPos, task.mess, 0, task.have);          // read the rest of the message         if (!readBuffer(is, task.mess, task.have, task.len - task.have)) {           System.out.println(""Failed to read remaining BUFR message"");           break;         }        } else {         task.have = task.len;         System.arraycopy(b.buff, matchPos, task.mess, 0, task.have);       }        boolean ok = true;        // check on ending       for (int i = task.len - 4; i < task.len; i++) {         int bb = task.mess[i];         if (bb != 55) {           //System.out.println(""Missing End of BUFR message at pos="" + i + "" "" + bb);           ok = false;           bad_msgs++;         }       }        try {         if (ok) messQ.put(task);         total_msgs++;         //System.out.println("" added message "" + task.id + "" start="" + matchPos + "" end= "" + (matchPos + messLen));       } catch (InterruptedException e) {         System.out.println("" interrupted queue put - assume process exit"");         break;       }        start = matchPos + messLen + 1;     }      return -1;   }
public void cacheFile() {   if (orientation == Orientation.INV)    cache = new String[fields][elements];   else    cache = new String[elements][fields];   int x = 0, y = 0;   Scanner file = null;   try {    file = new Scanner(csvFile);   } catch (FileNotFoundException e) {    // TODO Auto-generated catch block    e.printStackTrace();   }   String line;   StringTokenizer tokenizer;   while(file.hasNextLine()){    line = file.nextLine();    tokenizer = new StringTokenizer(line, "","");    while(tokenizer.hasMoreTokens()){     cache[y][x] = tokenizer.nextToken();     x++;    }    x = 0;    y++;       }   file.close();   cached = true;  }
public CompletableFuture<Void> close() {     if (open.compareAndSet(true, false)) {       CompletableFuture<Void> future = new CompletableFuture<>();       threadContext.execute(() -> {         synchronized (this) {           for (Scheduled keepAliveFuture : keepAliveTimers.values()) {             keepAliveFuture.cancel();           }           protocol.unregisterHeartbeatHandler();         }         future.complete(null);       });       return future;     }     return CompletableFuture.completedFuture(null);   }
public Retryer<R> fibonacciWait(final long multiplier, final long maximumWait) {         return withWaitStrategy(new WaitStrategy() {                          @Override             public long computeSleepTime(int previousAttemptNumber, long delaySinceFirstAttemptInMillis) {                 long fib = fib(previousAttemptNumber);                 long result = multiplier * fib;                  if (result > maximumWait || result < 0L) {                     result = maximumWait;                 }                  return result >= 0L ? result : 0L;             }              private long fib(long n) {                 if (n == 0L) return 0L;                 if (n == 1L) return 1L;                  long prevPrev = 0L;                 long prev = 1L;                 long result = 0L;                  for (long i = 2L; i <= n; i++) {                     result = prev + prevPrev;                     prevPrev = prev;                     prev = result;                 }                  return result;             }         });     }
private static Segment<PrimitiveParameter> firstSegment(             PatternFinderUser def, Sequence<PrimitiveParameter> sequence,             Algorithm algorithm, int maxPatternLength) {         int size = sequence.size();         int minPatternLength = minPatternLength(algorithm, def);         if (size > 0 && size >= minPatternLength) {             int x = 0;             int y = minPatternLength < 1 ? size - 1 : minPatternLength - 1;             if (x <= y) {                 return resetSegmentHelper(def, sequence, x, y,                         new Segment<>(sequence, x, y),                         algorithm, maxPatternLength);             }         }         return null;     }
public SortV1 and(SortV1 sort) {      if (sort == null) {       return this;     }      ArrayList<OrderV1> these = new ArrayList<>(this.orders);      for (OrderV1 order : sort) {       these.add(order);     }      return new SortV1(these);   }
private static void readDecoderPicMarking(NALUnit nalUnit, SliceHeader sh, BitReader _in) {         if (nalUnit.type == NALUnitType.IDR_SLICE) {             boolean noOutputOfPriorPicsFlag = readBool(_in, ""SH: no_output_of_prior_pics_flag"");             boolean longTermReferenceFlag = readBool(_in, ""SH: long_term_reference_flag"");             sh.refPicMarkingIDR = new RefPicMarkingIDR(noOutputOfPriorPicsFlag, longTermReferenceFlag);         } else {             boolean adaptiveRefPicMarkingModeFlag = readBool(_in, ""SH: adaptive_ref_pic_marking_mode_flag"");             if (adaptiveRefPicMarkingModeFlag) {                 ArrayList<Instruction> mmops = new ArrayList<Instruction>();                 int memoryManagementControlOperation;                 do {                     memoryManagementControlOperation = readUEtrace(_in, ""SH: memory_management_control_operation"");                      Instruction instr = null;                      switch (memoryManagementControlOperation) {                     case 1:                         instr = new RefPicMarking.Instruction(InstrType.REMOVE_SHORT, readUEtrace(_in,                                 ""SH: difference_of_pic_nums_minus1"") + 1, 0);                         break;                     case 2:                         instr = new RefPicMarking.Instruction(InstrType.REMOVE_LONG,                                 readUEtrace(_in, ""SH: long_term_pic_num""), 0);                         break;                     case 3:                         instr = new RefPicMarking.Instruction(InstrType.CONVERT_INTO_LONG, readUEtrace(_in,                                 ""SH: difference_of_pic_nums_minus1"") + 1, readUEtrace(_in, ""SH: long_term_frame_idx""));                         break;                     case 4:                         instr = new RefPicMarking.Instruction(InstrType.TRUNK_LONG, readUEtrace(_in,                                 ""SH: max_long_term_frame_idx_plus1"") - 1, 0);                         break;                     case 5:                         instr = new RefPicMarking.Instruction(InstrType.CLEAR, 0, 0);                         break;                     case 6:                         instr = new RefPicMarking.Instruction(InstrType.MARK_LONG,                                 readUEtrace(_in, ""SH: long_term_frame_idx""), 0);                         break;                     }                     if (instr != null)                         mmops.add(instr);                 } while (memoryManagementControlOperation != 0);                 sh.refPicMarkingNonIDR = new RefPicMarking(mmops.toArray(new Instruction[] {}));             }         }     }
public void getCharacterEquipment(String API, String name, Callback<CharacterEquipment> callback) throws GuildWars2Exception, NullPointerException {   isParamValid(new ParamChecker(ParamType.API, API), new ParamChecker(ParamType.CHAR, name));   gw2API.getCharacterEquipment(name, API).enqueue(callback);  }
public static List<MethodInfo> findOverrideMethods(final Index index, final MethodInfo method) {            return findOverrideMethods(index, method.declaringClass(), method, 0);        }
public <T5> Pattern5<T1, T2, T3, T4, T5> and(Observable<T5> other) {         if (other == null) {             throw new NullPointerException();         }         return new Pattern5<T1, T2, T3, T4, T5>(o1, o2, o3, o4, other);     }
public static final void setAccessController(AccessController mgr)     {         if (tc.isEntryEnabled())             Tr.entry(tc, ""setAccessController"", mgr);         _accessController = mgr;         if (tc.isEntryEnabled())             Tr.exit(tc, ""setAccessController"");     }
public DescribeDBParameterGroupsResult withDBParameterGroups(DBParameterGroup... dBParameterGroups) {         if (this.dBParameterGroups == null) {             setDBParameterGroups(new com.amazonaws.internal.SdkInternalList<DBParameterGroup>(dBParameterGroups.length));         }         for (DBParameterGroup ele : dBParameterGroups) {             this.dBParameterGroups.add(ele);         }         return this;     }
@Override   public EClass getIfcMassPerLengthMeasure() {    if (ifcMassPerLengthMeasureEClass == null) {     ifcMassPerLengthMeasureEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)       .getEClassifiers().get(837);    }    return ifcMassPerLengthMeasureEClass;   }
protected void closeConnection() throws SQLException {         if (connection != null && !connection.isClosed()) {             connection.close();             connection = null;         }      }
public void marshall(EBSOptionsStatus eBSOptionsStatus, ProtocolMarshaller protocolMarshaller) {          if (eBSOptionsStatus == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(eBSOptionsStatus.getOptions(), OPTIONS_BINDING);             protocolMarshaller.marshall(eBSOptionsStatus.getStatus(), STATUS_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public EClass getGDD() {   if (gddEClass == null) {    gddEClass = (EClass)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(271);   }   return gddEClass;  }
public static Class[] extractAllInterfaces(Object o)   {     Set<Class> interfaces = new LinkedHashSet<Class>();      Class c = o.getClass();     do     {       interfaces.addAll(Arrays.asList(c.getInterfaces()));       c = c.getSuperclass();     }     while(c != null);      return interfaces.toArray(new Class[interfaces.size()]);   }
private static void extractAtoms(String[] atomNames, List<Chain> chains,    List<Atom> atoms) {    for (Chain c : chains) {     for (Group g : c.getAtomGroups()) {      // a temp container for the atoms of this group     List<Atom> thisGroupAtoms = new ArrayList<Atom>();     // flag to check if this group contains all the requested atoms.     boolean thisGroupAllAtoms = true;     for (String atomName : atomNames) {      Atom a = g.getAtom(atomName);       if (a == null) {       // this group does not have a required atom, skip it...       thisGroupAllAtoms = false;       break;      }      thisGroupAtoms.add(a);     }     if (thisGroupAllAtoms) {      // add the atoms of this group to the array.      for (Atom a : thisGroupAtoms) {       atoms.add(a);      }     }     }   }  }
public static <T1, T2, T3, T4, T5, T6, R> Function<Object[], R> fn6(final Function<Tuple6<T1, T2, T3, T4, T5, T6>, R> delegate) {   return objects -> delegate.apply(Tuples.<T1, T2, T3, T4, T5, T6>fn6().apply(objects));  }
@Override   public void appendPlotCommands(PlotBundle.Builder sb) {     sb.append(""set grid "");     sb.append(yesNo(showXMajor)).append(""xtics "");     sb.append(yesNo(showXMinor)).append(""mxtics "");     sb.append(yesNo(showYMajor)).append(""ytics "");     sb.append(yesNo(showYMinor)).append(""mytics "");      sb.append(zIndex.asPlotCommand()).append("" "");     majorLineStyle.appendPlotCommands(sb);     sb.append("" , "");     minorLineStyle.appendPlotCommands(sb);     sb.append("" \nshow grid\n"");   }
@SuppressWarnings(""fallthrough"")   private String nextUnquotedValue()   {     int i = 0;      findNonLiteralCharacter:     for (; pos + i < limit; i++) {       switch (in.charAt(pos + i)) {       case '/':       case '\\':       case ';':       case '#':       case '=':         checkLenient(); // fall-through       case '{':       case '}':       case '[':       case ']':       case ':':       case ',':       case ' ':       case '\t':       case '\f':       case '\r':       case '\n':         break findNonLiteralCharacter;       }     }      String result = in.substring( pos, pos + i);     pos += i;     return result;   }
public void clear() {         Map<String, String> map = inheritableThreadLocal.get();         if (map != null) {             map.clear();             inheritableThreadLocal.remove();         }     }
static public String stripTopLevelTag(String xmlString){    return xmlString.substring(xmlString.indexOf('>') + 1, xmlString.lastIndexOf('<'));   }
private IQueryAtomContainer matchExact(IAtomContainer mol) {         final IChemObjectBuilder bldr = mol.getBuilder();         final IQueryAtomContainer qry = new QueryAtomContainer(mol.getBuilder());         final Map<IAtom, IAtom> atmmap = new HashMap<>();          for (IAtom atom : mol.atoms()) {             IAtom qatom = matchExact(mol, atom);             if (qatom != null) {                 atmmap.put(atom, qatom);                 qry.addAtom(qatom);             }         }          for (IBond bond : mol.bonds()) {             final IAtom beg = atmmap.get(bond.getBegin());             final IAtom end = atmmap.get(bond.getEnd());              // attach bond skipped             if (beg == null || end == null)                 continue;              IQueryBond qbond = new QueryBond(beg, end, Expr.Type.TRUE);             qry.addBond(qbond);         }          return qry;     }
protected void createSamplePoints(int numSamples) {   for( int y = 0; y < numSamples; y++ ) {    float regionY = (y/(numSamples-1.0f) - 0.5f);     for( int x = 0; x < numSamples; x++  ) {     float regionX = (x/(numSamples-1.0f) - 0.5f);     samplePts.add( new Point2D_F32(regionX,regionY));    }   }  }
public static LinkedHashMap<String, String> readFileToHashMap( String filePath, String separator, boolean valueFirst )             throws IOException {         if (separator == null) {             separator = ""="";         }         List<String> lines = readFileToLinesList(filePath);         LinkedHashMap<String, String> propertiesMap = new LinkedHashMap<>();         for( String line : lines ) {             line = line.trim();             if (line.length() == 0) {                 continue;             }             if (!line.contains(separator)) {                 continue;             }             String[] lineSplit = line.split(separator);             if (!valueFirst) {                 String key = lineSplit[0].trim();                 String value = """";                 if (lineSplit.length > 1) {                     value = lineSplit[1].trim();                 }                 propertiesMap.put(key, value);             } else {                 if (lineSplit.length > 1) {                     String key = lineSplit[0].trim();                     String value = lineSplit[1].trim();                     propertiesMap.put(value, key);                 }             }         }         return propertiesMap;     }
public EClass getMediumOrientation() {   if (mediumOrientationEClass == null) {    mediumOrientationEClass = (EClass)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(362);   }   return mediumOrientationEClass;  }
public Vector<Object> getSpecificationRepositoriesOfAssociatedProject(Vector<Object> repositoryParams)     {         try         {             Repository repository = loadRepository( repositoryParams );              Collection<Repository> repositories = service.getSpecificationRepositoriesOfAssociatedProject(repository.getUid());              log.debug( ""Retrieved Test Repositories Of Associated Project of "" + repository.getUid() + "" number: "" + repositories.size() );             return XmlRpcDataMarshaller.toXmlRpcRepositoriesParameters( repositories );         }         catch (Exception e)         {             return errorAsVector( e, RETRIEVE_SPECIFICATION_REPOS );         }     }
private static boolean isPermutation(List<?> first, List<?> second) {     if (first.size() != second.size()) {       return false;     }     Multiset<?> firstMultiset = HashMultiset.create(first);     Multiset<?> secondMultiset = HashMultiset.create(second);     return firstMultiset.equals(secondMultiset);   }
@SuppressWarnings(""unchecked"")    public static Map<String, String> parseCommandLineArguments(String[] args) {      return (Map)parseCommandLineArguments(args, false);    }
protected void removeEdgeWithoutCallback(EdgeBean eBean) {         if (eBean == null) {             return;         }          // Update in and out vertices         VertexBean outV = eBean.outVertex;         VertexBean inV = eBean.inVertex;          outV.outEdges = removeEdgeFromAdjList(outV.outEdges, eBean); // CompactSet.<EdgeBean>remove(outV.outEdges, eBean);         inV.inEdges = removeEdgeFromAdjList(inV.inEdges, eBean);; // CompactSet.<EdgeBean>remove(inV.inEdges, eBean);     }
public EmbeddedId<Attributes<T>> getOrCreateEmbeddedId()    {       Node node = childNode.getOrCreate(""embedded-id"");       EmbeddedId<Attributes<T>> embeddedId = new EmbeddedIdImpl<Attributes<T>>(this, ""embedded-id"", childNode, node);       return embeddedId;    }
public static int reflectionHashCode(final Object object, final boolean testTransients) {         return reflectionHashCode(DEFAULT_INITIAL_VALUE, DEFAULT_MULTIPLIER_VALUE, object,                  testTransients, null);     }
public void marshall(VPCOptions vPCOptions, ProtocolMarshaller protocolMarshaller) {          if (vPCOptions == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(vPCOptions.getSubnetIds(), SUBNETIDS_BINDING);             protocolMarshaller.marshall(vPCOptions.getSecurityGroupIds(), SECURITYGROUPIDS_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
private static PolicyDefinitionTemplateBean getTemplateBean(PolicyDefinitionBean def) {         Locale currentLocale = Messages.i18n.getLocale();         String lang = currentLocale.getLanguage();         String country = lang + ""_"" + currentLocale.getCountry(); //$NON-NLS-1$          PolicyDefinitionTemplateBean nullBean = null;         PolicyDefinitionTemplateBean langBean = null;         PolicyDefinitionTemplateBean countryBean = null;         for (PolicyDefinitionTemplateBean pdtb : def.getTemplates()) {             if (pdtb.getLanguage() == null) {                 nullBean = pdtb;             } else if (pdtb.getLanguage().equals(country)) {                 countryBean = pdtb;                 break;             } else if (pdtb.getLanguage().equals(lang)) {                 langBean = pdtb;             }         }         if (countryBean != null) {             return countryBean;         }         if (langBean != null) {             return langBean;         }         if (nullBean != null) {             return nullBean;         }         return null;     }
public boolean deactivate() throws Exception    {       if (activated)       {          if (jndiObject != null)          {             jndiStrategy.unbind(jndiName, jndiObject);          }          else          {             jndiStrategy.unbind(jndiName, adminObject);          }           activated = false;          return true;       }        return false;    }
@Override  public Object eGet(int featureID, boolean resolve, boolean coreType)  {   switch (featureID)   {    case XbasePackage.XINSTANCE_OF_EXPRESSION__TYPE:     return getType();    case XbasePackage.XINSTANCE_OF_EXPRESSION__EXPRESSION:     return getExpression();   }   return super.eGet(featureID, resolve, coreType);  }
public ResultList<Review> getMovieReviews(int movieId, Integer page, String language) throws MovieDbException {         return tmdbMovies.getMovieReviews(movieId, page, language);     }
@Nonnull   public <T extends IValidationExecutorSet> T registerValidationExecutorSet (@Nonnull final T aVES)   {     ValueEnforcer.notNull (aVES, ""VES"");      final VESID aKey = aVES.getID ();     m_aRWLock.writeLocked ( () -> {       if (m_aMap.containsKey (aKey))         throw new IllegalStateException (""Another validation executor set with the ID '"" +                                          aKey +                                          ""' is already registered!"");       m_aMap.put (aKey, aVES);     });     return aVES;   }
public void updateCapacityBytes(Map<String, Long> capacityBytesOnTiers) {     mCapacityBytes = 0;     mTotalBytesOnTiers = capacityBytesOnTiers;     for (long t : mTotalBytesOnTiers.values()) {       mCapacityBytes += t;     }   }
public static Field getDeclaredFieldInHierarchy(Class<?> clazz, String fieldName) throws NoSuchFieldException {      Field field = null;   for (Class<?> acls = clazz; acls != null; acls = acls.getSuperclass()) {    try {     field = acls.getDeclaredField(fieldName);     break;    } catch (NoSuchFieldException e) {     // ignore    }   }   if (field == null) {    throw new NoSuchFieldException(""Could not find field '"" + fieldName + ""' in class '"" + clazz.getName() + ""' or its super classes"");   }      return field;  }
@Override     public boolean compareTokens(String a, String b) {         if (isSignedToken()) {             return crypto.compareSignedTokens(a, b);         } else {             return crypto.constantTimeEquals(a, b);         }     }
public static int bitLength (byte[] bytes) {         Objects.requireNonNull(bytes, Required.BYTES.toString());         int byteLength = bytes.length;                  int length = 0;         if (byteLength <= MAX_BYTE_LENGTH && byteLength > 0) {             length = byteLength * BYTES;         }                  return length;     }
private Socket createSocks4ProxySocket(final String host, final int port) {   Socket socket = null;   final String proxyHost = proxy.getProxyAddress();   final int proxyPort = proxy.getProxyPort();   final String user = proxy.getProxyUsername();    try {    socket = Sockets.connect(proxyHost, proxyPort, connectionTimeout);     final InputStream in = socket.getInputStream();    final OutputStream out = socket.getOutputStream();     socket.setTcpNoDelay(true);     byte[] buf = new byte[1024];     // 1) CONNECT     int index = 0;    buf[index++] = 4;    buf[index++] = 1;     buf[index++] = (byte) (port >>> 8);    buf[index++] = (byte) (port & 0xff);     InetAddress addr = InetAddress.getByName(host);    byte[] byteAddress = addr.getAddress();    for (byte byteAddres : byteAddress) {     buf[index++] = byteAddres;    }     if (user != null) {     System.arraycopy(user.getBytes(), 0, buf, index, user.length());     index += user.length();    }    buf[index++] = 0;    out.write(buf, 0, index);     // 2) RESPONSE     int len = 6;    int s = 0;    while (s < len) {     int i = in.read(buf, s, len - s);     if (i <= 0) {      throw new HttpException(ProxyInfo.ProxyType.SOCKS4, ""stream is closed"");     }     s += i;    }    if (buf[0] != 0) {     throw new HttpException(ProxyInfo.ProxyType.SOCKS4, ""proxy returned VN "" + buf[0]);    }    if (buf[1] != 90) {     try {      socket.close();     } catch (Exception ignore) {     }     throw new HttpException(ProxyInfo.ProxyType.SOCKS4, ""proxy returned CD "" + buf[1]);    }     byte[] temp = new byte[2];    in.read(temp, 0, 2);     return socket;   } catch (RuntimeException rtex) {    closeSocket(socket);    throw rtex;   } catch (Exception ex) {    closeSocket(socket);    throw new HttpException(ProxyInfo.ProxyType.SOCKS4, ex.toString(), ex);   }  }
@Override  public String createMachine( TargetHandlerParameters parameters ) throws TargetException {    this.logger.fine( ""Creating a new VM @ VMware."" );    // For IaaS, we only expect root instance names to be passed   if( InstanceHelpers.countInstances( parameters.getScopedInstancePath()) > 1 )    throw new TargetException( ""Only root instances can be passed in arguments."" );    String rootInstanceName = InstanceHelpers.findRootInstancePath( parameters.getScopedInstancePath());    // Deal with the creation   try {    System.setProperty(""org.xml.sax.driver"",""org.apache.xerces.parsers.SAXParser"");    Map<String,String> targetProperties = parameters.getTargetProperties();    final String machineImageId = targetProperties.get( TEMPLATE );    final ServiceInstance vmwareServiceInstance = getServiceInstance( targetProperties );     final ComputeResource vmwareComputeResource = (ComputeResource)(      new InventoryNavigator( vmwareServiceInstance.getRootFolder())      .searchManagedEntity(""ComputeResource"", targetProperties.get( CLUSTER )));     // Generate the user data first, so that nothing has been done on the IaaS if it fails    String userData = UserDataHelpers.writeUserDataAsString(      parameters.getMessagingProperties(),      parameters.getDomain(),      parameters.getApplicationName(),      rootInstanceName );     VirtualMachine vm = getVirtualMachine( vmwareServiceInstance, machineImageId );    String vmwareDataCenter = targetProperties.get( DATA_CENTER );    Folder vmFolder =      ((Datacenter)(new InventoryNavigator( vmwareServiceInstance.getRootFolder())      .searchManagedEntity(""Datacenter"", vmwareDataCenter)))      .getVmFolder();     this.logger.fine(""machineImageId="" + machineImageId);    if (vm == null || vmFolder == null)     throw new TargetException(""VirtualMachine (= "" + vm + "" ) or Datacenter path (= "" + vmFolder + "" ) is NOT correct. Please, double check."");     VirtualMachineCloneSpec cloneSpec = new VirtualMachineCloneSpec();    cloneSpec.setLocation(new VirtualMachineRelocateSpec());    cloneSpec.setPowerOn(false);    cloneSpec.setTemplate(true);     VirtualMachineConfigSpec vmSpec = new VirtualMachineConfigSpec();    vmSpec.setAnnotation( userData );    cloneSpec.setConfig(vmSpec);     Task task = vm.cloneVM_Task( vmFolder, rootInstanceName, cloneSpec );    this.logger.fine(""Cloning the template: ""+ machineImageId +"" ..."");    String status = task.waitForTask();    if (!status.equals(Task.SUCCESS))     throw new TargetException(""Failure: Virtual Machine cannot be cloned."" );     VirtualMachine vm2 = getVirtualMachine( vmwareServiceInstance, rootInstanceName );    this.logger.fine(""Transforming the clone template to Virtual machine ..."");    vm2.markAsVirtualMachine( vmwareComputeResource.getResourcePool(), null);     DynamicProperty dprop = new DynamicProperty();    dprop.setName(""guestinfo.userdata"");    dprop.setVal(userData);    vm2.getGuest().setDynamicProperty(new DynamicProperty[]{dprop});     task = vm2.powerOnVM_Task(null);    this.logger.fine(""Starting the virtual machine: ""+ rootInstanceName +"" ..."");    status = task.waitForTask();    if( ! status.equals( Task.SUCCESS ))     throw new TargetException(""Failure: Virtual Machine cannot be started."" );     return vm2.getName();    } catch( Exception e ) {    throw new TargetException( e );   }  }
public static final void logMessage(Level level, String key, Object... args) {         if (WsLevel.AUDIT.equals(level))             Tr.audit(tc, key, args);         else if (WsLevel.ERROR.equals(level))             Tr.error(tc, key, args);         else if (Level.INFO.equals(level))             Tr.info(tc, key, args);         else if (Level.WARNING.equals(level))             Tr.warning(tc, key, args);         else             throw new UnsupportedOperationException(level.toString());     }
public void paintTabbedPaneTabAreaBackground(SynthContext context, Graphics g, int x, int y, int w, int h) {         paintBackground(context, g, x, y, w, h, null);     }
@Nonnull   public static ICommonsSet <LocalDate> getDatesFromChronologyWithinGregorianYear (final int nTargetMonth,                                                                                    final int nTargetDay,                                                                                    final int nGregorianYear,                                                                                    final Chronology aTargetChrono)   {     final Year aIsoYear = Year.of (nGregorianYear);     final ChronoLocalDate aFirstTargetDate = aTargetChrono.date (aIsoYear.atDay (1));     final ChronoLocalDate aLastTargetDate = aTargetChrono.date (aIsoYear.atDay (365 + (aIsoYear.isLeap () ? 1 : 0)));      final ICommonsSet <LocalDate> aHolidays = new CommonsHashSet <> ();     final int nStartYear = aFirstTargetDate.get (ChronoField.YEAR);     final int nEndYear = aLastTargetDate.get (ChronoField.YEAR);     for (int nTargetYear = nStartYear; nTargetYear <= nEndYear; ++nTargetYear)     {       final ChronoLocalDate aLocalDate = aTargetChrono.date (nTargetYear, nTargetMonth, nTargetDay);       if (!aLocalDate.isBefore (aFirstTargetDate) && !aLocalDate.isAfter (aLastTargetDate))       {         // Convert to ISO chronology         aHolidays.add (LocalDate.from (aLocalDate));       }     }     return aHolidays;   }
public CompletionStage<Long> runningWithTransaction() {     return CompletableFuture.supplyAsync(         () -> {           // lambda is an instance of Function<EntityManager, Long>           return jpaApi.withTransaction(               entityManager -> {                 Query query = entityManager.createNativeQuery(""select max(age) from people"");                 return (Long) query.getSingleResult();               });         },         executionContext);   }
public Observable<DatabaseInner> pauseAsync(String resourceGroupName, String serverName, String databaseName) {         return pauseWithServiceResponseAsync(resourceGroupName, serverName, databaseName).map(new Func1<ServiceResponse<DatabaseInner>, DatabaseInner>() {             @Override             public DatabaseInner call(ServiceResponse<DatabaseInner> response) {                 return response.body();             }         });     }
private void noteUnconditionallyDereferencedNullValue(Location thisLocation,             Map<ValueNumber, SortedSet<Location>> bugLocations,             Map<ValueNumber, NullValueUnconditionalDeref> nullValueGuaranteedDerefMap, UnconditionalValueDerefSet derefSet,             IsNullValue isNullValue, ValueNumber valueNumber) {         if (DEBUG) {             System.out.println(""%%% HIT for value number "" + valueNumber + "" @ "" + thisLocation);         }         Set<Location> unconditionalDerefLocationSet = derefSet.getUnconditionalDerefLocationSet(valueNumber);         if (unconditionalDerefLocationSet.isEmpty()) {             AnalysisContext.logError(""empty set of unconditionally dereferenced locations at ""                     + thisLocation.getHandle().getPosition() + "" in "" + classContext.getClassDescriptor() + "".""                     + method.getName() + method.getSignature());             return;         }          // OK, we have a null value that is unconditionally         // derferenced. Make a note of the locations where it         // will be dereferenced.         NullValueUnconditionalDeref thisNullValueDeref = nullValueGuaranteedDerefMap.get(valueNumber);         if (thisNullValueDeref == null) {             thisNullValueDeref = new NullValueUnconditionalDeref();             nullValueGuaranteedDerefMap.put(valueNumber, thisNullValueDeref);         }         thisNullValueDeref.add(isNullValue, unconditionalDerefLocationSet);          if (thisLocation != null) {             SortedSet<Location> locationsForThisBug = bugLocations.get(valueNumber);              if (locationsForThisBug == null) {                 locationsForThisBug = new TreeSet<>();                 bugLocations.put(valueNumber, locationsForThisBug);             }             locationsForThisBug.add(thisLocation);         }     }
public boolean isValidInfrastructureTld(String iTld) {         iTld = unicodeToASCII(iTld);         return Arrays.binarySearch(INFRASTRUCTURE_TLDS, (chompLeadingDot(iTld.toLowerCase(Locale.ENGLISH)))) >= 0;     }
public char nextClean(char c) {         char n = nextClean();         if (n != c) {             throw syntaxError(""Expected '"" + c + ""' and instead saw '"" + n + ""'"");         }         return n;     }
public void start(BundleContext bc) throws Exception {   /*    * The pax-web-war service can take a little longer to start, we can't    * say how much it will take, so we do need to sit down a while and wait    * it's availability in order to use it's reference.    *    * This is a MUST, it's really important - mostly when using the    * config.ini file (Equinox).    *    * Anaximandro April 19, 2010.    */   int counter = 0;   boolean started = false;   while (!started) {     webContainerRef = bc.getServiceReference(WebContainer.class);    started = webContainerRef != null;    if (started) {     final WebContainer webContainer = (WebContainer) bc       .getService(webContainerRef);     if (webContainer != null) {      httpContext = webContainer        .createDefaultHttpContext();      // set a session timeout of 10 minutes      webContainer.setSessionTimeout(10, httpContext);      // register the hello world servlet for filtering with url      // pattern      final Dictionary<String, Object> initParamsServlet = new Hashtable<>();      initParamsServlet.put(""from"", ""WebContainer"");      helloWorldServlet = new HelloWorldServlet();      webContainer.registerServlet(helloWorldServlet, // registered        // servlet        new String[]{""/helloworld/wc""}, // url patterns        initParamsServlet, // init params        httpContext // http context      );      // register the hello world filter based on url paterns      final Dictionary<String, Object> initParamsFilter = new Hashtable<>();      initParamsFilter.put(""title"", ""Hello World (url pattern)"");      helloWorldFilter = new HelloWorldFilter();      webContainer.registerFilter(helloWorldFilter, // registered        // filter        new String[]{""/helloworld/wc""}, // url patterns        null, // servlet names        initParamsFilter, // init params        httpContext // http context      );      worldServlet = new HelloWorldServlet();      webContainer.registerServlet(worldServlet, // registered        // servlet        ""HelloWorld"", // servlet name        new String[]{""/helloworld/wc/sn""}, // url        // patterns        initParamsServlet, // init params        httpContext // http context      );      // register the hello world filter based on servlet name      initParamsFilter.put(""title"", ""Hello World (servlet name)"");      webContainer.registerFilter(new HelloWorldFilter(), // registered        // filter        null, // url patterns        new String[]{""HelloWorld""}, // servlet names        initParamsFilter, // init params        httpContext // http context      );      helloWorldListener = new HelloWorldListener();      webContainer.registerEventListener(        helloWorldListener, // registered request        // listener        httpContext // http context      );      sessionListener = new HelloWorldSessionListener();      webContainer.registerEventListener(        sessionListener, // registered        // session        // listener        httpContext // http context      );      // register images as resources      webContainer.registerResources(""/images"", ""/images"",        httpContext);      // register a welcome file - should be used for ALL resource servlets      // - default and non default      webContainer.registerWelcomeFiles(        new String[] { ""index.html"" }, true, httpContext);      // register static htmls      webContainer.registerResources(""/html"", ""/html"",        httpContext);      errorServlet = new HelloWorldErrorServlet();      webContainer.registerServlet(errorServlet, // registered        // servlet        new String[]{""/helloworld/wc/error""}, // url        // patterns        null, // no init params        httpContext // http context      );      errorMakerServlet = new HelloWorldErrorMakerServlet();      webContainer.registerServlet(        errorMakerServlet, // registered        // servlet        new String[]{""/helloworld/wc/error/create""}, // url        // patterns        null, // no init params        httpContext // http context      );      // register error page for any Exception      webContainer.registerErrorPage(""java.lang.Exception"", // fully        // qualified        // name        ""/helloworld/wc/error"", // path to error servlet        httpContext // http context      );      // register error page for 404 (Page not found)      webContainer.registerErrorPage(""404"", // error code        ""/helloworld/wc/error"", // path to error servlet        httpContext // http context      );       webContainer.end(httpContext);     }    } else {     // wait, throw exception after 5 retries.     if (counter > 10) {      throw new Exception(        ""Could not start the helloworld-wc service, WebContainer service not started or not available."");     } else {      counter++;      Thread.sleep(counter * 1000);     }    }   }  }
public static String getPackage(Class<?> cls) {         // cls.getPackage() sometimes returns null, in which case fall back to string massaging.         java.lang.Package pkg = cls.isArray() ? cls.getComponentType().getPackage() : cls.getPackage();         if ( pkg == null ) {             int dotPos;             int dolPos = cls.getName().indexOf( '$' );             if ( dolPos > 0 ) {                 // we have nested classes, so adjust dotpos to before first $                 dotPos = cls.getName().substring( 0, dolPos ).lastIndexOf( '.' );             } else {                 dotPos = cls.getName().lastIndexOf( '.' );             }                              if ( dotPos > 0 ) {                 return cls.getName().substring( 0,                                                 dotPos );             } else {                 // must be default package.                 return """";             }         } else {             return pkg.getName();         }     }
public void addConsumer(     Object key,     String topic,     String selectorString,     MatchTarget target,     boolean isWildcarded)   throws SIDiscriminatorSyntaxException                                            {     if (tc.isEntryEnabled())        SibTr.entry(tc,                    ""addConsumer"",                    new Object[]{key,                                 topic,                                 selectorString,                                 target,                                new Boolean(isWildcarded)});      boolean selector = false;     MonitoredConsumer mc = (MonitoredConsumer)target;     // Is there a selector expression     if (selectorString != null && selectorString.trim().length() != 0)     {       selector = true;     }          // Has a consumer already registered on this topicexpression?      //     // If they have then, we can use the matching monitor lists in the existing consumer     // to short circuit the monitor matching process.     //     // Note that in this case we are agnostic about selectors.....but need to      // make sure that the SubscriptionRegistrar adds the consumer in the      // correct place     if(selector)     {       // This consumer has a selector, see if there is an existing subscription       // registrar entry       if(_subscriptionRegistrar.isKnownSelectorExpression(topic, isWildcarded))       {         // Found existing entry in selector table add this consumer to         // that entry                 addConsumerForKnownTopicExpr(topic, selector, isWildcarded, mc, true);               }       else       {         // See if theres a corresponding non-selector entry         if(_subscriptionRegistrar.isKnownNonSelectorExpression(topic, isWildcarded))         {           // Found existing entry in non-selector table, add a new row in the            // subscriptionRegistrar's selector table           _subscriptionRegistrar.addNewConsumerForExpression(topic,mc,selector, isWildcarded);           addConsumerForKnownTopicExpr(topic, selector, isWildcarded, mc, false);                      }         else         {           // An Entirely new expression, we'll have to do the matching           // Add a new row in the table of subscriptions                   _subscriptionRegistrar.addNewConsumerForExpression(topic,mc,selector, isWildcarded);                     addConsumerForNewTopicExpr(topic, isWildcarded, mc);                           }       }     }     else     {       // This consumer has no selector, see if there is an existing subscription       // registrar entry       if(_subscriptionRegistrar.isKnownNonSelectorExpression(topic, isWildcarded))       {         // Found existing entry in non-selector table add this consumer to         // that entry                 addConsumerForKnownTopicExpr(topic, selector, isWildcarded, mc, true);               }       else       {         // See if theres a corresponding selector entry         if(_subscriptionRegistrar.isKnownSelectorExpression(topic, isWildcarded))         {           // Found existing entry in selector table, add a new row in the            // subscriptionRegistrar's non-selector table           _subscriptionRegistrar.addNewConsumerForExpression(topic,mc,selector, isWildcarded);           addConsumerForKnownTopicExpr(topic, selector, isWildcarded, mc, false);                      }         else         {           // An Entirely new expression, we'll have to do the matching           // Add a new row in the table of subscriptions                   _subscriptionRegistrar.addNewConsumerForExpression(topic,mc,selector, isWildcarded);                     addConsumerForNewTopicExpr(topic, isWildcarded, mc);                           }       }           }      // Set info into the Target itself     if(selector)       mc.setSelector();     if(isWildcarded)       mc.setWildcarded();     mc.setTopic(topic);            if (tc.isEntryEnabled()) SibTr.exit(tc, ""addConsumer"");   }
private void fireNewCurrentSolution(SolutionType newCurrentSolution,                                         Evaluation newCurrentSolutionEvaluation,                                         Validation newCurrentSolutionValidation){         for(SearchListener<? super SolutionType> l : getSearchListeners()){             l.newCurrentSolution(this, newCurrentSolution,                                        newCurrentSolutionEvaluation,                                        newCurrentSolutionValidation);         }     }
public void setContentView(View contentView, FrameLayout.LayoutParams params) {         if(params == null) {             params = new FrameLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, Gravity.CENTER);             final int margin = getResources().getDimensionPixelSize(R.dimen.sub_action_button_content_margin);             params.setMargins(margin, margin, margin, margin);         }          contentView.setClickable(false);         this.addView(contentView, params);     }
public void initiateTransfer(              String connId,              String destination,              KeyValueCollection userData      ) throws WorkspaceApiException {          this.initiateTransfer(connId, destination, null, null, userData, null, null);      }
@Override     public boolean publish(String channel, IMessage<ID, DATA> msg) {         try {             eventBus.get(channel).post(msg);         } catch (ExecutionException e) {             throw new RuntimeException(e);         }         return true;     }
public BsonDecimal128 getDecimal128(final Object key, final BsonDecimal128 defaultValue) {         if (!containsKey(key)) {             return defaultValue;         }         return get(key).asDecimal128();     }
public static MetricContext newContextFromReferenceContext(MetricContext context, List<Tag<?>> newTags,       Optional<String> name) {      String newName = name.orNull();      if (Strings.isNullOrEmpty(newName)) {       UUID uuid = UUID.randomUUID();       String randomIdPrefix = ""uuid:"";        String oldName = context.getName();       List<String> splitName = Strings.isNullOrEmpty(oldName) ? Lists.<String> newArrayList()           : Lists.newArrayList(Splitter.on(""."").splitToList(oldName));       if (splitName.size() > 0 && StringUtils.startsWith(Iterables.getLast(splitName), randomIdPrefix)) {         splitName.set(splitName.size() - 1, String.format(""%s%s"", randomIdPrefix, uuid.toString()));       } else {         splitName.add(String.format(""%s%s"", randomIdPrefix, uuid.toString()));       }       newName = Joiner.on(""."").join(splitName);     }      MetricContext.Builder builder = context.getParent().isPresent() ? context.getParent().get().childBuilder(newName)         : MetricContext.builder(newName);     return builder.addTags(context.getTags()).addTags(newTags).build();   }
public static void cublasCgerc(int m, int n, cuComplex alpha, Pointer x, int incx, Pointer y, int incy, Pointer A, int lda)      {          cublasCgercNative(m, n, alpha, x, incx, y, incy, A, lda);          checkResultBLAS();      }
private void handleReadsAndWrites(final SelectionKey sk, final MemcachedNode node) throws IOException {       if (sk.isValid() && sk.isReadable()) {           handleReads(node);       }        if (sk.isValid() && sk.isWritable()) {           handleWrites(node);       }   }
public Optional<Script> updateScript(String monitorId, Script script)     {         HTTP.PUT(String.format(""/v3/monitors/%s/script"", monitorId), script);         return Optional.of(script);     }
@Override     public MoveSelector buildBaseMoveSelector(HeuristicConfigPolicy configPolicy,             SelectionCacheType minimumCacheType, boolean randomSelection) {         if (moveIteratorFactoryClass == null) {             throw new IllegalArgumentException(""The moveIteratorFactoryConfig ("" + this                     + "") lacks a moveListFactoryClass ("" + moveIteratorFactoryClass + "")."");         }         MoveIteratorFactory moveIteratorFactory = ConfigUtils.newInstance(this,                 ""moveIteratorFactoryClass"", moveIteratorFactoryClass);         ConfigUtils.applyCustomProperties(moveIteratorFactory, ""moveIteratorFactoryClass"",                 moveIteratorFactoryCustomProperties, ""moveIteratorFactoryCustomProperties"");         return new MoveIteratorFactoryToMoveSelectorBridge(moveIteratorFactory, randomSelection);     }
public ELBinder bindELAnnotation(Class<? extends Annotation> annotationClass, ExecutionPolicy policy) {         ELInterceptor interceptor = new ELInterceptor(annotationClass, policy);         binder.requestInjection(interceptor);         binder.bindInterceptor(Matchers.any(), handlerMethodMatcher(annotationClass), interceptor);         return this;     }
public <A> SetPath<A, PathBuilder<A>> getSet(String property, Class<A> type) {         return this.<A, PathBuilder<A>>getSet(property, type, PathBuilder.class);     }
@Override  public void updateBeanValue() {   TableDataModel model = getDataModel();    if (model instanceof ScrollableTableDataModel) {    LOG.warn(""UpdateBeanValue only updating the current page for ScrollableTableDataModel"");    updateBeanValueCurrentPageOnly();   } else if (model.getRowCount() > 0) {    // Temporarily widen the pagination on the repeater to hold all rows    // Calling setBean with a non-null value overrides the DataTableBeanProvider    repeater.setBean(new RowIdList(0, model.getRowCount() - 1));    updateBeanValueCurrentPageOnly();    repeater.setBean(null);   }  }
public static JTSGeometryExpression<Geometry> geometryOperation(Operator op, Expression<?>... args) {         return new JTSGeometryOperation<Geometry>(Geometry.class, op, args);     }
public void addName(String name)    {       if (names.contains(name))       {          throw new IllegalArgumentException(""already contains: "" + name);       }       indexes.add(name);       names.add(name);       dirty = true;    }
public void handleExceptionProcess(Exception e, Object w)       {         final String mName = ""handleExceptionProcess"";                  if(logger.isLoggable(Level.FINER))            logger.logp(Level.FINE, className, mName, e.getClass().getName() + ""; "" + this.toString());                  if (!isRetryLimitReached() && excMatcher.isSkippableOrRetryable(e))         {           retryType = RETRY_PROCESS;           _retryException = e;           // Retry it.  Log it.  Call the RetryListener.           ++_retryCount;           logRetry(e);            if (_retryProcessListeners != null) {               for (RetryProcessListenerProxy retryProcessListenerProxy : _retryProcessListeners) {                   retryProcessListenerProxy.onRetryProcessException(w, e);                 }           }         }         else         {           // No retry.  Throw it back.           if(logger.isLoggable(Level.FINER))              logger.logp(Level.FINE, className, mName, ""No retry.  Rethrow "", e);           throw new BatchContainerRuntimeException(e);         }       }
@Override     public TextMapper build(String field) {         return new TextMapper(field, column, validated, analyzer);     }
public Map<String, String> encode(Map<String, Object> tableProperties)     {         return ImmutableMap.of();     }
public boolean isSiteUnderSite(String siteRootPath) {          for (String siteRoot : getSiteRoots()) {             if ((siteRootPath.length() > siteRoot.length())                 & siteRootPath.startsWith(CmsFileUtil.addTrailingSeparator(siteRoot))) {                 return true;             }         }         return false;     }
public static int deleteOrphans(EntityManager em) {         requireArgument(em != null, ""Entity manager cannot be null."");          Query query = em.createNamedQuery(""Audit.cullOrphans"");          return query.executeUpdate();     }
private List<Column> resolveProjection(View from) {      List<Column> projection = getProjection();      Assert.isTrue(projection.stream().allMatch(from::contains),       () -> String.format(""The View of Columns %1$s does not contain all the selected, or projected Columns %2$s"",         from.columns(), projection));      return projection;   }
public Traverse TRAVERSE_FROM(DomainObjectMatch<?> start) {   DomainObjectMatch<?> delegate = APIAccess.getDelegate(start);   DomainObjectMatch<?> match = delegate != null ? delegate : start;   TraversalExpression te = new TraversalExpression(match, this.queryExecutor);   this.queryExecutor.addAstObject(te);   Traverse ret = APIAccess.createTraverse(te);   QueryRecorder.recordInvocation(this, ""TRAVERSE_FROM"", ret, QueryRecorder.placeHolder(match));   return ret;  }
public static int indexOf(String s, String substr, int startIndex, int endIndex) {         if (startIndex < 0) {             startIndex = 0;         }         int srclen = s.length();         if (endIndex > srclen) {             endIndex = srclen;         }         int sublen = substr.length();         if (sublen == 0) {             return startIndex > srclen ? srclen : startIndex;         }          int total = endIndex - sublen + 1;         char c = substr.charAt(0);         mainloop: for (int i = startIndex; i < total; i++) {             if (s.charAt(i) != c) {                 continue;             }             int j = 1;             int k = i + 1;             while (j < sublen) {                 if (substr.charAt(j) != s.charAt(k)) {                     continue mainloop;                 }                 j++;                 k++;             }             return i;         }         return -1;     }
@Override     public boolean containsWithinBounds(Object value) {         final int result = compareTo(from, value);         return result == 0 || result < 0 && compareTo(to, value) >= 0;     }
public static JaxbPersistence unmarshal(JPAPXml pxml) throws PersistenceException //d86387     {         final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();         if (isTraceOn && tc.isEntryEnabled())             Tr.entry(tc, ""unmarshal : "" + pxml);          InputStream is = null;         JaxbPersistence persistence = null;          try {             SAXParser parser = ParserFactory.newSAXParser(true, false);             JaxbUnmarshaller handler = new JaxbUnmarshaller(pxml); // d656864              is = pxml.openStream();             parser.parse(is, handler);              persistence = handler.ivPersistence;             persistence.setResult(handler.ivHandler.getResult());         } catch (Throwable ex) {             FFDCFilter.processException(ex, CLASS_NAME + "".unmarshal"", ""109"", pxml);              if (isTraceOn && tc.isDebugEnabled())                 Tr.debug(tc, ""  unmarshal : caught exception : "" + ex);              // 7.1.1 Responsibilities of the Container             //             // At deployment time the container is responsible for scanning the locations specified             // in Section 6.2 and discovering the persistence.xml files and processing them.             //             // When the container finds a persistence.xml file, it processes the persistence unit             // definitions that it contains. The container must validate the persistence.xml file             // against the persistence_1_0.xsd schema and report any validation errors.             //             // Provider or data source information not specified in the persistence.xml file must be             // provided at deployment time or defaulted by the container.              Throwable root = findRootCause(ex);              // Log an error message and create a MetaDataException to throw.             PersistenceException pex = null; // d86387             String appName = pxml.getApplInfo().getApplName();             String modName = pxml.getArchiveName();              if (root instanceof SAXParseException) {                 // Use data in SAXParseException for a more meaningful error message.                 SAXParseException saxEx = (SAXParseException) root;                  // SYNTAX_ERROR_IN_PERSISTENCE_XML_CWWJP0040E=CWWJP0040E:                 // Incorrect syntax or error detected in the persistence.xml                 // file in application: {0}, module: {1}, at line number: {2},                 // column number: {3}. The following associated error message                 // occurred: {4}                 int line = saxEx.getLineNumber();                 int column = saxEx.getColumnNumber();                 Tr.error(tc, ""SYNTAX_ERROR_IN_PERSISTENCE_XML_CWWJP0040E"", appName, modName, line, column, saxEx);                  pex = new PersistenceException(""CWWJP0040E: The persistence.xml"" +                                                "" in application "" + appName +                                                "", module "" + modName +                                                "", has a syntax error at line number: "" +                                                line + "", column number: "" + column +                                                ""."", saxEx); // d86387             } else {                 // SAXParseException did not occur, so we must log a more generic error                 // message to indicate some kind of failure occurred while trying to read                 // the persistence.xml file.                  // MALFORMED_PERSISTENCE_XML_CWWJP0018E=CWWJP0018E: Incorrect syntax                 // or error detected in the {0} file. The following associated error                 // message occurred: {1}                 String urlString = pxml.getRootURL().getPath();                 Tr.error(tc, ""MALFORMED_PERSISTENCE_XML_CWWJP0018E"", urlString, root);                  pex = new PersistenceException(""CWWJP0018E: Incorrect syntax "" +                                                ""or error detected in "" + urlString +                                                "" for application "" + appName +                                                "" module "" + modName +                                                "". The following associated error occurred:"", root); // 86387             }              throw pex;         } finally {             // Normally, the close will be performed as soon as possible, to             // insure the jar file locks are not held (which can be problematic             // on windows)... but just in case there is a failure before the             // close() occurs, make sure the close occurs here.             if (is != null) {                 try {                     is.close();                 } catch (Throwable ex) {                     // The only way this occurs is if an exception was already                     // thrown above... so just log this, and allow the above                     // exception to flow out of this method.                     FFDCFilter.processException(ex, CLASS_NAME + "".unmarshal"", ""192"", is);                     if (isTraceOn && tc.isDebugEnabled())                         Tr.debug(tc, ""  unmarshal : caught exception : "" + ex);                 }             }              if (isTraceOn && tc.isEntryEnabled())                 Tr.exit(tc, ""unmarshal : "" + persistence);         }          return persistence;     }
@Override   public void setDimensionality(int dimensionality) throws IllegalArgumentException {     final int maxdim = getMaxDim();     if(maxdim > dimensionality) {       throw new IllegalArgumentException(""Given dimensionality "" + dimensionality + "" is too small w.r.t. the given values (occurring maximum: "" + maxdim + "")."");     }     this.dimensionality = dimensionality;   }
public static ColumnValue orr(String column, Serializable value) {          return new ColumnValue(column, ORR, value);      }
protected void checkWritePermissionsInFolder(CmsDbContext dbc, CmsResource folder) throws CmsDataAccessException {          ResultSet res = null;         PreparedStatement stmt = null;         Connection conn = null;          CmsUUID projectId = dbc.getRequestContext().getCurrentProject().getUuid();          // first read all subresources with ACEs         List<CmsResource> resources = new ArrayList<CmsResource>();         try {             conn = m_sqlManager.getConnection(dbc);             stmt = m_sqlManager.getPreparedStatement(conn, projectId, ""C_RESOURCES_READ_WITH_ACE_1"");             stmt.setString(1, folder.getRootPath() + ""%"");             res = stmt.executeQuery();              while (res.next()) {                 resources.add(createResource(res, projectId));             }         } catch (SQLException e) {             throw new CmsDbSqlException(                 Messages.get().container(Messages.ERR_GENERIC_SQL_1, CmsDbSqlException.getErrorQuery(stmt)),                 e);         } finally {             m_sqlManager.closeAll(dbc, conn, stmt, res);         }          // check current user write permission for each of these resources         Iterator<CmsResource> itResources = resources.iterator();         while (itResources.hasNext()) {             CmsResource resource = itResources.next();             try {                 m_driverManager.getSecurityManager().checkPermissions(                     dbc.getRequestContext(),                     resource,                     CmsPermissionSet.ACCESS_WRITE,                     false,                     CmsResourceFilter.ALL);             } catch (CmsException e) {                 throw new CmsDataAccessException(e.getMessageContainer(), e);             }         }          // then check for possible jsp pages without permissions         CmsResourceFilter filter = CmsResourceFilter.ALL;         itResources = readTypesInResourceTree(             dbc,             projectId,             folder.getRootPath(),             CmsResourceTypeJsp.getJspResourceTypeIds(),             filter.getState(),             filter.getModifiedAfter(),             filter.getModifiedBefore(),             filter.getReleaseAfter(),             filter.getReleaseBefore(),             filter.getExpireAfter(),             filter.getExpireBefore(),             CmsDriverManager.READMODE_INCLUDE_TREE).iterator();         while (itResources.hasNext()) {             CmsResource resource = itResources.next();             try {                 m_driverManager.getSecurityManager().checkPermissions(                     dbc.getRequestContext(),                     resource,                     CmsPermissionSet.ACCESS_WRITE,                     false,                     CmsResourceFilter.ALL);             } catch (CmsException e) {                 throw new CmsDataAccessException(e.getMessageContainer(), e);             }         }     }
public Integer getMaxStatements()    {       if (childNode.getTextValueForPatternName(""max-statements"") != null && !childNode.getTextValueForPatternName(""max-statements"").equals(""null"")) {          return Integer.valueOf(childNode.getTextValueForPatternName(""max-statements""));       }       return null;    }
@Override     public InputStream read()         throws EFapsException     {         StoreResourceInputStream in = null;         ConnectionResource res = null;         try {             res = Context.getThreadContext().getConnectionResource();              final Statement stmt = res.createStatement();             final StringBuffer cmd = new StringBuffer()                 .append(""select "").append(JDBCStoreResource.COLNAME_FILECONTENT).append("" "")                 .append(""from "").append(JDBCStoreResource.TABLENAME_STORE).append("" "")                 .append(""where ID ="").append(getGeneralID());             final ResultSet resultSet = stmt.executeQuery(cmd.toString());             if (resultSet.next()) {                 if (Context.getDbType().supportsBinaryInputStream())  {                     in = new JDBCStoreResourceInputStream(this,                                                           res,                                                           resultSet.getBinaryStream(1));                 } else  {                     in = new JDBCStoreResourceInputStream(this,                                                           res,                                                           resultSet.getBlob(1));                 }             }             resultSet.close();             stmt.close();         } catch (final IOException e) {             JDBCStoreResource.LOG.error(""read of content failed"", e);             throw new EFapsException(JDBCStoreResource.class, ""read.SQLException"", e);         } catch (final SQLException e) {             JDBCStoreResource.LOG.error(""read of content failed"", e);             throw new EFapsException(JDBCStoreResource.class, ""read.SQLException"", e);         }         return in;     }
@Nullable     private DataType getCachedData(@NonNull final KeyType key) {         synchronized (cache) {             return cache.get(key);         }     }
public R toFloat64Array(@Nullable double[] values, int pos, int length) {     return handle(Value.float64Array(values, pos, length));   }
public static String param(String name){         if(name.equals(""id"")){             return getId();         }else if(RequestContext.getRequestVo().getUserSegments().get(name) != null){             return RequestContext.getRequestVo().getUserSegments().get(name);         }else if(RequestContext.getRequestVo().getWildCardName() != null                 && name.equals(RequestContext.getRequestVo().getWildCardName())){             return RequestContext.getRequestVo().getWildCardValue();         }else{             return RequestContext.getHttpRequest().getParameter(name);         }     }
public Collection<GerritEventListener> removeAllEventListeners() {         synchronized (this) {             HashSet<GerritEventListener> listeners = new HashSet<GerritEventListener>(gerritEventListeners);             gerritEventListeners.clear();             return listeners;         }     }
public static BaseResult shopUpdate(String accessToken, ShopUpdate shopUpdate) {          return shopUpdate(accessToken, JsonUtil.toJSONString(shopUpdate));      }
public void setLevel2CacheLocation(String locationExpr) {   if (null != locationExpr) {    // property name handling in location    String location = propertyReplace(locationExpr);     // create caching directory    File dir = new File(location);    if (!dir.isDirectory()) {     if (dir.exists()) {      log.error(""Location {} for 2nd level cache should be a directory."", location);      throw new RuntimeException(""Invalid location for setLevel2CacheLocation, "" + location + //NOPMD        "" has to be a directory.""); //NOPMD     } else {      if (!dir.mkdirs()) {       log.warn(""Directory {} for 2nd level cache could not be created."", location);      }     }    }    this.location = location;   }  }
private void deleteBus(BusGroup group)   {     if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())       SibTr.entry(tc, ""deleteBus"", group);      // Find the position in the list which contains the group, and remove     // the group.      final BusGroup[] t = _buses;     for (int i = 0; i < _buses.length; i++)     {       if (_buses[i].equals(group))       {         _buses = new BusGroup[t.length - 1];         if (i > 0)           System.arraycopy(t, 0, _buses, 0, i);         if (i < t.length - 1)           System.arraycopy(t, i + 1, _buses, i, t.length - 1 - i);          break;       }     }      if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())       SibTr.exit(tc, ""deleteBus"");   }
public static int getLongOctalBytes(long value, byte[] buf, int offset, int length) {          byte[] temp = new byte[length + 1];          getOctalBytes( value, temp, 0, length + 1 );          System.arraycopy( temp, 0, buf, offset, length );          return offset + length;      }
public R get() throws InterruptedException, ExecutionException {         latch.await();          try {             lock.lock();             if (isCancelled) {                 throw new CancellationException();             }             else if (failure != null) {                 throw new ExecutionException(failure);             }              return result;         }         finally {             lock.unlock();         }     }
@Override     public Request<ImportInstanceRequest> getDryRunRequest() {         Request<ImportInstanceRequest> request = new ImportInstanceRequestMarshaller().marshall(this);         request.addParameter(""DryRun"", Boolean.toString(true));         return request;     }
@Override  public void eUnset(int featureID)  {   switch (featureID)   {    case TypesPackage.JVM_ENUM_ANNOTATION_VALUE__VALUES:     getValues().clear();     return;   }   super.eUnset(featureID);  }
@Override public BraveSpan setTag(String key, Number value) {     if (finishCalled) return this;      if (trySetPeer(key, value)) return this;      // handle late sampling decision     if (Tags.SAMPLING_PRIORITY.getKey().equals(key) && value.intValue() == 0) {       delegate.abandon();       // convert the span to no-op       delegate = tracer.toSpan(delegate.context().toBuilder().sampled(false).build());     }     return setTag(key, value.toString());   }
public Object clickAndExpectOneOf(final Object... expected) {         dispatcher.beforeClick(this, expected);          getElement().click();         if (Boolean.parseBoolean(Config.getConfigProperty(ConfigProperty.ENABLE_GUI_LOGGING))) {             logUIAction(UIActions.CLICKED);         }          // If there are no expected objects, then it means user wants this method         // to behave as a clickonly. So lets skip processing of alerts and leave         // that to the user.         if (expected == null || expected.length == 0) {             return null;         }         if (parent != null) {             WebDriverWaitUtils.waitUntilPageIsLoaded(parent.getCurrentPage());         }         validatePresenceOfAlert();          long timeout = Grid.getExecutionTimeoutValue() / 1000;          try {              WebDriverWait wait = new WebDriverWait(Grid.driver(), timeout);             wait.ignoring(NoSuchElementException.class);             wait.ignoring(PageValidationException.class);              Object expectedObj = wait.ignoring(ExpectOneOfException.class).until(new Function<WebDriver, Object>() {                  // find the first object that is matched and return it                 @Override                 public Object apply(WebDriver webDriver) {                     StringBuilder sb = new StringBuilder();                      int i = 1;                     for (Object expect : expected) {                         try {                             if (expect instanceof AbstractElement) {                                 AbstractElement element = (AbstractElement) expect;                                 if (HtmlElementUtils.locateElement(element.getLocator()) != null) {                                     return expect;                                 }                             } else if (expect instanceof String) {                                 String s = (String) expect;                                 if (HtmlElementUtils.locateElement(s) != null) {                                     return expect;                                 }                             } else if (expect instanceof WebPage) {                                 WebPage w = (WebPage) expect;                                  w.validatePage();                                 return expect;                             }                         } catch (NoSuchElementException | PageValidationException e) { // NOSONAR                             sb.append(""\n\tObject "" + i + "": "" + expect.getClass().getSimpleName() + ""\n"");                             sb.append(""\t"" + ExceptionUtils.getRootCauseMessage(e) + ""\n"");                             sb.append(""\t\t"" + StringUtils.substringBetween(ExceptionUtils.getStackTrace(e), ""\n""));                         }                         i++;                     }                      throw new ExpectOneOfException(sb.toString());                 }             });              return expectedObj;          } finally {             // Attempt at taking screenshots even when there are time-outs triggered from the wait* methods.             processScreenShot();              dispatcher.afterClick(this, expected);         }     }
@Override     protected void defineWidgets() {          List selectOptions = getModulesFromServer();          if (selectOptions.isEmpty()) {             // no import modules available, display message             addWidget(                 new CmsWidgetDialogParameter(                     this,                     ""moduleupload"",                     PAGES[0],                     new CmsDisplayWidget(key(Messages.GUI_MODULES_IMPORT_NOT_AVAILABLE_0))));         } else {             // add the file select box widget             addWidget(new CmsWidgetDialogParameter(this, ""moduleupload"", PAGES[0], new CmsSelectWidget(selectOptions)));         }     }
private void _writeStringCustom(final int len)    throws IOException, JsonGenerationException  {   // And then we'll need to verify need for escaping etc:   int end = _outputTail + len;   final int[] escCodes = _outputEscapes;   final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;   final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);   int escCode = 0;   final CharacterEscapes customEscapes = _characterEscapes;    output_loop:   while (_outputTail < end) {    char c;    // Fast loop for chars not needing escaping    escape_loop:    while (true) {     c = _outputBuffer[_outputTail];     if (c < escLimit) {      escCode = escCodes[c];      if (escCode != 0) {       break escape_loop;      }     } else if (c > maxNonEscaped) {      escCode = CharacterEscapes.ESCAPE_STANDARD;      break escape_loop;     } else {      if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {       escCode = CharacterEscapes.ESCAPE_CUSTOM;       break escape_loop;      }     }     if (++_outputTail >= end) {      break output_loop;     }    }    int flushLen = (_outputTail - _outputHead);    if (flushLen > 0) {     _writer.write(_outputBuffer, _outputHead, flushLen);    }    ++_outputTail;    _prependOrWriteCharacterEscape(c, escCode);   }  }
protected void decideIfProxyGrantingTicketShouldBeReleasedAsAttribute(final Map<String, List<Object>> attributes,                                                                           final Map<String, Object> model, final RegisteredService service) {         val policy = service.getAttributeReleasePolicy();         val isAuthorized = policy != null && policy.isAuthorizedToReleaseProxyGrantingTicket();          val pgtIou = (String) model.get(CasViewConstants.MODEL_ATTRIBUTE_NAME_PROXY_GRANTING_TICKET_IOU);         decideAttributeReleaseBasedOnServiceAttributePolicy(attributes, pgtIou,             CasViewConstants.MODEL_ATTRIBUTE_NAME_PROXY_GRANTING_TICKET_IOU, service, isAuthorized);         val pgtId = (String) model.get(CasViewConstants.MODEL_ATTRIBUTE_NAME_PROXY_GRANTING_TICKET);         decideAttributeReleaseBasedOnServiceAttributePolicy(attributes, pgtId,             CasViewConstants.MODEL_ATTRIBUTE_NAME_PROXY_GRANTING_TICKET, service, isAuthorized);     }
public String buildLine(T entity, boolean appendLineTermination) {   checkEntityConfig();   StringBuilder sb = new StringBuilder();   boolean first = true;   for (ColumnInfo<Object> columnInfo : allColumnInfos) {    if (first) {     first = false;    } else {     sb.append(columnSeparator);    }    Object value;    try {     value = columnInfo.getValue(entity);    } catch (Exception e) {     throw new IllegalStateException(""Could not get value from entity field: "" + columnInfo);    }    @SuppressWarnings(""unchecked"")    Converter<Object, Object> castConverter = (Converter<Object, Object>) columnInfo.getConverter();    String str = castConverter.javaToString(columnInfo, value);    boolean needsQuotes = columnInfo.isNeedsQuotes();    if (str == null) {     if (needsQuotes) {      sb.append(columnQuote).append(columnQuote);     }     continue;    }    // need to protect the column if it contains a quote    if (str.indexOf(columnQuote) >= 0) {     writeQuoted(sb, str);     continue;    }    if (!needsQuotes) {     for (int i = 0; i < str.length(); i++) {      char ch = str.charAt(i);      if (ch == columnSeparator || ch == '\r' || ch == '\n' || ch == '\t' || ch == '\b') {       needsQuotes = true;       break;      }     }    }    if (needsQuotes) {     sb.append(columnQuote);    }    sb.append(str);    if (needsQuotes) {     sb.append(columnQuote);    }   }   if (appendLineTermination) {    sb.append(lineTermination);   }   return sb.toString();  }
public String getBaseName() {         String n = getName();         int idx = n.lastIndexOf('.');         if (idx<0)  return n;         return n.substring(0,idx);     }
@Override     public void notificationCreated(RuntimeUpdateManager updateManager, RuntimeUpdateNotification notification) {          class MyCompletionListener implements CompletionListener<Boolean> {             String notificationName;              public MyCompletionListener(String name) {                 notificationName = name;             }              @Override             public void successfulCompletion(Future<Boolean> future, Boolean result) {                 // The configuration update for which we were monitoring is now complete.                 // Update our awareness to the update and perform any deferred actions.                 configUpdateCompleted(notificationName);             }              @Override             public void failedCompletion(Future<Boolean> future, Throwable t) {                 // The configuration update failed, but we still want to resume functions.                 // Update our awareness to the update and perform any deferred actions.                 configUpdateCompleted(notificationName);             }         }          if (deactivated)             return;          int prevCnt = configUpdateInProgress();          if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())             Tr.debug(PersistentExecutorImpl.this, tc, ""Notified of \"""" + notification.getName() + ""\"" previous configUpdatesInProgress: "" + prevCnt);          FutureMonitor futureMonitor = _futureMonitor;         if (futureMonitor != null) {             MyCompletionListener newListener = new MyCompletionListener(notification.getName());              futureMonitor.onCompletion(notification.getFuture(), newListener);         }     }
public final void setNumberOfDigits(final int numberOfDigits) {         Condition.INSTANCE                 .ensureAtLeast(numberOfDigits, 1, ""The number of digits must be at least 1"");         this.numberOfDigits = numberOfDigits;         setNumber(Math.min(getNumber(), getMaxNumber(numberOfDigits)));     }
protected void deleteRelationsWithSiblings(CmsDbContext dbc, CmsResource resource) throws CmsException {          // get all siblings         List<CmsResource> siblings;         if (resource.getSiblingCount() > 1) {             siblings = readSiblings(dbc, resource, CmsResourceFilter.ALL);         } else {             siblings = new ArrayList<CmsResource>();             siblings.add(resource);         }         // clean the relations in content for all siblings         I_CmsVfsDriver vfsDriver = getVfsDriver(dbc);         Iterator<CmsResource> it = siblings.iterator();         while (it.hasNext()) {             CmsResource sibling = it.next();             // clean the relation information for this sibling             vfsDriver.deleteRelations(                 dbc,                 dbc.currentProject().getUuid(),                 sibling,                 CmsRelationFilter.TARGETS.filterDefinedInContent());         }     }
public int checkIn() {          try {             synchronized (STATIC_LOCK) {                 m_logStream = new PrintStream(new FileOutputStream(DEFAULT_LOGFILE_PATH, false));                 CmsObject cms = getCmsObject();                 if (cms != null) {                     return checkInInternal();                 } else {                     m_logStream.println(""No CmsObject given. Did you call init() first?"");                     return -1;                 }             }         } catch (FileNotFoundException e) {             e.printStackTrace();             return -2;         }     }
public Observable<PolicyDefinitionInner> getAtManagementGroupAsync(String policyDefinitionName, String managementGroupId) {         return getAtManagementGroupWithServiceResponseAsync(policyDefinitionName, managementGroupId).map(new Func1<ServiceResponse<PolicyDefinitionInner>, PolicyDefinitionInner>() {             @Override             public PolicyDefinitionInner call(ServiceResponse<PolicyDefinitionInner> response) {                 return response.body();             }         });     }
public static <T> T[] concat(T first, T[] others) {   @SuppressWarnings(""unchecked"")   T[] arr = (T[]) Array.newInstance(first.getClass(), 1);   arr[0] = first;   return concat(arr, others);  }
@Override     public final void copyStartElement(InputElementStack elemStack,             AttributeCollector attrCollector)         throws IOException, XMLStreamException     {         // Any namespace declarations/bindings?         int nsCount = elemStack.getCurrentNsCount();         if (nsCount > 0) { // yup, got some...             /* First, need to (or at least, should?) add prefix bindings:              * (may not be 100% required, but probably a good thing to do,              * just so that app code has access to prefixes then)              */             for (int i = 0; i < nsCount; ++i) {                 String prefix = elemStack.getLocalNsPrefix(i);                 String uri = elemStack.getLocalNsURI(i);                 if (prefix == null || prefix.length() == 0) { // default NS                     setDefaultNamespace(uri);                 } else {                     setPrefix(prefix, uri);                 }             }         }          writeStartElement(elemStack.getPrefix(),                 elemStack.getLocalName(),                 elemStack.getNsURI());          if (nsCount > 0) {             // And then output actual namespace declarations:             for (int i = 0; i < nsCount; ++i) {                 String prefix = elemStack.getLocalNsPrefix(i);                 String uri = elemStack.getLocalNsURI(i);                  if (prefix == null || prefix.length() == 0) { // default NS                     writeDefaultNamespace(uri);                 } else {                     writeNamespace(prefix, uri);                 }             }         }          /* And then let's just output attributes, if any (whether to copy          * implicit, aka ""default"" attributes, is configurable)          */         int attrCount = mCfgCopyDefaultAttrs ?             attrCollector.getCount() :             attrCollector.getSpecifiedCount();          if (attrCount > 0) {             for (int i = 0; i < attrCount; ++i) {                 attrCollector.writeAttribute(i, mWriter, mValidator);             }         }     }
Rule Unicode() {         return Sequence(                 '\\',                 Hex(), Optional(Hex(), Optional(Hex(), Optional(Hex(), Optional(Hex(), Optional(Hex()))))),                 Optional(Whitespace())         );     }
public void valueWasAccessed(DCache cache, Object id, long expirationTime, int inactivity) {         valueHasChanged(cache, id, expirationTime, inactivity);     }
public T get(Object term) {         // Check that an index vector does not already exist.         T v = termToItem.get(term);         if (v == null) {             synchronized (this) {                 // Confirm that some other thread has not created an index                 // vector for this term.                 v = termToItem.get(term);                 if (v == null) {                     // Generate the index vector for this term and store it.                     v = generator.generate();                     termToItem.put((String) term, v);                 }             }         }         return v;     }
public static void assertOneParameter(final Method method, Class<? extends Annotation> annotation)    {       if (method.getParameterTypes().length != 1)       {          throw annotation == null ? MESSAGES.methodHasToDeclareExactlyOneParameter(method) : MESSAGES.methodHasToDeclareExactlyOneParameter2(method, annotation);       }    }
public ObjectInstance registerMBean(Object object, ObjectName name) throws InstanceAlreadyExistsException, MBeanRegistrationException, NotCompliantMBeanException {         return delegate.registerMBean(object, name);     }
private int get_size_i(final boolean fwd) {  int size = 0;  final Iterator it = elements.iterator();  while (it.hasNext()) {      final GroupElement e = (GroupElement) it.next();      if (e instanceof GroupDeviceElement || fwd) {   size += e.get_size(true);      }  }  return size;     }
public Future<MatchDetail> getMatch(long matchId, boolean includeTimeline) {         return new ApiFuture<>(() -> handler.getMatch(matchId, includeTimeline));     }
@Override  public boolean eIsSet(int featureID) {   switch (featureID) {    case AfplibPackage.EDM__DM_NAME:     return DM_NAME_EDEFAULT == null ? dmName != null : !DM_NAME_EDEFAULT.equals(dmName);   }   return super.eIsSet(featureID);  }
@Pure  public static String getColorNameFromValue(int colorValue) {   for (final Entry<String, Integer> entry : COLOR_MATCHES.entrySet()) {    final int knownValue = entry.getValue().intValue();    if (colorValue == knownValue) {     return entry.getKey();    }   }   return null;  }
public void scrollContinuously(final int numberOfSeconds) {   for (int i = 0; i < numberOfSeconds; i += 2) {    ((JavascriptExecutor) driver)      .executeScript(""window.scrollBy(0,250);"");    try {     Thread.sleep(SECONDS_TO_SLEEP);    } catch (InterruptedException e) {     LOG.info(""Error while scrolling!"");    }   }  }
void setAttributesForInit(Map<String, Object> attr) {     this.attributes.clear();     if (attr != null) {       this.attributes.putAll(attr);     }   }
public static <T> Rule<T> fromUri(final String uri, final List<String> methods, final T target) {     return new Rule<>(uri, methods, target);   }
public Observable<ServiceResponse<RecommendationRuleInner>> getRuleDetailsByWebAppWithServiceResponseAsync(String resourceGroupName, String siteName, String name) {         if (resourceGroupName == null) {             throw new IllegalArgumentException(""Parameter resourceGroupName is required and cannot be null."");         }         if (siteName == null) {             throw new IllegalArgumentException(""Parameter siteName is required and cannot be null."");         }         if (name == null) {             throw new IllegalArgumentException(""Parameter name is required and cannot be null."");         }         if (this.client.subscriptionId() == null) {             throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");         }         if (this.client.apiVersion() == null) {             throw new IllegalArgumentException(""Parameter this.client.apiVersion() is required and cannot be null."");         }         final Boolean updateSeen = null;         final String recommendationId = null;         return service.getRuleDetailsByWebApp(resourceGroupName, siteName, name, this.client.subscriptionId(), updateSeen, recommendationId, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())             .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RecommendationRuleInner>>>() {                 @Override                 public Observable<ServiceResponse<RecommendationRuleInner>> call(Response<ResponseBody> response) {                     try {                         ServiceResponse<RecommendationRuleInner> clientResponse = getRuleDetailsByWebAppDelegate(response);                         return Observable.just(clientResponse);                     } catch (Throwable t) {                         return Observable.error(t);                     }                 }             });     }
@Override  public void encodeBegin(FacesContext context) throws IOException {    // Initialize attributes   String src = (String) getAttributes().get(""src"");    // src is mandatory   if (null == src)    throw new IllegalStateException(""The src attribute is mandatory for the Jawr image path tag. "");    HttpServletRequest request = ((HttpServletRequest) context.getExternalContext().getRequest());   BinaryResourcesHandler imgRsHandler = getBinaryResourcesHandler(context);    // Refresh the config if needed   RendererRequestUtils.refreshConfigIfNeeded(request, imgRsHandler.getConfig());    render(context);    super.encodeBegin(context);    // Reset the Thread local for the Jawr context   ThreadLocalJawrContext.reset();  }
private double calculateRate(long cumulative, long currentTime) {     long timeSinceMapStart = 0;     assert getPhase() == Phase.MAP : ""MapTaskStatus not in map phase!"";      long startTime = getStartTime();     timeSinceMapStart = currentTime - startTime;     if (timeSinceMapStart <= 0) {       LOG.error(""Current time is "" + currentTime +            "" but start time is "" + startTime);       return 0;     }          return cumulative/timeSinceMapStart;    }
@Override     public int doStartTag() throws JspException {   try {      conn = getConnection();  } catch (SQLException e) {      throw new JspException(sql + "": "" + e.getMessage(), e);  }   return EVAL_BODY_BUFFERED;     }
@Override   public SimpleHadoopFilesystemConfigStore createConfigStore(URI configKey) throws ConfigStoreCreationException {     FileSystem fs = createFileSystem(configKey);     URI physicalStoreRoot = getStoreRoot(fs, configKey);     URI logicalStoreRoot = URI.create(getSchemePrefix() + physicalStoreRoot);     return new SimpleHadoopFilesystemConfigStore(fs, physicalStoreRoot, logicalStoreRoot);   }
Map<Class<?>, List<InjectionTarget>> getDeclaredInjectionTargets                     (List<InjectionBinding<?>> resolvedInjectionBindings)     {         final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();         if (isTraceOn && tc.isEntryEnabled())             Tr.entry(tc, ""getDeclaredInjectionTargets"");          Map<Class<?>, List<InjectionTarget>> declaredTargets =                         new HashMap<Class<?>, List<InjectionTarget>>();          // First, collect declared injection targets on a per-class basis.         for (InjectionBinding<?> injectionBinding : resolvedInjectionBindings)         {             if (!injectionBinding.isResolved())             {                 if (isTraceOn && tc.isDebugEnabled())                     Tr.debug(tc, ""skipping unresolved "" + injectionBinding);                 continue;             }              if (isTraceOn && tc.isDebugEnabled())                 Tr.debug(tc, ""adding targets for "" +                              Util.identity(injectionBinding) + '[' + injectionBinding.getDisplayName() + ']');              List<InjectionTarget> injectionTargets = InjectionProcessorContextImpl.getInjectionTargets(injectionBinding);             if (injectionTargets != null)             {                 for (InjectionTarget target : injectionTargets)                 {                     Member member = target.getMember();                     Class<?> memberClass = member.getDeclaringClass();                      if (isTraceOn && tc.isDebugEnabled())                         Tr.debug(tc, ""adding "" + member);                      List<InjectionTarget> classTargets = declaredTargets.get(memberClass);                     if (classTargets == null)                     {                         if (isTraceOn && tc.isDebugEnabled())                             Tr.debug(tc, ""creating list for "" + memberClass + ""/"" + AccessController.doPrivileged(new GetClassLoaderPrivileged(memberClass)));                          classTargets = new ArrayList<InjectionTarget>();                         declaredTargets.put(memberClass, classTargets);                     }                      classTargets.add(target);                 }             }         }          if (isTraceOn && tc.isEntryEnabled())             Tr.exit(tc, ""getDeclaredInjectionTargets"");         return declaredTargets;     }
public synchronized boolean isInconsistent() throws ElkException {    restoreConsistencyCheck();    if (!consistencyCheckingState.isInconsistent()) {    incompleteness_.log(incompleteness_      .getIncompletenessMonitorForClassification());   }   return consistencyCheckingState.isInconsistent();  }
private CmsFavoriteEntry getEntry(Component row) {          if (row instanceof CmsFavInfo) {              return ((CmsFavInfo)row).getEntry();          }         return null;      }
public MatchIterator get(long key, int hashCode) {   int bucket = hashCode & numBucketsMask;    int bucketOffset = bucket << 4;   MemorySegment segment = buckets[bucketOffset >>> segmentSizeBits];   int segOffset = bucketOffset & segmentSizeMask;    while (true) {    long address = segment.getLong(segOffset + 8);    if (address != INVALID_ADDRESS) {     if (segment.getLong(segOffset) == key) {      return valueIter(address);     } else {      bucket = (bucket + 1) & numBucketsMask;      if (segOffset + 16 < segmentSize) {       segOffset += 16;      } else {       bucketOffset = bucket << 4;       segOffset = bucketOffset & segmentSizeMask;       segment = buckets[bucketOffset >>> segmentSizeBits];      }     }    } else {     return valueIter(INVALID_ADDRESS);    }   }  }
@Override     public InventoryMessage makeInventoryMessage(byte[] payloadBytes, int length) throws ProtocolException {         return new InventoryMessage(params, payloadBytes, this, length);     }
public List<DistRaid> getRunningJobs() {     List<DistRaid> list = new LinkedList<DistRaid>();     synchronized(jobs) {       for (List<DistRaid> jobList : jobs.values()) {         synchronized(jobList) {           list.addAll(jobList);         }       }     }     return list;   }
ViewPager.OnPageChangeListener setInternalPageChangeListener(ViewPager.OnPageChangeListener listener) {         ViewPager.OnPageChangeListener oldListener = mInternalPageChangeListener;         mInternalPageChangeListener = listener;         return oldListener;     }
@Override  public List<CPDefinitionOptionRel> findByCPDefinitionId(   long CPDefinitionId, int start, int end,   OrderByComparator<CPDefinitionOptionRel> orderByComparator) {   return findByCPDefinitionId(CPDefinitionId, start, end,    orderByComparator, true);  }
private OASFilter getFilter() {         ClassLoader cl = getContextClassLoader();         if (cl == null) {             cl = OpenApiServletContextListener.class.getClassLoader();         }         return OpenApiProcessor.getFilter(config, cl);     }
public void setPayloadPercentage(int payloadPercentage) {         if( !(payloadPercentage > 0 && payloadPercentage <= 100) ) {             //if an invalid percentage is given             payloadPercentage = 95;         }         this.actualPayloadPercentage = (double) payloadPercentage/100;         setMaxBps(this.downStream, this.downStream.maxBps);         setMaxBps(this.upStream, this.upStream.maxBps);     }
public static void setIdentity( DMatrix1Row mat )     {         int width = mat.numRows < mat.numCols ? mat.numRows : mat.numCols;          Arrays.fill(mat.data,0,mat.getNumElements(),0);          int index = 0;         for( int i = 0; i < width; i++ , index += mat.numCols + 1) {             mat.data[index] = 1;         }     }
public MessagePacker writePayload(byte[] src, int off, int len)             throws IOException     {         if (buffer == null || buffer.size() - position < len || len > bufferFlushThreshold) {             flush();  // call flush before write             // Directly write payload to the output without using the buffer             out.write(src, off, len);             totalFlushBytes += len;         }         else {             buffer.putBytes(position, src, off, len);             position += len;         }         return this;     }
public void removeSlot(TimeSlot oldSlot) {          if (oldSlot.nextEntry != null) {             oldSlot.nextEntry.prevEntry = oldSlot.prevEntry;         } else {             // old slot was tail.             this.lastSlot = oldSlot.prevEntry;         }          if (oldSlot.prevEntry != null) {             oldSlot.prevEntry.nextEntry = oldSlot.nextEntry;         } else {             // oldSlot was head.             this.firstSlot = oldSlot.nextEntry;         }      }
public static Set<Policy> policies(BasicSettings settings) {     return settings.policies().stream()         .flatMap(name -> policy(settings, name).stream())         .collect(toSet());   }
private void writeObject( ObjectOutputStream aStream ) throws IOException {         aStream.writeBoolean(absolute);         aStream.writeBoolean(normalized);         aStream.writeObject(Collections.unmodifiableList(new ArrayList<Path.Segment>(segments))); // make a copy!     }
public void rollback() throws ServiceBusException, InterruptedException {         if (this.messagingFactory == null) {             throw new ServiceBusException(false, ""MessagingFactory should not be null"");         }          this.messagingFactory.endTransaction(this, false);     }
private void readActivityCodes(Task task, List<CodeAssignmentType> codes)    {       for (CodeAssignmentType assignment : codes)       {          ActivityCodeValue code = m_activityCodeMap.get(Integer.valueOf(assignment.getValueObjectId()));          if (code != null)          {             task.addActivityCode(code);          }       }    }
@Override     public void removeSession(String id) {         if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_CORE.isLoggable(Level.FINE)) {             String s = id + appNameForLogging;             LoggingUtil.SESSION_LOGGER_CORE.logp(Level.FINE, methodClassName, ""removeSession"", s);         }         Object removedEntry = _sessions.remove(id);         if (removedEntry != null) {             _storeCallback.sessionLiveCountDec(removedEntry);         }     }
protected void performUpdate() {            // Wrap a try-catch around everything, because an escaping exception would cancel the task from which this is called          List<CmsWaitHandle> waitHandles = new ArrayList<>();          try {              ArrayList<Object> work = new ArrayList<>();              m_workQueue.drainTo(work);              Set<CmsUUID> updateIds = new HashSet<CmsUUID>();                for (Object item : work) {                  if (item instanceof CmsUUID) {                      updateIds.add((CmsUUID)item);                  } else if (item instanceof CmsWaitHandle) {                      waitHandles.add((CmsWaitHandle)item);                  }              }              CmsADEConfigCacheState oldState = m_state;              if (!updateIds.isEmpty() || (oldState == null)) {                  try {                      // Although  the updates are performed in a scheduled task, it is still possible                      // that the task is scheduled immediately after a configuration update event. So                      // here we ensure that there is at least a small delay between the event and the                      // actual update. This is required to prevent problems with other caches.                      Thread.sleep(100);                  } catch (InterruptedException e) {                      // ignore                  }                  if (updateIds.contains(ID_UPDATE_ALL) || (oldState == null)) {                      m_state = readCompleteConfiguration();                  } else {                      boolean updateModules = updateIds.remove(ID_UPDATE_MODULES);                      boolean updateElementViews = updateIds.remove(ID_UPDATE_ELEMENT_VIEWS);                      updateIds.remove(ID_UPDATE_FOLDERTYPES); // folder types are always updated when the update set is not empty, so at this point we don't care whether the id for folder type updates actually is in the update set                      Map<CmsUUID, CmsADEConfigDataInternal> updateMap = Maps.newHashMap();                      for (CmsUUID structureId : updateIds) {                          CmsADEConfigDataInternal sitemapConfig = parseSitemapConfiguration(structureId);                          // sitemapConfig may be null at this point                          updateMap.put(structureId, sitemapConfig);                      }                      List<CmsADEConfigDataInternal> moduleConfigs = null;                      if (updateModules) {                          moduleConfigs = loadModuleConfiguration();                      }                      Map<CmsUUID, CmsElementView> elementViews = null;                      if (updateElementViews) {                          elementViews = loadElementViews();                      }                      m_state = oldState.createUpdatedCopy(updateMap, moduleConfigs, elementViews);                  }              }            } catch (Exception e) {              LOG.error(""Could not perform configuration cache update: "" + e.getMessage(), e);          } finally {              for (CmsWaitHandle handle : waitHandles) {                  handle.release();              }          }      }
public void internalError(final Exception cause) {     logError(""Internal Server Error on "" + request().getUri(), cause);     sendBuffer(HttpResponseStatus.INTERNAL_SERVER_ERROR,         ChannelBuffers.wrappedBuffer(             cause.toString().getBytes(Const.UTF8_CHARSET)),         ""text/plain"");   }
public MongoDB format(MongoDBFormat format) {         String strFormat;         switch (format) {             case BASIC_INTERACTION_META:                 strFormat = ""basic_interaction_meta"";                 break;             case FULL_INTERACTION_META_DATE:                 strFormat = ""full_interaction_meta_date"";                 break;             default:             case FULL_INTERACTION_META:                 strFormat = ""full_interaction_meta"";                 break;         }         return setParam(""format"", strFormat);     }
@Override  protected Component newListComponent(final String id, final ListItem<ResourceBundleKey> item)  {   return new Label(id, newContentResourceModel(item.getModel()))    .add(new JQueryJsAppenderBehavior(""wrap"", ""<p></p>""));  }
public void addFormatter(Formatter formatter) {         if(_formatters == null)             _formatters = new ArrayList/*<Formatter>*/();          _formatters.add(formatter);     }
public Observable<KeyBundle> createKeyAsync(String vaultBaseUrl, String keyName, JsonWebKeyType kty, Integer keySize, List<JsonWebKeyOperation> keyOps, KeyAttributes keyAttributes, Map<String, String> tags, JsonWebKeyCurveName curve) {         return createKeyWithServiceResponseAsync(vaultBaseUrl, keyName, kty, keySize, keyOps, keyAttributes, tags, curve).map(new Func1<ServiceResponse<KeyBundle>, KeyBundle>() {             @Override             public KeyBundle call(ServiceResponse<KeyBundle> response) {                 return response.body();             }         });     }
@Override   public JAnnotation getAnnotation(String name)   {     Annotation []ann = _class.getAnnotations();      for (int i = 0; i < ann.length; i++) {       if (ann[i].annotationType().getName().equals(name))         return new JAnnotationWrapper(ann[i]);     }      return null;   }
protected void createOrReuseConnection(ConnectionContext context, boolean start) throws JMSException {         Connection conn;          if (isReuseConnection()) {             conn = getConnection();             if (conn != null) {                 // already have a connection cached, give it to the context                 context.setConnection(conn);             } else {                 // there is no connection yet; create it and cache it                 createConnection(context);                 conn = context.getConnection();                 cacheConnection(conn, false);             }         } else {             // we are not to cache connections - always create one             createConnection(context);             conn = context.getConnection();             cacheConnection(conn, false);         }          if (start) {             // Calling start on started connection is ignored.             // But if an exception is thrown, we need to throw away the connection             try {                 conn.start();             } catch (JMSException e) {                 msglog.errorFailedToStartConnection(e);                 cacheConnection(null, true);                 throw e;             }         }     }
private void dumpNode(final Node node, final TransformContext transformContext, final StringBuilder builder) {   if (node == null) {    return;   }   if (node instanceof ASTProperty) {    ASTProperty prop = (ASTProperty) node;    if (!StringFunction.SHORT_NAME.equals(prop.toString())) {     try {      Object value = Ognl.getValue(prop, transformContext, null);      builder.append(prop)        .append("":["")        .append(value == null ? null          : ToStringBuilder.reflectionToString(value,            ToStringStyle.SIMPLE_STYLE))        .append(""],"");     } catch (OgnlException ex) {      // ダンプ処理でシステムが止まっては困るのでスタックトレースを出して握りつぶす      ex.printStackTrace();     }    }   } else {    int childCount = node.jjtGetNumChildren();    for (int i = 0; i < childCount; i++) {     Node child = node.jjtGetChild(i);     dumpNode(child, transformContext, builder);    }   }  }
public void trackPendingDialogCall(FacebookDialog.PendingCall pendingCall) {         if (pendingFacebookDialogCall != null) {             // If one is already pending, cancel it; we don't allow multiple pending calls.             Log.i(""Facebook"", ""Tracking new app call while one is still pending; canceling pending call."");             cancelPendingAppCall(null);         }         pendingFacebookDialogCall = pendingCall;     }
public static String getOperation(HttpString method) {         String operation = """";                  if (Methods.POST.equals(method)) {             operation = WRITE;         } else if (Methods.PUT.equals(method)) {             operation = WRITE;         } else if (Methods.DELETE.equals(method)) {             operation = WRITE;         } else if (Methods.GET.equals(method)) {             operation = READ;         } else if (Methods.PATCH.equals(method)) {             operation = WRITE;         } else if (Methods.OPTIONS.equals(method)) {             operation = READ;         } else if (Methods.HEAD.equals(method)) {             operation = READ;         } else {             // ignore everything else         }                  return operation;     }
public void marshall(UpdateBasePathMappingRequest updateBasePathMappingRequest, ProtocolMarshaller protocolMarshaller) {          if (updateBasePathMappingRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(updateBasePathMappingRequest.getDomainName(), DOMAINNAME_BINDING);             protocolMarshaller.marshall(updateBasePathMappingRequest.getBasePath(), BASEPATH_BINDING);             protocolMarshaller.marshall(updateBasePathMappingRequest.getPatchOperations(), PATCHOPERATIONS_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
protected CmsUserSearchParameters getSearchParams() throws CmsException {          CmsListState state = getListState();         CmsUserSearchParameters params = new CmsUserSearchParameters();         String searchFilter = state.getFilter();         params.setSearchFilter(searchFilter);         if (!hasOuDetail()) {             params.setOrganizationalUnit(OpenCms.getOrgUnitManager().readOrganizationalUnit(getCms(), getParamOufqn()));         }         params.setPaging(getList().getMaxItemsPerPage(), state.getPage());         params.setSorting(getSortKey(state.getColumn()), state.getOrder().equals(CmsListOrderEnum.ORDER_ASCENDING));         CmsGroup group = getCms().readGroup(new CmsUUID(getParamGroupid()));         params.setGroup(group);         params.setFilterByGroupOu(false);         return params;     }
public static Date getInstance(final java.util.Date date, final Value type) {         if (Value.DATE.equals(type)) {             return new Date(date);         }         return new DateTime(date);     }
private void parseElements(Node parent)          throws JasperException      {         if( scriptlessCount > 0 ) {             // vc: ScriptlessBody             // We must follow the ScriptlessBody production if one of             // our parents is ScriptlessBody.             parseElementsScriptless( parent );             return;         }           start = reader.mark();  if (reader.matches(""<%--"")) {      parseComment(parent);  } else if (reader.matches(""<%@"")) {      parseDirective(parent);         } else if (reader.matches(""<jsp:directive."")) {             parseXMLDirective(parent);  } else if (reader.matches(""<%!"")) {      parseDeclaration(parent);         } else if (reader.matches(""<jsp:declaration"")) {             parseXMLDeclaration(parent);         } else if (reader.matches(""<%="")) {             parseExpression(parent);         } else if (reader.matches(""<jsp:expression"")) {             parseXMLExpression(parent);  } else if (reader.matches(""<%"")) {      parseScriptlet(parent);         } else if (reader.matches(""<jsp:scriptlet"")) {             parseXMLScriptlet(parent);         } else if (reader.matches(""<jsp:text"")) {             parseXMLTemplateText(parent);         } else if (reader.matches(""${"")) {             parseELExpression(parent, ""${"");         } else if (reader.matches(""#{"")) {             parseELExpression(parent, ""#{"");  } else if (reader.matches(""<jsp:"")) {      parseStandardAction(parent);  } else if (!parseCustomTag(parent)) {             checkUnbalancedEndTag();             parseTemplateText(parent);  }     }
@RequestMapping(value = ""application"", method = RequestMethod.GET)     public Resources<ApplicationInfo> applicationInfo() {         return Resources.of(                 applicationInfoService.getApplicationInfoList(),                 uri(on(InfoController.class).applicationInfo())         );     }
public static <T> Comparator<T> withNullsFirst(final Comparator<T> comparator)  {   Parameters.checkNotNull(comparator);   return new Comparator<T>()   {    @Override    public int compare(T o1, T o2)    {     return o1 == o2 ? 0      : o1 == null ? -1      : o2 == null ? 1      : comparator.compare(o1, o2);    }   };  }
void writeLock(int count) {       if (count > 0 && counter != null)          counter.acquireShared(count);       sync.acquireShared(1);    }
public Subscriptions getSubscriptions() throws JinxException {     Map<String, String> params = new TreeMap<>();     params.put(""method"", ""flickr.push.getSubscriptions"");     return jinx.flickrGet(params, Subscriptions.class);   }
public void delistFromCleanup(OnePhaseXAResource resource) throws IllegalStateException     {         if (tc.isEntryEnabled()) Tr.entry(tc, ""delistFromCleanup"", resource);          if (LocalTranCurrentImpl.globalTranExists())         {             final IllegalStateException ise = new IllegalStateException(""Cannot delist Resource from cleanup. A Global transaction is active."");             FFDCFilter.processException(ise, ""com.ibm.tx.ltc.LocalTranCoordImpl.delistFromCleanup"", ""525"", this);             Tr.error(tc, ""ERR_DELIST_TX_GLB_ACT"");             if (tc.isEntryEnabled()) Tr.exit(tc, ""delistFromCleanup"", ise);             throw ise;         }          if (_cleanupResources == null)         {             final IllegalStateException ise = new IllegalStateException(""Cannot delist Resource. It is not enlisted for cleanup with this LocalTransactionCoordinator."");             FFDCFilter.processException(ise, ""com.ibm.tx.ltc.LocalTranCoordImpl.delistFromCleanup"", ""534"", this);             Tr.error(tc, ""ERR_DELIST_NOT_ENLISTED"");             if (tc.isEntryEnabled()) Tr.exit(tc, ""delistFromCleanup"", ise);             throw ise;         }          if ((_state == Running) || (_state == Suspended))         {             int index = _cleanupResources.indexOf(resource);              if (index == -1)             {                 final IllegalStateException ise = new IllegalStateException(""Cannot delist Resource. It is not enlisted for cleanup with this LocalTransactionCoordinator."");                 FFDCFilter.processException(ise, ""com.ibm.tx.ltc.LocalTranCoordImpl.delistFromCleanup"", ""547"", this);                 Tr.error(tc, ""ERR_DELIST_NOT_ENLISTED"");                 if (tc.isEntryEnabled()) Tr.exit(tc, ""delistFromCleanup"", ise);                 throw ise;             }              _cleanupResources.remove(index);         }         // Defect 156223         //          // If we are completing or completed then we can't allow the          // delist but throwing an exception may cause problems in         // the ConnectionManager so we simply do nothing.          if (tc.isEntryEnabled()) Tr.exit(tc, ""delistFromCleanup"");     }
@Override     public Set<CharSequence> keySet() {         final Set<CharSequence> ks = keySet;         return ks != null ? ks : (keySet = new KeySet());     }
public static double fBeta(double beta, double precision, double recall) {         if (precision == 0.0 || recall == 0.0)             return 0;          double numerator = (1 + beta * beta) * precision * recall;         double denominator = beta * beta * precision + recall;          return numerator / denominator;     }
public final void setDatas(@NonNull Iterable<? extends Data<?>> datas) {         checkNotNull(datas, ""datas"");         mDataWatcher.setDatas(datas);         mDatas.clear();         for (Data<?> data : datas) {             mDatas.add(data);         }         // Clear error message, because the caller expects the view state to be reset when all datas change         if (mDatas.isEmpty()) {             mErrorMessage = null;         }         updateViews();     }
public static int convertColToInt(final String col) {    String name = col.toUpperCase();    int number = 0;    int pow = 1;    for (int i = name.length() - 1; i >= 0; i--) {     number += (name.charAt(i) - 'A' + 1) * pow;     pow *= TieConstants.EXCEL_LETTER_NUMBERS;    }      return number - 1;   }
public com.squareup.okhttp.Call getStatusAsync(String datasource, String ifNoneMatch,             final ApiCallback<StatusResponse> callback) throws ApiException {          com.squareup.okhttp.Call call = getStatusValidateBeforeCall(datasource, ifNoneMatch, callback);         Type localVarReturnType = new TypeToken<StatusResponse>() {         }.getType();         apiClient.executeAsync(call, localVarReturnType, callback);         return call;     }
private static String getClassnameFor(String platform)      {          String pf = ""Default"";          if (platform != null)          {              pf = platform;          }          return ""org.apache.ojb.broker.platforms.Platform"" + pf.substring(0, 1).toUpperCase() + pf.substring(1) + ""Impl"";      }
public List<Object> decodeBuffer(RTMPConnection conn, IoBuffer buffer) {          final int position = buffer.position();          //if (log.isTraceEnabled()) {              //log.trace(""decodeBuffer: {}"", Hex.encodeHexString(Arrays.copyOfRange(buffer.array(), position, buffer.limit())));          //}          // decoded results          List<Object> result = null;          if (conn != null) {              //log.trace(""Decoding for connection - session id: {}"", conn.getSessionId());              try {                  // instance list to hold results                  result = new LinkedList<>();                  // get the local decode state                  RTMPDecodeState state = conn.getDecoderState();                  //if (log.isTraceEnabled()) {                      //log.trace(""RTMP decode state {}"", state);                  //}                  if (!conn.getSessionId().equals(state.getSessionId())) {                      log.warn(""Session decode overlap: {} != {}"", conn.getSessionId(), state.getSessionId());                  }                  int remaining;                  while ((remaining = buffer.remaining()) > 0) {                      if (state.canStartDecoding(remaining)) {                          //log.trace(""Can start decoding"");                          state.startDecoding();                      } else {                          log.trace(""Cannot start decoding"");                          break;                      }                      final Object decodedObject = decode(conn, state, buffer);                      if (state.hasDecodedObject()) {                          //log.trace(""Has decoded object"");                          if (decodedObject != null) {                              result.add(decodedObject);                          }                      } else if (state.canContinueDecoding()) {                          //log.trace(""Can continue decoding"");                          continue;                      } else {                          log.trace(""Cannot continue decoding"");                          break;                      }                  }              } catch (Exception ex) {                  log.warn(""Failed to decodeBuffer: pos {}, limit {}, chunk size {}, buffer {}"", position, buffer.limit(), conn.getState().getReadChunkSize(), Hex.encodeHexString(Arrays.copyOfRange(buffer.array(), position, buffer.limit())));                  // catch any non-handshake exception in the decoding; close the connection                  log.warn(""Closing connection because decoding failed: {}"", conn, ex);                  // clear the buffer to eliminate memory leaks when we can't parse protocol                  buffer.clear();                  // close connection because we can't parse data from it                  conn.close();              } finally {                  //if (log.isTraceEnabled()) {                      //log.trace(""decodeBuffer - post decode input buffer position: {} remaining: {}"", buffer.position(), buffer.remaining());                  //}                  buffer.compact();              }          } else {              log.error(""Decoding buffer failed, no current connection!?"");          }          return result;      }
public <C> CacheManagerBuilder<T> withCopier(Class<C> clazz, Class<? extends Copier<C>> copier) {     DefaultCopyProviderConfiguration service = configBuilder.findServiceByClass(DefaultCopyProviderConfiguration.class);     if (service == null) {       service = new DefaultCopyProviderConfiguration();       service.addCopierFor(clazz, copier);       return new CacheManagerBuilder<>(this, configBuilder.addService(service));     } else {       DefaultCopyProviderConfiguration newConfig = new DefaultCopyProviderConfiguration(service);       newConfig.addCopierFor(clazz, copier, true);       return new CacheManagerBuilder<>(this, configBuilder.removeService(service).addService(newConfig));     }   }
public static INDArray min(INDArray first, INDArray second) {         return min(first, second, true);     }
private void onProgress(final int workerNumber, final int workerSize, final List<Long> pointerList, final float progress) {    if (progressCache == null) {    progressCache = new ProgressCache(workerSize, (onRealtimeResultListener != null));   }    progressCache.setProgress(workerNumber, progress, pointerList);    if (onProgressListener != null) {    onProgressListener.onProgress(progressCache.getProgress());   }    if (onRealtimeResultListener != null) {    onRealtimeResultListener.onRealtimeResultListener(progressCache.getProgress(), progressCache.getResultPointers());   }  }
public Datatype.Builder clearNestedClasses() {     if (nestedClasses instanceof ImmutableList) {       nestedClasses = ImmutableList.of();     } else {       nestedClasses.clear();     }     return (Datatype.Builder) this;   }
public static byte[] decryptBase64AES(byte[] data, byte[] key) {         try {             return decryptAES(Base64.getDecoder().decode(data), key);         } catch (Exception e) {             return null;         }     }
public void saveUniqueViolation(SensorContext sensorContext, CxxReportIssue issue) {      if (uniqueIssues.add(issue)) {        saveViolation(sensorContext, issue);      }    }
public void deletePrivacyList(String listName) throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {         // The request of the list is an privacy message with an empty list         Privacy request = new Privacy();         request.setPrivacyList(listName, new ArrayList<PrivacyItem>());          // Send the package to the server         setRequest(request);     }
public void getExchangeInfo(Exchange.Type currency, long quantity, Callback<Exchange> callback) throws GuildWars2Exception, NullPointerException {   isValueValid(quantity);   gw2API.getExchangeInfo(currency.name(), Long.toString(quantity)).enqueue(callback);  }
public static Reader createReaderForFile(File source, Encoding encoding)    throws FileNotFoundException, UnsupportedEncodingException  {   return createReaderForInputStream(new FileInputStream(source), encoding);  }
private static boolean isLowerBoundCompatible(final WildcardType type, final Class... with) {         boolean res = true;         if (type.getLowerBounds().length > 0) {             // only one super could be used             // couldn't be an object here as ? super Object is always replaced to simply Object before comparison             final Class<?> lower = GenericsUtils.resolveClassIgnoringVariables(type.getLowerBounds()[0]);              // target may only be lower bound's super type (or same type)             for (Class<?> target : with) {                 if (!target.isAssignableFrom(lower)) {                     res = false;                     break;                 }             }         }         return res;     }
public static int cuMemsetD2D16Async(CUdeviceptr dstDevice, long dstPitch, short us, long Width, long Height, CUstream hStream)      {          return checkResult(cuMemsetD2D16AsyncNative(dstDevice, dstPitch, us, Width, Height, hStream));      }
public static <E> Collection<E> unionColl(Collection<E> c1, Collection<E> c2) {  return new UColl<E>(c1, c2);     }
public static Vector4d equationFromPoints(             Vector3d v0, Vector3d v1, Vector3d v2,             Vector4d dest) {         return equationFromPoints(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, dest);     }
public void putEvents(List<Event> events) {         List<Event> filteredEvents = filterEvents(events);         executeHandlers(filteredEvents);         for (Event event : filteredEvents) {             persistenceHandler.writeEvent(event);         }     }
private SheetMapper<T> getPoiMapper(int startRow, Sheet sheet) {         Row row = sheet.getRow(startRow);          List<CsvColumnKey> keys = new ArrayList<CsvColumnKey>(row.getLastCellNum() - row.getFirstCellNum());         for(short i = row.getFirstCellNum(); i <= row.getLastCellNum(); i++) {             Cell cell = row.getCell(i);             if (cell != null && cell.getCellType() != Cell.CELL_TYPE_BLANK) {                 keys.add(new CsvColumnKey(cell.getStringCellValue(), i));             }         }          return getPoiMapper(new MapperKey<CsvColumnKey>(keys.toArray(new CsvColumnKey[0])));       }
private void addAttributes(PublisherRegistration publisherRegistration, String group) {         // if group == null; group = ""DEFAULT_GROUP""         if (StringUtils.isNotEmpty(group)) {             publisherRegistration.setGroup(group);         }      }
public String getJavaDataType(Map<String, Shape> shapes, String shapeName,                                   CustomizationConfig customConfig) {          if (shapeName == null || shapeName.trim().isEmpty()) {             throw new IllegalArgumentException(                     ""Cannot derive shape type. Shape name cannot be null or empty"");         }          final Shape shape = shapes.get(shapeName);          if (shape == null) {             throw new IllegalArgumentException(                     ""Cannot derive shape type. No shape information available for "" + shapeName);         }          final String shapeType = shape.getType();          if (Structure.getName().equals(shapeType)) {             return namingStrategy.getJavaClassName(shapeName);         } else if (List.getName().equals(shapeType)) {             String listType =                     customConfig != null && customConfig.isUseAutoConstructList() ? LIST_AUTO_CONSTRUCT_IMPL : LIST_INTERFACE;             final String listContainerType = dataTypeMappings.get(listType);             return listContainerType + ""<"" +                    getJavaDataType(shapes, shape.getListMember().getShape()) + "">"";         } else if (Map.getName().equals(shapeType)) {             String mapType =                     customConfig != null && customConfig.isUseAutoConstructMap() ? MAP_AUTO_CONSTRUCT_IMPL : MAP_INTERFACE;             final String mapContainerType = dataTypeMappings.get(mapType);             return mapContainerType + ""<"" +                    getJavaDataType(shapes, shape.getMapKeyType().getShape()) + "","" +                    getJavaDataType(shapes, shape.getMapValueType().getShape()) + "">"";         } else {              if (shape.isStreaming()) {                 return dataTypeMappings.get(""stream"");             }              // scalar type.             final String dataType = dataTypeMappings.get(shapeType);             if (dataType == null) {                 throw new RuntimeException(                         ""Equivalent Java data type cannot be found for data type : "" + shapeType);             }             return dataType;         }     }
public void consumeAsync(List<Purchase> purchases, OnConsumeMultiFinishedListener listener) {         checkNotDisposed();         checkSetupDone(""consume"");         consumeAsyncInternal(purchases, null, listener);     }
@Override     protected final T create(Object... args) {         final K key = this.getKey(args);         final T value = this.createInternal(key, args);         this.objectCache.put(key, value);         return value;     }
public static long getEffectivePermission(Member member)     {         Checks.notNull(member, ""Member"");          if (member.isOwner())             return Permission.ALL_PERMISSIONS;         //Default to binary OR of all global permissions in this guild         long permission = member.getGuild().getPublicRole().getPermissionsRaw();         for (Role role : member.getRoles())         {             permission |= role.getPermissionsRaw();             if (isApplied(permission, Permission.ADMINISTRATOR.getRawValue()))                 return Permission.ALL_PERMISSIONS;         }          return permission;     }
private static ProtocolSigFingerprint getSigFingerprint(       Class <? extends VersionedProtocol> protocol, long serverVersion) {     String protocolName = protocol.getName();     synchronized (PROTOCOL_FINGERPRINT_CACHE) {       ProtocolSigFingerprint sig = PROTOCOL_FINGERPRINT_CACHE.get(protocolName);       if (sig == null) {         int[] serverMethodHashcodes = getFingerprints(protocol.getMethods());         sig = new ProtocolSigFingerprint(             new ProtocolSignature(serverVersion, serverMethodHashcodes),             getFingerprint(serverMethodHashcodes));         PROTOCOL_FINGERPRINT_CACHE.put(protocolName, sig);       }       return sig;     }   }
public boolean isEscape(StringBuilder temp, int index)   {    if (index != 0 && cs[index - 1] == this.ESCAPE)    {     if (index >= 2 && cs[index - 2] == this.ESCAPE)     {      // 俩个转义符号，删除一个      if (temp.length() != 0)       temp.setLength(temp.length() - 1);      return false;     }     else     {      // 将已经添加的转义符号删除      if (temp.length() != 0)       temp.setLength(temp.length() - 1);      return true;     }    }    else    {     return false;    }      // //将已经添加的转义符号删除    // if(temp.length()!=0)temp.setLength(temp.length()-1);    // return true ;   }
public String onQueryOverCQL3(EntityMetadata m, Client client, MetamodelImpl metaModel, List<String> relations) {         // select column will always be of entity field only!         // where clause ordering          Class compoundKeyClass = m.getIdAttribute().getBindableJavaType();         EmbeddableType compoundKey = null;         String idColumn;         if (metaModel.isEmbeddable(compoundKeyClass)) {             compoundKey = metaModel.embeddable(compoundKeyClass);             idColumn = ((AbstractAttribute) m.getIdAttribute()).getJPAColumnName();         } else {             idColumn = ((AbstractAttribute) m.getIdAttribute()).getJPAColumnName();         }         StringBuilder builder = new StringBuilder();          boolean isPresent = false;         List<String> columns = getColumnList(m, metaModel, getKunderaQuery().getResult(), compoundKey);         String selectQuery = setSelectQuery(columns);          CQLTranslator translator = new CQLTranslator();          selectQuery = StringUtils.replace(selectQuery, CQLTranslator.COLUMN_FAMILY,             translator.ensureCase(new StringBuilder(), m.getTableName(), false).toString());          builder = CassandraUtilities.appendColumns(builder, columns, selectQuery, translator);          addWhereClause(builder);          onCondition(m, metaModel, compoundKey, idColumn, builder, isPresent, translator, true);          return builder.toString();     }
private static Bitmap createEdgeShadow(@NonNull final Context context, final int elevation,                                            @NonNull final Orientation orientation,                                            final boolean parallelLight) {         if (elevation == 0) {             return null;         } else {             float shadowWidth = getShadowWidth(context, elevation, orientation, parallelLight);             int shadowColor = getShadowColor(elevation, orientation, parallelLight);             int bitmapWidth = (int) Math                     .round((orientation == Orientation.LEFT || orientation == Orientation.RIGHT) ?                             Math.ceil(shadowWidth) : 1);             int bitmapHeight = (int) Math                     .round((orientation == Orientation.TOP || orientation == Orientation.BOTTOM) ?                             Math.ceil(shadowWidth) : 1);             Bitmap bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);             Canvas canvas = new Canvas(bitmap);             Shader linearGradient =                     createLinearGradient(orientation, bitmapWidth, bitmapHeight, shadowWidth,                             shadowColor);             Paint paint = new Paint();             paint.setAntiAlias(true);             paint.setDither(true);             paint.setShader(linearGradient);             canvas.drawRect(0, 0, bitmapWidth, bitmapHeight, paint);             return bitmap;         }     }
void addChronoChangedListener(Consumer<Chronology> listener) {         if (chronoListeners == null) {             chronoListeners = new ArrayList<Consumer<Chronology>>();         }         chronoListeners.add(listener);     }
public void modifyRequest(ResponseBuilder rb, SearchComponent who,       ShardRequest sreq) {     if (sreq.params.getBool(MtasSolrSearchComponent.PARAM_MTAS, false)         && sreq.params.getBool(PARAM_MTAS_LIST, false)) {       // compute keys       Set<String> keys = MtasSolrResultUtil           .getIdsFromParameters(rb.req.getParams(), PARAM_MTAS_LIST);       if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {         for (String key : keys) {           sreq.params.remove(               PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_PREFIX);           sreq.params               .remove(PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_START);           sreq.params.remove(               PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_NUMBER);           sreq.params               .remove(PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_LEFT);           sreq.params               .remove(PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_RIGHT);           sreq.params.remove(               PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_OUTPUT);           // don't get data           sreq.params.add(               PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_NUMBER, ""0"");         }       } else {         sreq.params.remove(PARAM_MTAS_LIST);         for (String key : keys) {           sreq.params               .remove(PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_FIELD);           sreq.params.remove(               PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_QUERY_VALUE);           sreq.params.remove(               PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_QUERY_TYPE);           sreq.params.remove(               PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_QUERY_PREFIX);           sreq.params.remove(               PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_QUERY_IGNORE);           sreq.params.remove(PARAM_MTAS_LIST + ""."" + key + "".""               + NAME_MTAS_LIST_QUERY_MAXIMUM_IGNORE_LENGTH);           Set<String> subKeys = MtasSolrResultUtil               .getIdsFromParameters(rb.req.getParams(), PARAM_MTAS_LIST + "".""                   + key + ""."" + NAME_MTAS_LIST_QUERY_VARIABLE);           for (String subKey : subKeys) {             sreq.params.remove(PARAM_MTAS_LIST + ""."" + key + "".""                 + NAME_MTAS_LIST_QUERY_VARIABLE + ""."" + subKey + "".""                 + SUBNAME_MTAS_LIST_QUERY_VARIABLE_NAME);             sreq.params.remove(PARAM_MTAS_LIST + ""."" + key + "".""                 + NAME_MTAS_LIST_QUERY_VARIABLE + ""."" + subKey + "".""                 + SUBNAME_MTAS_LIST_QUERY_VARIABLE_VALUE);           }           sreq.params               .remove(PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_KEY);           sreq.params.remove(               PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_PREFIX);           sreq.params               .remove(PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_START);           sreq.params.remove(               PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_NUMBER);           sreq.params               .remove(PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_LEFT);           sreq.params               .remove(PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_RIGHT);           sreq.params.remove(               PARAM_MTAS_LIST + ""."" + key + ""."" + NAME_MTAS_LIST_OUTPUT);         }       }     }   }
public static SystemInputDef getRequestInputModel( InputStream api, ModelOptions options)     {     try( OpenApiReader reader = new OpenApiReader( api))       {       return TcasesOpenApi.getRequestInputModel( reader.read(), options);       }     }
private final int deserializeAdditionalHeaderSegments (final ByteBuffer pdu, final int offset) throws InternetSCSIException {          // parsing Additional Header Segment         int off = offset;         int ahsLength = basicHeaderSegment.getTotalAHSLength();         while (ahsLength != 0) {             final AdditionalHeaderSegment tmpAHS = new AdditionalHeaderSegment();             tmpAHS.deserialize(pdu, off);              additionalHeaderSegments.add(tmpAHS);             ahsLength -= tmpAHS.getLength();              off += tmpAHS.getSpecificField().position();         }          return off - offset;     }
@Override     protected void _predict(Dataframe newData) {         //load all trainables on the bundles         initBundle();          List<Double> weakClassifierWeights = knowledgeBase.getModelParameters().getWeakClassifierWeights();          //create a temporary map for the observed probabilities in training set         StorageEngine storageEngine = knowledgeBase.getStorageEngine();         Map<Object, DataTable2D> tmp_recordDecisions = storageEngine.getBigMap(""tmp_recordDecisions"", Object.class, DataTable2D.class, MapType.HASHMAP, StorageHint.IN_DISK, false, true);                  //initialize array of recordDecisions         for(Integer rId : newData.index()) {             tmp_recordDecisions.put(rId, new DataTable2D());         }                  //using the weak classifiers         AssociativeArray classifierWeightsArray = new AssociativeArray();         int totalWeakClassifiers = weakClassifierWeights.size();         for(int i=0;i<totalWeakClassifiers;++i) {              AbstractClassifier mlclassifier = (AbstractClassifier) bundle.get(STORAGE_INDICATOR + i);             mlclassifier.predict(newData);                          classifierWeightsArray.put(i, weakClassifierWeights.get(i));                          for(Map.Entry<Integer, Record> e : newData.entries()) {                 Integer rId = e.getKey();                 Record r = e.getValue();                 AssociativeArray classProbabilities = r.getYPredictedProbabilities();                                  DataTable2D rDecisions = tmp_recordDecisions.get(rId);                 rDecisions.put(i, classProbabilities);                                  tmp_recordDecisions.put(rId, rDecisions); //WARNING: Do not remove this! We must put it back to the Map to store it on Disk-backed maps             }         }                  //for each record find the combined classification by majority vote         for(Map.Entry<Integer, Record> e : newData.entries()) {             Integer rId = e.getKey();             Record r = e.getValue();                          AssociativeArray combinedClassVotes = FixedCombinationRules.weightedAverage(tmp_recordDecisions.get(rId), classifierWeightsArray);             Descriptives.normalize(combinedClassVotes);                          newData._unsafe_set(rId, new Record(r.getX(), r.getY(), MapMethods.selectMaxKeyValue(combinedClassVotes).getKey(), combinedClassVotes));         }                  //Drop the temporary Collection         storageEngine.dropBigMap(""tmp_recordDecisions"", tmp_recordDecisions);     }
public final @NotNull S isIn(@NotNull Collection<?> values) {     checkNotNull(values);     if (isActualIn(values)) {       return myself();     }     failIfCustomMessageIsSet();     throw failure(unexpectedNotIn(actual, values));   }
public TableColumnVisibility convertTableColumnVisibility(final String tableIdentifier, final String json) {         final String[] split = this.splitColumns(json);          final List<String> visibleColumns = new ArrayList<>();         final List<String> invisibleColumns = new ArrayList<>();          for (String column : split) {             final String[] attribute = this.splitAttributes(column);             final String identifier = attribute[0].split("":"")[1];             final String visible = attribute[1].split("":"")[1];              if (Boolean.valueOf(visible)) {                 visibleColumns.add(identifier);             } else {                 invisibleColumns.add(identifier);             }         }          return new TableColumnVisibility(tableIdentifier, visibleColumns, invisibleColumns);     }
public CreateImageBuilderRequest withTags(java.util.Map<String, String> tags) {         setTags(tags);         return this;     }
public org.w3c.dom.Node readNode()         throws IOException     {         int tag = read();          switch (tag) {             case 'N':                 return null;              case 'S':             case 's':             case 'X':             case 'x':                 _isLastChunk = tag == 'S' || tag == 'X';                 _chunkLength = (read() << 8) + read();                  throw error(""Can't handle string in this context"");              default:                 throw expect(""string"", tag);         }     }
private void saveHistory(String folder) throws IOException {    String name = msa.getStructureIdentifier(0).getIdentifier();   FileWriter writer = new FileWriter(folder + name     + ""-symm_opt.csv"");   writer.append(""Step,Time,RepeatLength,RMSD,TMscore,MCscore\n"");    for (int i = 0; i < lengthHistory.size(); i++) {    writer.append(i * saveStep + "","");    writer.append(timeHistory.get(i) + "","");    writer.append(lengthHistory.get(i) + "","");    writer.append(rmsdHistory.get(i) + "","");    writer.append(tmScoreHistory.get(i) + "","");    writer.append(mcScoreHistory.get(i) + ""\n"");   }    writer.flush();   writer.close();  }
private ST genAlternativeTypes(ElementDefinition ed, String id, String shortId) {      ST shex_alt = tmplt(ALTERNATIVE_SHAPES_TEMPLATE);      List<String> altEntries = new ArrayList<String>();          for(ElementDefinition.TypeRefComponent typ : ed.getType())  {        altEntries.add(genAltEntry(id, typ));      }      shex_alt.add(""altEntries"", StringUtils.join(altEntries, "" OR\n    ""));      return shex_alt;    }
public String getViewId(FacesContext context, String fromAction, String outcome)     {         return this.getNavigationCase(context, fromAction, outcome).getToViewId(context);     }
@SuppressWarnings(""unchecked"")   public Class<? extends TypedConfig<?>> getConcreteClass(AtomixRegistry registry, String typeName) {     ConfiguredType type = registry.getType(typeClass, typeName);     if (type == null) {       return null;     }     return (Class<? extends TypedConfig<?>>) type.newConfig().getClass();   }
public EntityNameAvailabilityCheckOutputInner checkNameAvailability(String locationName, CheckNameAvailabilityInput parameters) {         return checkNameAvailabilityWithServiceResponseAsync(locationName, parameters).toBlocking().single().body();     }
public void parse(InputSource is, DefaultHandler handler) throws IOException, SAXException{         setDefaultHandler(handler);         parse(is);     }
@ObjectiveCName(""sendPhotoWithPeer:withName:withW:withH:withThumb:withDescriptor:"")     public void sendPhoto(@NotNull Peer peer, @NotNull String fileName,                           int w, int h, @Nullable FastThumb fastThumb,                           @NotNull String descriptor) {         modules.getMessagesModule().sendPhoto(peer, fileName, w, h, fastThumb, descriptor);     }
public static Point2D_F64 center( Quadrilateral_F64 quad , Point2D_F64 center ) {   if( center == null )    center = new Point2D_F64();    center.x = quad.a.x + quad.b.x + quad.c.x + quad.d.x;   center.y = quad.a.y + quad.b.y + quad.c.y + quad.d.y;    center.x /= 4.0;   center.y /= 4.0;    return center;  }
@Nonnull   @Nonempty   @OverrideOnDemand   protected String getLogMessage (@Nullable final Throwable t)   {     if (t == null)       return ""An error occurred"";     return ""An exception was thrown"";   }
public final hqlParser.groupByClause_return groupByClause() throws RecognitionException {   hqlParser.groupByClause_return retval = new hqlParser.groupByClause_return();   retval.start = input.LT(1);    CommonTree root_0 = null;    Token GROUP121=null;   Token string_literal122=null;   Token COMMA124=null;   ParserRuleReturnScope expression123 =null;   ParserRuleReturnScope expression125 =null;    CommonTree GROUP121_tree=null;   CommonTree string_literal122_tree=null;   CommonTree COMMA124_tree=null;    try {    // hql.g:331:2: ( GROUP ^ 'by' ! expression ( COMMA ! expression )* )    // hql.g:331:4: GROUP ^ 'by' ! expression ( COMMA ! expression )*    {    root_0 = (CommonTree)adaptor.nil();      GROUP121=(Token)match(input,GROUP,FOLLOW_GROUP_in_groupByClause1573);    GROUP121_tree = (CommonTree)adaptor.create(GROUP121);    root_0 = (CommonTree)adaptor.becomeRoot(GROUP121_tree, root_0);     string_literal122=(Token)match(input,LITERAL_by,FOLLOW_LITERAL_by_in_groupByClause1579);    pushFollow(FOLLOW_expression_in_groupByClause1582);    expression123=expression();    state._fsp--;     adaptor.addChild(root_0, expression123.getTree());     // hql.g:332:20: ( COMMA ! expression )*    loop39:    while (true) {     int alt39=2;     int LA39_0 = input.LA(1);     if ( (LA39_0==COMMA) ) {      alt39=1;     }      switch (alt39) {     case 1 :      // hql.g:332:22: COMMA ! expression      {      COMMA124=(Token)match(input,COMMA,FOLLOW_COMMA_in_groupByClause1586);      pushFollow(FOLLOW_expression_in_groupByClause1589);      expression125=expression();      state._fsp--;       adaptor.addChild(root_0, expression125.getTree());       }      break;      default :      break loop39;     }    }     }     retval.stop = input.LT(-1);     retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);    adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);    }   catch (RecognitionException re) {    reportError(re);    recover(input,re);    retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);   }   finally {    // do for sure before leaving   }   return retval;  }
public static Object mult(Object left, Object right) {         return InfixOpNode.mult(left, right, null);     }
public void connectionFailed (String ident, boolean readOnly, Connection conn,                                   SQLException error)     {         try {             conn.close();         } catch (Exception e) {             log.warning(""Failure closing failed connection"",                         ""ident"", ident, ""ro"", readOnly, ""conn"", conn, e);         }     }
@Override   public void consumeLine(final String line) {    sb.append(line).append(LINE_SEPARATOR);      String logMessage = logMessagePrefix != null ? logMessagePrefix + line : line;    if (error) {     logger.error(logMessage);    } else {     logger.info(logMessage);    }   }
private boolean newPluginImage(String name, String pluginId,       String filename) {      boolean success = true;     ImageDescriptor id =         AbstractUIPlugin.imageDescriptorFromPlugin(pluginId, filename);      if (id == null) {       id = ImageDescriptor.getMissingImageDescriptor();       // id = getSharedByName(ISharedImages.IMG_OBJS_ERROR_TSK);       success = false;     }      descMap.put(name, id);     imageMap.put(name, id.createImage(true));      return success;   }
public void objectAvailable (ConfigObject object)     {         // keep this for later         _object = object;          // create our field editors         try {             Field[] fields = object.getClass().getFields();             for (Field field : fields) {                 // if the field is anything but a plain old public field,                 // we don't want to edit it                 if (field.getModifiers() == Modifier.PUBLIC) {                     add(_object.getEditor(_ctx, field));                 }             }          } catch (SecurityException se) {             log.warning(""Unable to introspect DObject!? "" + se);         }          SwingUtil.refresh(this);     }
public void setCurrentShardLevelMetrics(java.util.Collection<String> currentShardLevelMetrics) {         if (currentShardLevelMetrics == null) {             this.currentShardLevelMetrics = null;             return;         }          this.currentShardLevelMetrics = new com.amazonaws.internal.SdkInternalList<String>(currentShardLevelMetrics);     }
private void loadDictionary(final InputStream dictInputStream)       throws IOException {     dictionary = new HashMap<String, String>();     final BufferedReader breader = new BufferedReader(         new InputStreamReader(dictInputStream, Charset.forName(""UTF-8"")));     String line;     while ((line = breader.readLine()) != null) {       final String[] lineArray = tabPattern.split(line);       if (lineArray.length == 4) {         final Matcher lineMatcher = linePattern             .matcher(lineArray[0].toLowerCase());         dictionary.put(lineMatcher.replaceAll("" ""), lineArray[2]);       } else {         System.err.println(""WARNING: line starting with "" + lineArray[0]             + "" is not well-formed; skipping!!"");       }     }   }
public static void checkForValidSubTupleIndices(          int parentSize, int fromIndex, int toIndex)      {          if (fromIndex < 0)          {              throw new IllegalArgumentException(                  ""Start index is negative: ""+fromIndex);          }          if (toIndex > parentSize)          {              throw new IllegalArgumentException(                  ""End index is ""+toIndex+"", parent size is ""+parentSize);          }          if (fromIndex > toIndex)          {              throw new IllegalArgumentException(                  ""Start index is ""+fromIndex+"", end index is ""+toIndex);          }      }
public DialogActivity getNewDialog(Address from, Address to)    throws SipException {   checkState();   if (from == null) {    throw new IllegalArgumentException(""From address cant be null"");   }   if (to == null) {    throw new IllegalArgumentException(""To address cant be null"");   }   return _getNewDialog(from, gov.nist.javax.sip.Utils.getInstance()     .generateTag(), to, null);  }
public OcrResult recognizePrintedText(boolean detectOrientation, String url, RecognizePrintedTextOptionalParameter recognizePrintedTextOptionalParameter) {         return recognizePrintedTextWithServiceResponseAsync(detectOrientation, url, recognizePrintedTextOptionalParameter).toBlocking().single().body();     }
public JFeatureExtractor<T> extract(List<T> input) {     return new JFeatureExtractor<>(JavaOps.extract(self, input));   }
private List setPropertyInFolder(         String resourceRootPath,         String propertyDefinition,         String newValue,         boolean recursive) throws CmsException, CmsVfsException {          CmsObject cms = getCms();          // collect the resources to look up         List resources = new ArrayList();         if (recursive) {             resources = cms.readResources(resourceRootPath, CmsResourceFilter.IGNORE_EXPIRATION);         } else {             resources.add(resourceRootPath);         }          List changedResources = new ArrayList(resources.size());         CmsProperty newProperty = new CmsProperty(propertyDefinition, null, null);         // create permission set and filter to check each resource         for (int i = 0; i < resources.size(); i++) {             // loop through found resources and check property values             CmsResource res = (CmsResource)resources.get(i);             CmsProperty property = cms.readPropertyObject(res, propertyDefinition, false);             if (property.isNullProperty()) {                 // change structure value                 newProperty.setStructureValue(newValue);                 newProperty.setName(propertyDefinition);                 cms.writePropertyObject(cms.getRequestContext().removeSiteRoot(res.getRootPath()), newProperty);                 changedResources.add(res);             } else {                 // nop             }         }         return changedResources;     }
public void rollback() throws GeomajasException {   try {    setConfigLocations(previousConfigLocations);    refresh();   } catch (Exception e) {    throw new GeomajasException(e, ExceptionCode.REFRESH_CONFIGURATION_FAILED);   }  }
protected void report(LocatedException error, VDMToken[] after,    VDMToken[] upto)  {   VDMError vdmerror = new VDMError(error);   errors.add(vdmerror);    if (errors.size() >= MAX - 1)   {    errors.add(new VDMError(9, ""Too many syntax errors"", error.location));    throw new InternalException(9, ""Too many syntax errors"");   }    // Either leave one token beyond something in the after list, or   // at something in the next upto list.    List<VDMToken> afterList = Arrays.asList(after);   List<VDMToken> uptoList = Arrays.asList(upto);    try   {    VDMToken tok = lastToken().type;     while (!uptoList.contains(tok) && tok != VDMToken.EOF)    {     if (afterList.contains(tok))     {      nextToken();      break;     }      tok = nextToken().type;    }   } catch (LexException le)   {    errors.add(new VDMError(le));   }  }
public String getProviderURL() {          if (providerURL == null) {             providerURL = getProviderURLPattern().replace(""#host#"", getHost())                     .replace(""#port#"", Integer.toString(getPort()));         }         return providerURL;     }
public static void main(String[] args) {     org.apache.commons.cli.Options cliOptions = createCliOptions();     try {       CommandLine cli = parseCli(args, cliOptions);       Options options = loadOptions(cli);       validate(options);       ConstraintParser parser = new ConstraintParser(options);       try {         output(parser, options.getOutputFile());       } catch (IOException e) {         throw new RuntimeException(e);       }     } catch (IncompleteCliException e) {       // If the command line is not complete just print usage and help       printErrorWithUsageAndHelp(cliOptions);     }   }
public Observable<ServiceResponse<List<ApplicationInsightsComponentAnalyticsItemInner>>> listWithServiceResponseAsync(String resourceGroupName, String resourceName, ItemScopePath scopePath, ItemScope scope, ItemTypeParameter type, Boolean includeContent) {         if (this.client.subscriptionId() == null) {             throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");         }         if (resourceGroupName == null) {             throw new IllegalArgumentException(""Parameter resourceGroupName is required and cannot be null."");         }         if (resourceName == null) {             throw new IllegalArgumentException(""Parameter resourceName is required and cannot be null."");         }         if (scopePath == null) {             throw new IllegalArgumentException(""Parameter scopePath is required and cannot be null."");         }         if (this.client.apiVersion() == null) {             throw new IllegalArgumentException(""Parameter this.client.apiVersion() is required and cannot be null."");         }         return service.list(this.client.subscriptionId(), resourceGroupName, resourceName, scopePath, this.client.apiVersion(), scope, type, includeContent, this.client.acceptLanguage(), this.client.userAgent())             .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ApplicationInsightsComponentAnalyticsItemInner>>>>() {                 @Override                 public Observable<ServiceResponse<List<ApplicationInsightsComponentAnalyticsItemInner>>> call(Response<ResponseBody> response) {                     try {                         ServiceResponse<List<ApplicationInsightsComponentAnalyticsItemInner>> clientResponse = listDelegate(response);                         return Observable.just(clientResponse);                     } catch (Throwable t) {                         return Observable.error(t);                     }                 }             });     }
public static base_response update(nitro_service client, autoscaleprofile resource) throws Exception {   autoscaleprofile updateresource = new autoscaleprofile();   updateresource.name = resource.name;   updateresource.url = resource.url;   updateresource.apikey = resource.apikey;   updateresource.sharedsecret = resource.sharedsecret;   return updateresource.update_resource(client);  }
public static NoAvailablePortException newNoAvailablePortException(Throwable cause, String message, Object... args) {     return new NoAvailablePortException(format(message, args), cause);   }
public byte []data()   {     ByteArrayOutputStream bos = new ByteArrayOutputStream();          try {       toData(bos);     } catch (IOException e) {       throw new RuntimeException(e);     }          return bos.toByteArray();   }
public void setBS(java.util.Collection<java.nio.ByteBuffer> bS) {         if (bS == null) {             this.bS = null;             return;         }          this.bS = new java.util.ArrayList<java.nio.ByteBuffer>(bS);     }
protected boolean checkUnderflow(final int slot) {   if (childs[slot] == NULL_ID) {    return false;   }   if (slot == 0) {    return checkUnderflowWithRight(slot); // use nodeParent right sibling   } else {    if (getSlotLeft(slot) == slot) {     return checkUnderflowWithRight(slot); // use nodeParent right sibling    } else {     return checkUnderflowWithLeft(slot);  // use nodeParent left sibling    }   }  }
@Override  public CommercePriceListUserSegmentEntryRel getCommercePriceListUserSegmentEntryRelByUuidAndGroupId(   String uuid, long groupId) throws PortalException {   return commercePriceListUserSegmentEntryRelPersistence.findByUUID_G(uuid,    groupId);  }
public DrawerBuilder withActivity(@NonNull Activity activity) {         this.mRootView = (ViewGroup) activity.findViewById(android.R.id.content);         this.mActivity = activity;         this.mLayoutManager = new LinearLayoutManager(mActivity);         return this;     }
@SuppressWarnings(""unchecked"")     @Override     public void updated(String pid, Dictionary properties) throws ConfigurationException {         if (FrameworkState.isStopping() || bContext == null) {             return;         }          if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) {             Tr.entry(tc, ""updated"", properties);         }          SSLChannelOptions options = null;         SSLChannelOptions old = sslOptions.get(pid);          if (old == null) {             options = new SSLChannelOptions();             old = sslOptions.putIfAbsent(pid, options);         }          if (old != null) {             options = old;         }          options.updateConfguration(properties, defaultId);         options.updateRegistration(bContext, sslConfigs);          if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) {             Tr.exit(tc, ""updated"", properties);         }     }
public void markTask(StatusTrail st, boolean success) {                 st.setStatus(success ? JobStatus.done : JobStatus.not_done);         st.setAttemptsDone(st.getAttemptsDone() + 1);         st.setGivenUp(st.getAttemptsDone() >= getMaxTaskAttempts() ? 1 : 0);         updateStatusTrail(st);     }
@Override   public EClass getIfcMappedItem() {    if (ifcMappedItemEClass == null) {     ifcMappedItemEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI).getEClassifiers()       .get(355);    }    return ifcMappedItemEClass;   }
@SuppressWarnings(""unchecked"")   @Override   public EList<IfcRelSequence> getIsPredecessorTo() {    return (EList<IfcRelSequence>) eGet(Ifc4Package.Literals.IFC_PROCESS__IS_PREDECESSOR_TO, true);   }
public double getCountBetweenValues(final double lowValue, final double highValue)             throws ArrayIndexOutOfBoundsException {         return integerValuesHistogram.getCountBetweenValues(                 (long)(lowValue * doubleToIntegerValueConversionRatio),                 (long)(highValue * doubleToIntegerValueConversionRatio)         );     }
private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {         in.defaultReadObject();         this.runtimeMetaData = new HashMap<String, Object>();     }
public void addSample( double[] sampleData ) {         if( A.getNumCols() != sampleData.length )             throw new IllegalArgumentException(""Unexpected sample size"");         if( sampleIndex >= A.getNumRows() )             throw new IllegalArgumentException(""Too many samples"");          for( int i = 0; i < sampleData.length; i++ ) {             A.set(sampleIndex,i,sampleData[i]);         }         sampleIndex++;     }
@Override     public void setBitmapShaderShift(Point origin) {         Shader shader = this.paint.getShader();         if (shader != null) {             int relativeDx = ((int) -origin.x) % this.shaderWidth;             int relativeDy = ((int) -origin.y) % this.shaderHeight;              Matrix localMatrix = new Matrix();             localMatrix.setTranslate(relativeDx, relativeDy);             shader.setLocalMatrix(localMatrix);         }     }
public ServiceFuture<List<AnalysisDefinitionInner>> listSiteAnalysesAsync(final String resourceGroupName, final String siteName, final String diagnosticCategory, final ListOperationCallback<AnalysisDefinitionInner> serviceCallback) {         return AzureServiceFuture.fromPageResponse(             listSiteAnalysesSinglePageAsync(resourceGroupName, siteName, diagnosticCategory),             new Func1<String, Observable<ServiceResponse<Page<AnalysisDefinitionInner>>>>() {                 @Override                 public Observable<ServiceResponse<Page<AnalysisDefinitionInner>>> call(String nextPageLink) {                     return listSiteAnalysesNextSinglePageAsync(nextPageLink);                 }             },             serviceCallback);     }
public java.util.List<RebootRequest> getRebootWorkspaceRequests() {         if (rebootWorkspaceRequests == null) {             rebootWorkspaceRequests = new com.amazonaws.internal.SdkInternalList<RebootRequest>();         }         return rebootWorkspaceRequests;     }
public MetricRegistration collectResourceMetrics(final Resource resource,                                               ImmutableManagementResourceRegistration managementResourceRegistration,                                               Function<PathAddress, PathAddress> resourceAddressResolver) {         MetricRegistration registration = new MetricRegistration();         collectResourceMetrics0(resource, managementResourceRegistration, EMPTY_ADDRESS, resourceAddressResolver, registration);         return registration;     }
public static Message.Builder addDefaultInstanceToRepeatedField(final int repeatedFieldNumber, final Message.Builder builder) throws CouldNotPerformException {         return addDefaultInstanceToRepeatedField(builder.getDescriptorForType().findFieldByNumber(repeatedFieldNumber), builder);     }
public void syncRecords(Record recAlt, Record recMain)     {         boolean bFieldsInSync = true;         // Copy the language-specific fields         m_buffer = new VectorBuffer(null);         for (int iIndex = 0; iIndex < recMain.getFieldCount(); iIndex++)         {             BaseField fieldAlt = recAlt.getField(iIndex);             BaseField fieldMain = null;             if (bFieldsInSync)                 fieldMain = recMain.getField(iIndex);             if ((fieldMain == null) || (!fieldMain.getFieldName().equals(fieldAlt.getFieldName())))             {                 fieldMain = recMain.getField(fieldAlt.getFieldName());                 bFieldsInSync = false;             }             if (fieldMain != null) if (fieldAlt != null)                 if (this.isLanguageOverride(fieldMain))             { // Move this field, but don't call doRecordChange (READ_MOVE)                 m_buffer.addNextField(fieldMain);   // Save these to restore later                 if (!fieldAlt.isNull())   // Don't move a null                 {                     fieldMain.moveFieldToThis((BaseField)fieldAlt, DBConstants.DISPLAY, DBConstants.READ_MOVE);                     fieldMain.setModified(false);                 }             }         }     }
private void loadYAMLResource(final File file) {    BufferedReader reader = null;   try {    reader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));     String line = null;    while ((line = reader.readLine()) != null) {      // 1. check for comments     String[] comments = line.split(""#"", 2);     String conf = comments[0];      // 2. get key and value     if (conf.length() > 0) {      String[] kv = conf.split("": "", 2);       // skip line with no valid key-value pair      if (kv.length == 1) {       LOG.warn(""Error while trying to split key and value in configuration file "" + file + "": "" + line);       continue;      }       String key = kv[0].trim();      String value = kv[1].trim();            // sanity check      if (key.length() == 0 || value.length() == 0) {       LOG.warn(""Error after splitting key and value in configuration file "" + file + "": "" + line);       continue;      }       LOG.debug(""Loading configuration property: "" + key + "", "" + value);       this.confData.put(key, value);     }    }   } catch (IOException e) {    e.printStackTrace();   } finally {    try {     reader.close();    } catch (IOException e) {     e.printStackTrace();    }   }  }
public static String decode(final String str) {         try {             return URLDecoder.decode(str, ""UTF-8"");         } catch (final Exception e) {             LOGGER.log(Level.WARN, ""Decodes str ["" + str + ""] failed"", e);              return str;         }     }
public final void addTemplateAlias(final String alias, final String templateName) {         Validate.notNull(alias, ""Alias cannot be null"");         Validate.notNull(templateName, ""Template name cannot be null"");         this.templateAliases.put(alias, templateName);     }
public void sendMessage(String text) throws NotConnectedException, InterruptedException {         Message message = createMessage();         message.setBody(text);         connection.sendStanza(message);     }
public void forceSet(byte[] newValue) throws Exception     {         try         {             client.setData().forPath(path, newValue);         }         catch ( KeeperException.NoNodeException dummy )         {             try             {                 client.create().creatingParentContainersIfNeeded().forPath(path, newValue);             }             catch ( KeeperException.NodeExistsException dummy2 )             {                 client.setData().forPath(path, newValue);             }         }     }
public void prepareDialogInstance() {         final LmlParser parser = interfaceService.getParser();         if (actionContainer != null) {             parser.getData().addActionContainer(getId(), actionContainer);         }         dialog = (Window) parser.createView(wrappedObject, Gdx.files.internal(dialogData.value())).first();         if (actionContainer != null) {             parser.getData().removeActionContainer(getId());         }     }
public static String getCanonicalSMILESForPolymer(PolymerNotation polymer) throws BuilderMoleculeException,     HELM2HandledException, CTKSmilesException, CTKException, NotationException, ChemistryException {    AbstractMolecule molecule = BuilderMolecule.buildMoleculefromSinglePolymer(polymer).getMolecule();    molecule = BuilderMolecule.mergeRgroups(molecule);      return Chemistry.getInstance().getManipulator().canonicalize(Chemistry.getInstance().getManipulator()      .convertMolecule(molecule, AbstractChemistryManipulator.StType.SMILES));   }
public static String getMainSidePropertyName(OgmCollectionPersister collectionPersister) {   if ( !collectionPersister.isInverse() ) {    return collectionPersister.getUnqualifiedRole();   }    Loadable mainSidePersister = (Loadable) collectionPersister.getElementPersister();    for ( int i = 0; i < mainSidePersister.getPropertyNames().length; i++ ) {    String candidateProperty = mainSidePersister.getPropertyNames()[i];    Type type = mainSidePersister.getPropertyType( candidateProperty );     // candidate is to-one association    if ( type.isEntityType() ) {     if ( Arrays.equals( collectionPersister.getKeyColumnNames(), mainSidePersister.getPropertyColumnNames( i ) ) ) {      return candidateProperty;     }    }    // candidate is to-many association    else if ( type.isCollectionType() ) {     OgmCollectionPersister mainSideCollectionPersister = getPersister( collectionPersister.getFactory(), (CollectionType) type );     if ( isCollectionMatching( mainSideCollectionPersister, collectionPersister ) ) {      return candidateProperty;     }    }   }    throw new HibernateException( ""Couldn't determine main side role for collection "" + collectionPersister.getRole() );  }
@Override  public final boolean put(String key, Bitmap value) {   if (key == null || value == null) {    throw new NullPointerException(""key == null || value == null"");   }    synchronized (this) {    size += sizeOf(key, value);    Bitmap previous = map.put(key, value);    if (previous != null) {     size -= sizeOf(key, previous);    }   }    trimToSize(maxSize);   return true;  }
public void onInitialDataDownloaded() {         Log.d(TAG, ""Initial Data Loaded"");         context().getContactsModule().startImport();         if (appStateVM.isBookImported()) {             onAppLoaded();         }     }
@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> filter(Predicate<? super T> predicate) {         ObjectHelper.requireNonNull(predicate, ""predicate is null"");         return RxJavaPlugins.onAssembly(new FlowableFilter<T>(this, predicate));     }
public static double hypergeometric(int k, int n, int Kp, int Np) {         if(k<0 || n<0 || Kp<0 || Np<0) {             throw new IllegalArgumentException(""All the parameters must be positive."");         }         Kp = Math.max(k, Kp);         Np = Math.max(n, Np);                  /*         //slow!         $probability=StatsUtilities::combination($Kp,$k)*StatsUtilities::combination($Np-$Kp,$n-$k)/StatsUtilities::combination($Np,$n);         */          //fast and can handle large numbers         //Cdf(k)-Cdf(k-1)         double probability = approxHypergeometricCdf(k,n,Kp,Np);         if(k>0) {             probability -= approxHypergeometricCdf(k-1,n,Kp,Np);         }                   return probability;     }
public static void main(String args[]) throws IOException {     String url = ""C:/data/metars/Surface_METAR_20060326_0000.nc"";      StationObsDataset ncd = (StationObsDataset) TypedDatasetFactory.open(FeatureType.STATION, url, null, new StringBuilder());     StationObsDatasetInfo info = new StationObsDatasetInfo(ncd, null);     FileOutputStream fos2 = new FileOutputStream(""C:/TEMP/stationCollection.xml"");     GZIPOutputStream zout =  new GZIPOutputStream( fos2);      info.writeStationObsDatasetXML(System.out);     info.writeStationCollectionXML(zout);      zout.close();     File f = new File(""C:/TEMP/stationCollection.xml"");     System.out.println("" size=""+f.length());   }
public StartInstancesResult withStartingInstances(InstanceStateChange... startingInstances) {         if (this.startingInstances == null) {             setStartingInstances(new com.amazonaws.internal.SdkInternalList<InstanceStateChange>(startingInstances.length));         }         for (InstanceStateChange ele : startingInstances) {             this.startingInstances.add(ele);         }         return this;     }
@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)     public static void setNavigationBarColor(Window window, int navigationBarColor) {         window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);         window.setNavigationBarColor(navigationBarColor);     }
public String getComponentId() {     if (Annotation_Type.featOkTst && ((Annotation_Type)jcasType).casFeat_componentId == null)       jcasType.jcas.throwFeatMissing(""componentId"", ""de.julielab.jules.types.Annotation"");     return jcasType.ll_cas.ll_getStringValue(addr, ((Annotation_Type)jcasType).casFeatCode_componentId);}
public static <T1, T2, T3> Tuple3<T1, T2, T3> tuple(T1 v1, T2 v2, T3 v3) {         return new Tuple3<>(v1, v2, v3);     }
public static int readUnsignedVarint(ByteBuffer buffer) throws IOException {     int val = 0;     int bits = 0;     while(true) {       final int data = buffer.get();       val |= (data & 0x7F) << bits;       if((data & 0x80) == 0) {         return val;       }       bits += 7;       if(bits > 35) {         throw new IOException(""Variable length quantity is too long for expected integer."");       }     }   }
@BetaApi   public final TargetTcpProxy getTargetTcpProxy(ProjectGlobalTargetTcpProxyName targetTcpProxy) {      GetTargetTcpProxyHttpRequest request =         GetTargetTcpProxyHttpRequest.newBuilder()             .setTargetTcpProxy(targetTcpProxy == null ? null : targetTcpProxy.toString())             .build();     return getTargetTcpProxy(request);   }
public static String identifier(SourceCode cfml, boolean throwError, boolean allowColon) throws TemplateException {  int start = cfml.getPos();   if (!cfml.isCurrentBetween('a', 'z') && !cfml.isCurrent('_')) {      if (throwError) throw new TemplateException(cfml, ""Invalid Identifier, the following character cannot be part of a identifier ["" + cfml.getCurrent() + ""]"");      return null;  }  do {      cfml.next();      if (!(cfml.isCurrentBetween('a', 'z') || cfml.isCurrentBetween('0', '9') || cfml.isCurrent('_') || (allowColon && cfml.isCurrent(':')) || cfml.isCurrent('-'))) {   break;      }  }  while (cfml.isValidIndex());  return cfml.substring(start, cfml.getPos() - start);     }
public void setAction(final Action action) {   MenuItemModel model = getOrCreateComponentModel();   model.action = action;   model.url = null;  }
@Override     protected Long logResponse(Response response) {         Long responseId = super.logResponse(response);         int code = response.getStatusCode() == null ? 0 : response.getStatusCode();         String message = response.getStatusMessage() == null ? StatusResponse.forCode(code).getStatus().getMessage() :                 response.getStatusMessage();         Status status = new Status(code, message);         try {             updateServiceSummary(status, responseId);         }         catch (ActivityException | SQLException ex) {             logexception(ex.getMessage(), ex);         }         return responseId;     }
public static String getDescription(String keyword, ApplicationContext context, Map<String, String> beanMap) {         KeywordInfo keywordInfo = getKeywordInfo(keyword, context, beanMap);          if(keywordInfo == null) {             return """";         }          String desc = keywordInfo.description();          if(desc.startsWith(""classpath:"")) {             try {                 ResourceEditor editor = new ResourceEditor();                 editor.setAsText(desc);                 Resource r = (Resource) editor.getValue();                  return IOUtils.toString(r.getInputStream());             } catch (Exception ignored) {             }         }          return desc;     }
private void loadBinlogChecksum() {         ResultSetPacket rs = null;         try {             rs = query(""select @@global.binlog_checksum"");             List<String> columnValues = rs.getFieldValues();             if (columnValues != null && columnValues.size() >= 1 && columnValues.get(0).toUpperCase().equals(""CRC32"")) {                 binlogChecksum = LogEvent.BINLOG_CHECKSUM_ALG_CRC32;             } else {                 binlogChecksum = LogEvent.BINLOG_CHECKSUM_ALG_OFF;             }         } catch (Throwable e) {             logger.error("""", e);             binlogChecksum = LogEvent.BINLOG_CHECKSUM_ALG_OFF;         }     }
public void setTextSize(byte field, float size, SizeUnit unit) {    FieldInfos fi = getFieldInfos(field);    fi.m_fontSize = size;    fi.m_fontSizeUnit = unit;    notifyListeners();   }
private final Result tryLockForUpgrade_(L locker, long timeout, TimeUnit unit)          throws InterruptedException      {          if (Thread.interrupted()) {              throw new InterruptedException();          }          Result result;          if ((result = tryLockForUpgrade_(locker)) == Result.FAILED) {              result = lockForUpgradeQueuedInterruptibly(locker, addUpgradeWaiter(),                                                         unit.toNanos(timeout));          }          return result;      }
protected void doStart() throws Exception     {         if (isStarted())             return;          // save context classloader         Thread thread= Thread.currentThread();         ClassLoader lastContextLoader= thread.getContextClassLoader();          MultiException mex= null;         try         {             // Find the webapp             resolveWebApp();              // Get the handler             getServletHandler();                        _configurations=loadConfigurations();                          // initialize the classloader                         configureClassPath();             initClassLoader(true);             thread.setContextClassLoader(getClassLoader());             initialize();                          // Do the default configuration             configureDefaults();              // Set classpath for Jasper.             Map.Entry entry= _webAppHandler.getHolderEntry(""test.jsp"");             if (entry != null)             {                 ServletHolder jspHolder= (ServletHolder)entry.getValue();                 if (jspHolder != null && jspHolder.getInitParameter(""classpath"") == null)                 {                     String fileClassPath= getFileClassPath();                     jspHolder.setInitParameter(""classpath"", fileClassPath);                     if (log.isDebugEnabled())                         log.debug(""Set classpath="" + fileClassPath + "" for "" + jspHolder);                 }             }                          // configure webapp             configureWebApp();              // If we have servlets, don't init them yet             _webAppHandler.setAutoInitializeServlets(false);              // Start handlers             super.doStart();              mex= new MultiException();             // Context listeners             if (_contextListeners != null && _webAppHandler != null)             {                 ServletContextEvent event= new ServletContextEvent(getServletContext());                 for (int i= 0; i < LazyList.size(_contextListeners); i++)                 {                     try                     {                         ((ServletContextListener)LazyList.get(_contextListeners, i)).contextInitialized(event);                     }                     catch (Exception ex)                     {                         mex.add(ex);                     }                 }             }              // OK to Initialize servlets now             if (_webAppHandler != null && _webAppHandler.isStarted())             {                 try                 {                     _webAppHandler.initializeServlets();                 }                 catch (Exception ex)                 {                     mex.add(ex);                 }             }         }         catch (Exception e)         {             log.warn(""Configuration error on "" + _war, e);             throw e;         }         finally         {             thread.setContextClassLoader(lastContextLoader);         }          if (mex != null)             mex.ifExceptionThrow();     }
public List<LifecycleCallbackType<SessionBeanType<T>>> getAllPostConstruct()    {       List<LifecycleCallbackType<SessionBeanType<T>>> list = new ArrayList<LifecycleCallbackType<SessionBeanType<T>>>();       List<Node> nodeList = childNode.get(""post-construct"");       for(Node node: nodeList)       {          LifecycleCallbackType<SessionBeanType<T>>  type = new LifecycleCallbackTypeImpl<SessionBeanType<T>>(this, ""post-construct"", childNode, node);          list.add(type);       }       return list;    }
public static int cuMemsetD16Async(CUdeviceptr dstDevice, short us, long N, CUstream hStream)      {          return checkResult(cuMemsetD16AsyncNative(dstDevice, us, N, hStream));      }
public void setIdentityAttributeValues(java.util.Collection<AttributeNameAndValue> identityAttributeValues) {         if (identityAttributeValues == null) {             this.identityAttributeValues = null;             return;         }          this.identityAttributeValues = new java.util.ArrayList<AttributeNameAndValue>(identityAttributeValues);     }
public GVRAnimator animate(int animIndex, float timeInSec)     {         if ((animIndex < 0) || (animIndex >= mAnimations.size()))         {             throw new IndexOutOfBoundsException(""Animation index out of bounds"");         }         GVRAnimator anim = mAnimations.get(animIndex);         anim.animate(timeInSec);         return anim;     }
@XmlElementDecl(namespace = ""http://www.w3.org/2005/Atom"", name = ""updated"", scope = EntryType.class)     public JAXBElement<DateTimeType> createEntryTypeUpdated(DateTimeType value) {         return new JAXBElement<DateTimeType>(ENTRY_TYPE_UPDATED_QNAME,                 DateTimeType.class, EntryType.class, value);     }
public File write(File destination) throws IOException {    assertValid();        if (destination.isDirectory() == true) {     destination = new File(destination, this.header.getFileName());    }    if (data != null) {     FileUtil.writeBytes(data, destination);     data = null;    } else {     if (tempFile != null) {      FileUtil.move(tempFile, destination, true);     }    }    return destination;   }
public static Map<String, ImageArchiveManifestEntry> mapEntriesById(Iterable<ImageArchiveManifestEntry> entries) {         Map<String, ImageArchiveManifestEntry> mapped = new LinkedHashMap<>();          for(ImageArchiveManifestEntry entry : entries) {             mapped.put(entry.getId(), entry);         }          return mapped;     }
public void setTitle(final String TITLE) {         if (null == title) {             _title = null == TITLE ? """" : TITLE;             fireTileEvent(VISIBILITY_EVENT);             fireTileEvent(REDRAW_EVENT);         } else {             title.set(TITLE);         }     }
public static boolean apply(@NonNull ViewPosition pos, @NonNull View view) {         return pos.init(view);     }
@Override     public ListNamedQueriesResult listNamedQueries(ListNamedQueriesRequest request) {         request = beforeClientExecution(request);         return executeListNamedQueries(request);     }
@Override     public Authentication authenticate(Authentication authentication) throws AuthenticationException {         if (authentication == null) {             return authentication;         }         UsernamePasswordAuthenticationToken output = null;         if (authentication instanceof UsernamePasswordAuthenticationToken) {             output = (UsernamePasswordAuthenticationToken) authentication;         } else {             output = new UsernamePasswordAuthenticationToken(authentication, authentication.getCredentials(),                             authentication.getAuthorities());             output.setAuthenticated(authentication.isAuthenticated());             output.setDetails(authentication.getDetails());         }         return delegate.authenticate(output);     }
private static void request(final Request request) {         if (null == request) {             WonderPush.logError(""Request with null request."");             return;         }          WonderPush.safeDefer(new Runnable() {             @Override             public void run() {                 // Decorate parameters                 WonderPushRequestParamsDecorator.decorate(request.getResource(), request.getParams());                  // Generate signature                 BasicHeader authorizationHeader = request.getAuthorizationHeader();                  // Headers                 BasicHeader[] headers = null;                 if (null != authorizationHeader) {                     headers = new BasicHeader[1];                     headers[0] = authorizationHeader;                 }                  String url = WonderPushUriHelper.getAbsoluteUrl(request.getResource());                 WonderPush.logDebug(""requesting url: "" + request.getMethod() + "" "" + url + ""?"" + request.getParams().getURLEncodedString());                 // TODO: support other contentTypes such as ""application/json""                 String contentType = ""application/x-www-form-urlencoded"";                  // Handler                 final ResponseHandler handler = request.getHandler();                 HttpEntity entity = null;                 if (request.getParams() != null) {                     try {                         entity = request.getParams() != null ? request.getParams().getEntity(null) : null;                     } catch (IOException ex) {                         WonderPush.logError(""Failed to create HttpEntity from params "" + request.getParams(), ex);                         if (handler != null) {                             handler.onFailure(ex, new Response(""""));                         }                         return;                     }                 }                 final long sendDate = SystemClock.elapsedRealtime();                 JsonHttpResponseHandler jsonHandler = new JsonHttpResponseHandler() {                     @Override                     public void onProgress(long bytesWritten, long totalSize) {                         // mute this                     }                      @Override                     public void onSuccess(int statusCode, Header[] headers, JSONObject response) {                         syncTime(response);                         WonderPush.setNetworkAvailable(true);                         if (handler != null) {                             handler.onSuccess(statusCode, new Response(response));                         }                     }                      @Override                     public void onSuccess(int statusCode, Header[] headers, JSONArray response) {                         WonderPush.logError(""Unexpected JSONArray answer: "" + statusCode + "" headers: "" + Arrays.toString(headers) + "" response: ("" + response.length() + "") "" + response.toString());                     }                      @Override                     public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONObject errorResponse) {                         WonderPush.logError(""Error answer: "" + statusCode + "" headers: "" + Arrays.toString(headers) + "" response: "" + errorResponse);                         syncTime(errorResponse);                         WonderPush.logDebug(""Request Error: "" + errorResponse);                         WonderPush.setNetworkAvailable(errorResponse != null);                         if (handler != null) {                             handler.onFailure(throwable, new Response(errorResponse));                         }                     }                      @Override                     public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONArray errorResponse) {                         WonderPush.logError(""Unexpected JSONArray error answer: "" + statusCode + "" headers: "" + Arrays.toString(headers) + "" response: ("" + errorResponse.length() + "") "" + errorResponse.toString());                         this.onFailure(statusCode, headers, errorResponse.toString(), throwable);                     }                      @Override                     public void onFailure(int statusCode, Header[] headers, String responseString, Throwable throwable) {                         WonderPush.logError(""Unexpected string error answer: "" + statusCode + "" headers: "" + Arrays.toString(headers) + "" response: ("" + responseString.length() + "") \"""" + responseString + ""\"""");                         WonderPush.setNetworkAvailable(false);                         if (handler != null) {                             handler.onFailure(throwable, new Response(responseString));                         }                     }                      @Override                     public void onSuccess(int statusCode, Header[] headers, String responseString) {                         WonderPush.logError(""Unexpected string answer: "" + statusCode + "" headers: "" + Arrays.toString(headers) + "" response: ("" + responseString.length() + "") \"""" + responseString + ""\"""");                     }                      private void syncTime(JSONObject data) {                         long recvDate = SystemClock.elapsedRealtime();                         if (data == null || !data.has(""_serverTime"")) {                             return;                         }                         TimeSync.syncTimeWithServer(sendDate, recvDate, data.optLong(""_serverTime""), data.optLong(""_serverTook""));                     }                 };                 // NO UNNECESSARY WORK HERE, because of timed request                 switch (request.getMethod()) {                     case GET:                         sClient.get(null, url, headers, request.getParams(), jsonHandler);                         break;                     case PUT:                         sClient.put(null, url, headers, entity, contentType, jsonHandler);                         break;                     case POST:                         sClient.post(null, url, headers, entity, contentType, jsonHandler);                         break;                     case PATCH:                         sClient.patch(null, url, headers, entity, contentType, jsonHandler);                         break;                     case DELETE:                         sClient.delete(null, url, headers, request.getParams(), jsonHandler);                         break;                     default:                         jsonHandler.sendFailureMessage(0, null, null, new UnsupportedOperationException(""Unhandled method "" + request.getMethod()));                 }             }         }, 0);     }
@Override   public void initUpstream()   {    NucleicAcid nuc = tempReac.getTemplate();    if (nuc != null)    addToUpstream(nuc, getGraph());      for (Control cont : tempReac.getControlledOf())    {     addToUpstream(cont, graph);    }   }
protected static String jacksonObjectToString(Object object) {   try {    return mapper.writeValueAsString(object);   } catch (JsonProcessingException e) {    logger.error(""Failed to serialize JSON data: "" + e.toString());    return null;   }  }
public MonetaryFormat prefixCode() {         if (codePrefixed)             return this;         else             return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups,                     shift, roundingMode, codes, codeSeparator, true);     }
@Deprecated   public static <RequestT, ResponseT> MethodDescriptor<RequestT, ResponseT> create(       MethodType type, String fullMethodName,       Marshaller<RequestT> requestMarshaller,       Marshaller<ResponseT> responseMarshaller) {     return new MethodDescriptor<>(         type, fullMethodName, requestMarshaller, responseMarshaller, null, false, false, false);   }
private int getIndicatorStartPos() {         switch (getPosition()) {             case TOP:                 return mIndicatorClipRect.left;             case RIGHT:                 return mIndicatorClipRect.top;             case BOTTOM:                 return mIndicatorClipRect.left;             default:                 return mIndicatorClipRect.top;         }     }
@Override     public void execute() throws MojoExecutionException, MojoFailureException {         javaSourceDir = WatcherUtils.getJavaSource(basedir);          try {             for (File file : FileUtils.listFiles(javaSourceDir, new String[]{""java""}, true)) {                 if (accept(file)) {                     parseController(file);                 }             }         }catch (Exception we){             throw new MojoExecutionException(""An exception occurred while created raml file"",we);         }     }
@Override   public final String printNtz(final String pNumber, final String pDigSep,     final String pDigGrSep, final Integer pDigitsInGroup) {     if (pNumber == null || """".equals(pNumber)) {       return """";     }     int dotIdx = pNumber.indexOf(""."");     String leftWing;     String rightWing;     if (dotIdx == -1) {       leftWing = pNumber;       rightWing = null;     } else {       leftWing = pNumber.substring(0, dotIdx);       rightWing = pNumber.substring(dotIdx + 1);     }     StringBuffer sb = new StringBuffer();     if (leftWing.startsWith(""-"")) {       leftWing = leftWing.substring(1);       sb.append(""-"");     }     addLeftWing(leftWing, sb, pDigGrSep, pDigitsInGroup);     if (rightWing != null && rightWing.length() > 0 && !""0"".equals(rightWing)) {       sb.append(pDigSep);       int lastIdxZero = rightWing.lastIndexOf(""0"");       for (int i = 0; i < lastIdxZero; i++) {         char ch = rightWing.charAt(i);         sb.append(ch);       }     }     return sb.toString();   }
public Collection<Epic> epics(EpicFilter filter) {         return get(Epic.class, (filter != null) ? filter : new EpicFilter());     }
public static <O> O deserialise(HttpServletRequest request,                                     Class<O> requestMessageType) throws IOException {          return deserialise(request.getInputStream(), requestMessageType);     }
public String getArguments() {         return Optional.ofNullable(getHeader(FtpMessageHeaders.FTP_ARGS)).map(Object::toString).orElse(null);     }
public void loadBeans(Resource[] resources) throws IOException {   Closure beans = new Closure(this){    @Override    public Object call(Object... args) {     return beans((Closure)args[0]);    }   };   Binding b = new Binding();   b.setVariable(""beans"", beans);    GroovyShell shell = classLoader != null ? new GroovyShell(classLoader,b) : new GroovyShell(b);         for (Resource resource : resources) {             shell.evaluate(new InputStreamReader(resource.getInputStream()));         }  }
@Beta   @SuppressWarnings(""unchecked"")   // safe by specification of SortedSetMultimap.asMap()   public static <K, V> Map<K, SortedSet<V>> asMap(SortedSetMultimap<K, V> multimap) {     return (Map<K, SortedSet<V>>) (Map<K, ?>) multimap.asMap();   }
public static RunSet readRunSet(final File file) throws IOException {         checkNotNull(file);         try (BufferedReader reader = new BufferedReader(new FileReader(file))) {             return readRunSet(reader);         }     }
public static void forEachTrimmedToken(String string, String separator, Procedure<String> procedure)     {         for (StringTokenizer stringTokenizer = new StringTokenizer(string, separator); stringTokenizer.hasMoreTokens(); )         {             String token = stringTokenizer.nextToken().trim();             procedure.value(token);         }     }
@Override     public Object createResource(ResourceInfo refInfo) throws Exception {         final boolean trace = TraceComponent.isAnyTracingEnabled();         if (trace && tc.isEntryEnabled())             Tr.entry(this, tc, ""createResource"", refInfo);         try {             BootstrapContextImpl bootstrapContext = bootstrapContextRef.getServiceWithException();              if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())                 Tr.debug(this, tc, ""loading"", adminObjectImplClassName);             Class<?> adminObjectClass = bootstrapContext.loadClass(adminObjectImplClassName);             ComponentMetaData cData = ComponentMetaDataAccessorImpl.getComponentMetaDataAccessor().getComponentMetaData();             String currentApp = null;             ResourceAdapterMetaData metadata = bootstrapContext.getResourceAdapterMetaData();             // cData is null when its not in an application thread             if (cData != null && cData != metadata) {                 currentApp = cData.getJ2EEName().getApplication();                 applications.add(cData.getJ2EEName().getApplication());             }             String adapterName = bootstrapContext.getResourceAdapterName();             if (metadata != null && metadata.isEmbedded() && cData != metadata) { // Metadata is null for SIB/WMQ. No check needed if called from activationSpec                 String embeddedApp = metadata.getJ2EEName().getApplication();                 Utils.checkAccessibility(name, adapterName, embeddedApp, currentApp, false);             }             Object adminObject = adminObjectClass.getConstructor().newInstance();             bootstrapContext.configure(adminObject, name, properties, null, null, null);             return adminObject;         } catch (Exception x) {             throw x;         } catch (Error x) {             throw x;         } finally {             if (trace && tc.isEntryEnabled())                 Tr.exit(this, tc, ""createResource"");         }     }
@Override     public synchronized boolean send(final Object message,                                      final boolean shouldClose,                                      final OnComplete onComplete) throws IOException {         if (!isOpen()) {             return false;         }          this.sendQueued = true;          byte[] data;         if (message == null) {             data = null;         } else if (message instanceof String) {             data = ((String)message).getBytes(getResponseCharset());         } else if (message instanceof byte[]) {             data = (byte[])message;         } else {             throw WebsocketUtil.wrongMessageType(message.getClass());         }          enqueue(new PendingSend(data, shouldClose, onComplete));          return true;     }
public static float coerceToFloat(Object value, float defaultValue) {     if (value instanceof Float) {       return (float) value;     }     if (value instanceof Number) {       return ((Number) value).floatValue();     } else if (value instanceof String) {       try {         return Float.valueOf((String) value);       } catch (NumberFormatException ignored) {       }     }     return defaultValue;   }
public static InetAddress[]     getAllByName(String name) throws UnknownHostException {         try {             InetAddress addr = getByAddress(name);             return new InetAddress[]{addr};         } catch (UnknownHostException e) {             Record[] records = lookupHostName(name);             InetAddress[] addrs = new InetAddress[records.length];             for (int i = 0; i < records.length; i++)                 addrs[i] = addrFromRecord(name, records[i]);             return addrs;         }     }
private void handleJASPIMechanism(final DeploymentInfo deploymentInfo) {         ApplicationPolicy applicationPolicy = SecurityConfiguration.getApplicationPolicy(this.securityDomain);          if (applicationPolicy != null && JASPIAuthenticationInfo.class.isInstance(applicationPolicy.getAuthenticationInfo())) {             String authMethod = null;             LoginConfig loginConfig = deploymentInfo.getLoginConfig();             if (loginConfig != null && loginConfig.getAuthMethods().size() > 0) {                 authMethod = loginConfig.getAuthMethods().get(0).getName();             }             deploymentInfo.setJaspiAuthenticationMechanism(new JASPICAuthenticationMechanism(securityDomain, authMethod));             deploymentInfo.setSecurityContextFactory(new JASPICSecurityContextFactory(this.securityDomain));             deploymentInfo.addOuterHandlerChainWrapper(next -> new JASPICSecureResponseHandler(next));         }     }
public void toASCII(PrintWriter pw,                          boolean addName,                          String rootName,                          boolean newLine) {            if (_Debug)              System.out.println(""asciiGrid.toASCII("" + addName + "",'"" + rootName + ""')  getName(): "" + getEncodedName());            if (rootName != null)              rootName += ""."" + getEncodedName();          else              rootName = getEncodedName();            boolean firstPass = true;          Enumeration e = getVariables();          while (e.hasMoreElements()) {              toASCII ta = (toASCII) e.nextElement();                if (!newLine && !firstPass)                  pw.print("", "");                ta.toASCII(pw, addName, rootName, newLine);                firstPass = false;          }            if (newLine)              pw.print(""\n"");        }
private String getServiceName() {         TransportMetadata tm = getTransportMetadata();         if (tm == null) {             return ""null"";         }                  return tm.getProviderName() + ' ' + tm.getName();     }
@Deprecated     // This API was formerly @stable ICU 2.0     static public ResourceBundle getDateFormatBundle(Class<? extends Calendar> calendarClass,                                                      Locale locale)         throws MissingResourceException {         return null;     }
private void dynamicallyInitIfNeeded( Object value ) {          /* Check to see if this class was already initialized,           * if not, initialize it based on the type of the value.     */          if ( !isInitialized() ) {              if ( value instanceof Integer ) {                  init( new Integer( min.intValue() ), new Integer( max.intValue() ) );              } else if ( value instanceof Byte ) {                  init( new Byte( min.byteValue() ), new Byte( max.byteValue() ) );              } else if ( value instanceof Short ) {                  init( new Short( min.shortValue() ), new Short( max.shortValue() ) );              } else {                  init( min, max );              }          }      }
private static Field findFieldOrThrowException(Class<?> fieldType, Class<?> where) {         if (fieldType == null || where == null) {             throw new IllegalArgumentException(""fieldType and where cannot be null"");         }         Field field = null;         for (Field currentField : where.getDeclaredFields()) {             currentField.setAccessible(true);             if (currentField.getType().equals(fieldType)) {                 field = currentField;                 break;             }         }         if (field == null) {             throw new FieldNotFoundException(""Cannot find a field of type "" + fieldType + ""in where."");         }         return field;     }
public static Object [] unwrap( Object[] args )     {         if ( args == null )             return null;         Object [] oa = new Object[ args.length ];         for(int i=0; i<args.length; i++)             oa[i] = unwrap( args[i] );         return oa;     }
public static void defaultSmoothShapefile( String shapePath, String outPath ) throws Exception {         PrintStreamProgressMonitor pm = new PrintStreamProgressMonitor(System.out, System.err);         SimpleFeatureCollection initialFC = OmsShapefileFeatureReader.readShapefile(shapePath);          OmsLineSmootherMcMaster smoother = new OmsLineSmootherMcMaster();         smoother.pm = pm;         smoother.pLimit = 10;         smoother.inVector = initialFC;         smoother.pLookahead = 13;         // smoother.pSlide = 1;         smoother.pDensify = 0.2;         smoother.pSimplify = 0.01;         smoother.process();          SimpleFeatureCollection smoothedFeatures = smoother.outVector;          OmsShapefileFeatureWriter.writeShapefile(outPath, smoothedFeatures, pm);     }
private static BigInteger getMultiChoice(int[] choices, JSchema schema, JSVariant[] vars) throws JMFUninitializedAccessException {     // Mixed-radix-encode the contribution from all the subvariants     BigInteger base = BigInteger.ZERO;     for (int i = 0; i < vars.length; i++)       base = base.multiply(vars[i].getMultiChoiceCount()).add(getMultiChoice(choices, schema, vars[i]));     return base;   }
@Override  public boolean validate() {   if (searchGeometry == null) {    SC.say(messages.geometricSearchWidgetTitle(), messages.geometricSearchWidgetNoGeometry());    return false;   } else if (SearchCommService.getVisibleServerLayerIds(mapWidget.getMapModel()).size() < 1) {    SC.say(messages.geometricSearchWidgetTitle(), messages.geometricSearchWidgetNoLayers());    return false;   } else {    return true;   }  }
public void remove(String name){         Map<String,Object> m = getMap(name);         if(m!=null) {             memoryHeap.release(m.get(name));             m.remove(name);         }     }
public void remove(final Tree<?, ?> child) {   requireNonNull(child);    if (!isChild(child)) {    throw new IllegalArgumentException(""The given child is not a child."");   }   remove(getIndex(child));  }
public synchronized final void setValue(final Long value) {         this.edmType = EdmType.INT64;         this.type = Long.class;         this.value = value == null ? null : Long.toString(value);     }
public String getPropertyAsString(final String key) {   LOG.info(""Getting value for key: "" + key);   for (ResourceBundle bundle : bundles.values()) {    try {     return bundle.getString(key);    } catch (MissingResourceException e) {     LOG.info(""Resource: "" + key + "" not found!"");    }   }   return null;  }
public static DenseMatrix eye(int k)     {         DenseMatrix eye = new DenseMatrix(k, k);         for(int i = 0; i < k; i++ )             eye.set(i, i, 1);         return eye;     }
private void linkNodeLast(LinkedHashMapEntry<K,V> p) {         LinkedHashMapEntry<K,V> last = tail;         tail = p;         if (last == null)             head = p;         else {             p.before = last;             last.after = p;         }     }
private void sortActivities() {         synchronized (mInstanceLock) {             if (mActivitySorter != null && !mActivites.isEmpty()) {                 mActivitySorter.sort(mIntent, mActivites,                         Collections.unmodifiableList(mHistoricalRecords));                 notifyChanged();             }         }     }
public static JsonSimple parse(InputStream input) throws IOException {         JsonSimple inputData = new JsonSimple(input);         JsonSimple responseData = new JsonSimple();          // Go through every top level node         JsonObject object = inputData.getJsonObject();         for (Object key : object.keySet()) {             // Ignoring some non-form related nodes             String strKey = validString(key);             if (!EXCLUDED_FIELDS.contains(strKey)) {                 // And parse them into the repsonse                 String data = validString(object.get(key));                 parseField(responseData, strKey, data);             }         }         return responseData;     }
public static boolean isImage( File file ){   try {    String mimeType = Files.probeContentType(file.toPath());    if( mimeType == null ) {     // In some OS there is a bug where it always returns null/     String extension = FilenameUtils.getExtension(file.getName()).toLowerCase();     String[] suffixes = ImageIO.getReaderFileSuffixes();     for( String s : suffixes ) {      if( s.equals(extension)) {       return true;      }     }    } else {     return mimeType.startsWith(""image"");    }   } catch (IOException ignore) {}   return false;  }
public static Integer versionCompare(String str1, String str2) {      String[] vals1 = str1.split(""\\."");     String[] vals2 = str2.split(""\\."");      int idx = 0;     // set index to first non-equal ordinal or length of shortest version     // string     while (idx < vals1.length && idx < vals2.length && vals1[idx].equals(vals2[idx])) {       idx++;     }     // compare first non-equal ordinal number     if (idx < vals1.length && idx < vals2.length) {       int diff = Integer.valueOf(vals1[idx]).compareTo(Integer.valueOf(vals2[idx]));       return Integer.signum(diff);     } else {       // the strings are equal or one string is a substring of the other       // e.g. ""1.2.3"" = ""1.2.3"" or ""1.2.3"" < ""1.2.3.4""       return Integer.signum(vals1.length - vals2.length);     }   }
public UniqueConstraint<SecondaryTable<T>> getOrCreateUniqueConstraint()    {       List<Node> nodeList = childNode.get(""unique-constraint"");       if (nodeList != null &&  nodeList.size() > 0)       {          return new UniqueConstraintImpl<SecondaryTable<T>>(this, ""unique-constraint"", childNode, nodeList.get(0));       }       return createUniqueConstraint();    }
int[] impliedElements(int anc, int desc) {     // <style> and <script> are allowed anywhere.     if (desc == SCRIPT_TAG || desc == STYLE_TAG) {       return ZERO_INTS;     }      // It's dangerous to allow free <li> tags because of the way an <li>     // implies a </li> if there is an <li> on the parse stack without a     // LIST_SCOPE element in the middle.      // Since we don't control the context in which sanitized HTML is embedded,     // we can't assume that there isn't a containing <li> tag before parsing     // starts, so we make sure we never produce an <li> or <td> without a     // corresponding LIST or TABLE scope element on the stack.     // <select> is not a scope for <option> elements, but we do that too for     // symmetry and as an extra degree of safety against future spec changes.     FreeWrapper wrapper = desc != TEXT_NODE && desc < FREE_WRAPPERS.length         ? FREE_WRAPPERS[desc] : null;     if (wrapper != null) {       if (anc < wrapper.allowedContainers.length           && !wrapper.allowedContainers[anc]) {         return wrapper.implied;       }     }      if (desc != TEXT_NODE) {       int[] implied = impliedElements.getElementIndexList(anc, desc);       // This handles the table case at least       if (implied.length != 0) { return implied; }     }      // If we require above that all <li>s appear in a <ul> or <ol> then     // for symmetry, we require here that all content of a <ul> or <ol> appear     // nested in a <li>.     // This does not have the same security implications as the above, but is     // symmetric.     int[] oneImplied = null;     if (anc == OL_TAG || anc == UL_TAG) {       oneImplied = LI_TAG_ARR;     } else if (anc == SELECT_TAG) {       oneImplied = OPTION_TAG_ARR;     }     if (oneImplied != null) {       if (desc != oneImplied[0]) {         return LI_TAG_ARR;       }     }     // TODO: why are we dropping OPTION_AG_ARR?     return ZERO_INTS;   }
public void append(StringConcatenation concat, String indentation) {   if (indentation.isEmpty()) {    append(concat);   } else if (concat != null)    appendSegments(indentation, segments.size(), concat.getSignificantContent(), concat.lineDelimiter);  }
public void visitEnum(final String name, final String descriptor, final String value) {     if (av != null) {       av.visitEnum(name, descriptor, value);     }   }
public static Set<Integer> getAvailablePorts(int fromPort, int toPort) {         if (fromPort < MIN_PORT_NUMBER || toPort > MAX_PORT_NUMBER                 || fromPort > toPort) {             throw new IllegalArgumentException(""Invalid port range: ""                     + fromPort + "" ~ "" + toPort);         }          Set<Integer> result = new TreeSet<>();          for (int i = fromPort; i <= toPort; i++) {             ServerSocket s = null;              try {                 s = new ServerSocket(i);                 result.add(i);             } catch (IOException e) {                 // Do nothing             } finally {                 if (s != null) {                     try {                         s.close();                     } catch (IOException e) {                         /* should not be thrown */                     }                 }             }         }          return result;     }
private VelocityContext toContext(Map<?, ?> bindingMap) {    final Map<String, Object> map = Convert.convert(new TypeReference<Map<String, Object>>() {}, bindingMap);    return new VelocityContext(map);   }
public synchronized int addColumn(double[] column) {         if (isFinished)             throw new IllegalStateException(                 ""Cannot add rows to a MatrixBuilder that is finished"");         for (int r = 0; r < column.length; ++r) {             if (column[r] != 0d) {                 // NB: Matlab sparse format is in [col row val] format                 //                 // NOTE: Matlab indices start at 1, not 0, so update all the                 // row and column values to be Matlab formatted.                 addEntry(r + 1, curColumn + 1, column[r]);             }         }         return ++curColumn;     }
protected ResponseFuture doInvokeAsync(SofaRequest request, RpcInternalContext rpcContext, int timeoutMillis) {         SofaResponseCallback listener = request.getSofaResponseCallback();         if (listener != null) {             AbstractHttpClientHandler callback = new CallbackInvokeClientHandler(transportConfig.getConsumerConfig(),                 transportConfig.getProviderInfo(), listener, request, rpcContext,                 ClassLoaderUtils.getCurrentClassLoader());             doSend(request, callback, timeoutMillis);             return null;         } else {             HttpResponseFuture future = new HttpResponseFuture(request, timeoutMillis);             AbstractHttpClientHandler callback = new FutureInvokeClientHandler(transportConfig.getConsumerConfig(),                 transportConfig.getProviderInfo(), future, request, rpcContext,                 ClassLoaderUtils.getCurrentClassLoader());             doSend(request, callback, timeoutMillis);             future.setSentTime();             return future;         }     }
public final synchronized boolean reserveId(long id, Object obj)  {   if (tc.isEntryEnabled()) Tr.entry(tc, ""reserveId"", new Object[] {new Long(id), obj});    boolean reserved = false;    // The id can only be reserved if it   // isn't already in the map   if (_idMap.get(id) == null)   {    _idMap.put(id, obj);    reserved = true;   }        if (tc.isEntryEnabled()) Tr.exit(tc, ""reserveId"", new Boolean(reserved));    return reserved;  }
@SuppressWarnings(""unchecked"")     public <T extends WindupVertexFrame> Iterable<T> findVariableOfType(Class<T> type)     {         for (Map<String, Iterable<? extends WindupVertexFrame>> topOfStack : deque)         {             for (Iterable<? extends WindupVertexFrame> frames : topOfStack.values())             {                 boolean empty = true;                 for (WindupVertexFrame frame : frames)                 {                     if (!type.isAssignableFrom(frame.getClass()))                     {                         break;                     }                     else                     {                         empty = false;                     }                 }                 // now we know all the frames are of the chosen type                 if (!empty)                     return (Iterable<T>) frames;             }         }         return null;     }
void flush(OutputStream out, String encoding)          throws IOException     {         flush(new OutputStreamWriter(out,encoding));     }
boolean isUniqueWithColumns(int[] cols) {          if (constType != UNIQUE || core.mainCols.length != cols.length) {             return false;         }          return ArrayUtil.haveEqualSets(core.mainCols, cols, cols.length);     }
@Override  public Object eGet(int featureID, boolean resolve, boolean coreType) {   switch (featureID) {    case AfplibPackage.RESOURCE_SECTION_NUMBER__RES_SNUM:     return getResSNum();   }   return super.eGet(featureID, resolve, coreType);  }
@XmlElementDecl(namespace = ""http://www.opengis.net/gml"", name = ""TemporalCS"", substitutionHeadNamespace = ""http://www.opengis.net/gml"", substitutionHeadName = ""_CoordinateSystem"")     public JAXBElement<TemporalCSType> createTemporalCS(TemporalCSType value) {         return new JAXBElement<TemporalCSType>(_TemporalCS_QNAME, TemporalCSType.class, null, value);     }
public static int dimension(Class clazz) {         checkArrayType(clazz);          int result = 0;         while (clazz.isArray()) {             result++;             clazz = clazz.getComponentType();         }          return result;     }
protected BigDecimal eval(final Object... _values)         throws SQLException     {         final BigDecimal ret;          if (_values == null || _values.length == 0 || _values[0] == null)  {             ret = null;         } else if (_values[0] instanceof String && ((String) _values[0]).length() > 0) {             try {                 ret = DecimalType.parseLocalized((String) _values[0]);             } catch (final EFapsException e) {                 throw new SQLException(e);             }         } else if (_values[0] instanceof BigDecimal) {             ret = (BigDecimal) _values[0];         } else if (_values[0] instanceof Number) {             ret = new BigDecimal(((Number) _values[0]).toString());         } else  {             ret = null;         }          return ret;     }
synchronized void fireEvent(final Event<?> event) {         final String eventType = event.getType();         List<Event<?>> events = synchronizedEvents.get(eventType);         if (null == events) {             events = new ArrayList<>();             synchronizedEvents.put(eventType, events);         }          events.add(event);         setChanged();         notifyListeners(event);     }
private void listenOnEndAttribute() throws IOException {            if (lastElement == null) {              return;          }            // no nonce written -> do it          if (""script"".equalsIgnoreCase(lastElement) && LangUtils.isValueBlank(lastNonce)) {              getWrapped().writeAttribute(""nonce"", cspState.getNonce(), null);          }            if (lastEvents != null && !lastEvents.isEmpty()) {              String id = lastId;                // no id written -> generate a new one and write it              // otherwise we can't identify the element for our scripts              if (LangUtils.isValueBlank(id)) {                  id = lastElement.toLowerCase() + ""-"" + UUID.randomUUID().toString();                  getWrapped().writeAttribute(""id"", id, null);              }                // add current collected events to our state              cspState.getEventHandlers().put(id, lastEvents);          }            reset();      }
public static void runExample(       AdManagerServices adManagerServices, AdManagerSession session, long customTargetingValueId)       throws RemoteException {     // Get the CustomTargetingService.     CustomTargetingServiceInterface customTargetingService =         adManagerServices.get(session, CustomTargetingServiceInterface.class);      // Create a statement to select custom targeting value.     StatementBuilder statementBuilder =         new StatementBuilder()             .where(""WHERE id = :id"")             .orderBy(""id ASC"")             .limit(StatementBuilder.SUGGESTED_PAGE_LIMIT)             .withBindVariableValue(""id"", customTargetingValueId);      // Default for total result set size.     int totalResultSetSize = 0;      do {       // Get custom targeting values by statement.       CustomTargetingValuePage page =           customTargetingService.getCustomTargetingValuesByStatement(               statementBuilder.toStatement());        if (page.getResults() != null) {         totalResultSetSize = page.getTotalResultSetSize();         int i = page.getStartIndex();         for (CustomTargetingValue customTargetingValue : page.getResults()) {           System.out.printf(               ""%d) Custom targeting value with ID %d"" + "" will be deleted.%n"",               i++, customTargetingValue.getId());         }       }        statementBuilder.increaseOffsetBy(StatementBuilder.SUGGESTED_PAGE_LIMIT);     } while (statementBuilder.getOffset() < totalResultSetSize);      System.out.printf(""Number of custom targeting values to be deleted: %d%n"", totalResultSetSize);      if (totalResultSetSize > 0) {       // Remove limit and offset from statement.       statementBuilder.removeLimitAndOffset();        // Create action.       com.google.api.ads.admanager.axis.v201902.DeleteCustomTargetingValues action =           new com.google.api.ads.admanager.axis.v201902.DeleteCustomTargetingValues();        // Perform action.       UpdateResult result =           customTargetingService.performCustomTargetingValueAction(               action, statementBuilder.toStatement());        if (result != null && result.getNumChanges() > 0) {         System.out.printf(             ""Number of custom targeting values deleted: %d%n"", result.getNumChanges());       } else {         System.out.println(""No custom targeting values deleted."");       }     }   }
public Q setDouble(final int index, final Number value) {   if (value == null) {    setNull(index, Types.DOUBLE);   }   else {    setDouble(index, value.doubleValue());   }   return _this();  }
public void generateWitherForField(EclipseNode fieldNode, EclipseNode sourceNode, AccessLevel level) {   for (EclipseNode child : fieldNode.down()) {    if (child.getKind() == Kind.ANNOTATION) {     if (annotationTypeMatches(Wither.class, child)) {      //The annotation will make it happen, so we can skip it.      return;     }    }   }      List<Annotation> empty = Collections.emptyList();   createWitherForField(level, fieldNode, sourceNode, false, empty, empty);  }
@Override     public synchronized void add(DiscoveryEntry discoveryEntry) {         logger.debug(""adding discovery entry: {}"", discoveryEntry);         if (!(discoveryEntry instanceof GlobalDiscoveryEntryPersisted)) {             return;         }         GlobalDiscoveryEntryPersisted globalDiscoveryEntry = (GlobalDiscoveryEntryPersisted) discoveryEntry;         if (globalDiscoveryEntry.getDomain() == null || globalDiscoveryEntry.getInterfaceName() == null                 || globalDiscoveryEntry.getParticipantId() == null || globalDiscoveryEntry.getAddress() == null) {             String message = ""discoveryEntry being registered is not complete: "" + discoveryEntry;             logger.error(message);             throw new JoynrCommunicationException(message);         }          GlobalDiscoveryEntryPersisted discoveryEntryFound = entityManager.find(GlobalDiscoveryEntryPersisted.class,                                                                                discoveryEntry.getParticipantId());          EntityTransaction transaction = entityManager.getTransaction();         try {             transaction.begin();             if (discoveryEntryFound != null) {                 entityManager.merge(discoveryEntry);             } else {                 entityManager.persist(discoveryEntry);             }             transaction.commit();         } catch (Exception e) {             if (transaction.isActive()) {                 transaction.rollback();             }             logger.error(""unable to add discoveryEntry: "" + discoveryEntry, e);         }     }
public void readProperties(ImageInputStream in, int len, ExtendImageHeader imageHeader) throws IOException {         int transform = 0, numToRead = 0;          if (len >= 14) {             numToRead = 14;         } else if (len > 0) {             numToRead = len;         } else {             numToRead = 0;         }          byte[] datas = new byte[numToRead];          in.read(datas);         len -= numToRead;          if (numToRead >= 12 && datas[0] == 0x41 && datas[1] == 0x64 && datas[2] == 0x6F && datas[3] == 0x62             && datas[4] == 0x65) {             // Found Adobe APP14 marker             transform = datas[11];              imageHeader.setSawAdobeMarker(true);             imageHeader.setAdobeTransform(transform);         }          // skip any remaining data         if (len > 0) {             in.skipBytes(len);         }     }
@Override     public List<ProviderAccount> listProviderAccounts(String url,                                                String username,                                                String password) {         return duraCloudDao.listProviderAccounts(url, username, password);     }
@PublicAPI(usage = ACCESS)     public JavaClasses importUrls(Collection<URL> urls) {         return importLocations(Locations.of(urls));     }
@Bean     public Queue authenticationReceiverQueue() {         return QueueBuilder.nonDurable(amqpProperties.getAuthenticationReceiverQueue()).autoDelete()                 .withArguments(getTTLMaxArgsAuthenticationQueue()).build();     }
private JsonObject createMessage(Object value) {     // Tag the message with a monotonically increasing ID. The ID     // will be used by the other side of the connection to guarantee     // ordering.     JsonObject message = serializer.serialize(value);     long id = currentMessage++;     message.putNumber(""id"", id);     messages.put(id, message);     return message;   }
public ConnectorDescriptor removeAllNamespaces()    {       List<String> nameSpaceKeys = new ArrayList<String>();       java.util.Map<String, String> attributes = model.getAttributes();       for (Entry<String, String> e : attributes.entrySet())       {          final String name = e.getKey();          final String value = e.getValue();          if (value != null && value.startsWith(""http://""))           {             nameSpaceKeys.add(name);          }       }       for (String name: nameSpaceKeys)       {          model.removeAttribute(name);       }       return this;    }
public static base_responses add(nitro_service client, vpnclientlessaccessprofile resources[]) throws Exception {   base_responses result = null;   if (resources != null && resources.length > 0) {    vpnclientlessaccessprofile addresources[] = new vpnclientlessaccessprofile[resources.length];    for (int i=0;i<resources.length;i++){     addresources[i] = new vpnclientlessaccessprofile();     addresources[i].profilename = resources[i].profilename;    }    result = add_bulk_request(client, addresources);   }   return result;  }
@Override     public void logRetrySuccess(CardView view, SMailPostingDiscloser discloser, int challengeCount, Exception firstCause) {         if (normalLogger.isInfoEnabled()) {             normalLogger.info(buildRetrySuccessDisp(view, discloser, challengeCount, firstCause));         }     }
public WindowedStream<T, KEY, TimeWindow> timeWindow(Time size) {   if (environment.getStreamTimeCharacteristic() == TimeCharacteristic.ProcessingTime) {    return window(TumblingProcessingTimeWindows.of(size));   } else {    return window(TumblingEventTimeWindows.of(size));   }  }
public static AsyncCallback<String> wrapCallback(final JavaScriptObject func) {            return new AsyncCallback<String>() {                public void onFailure(Throwable caught) {                    // TODO Auto-generated method stub                }                public void onSuccess(String result) {                    callWithString(func, result);              }            };      }
public static Codec findEncodingCodecByIntID(int id) {     long cPtr = VideoJNI.Codec_findEncodingCodecByIntID(id);     return (cPtr == 0) ? null : new Codec(cPtr, false);   }
private AbstractSimon replaceUnknownSimon(AbstractSimon simon, Class<? extends AbstractSimon> simonClass) {   AbstractSimon newSimon = instantiateSimon(simon.getName(), simonClass);   newSimon.enabled = simon.enabled;    // fixes parent link and parent's children list   ((AbstractSimon) simon.getParent()).replaceChild(simon, newSimon);    // fixes children list and all children's parent link   for (Simon child : simon.getChildren()) {    newSimon.addChild((AbstractSimon) child);    ((AbstractSimon) child).setParent(newSimon);   }    allSimons.put(simon.getName(), newSimon);   return newSimon;  }
public static Object stringToValue(String string) {         if (""true"".equalsIgnoreCase(string)) {             return Boolean.TRUE;         }         if (""false"".equalsIgnoreCase(string)) {             return Boolean.FALSE;         }         if (""null"".equalsIgnoreCase(string)) {             return JSONObject.NULL;         }  // If it might be a number, try converting it, first as a Long, and then as a // Double. If that doesn't work, return the string.          try {             char initial = string.charAt(0);             if (initial == '-' || (initial >= '0' && initial <= '9')) {                 Long value = new Long(string);                 if (value.toString().equals(string)) {                     return value;                 }             }         }  catch (Exception ignore) {             try {                 Double value = new Double(string);                 if (value.toString().equals(string)) {                     return value;                 }             }  catch (Exception ignoreAlso) {             }         }         return string;     }
@Nonnull     public static List<TtlRunnable> gets(@Nullable Collection<? extends Runnable> tasks, boolean releaseTtlValueReferenceAfterRun) {         return gets(tasks, releaseTtlValueReferenceAfterRun, false);     }
public Object intercept(final Object object, Method method,     final Object[] args, final MethodProxy proxy) throws Throwable {   if (!descriptor.joinpoints().contains(method)) {    return proxy.invokeSuper(object, args);   }      Map<Descriptor<?>, Object> aspects = new HashMap<Descriptor<?>, Object>();   List<Descriptor<?>> descriptors = new ArrayList<Descriptor<?>>();   ListMultimap<Descriptor<?>, Method> before = ArrayListMultimap.create();   ListMultimap<Descriptor<?>, Method> around = ArrayListMultimap.create();   ListMultimap<Descriptor<?>, Method> after = ArrayListMultimap.create();   ListMultimap<Descriptor<?>, Method> throwing = ArrayListMultimap.create();      for (Annotation annotation : method.getAnnotations()) {    if (annotation.annotationType().isAnnotationPresent(Pointcut.class)) {     for (Descriptor<?> descriptor : container.pointcuts().get(annotation)) {      aspects.put(descriptor, container.component(descriptor));      descriptors.add(descriptor);      before.putAll(descriptor, descriptor.advices().get(Before.class));      around.putAll(descriptor, descriptor.advices().get(Around.class));      after.putAll(descriptor, descriptor.advices().get(After.class));      throwing.putAll(descriptor, descriptor.advices().get(Throwing.class));     }    }   }      new Invoke(logger, descriptors, before, aspects, ""before"").apply(args);   Invocation<?> invocation = new Invocation<Object>(method, object, args) {        @Override    public Object proceed() throws Throwable {     return proxy.invokeSuper(object, args);    }       };      List<Method> methods = new ArrayList<Method>();   Map<Method, Descriptor<?>> descs = new HashMap<Method, Descriptor<?>>();      for (Descriptor<?> descriptor : descriptors) {    if (around.containsKey(descriptor)) {     for (Method m : around.get(descriptor)) {      if (!m.isAccessible()) {       m.setAccessible(true);      }            methods.add(m);      descs.put(m, descriptor);     }    }   }      for (Method m : Lists.reverse(methods)) {    if (m.getParameterTypes().length == 1       && m.getParameterTypes()[0].isAssignableFrom(Invocation.class)) {     invocation = new Invocation<Object>(m,        aspects.get(descs.get(m)), new Object[] {invocation});    } else {     throw new ConfigurationException(""Around advice ["" + m       + ""] must receive one argument as ""        + ""org.eiichiro.jaguar.aspect.Invocation<R>"");    }   }      Object result = null;      try {    result = invocation.proceed();   } catch (Throwable t) {    if (around.isEmpty()) {     logger.error(""Failed to invoke component method ["" + method + ""]"", t);    } else {     logger.error(""Failed to invoke around advice"", t);    }        if (throwing.isEmpty()) {     throw t;    }        new Invoke(logger, descriptors, throwing, aspects, ""throwing"").apply(new Object[] {t});   }      new Invoke(logger, descriptors, after, aspects, ""after"").apply(new Object[] {result});   return result;  }
public GetActiveNamesResult withActiveNames(String... activeNames) {         if (this.activeNames == null) {             setActiveNames(new java.util.ArrayList<String>(activeNames.length));         }         for (String ele : activeNames) {             this.activeNames.add(ele);         }         return this;     }
@Override     public UpdateThingGroupsForThingResult updateThingGroupsForThing(UpdateThingGroupsForThingRequest request) {         request = beforeClientExecution(request);         return executeUpdateThingGroupsForThing(request);     }
public static int getClosestFixedBits(int width)     {         if (width == 0) {             return 1;         }          if (width >= 1 && width <= 24) {             return width;         }         else if (width > 24 && width <= 26) {             return 26;         }         else if (width > 26 && width <= 28) {             return 28;         }         else if (width > 28 && width <= 30) {             return 30;         }         else if (width > 30 && width <= 32) {             return 32;         }         else if (width > 32 && width <= 40) {             return 40;         }         else if (width > 40 && width <= 48) {             return 48;         }         else if (width > 48 && width <= 56) {             return 56;         }         else {             return 64;         }     }
public static Map<String, List<Object>> readDbf( String path ) throws IOException {          OmsDbfTableReader reader = new OmsDbfTableReader();         reader.file = path;         reader.readTable();          return reader.outTabledata;     }
public MessageSecurityMetadataSourceRegistry simpDestPathMatcher(    PathMatcher pathMatcher) {   Assert.notNull(pathMatcher, ""pathMatcher cannot be null"");   this.pathMatcher.setPathMatcher(pathMatcher);   this.defaultPathMatcher = false;   return this;  }
public static void unescapeProperties(final String text, final Writer writer)             throws IOException {          if (writer == null) {             throw new IllegalArgumentException(""Argument 'writer' cannot be null"");         }         if (text == null) {             return;         }         if (text.indexOf('\\') < 0) {             // Fail fast, avoid more complex (and less JIT-table) method to execute if not needed             writer.write(text);             return;         }          PropertiesUnescapeUtil.unescape(new InternalStringReader(text), writer);      }
public static Locale associatedLocale(Associator assoc) {         return assoc.associated(Selection.class)             .map(sel -> sel.get()[0]).orElse(Locale.getDefault());     }
static final void cleanup(XMLStreamReader reader) throws XMLStreamException {     if (reader.nextTag() != END_ELEMENT || !reader.getLocalName().equalsIgnoreCase(SPARQL.name())) {       logger.warn(""Extra data at end of results"");     } else if (reader.next() != END_DOCUMENT) {       logger.warn(""Unexpected data after XML"");     }     logger.debug(""End of input detected, closing reader..."");     reader.close();   }
public TreeGraphNode headWordNode() {      TreeGraphNode hwn = safeCast(label.get(TreeCoreAnnotations.HeadWordAnnotation.class));      if (hwn == null || (hwn.treeGraph() != null && !(hwn.treeGraph().equals(this.treeGraph())))) {        return null;      }      return hwn;    }
@Override     @SuppressWarnings(""unchecked"")     /**      * override to support ordering of returned keys.      */     public Iterator<String> getKeys() {          final Iterator tempKeysIter = super.getKeys();         final List<String> keys = sortKeys(tempKeysIter);          return keys.iterator();     }
public static boolean movies(final MovieInfo moviedb, final String title, final String year, int maxDistance, boolean caseSensitive) {         if ((moviedb == null) || (StringUtils.isBlank(title))) {             return false;         }          String primaryTitle, firstCompareTitle, secondCompareTitle;         if (caseSensitive) {             primaryTitle = title;             firstCompareTitle = moviedb.getOriginalTitle();             secondCompareTitle = moviedb.getTitle();         } else {             primaryTitle = title.toLowerCase();             firstCompareTitle = moviedb.getTitle().toLowerCase();             secondCompareTitle = moviedb.getOriginalTitle().toLowerCase();         }          if (isValidYear(year) && isValidYear(moviedb.getReleaseDate())) {             // Compare with year             String movieYear = moviedb.getReleaseDate().substring(0, YEAR_LENGTH);             return movieYear.equals(year) && compareTitles(primaryTitle, firstCompareTitle, secondCompareTitle, maxDistance);         }          // Compare without year         return compareTitles(primaryTitle, firstCompareTitle, secondCompareTitle, maxDistance);     }
public boolean detectTierIphone()    {       if ((this.initCompleted == true) ||                (this.isTierIphone == true))          return this.isTierIphone;        if (detectIphoneOrIpod()                || detectAndroidPhone()                || detectWindowsPhone()                || detectBlackBerry10Phone()                || (detectBlackBerryWebKit()                && detectBlackBerryTouch())                || detectPalmWebOS()                || detectBada()                || detectTizen()                || detectGamingHandheld()) {          return true;       }       return false;    }
public void setUserStackAssociations(java.util.Collection<UserStackAssociation> userStackAssociations) {         if (userStackAssociations == null) {             this.userStackAssociations = null;             return;         }          this.userStackAssociations = new java.util.ArrayList<UserStackAssociation>(userStackAssociations);     }
public void clear() {         exceptionSet.clear();         explicitSet.clear();         universalHandler = false;         commonSupertype = null;         size = 0;     }
private static XColor getXColorWithSchema(final String colorSchema,     final double preTint, final CTSchemeColor ctsColor,     final ThemesTable themeTable) {    int colorIndex = getThemeIndexFromName(colorSchema);    if (colorIndex < 0) {     return null;    }    XSSFColor bcolor = themeTable.getThemeColor(colorIndex);    if (bcolor == null) {     return null;    }    int lumOff = 0;    int lumMod = 0;    int alphaInt = 0;    if (ctsColor != null) {     try {      lumOff = ctsColor.getLumOffArray(0).getVal();     } catch (Exception ex) {      LOG.log(Level.FINE, ""No lumOff entry"", ex);     }     try {      lumMod = ctsColor.getLumModArray(0).getVal();     } catch (Exception ex) {      LOG.log(Level.FINE, ""No lumMod entry"", ex);     }     try {      alphaInt = ctsColor.getAlphaArray(0).getVal();     } catch (Exception ex) {      LOG.log(Level.FINE, ""No alpha entry"", ex);     }    }    return assembleXcolor(bcolor, preTint, lumOff, lumMod, alphaInt);   }
@SuppressWarnings(""unchecked"")  public static synchronized <D,S> IJMapper<D, S> getMapper(final Class<D> destination,final Class<S> source,final ChooseConfig config,final String xml) {      String mapperName = mapperClassName(destination, source, xml);      if(mapperCache.containsKey(mapperName))     return (IJMapper<D, S>) mapperCache.get(mapperName);       IJMapper<D, S> jmapper = new JMapper<D, S>(destination, source, config, xml);   mapperCache.put(mapperName, jmapper);   return jmapper;  }
public SSLEngine get() {         try {             String pass = env.sslKeystorePassword();             char[] password = pass == null || pass.isEmpty() ? null : pass.toCharArray();              KeyStore ks = env.sslKeystore();             if (ks == null) {                 String ksFile = env.sslKeystoreFile();                 if (ksFile != null && !ksFile.isEmpty()) {                     ks = KeyStore.getInstance(KeyStore.getDefaultType());                     ks.load(new FileInputStream(ksFile), password);                 }             }              KeyStore ts = env.sslTruststore();             if (ts == null) {                 String tsFile = env.sslTruststoreFile();                 if (tsFile != null && !tsFile.isEmpty()) {                     // filepath found, open and init                     String tsPassword = env.sslTruststorePassword();                     char[] tspass = tsPassword == null || tsPassword.isEmpty() ? null : tsPassword.toCharArray();                     ts = KeyStore.getInstance(KeyStore.getDefaultType());                     ts.load(new FileInputStream(tsFile), tspass);                 }             }              if (ks == null && ts == null) {                 throw new IllegalStateException(""Either a KeyStore or a TrustStore "" +                     ""need to be provided (or both)."");             } else if (ks == null) {                 ks = ts;                 LOGGER.debug(""No KeyStore provided, using provided TrustStore to initialize both factories."");             } else if (ts == null) {                 ts = ks;                 LOGGER.debug(""No TrustStore provided, using provided KeyStore to initialize both factories."");             }              String defaultAlgorithm = KeyManagerFactory.getDefaultAlgorithm();             KeyManagerFactory kmf = KeyManagerFactory.getInstance(defaultAlgorithm);             TrustManagerFactory tmf = TrustManagerFactory.getInstance(defaultAlgorithm);             kmf.init(ks, password);             tmf.init(ts);              if (!sslContextProtocol.startsWith(""TLS"")) {                 throw new IllegalArgumentException(                     ""SSLContext Protocol does not start with TLS, this is to prevent ""                         + ""insecure protocols (Like SSL*) to be used. Potential candidates ""                         + ""are TLS (default), TLSv1, TLSv1.1, TLSv1.2, TLSv1.3 depending on ""                         + ""the Java version used."");             }             SSLContext ctx = SSLContext.getInstance(sslContextProtocol);             ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);              SSLEngine engine = ctx.createSSLEngine();             engine.setUseClientMode(true);             return engine;         } catch (Exception ex) {             throw new SSLException(""Could not create SSLEngine."", ex);         }     }
@Override   public Snapshot getSnapshot() {     long now = System.nanoTime();      cacheLock.readLock().lock();     try {       if (now - cachedHistogramTimestampNanos < refreshIntervalNanos) {         return cachedSnapshot;       }     } finally {       cacheLock.readLock().unlock();     }      cacheLock.writeLock().lock();     try {       // Might have raced with another writer => re-check the timestamp       if (now - cachedHistogramTimestampNanos >= refreshIntervalNanos) {         LOG.debug(""Cached snapshot is too old, refreshing"");         cachedHistogram = recorder.getIntervalHistogram(cachedHistogram);         cachedSnapshot = new HdrSnapshot(cachedHistogram);         cachedHistogramTimestampNanos = now;       }       return cachedSnapshot;     } finally {       cacheLock.writeLock().unlock();     }   }
public Props load(final Map<?, ?> p) {   for (final Map.Entry<?, ?> entry : p.entrySet()) {    final String name = entry.getKey().toString();    final Object value = entry.getValue();    if (value == null) {     continue;    }    data.putBaseProperty(name, value.toString(), false);   }   return this;  }
public Collection<BuildProject> buildProjects(BuildProjectFilter filter) {         return get(BuildProject.class, (filter != null) ? filter : new BuildProjectFilter());     }
public void setLoggerLevel(String level) {         if (""TRACE"".equalsIgnoreCase(level)) {             this.level = TRACE;         } else if (""DEBUG"".equalsIgnoreCase(level)) {             this.level = DEBUG;         } else if (""INFO"".equalsIgnoreCase(level)) {             this.level = INFO;         } else if (""WARN"".equalsIgnoreCase(level)) {             this.level = WARN;         } else if (""ERROR"".equalsIgnoreCase(level)) {             this.level = ERROR;         }     }
public Observable<VirtualNetworkRuleInner> createOrUpdateAsync(String resourceGroupName, String accountName, String virtualNetworkRuleName, CreateOrUpdateVirtualNetworkRuleParameters parameters) {         return createOrUpdateWithServiceResponseAsync(resourceGroupName, accountName, virtualNetworkRuleName, parameters).map(new Func1<ServiceResponse<VirtualNetworkRuleInner>, VirtualNetworkRuleInner>() {             @Override             public VirtualNetworkRuleInner call(ServiceResponse<VirtualNetworkRuleInner> response) {                 return response.body();             }         });     }
public static ResponseAwareMatcher<Response> endsWithPath(final String path) {         return response -> endsWith(response.<String>path(path));     }
public final Trace warn(Class<?> c, String message) {          return _trace.warn(c, message);      }
public XAnnotation<javax.persistence.OneToOne> createOneToOne(    OneToOne cOneToOne) {   return cOneToOne == null ? null :   //     new XAnnotation<javax.persistence.OneToOne>(       javax.persistence.OneToOne.class,       //       cOneToOne.getTargetEntity() == null ? null :        new XSingleAnnotationField<Class<Object>>(         ""targetEntity"", Class.class,         new XClassByNameAnnotationValue<Object>(           cOneToOne.getTargetEntity())),       //       AnnotationUtils.create(""cascade"",         getCascadeType(cOneToOne.getCascade())),       //       AnnotationUtils.create(""fetch"",         getFetchType(cOneToOne.getFetch())),       //       AnnotationUtils.create(""optional"",         cOneToOne.isOptional()),       //       AnnotationUtils.create(""mappedBy"",         cOneToOne.getMappedBy()),       //       AnnotationUtils.create(""orphanRemoval"",         cOneToOne.isOrphanRemoval())     //     );  }
void noteHandshakeError(Exception failure) {         numberOfLogEntries++;         if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {             Tr.debug(tc, ""noteHandshakeError ("" + numberOfLogEntries + ""): "" + failure.getMessage(), failure);         }         if (shouldLogError) {             if (numberOfLogEntries <= maxLogEntries) {                 Tr.error(tc, SSLChannelConstants.HANDSHAKE_FAILURE, failure);             } else if (!loggingStopped && (numberOfLogEntries > maxLogEntries)) {                 loggingStopped = true;                 Tr.info(tc, SSLChannelConstants.HANDSHAKE_FAILURE_STOP_LOGGING);             }         }     }
public static CookieData match(String name, int offset, int length) {         if (null == name)             return null;         return (CookieData) myMatcher.match(name, offset, length);     }
private DateTime getADate(String s) {         DateTime retDT = null;         try         {             retDT = new DateTime( s );         } // the try         catch(IllegalArgumentException pe)         {             // ignore it here, caller sees null         } // the catch         return retDT;     }
public IOBObjType createIOBObjTypeFromString(EDataType eDataType, String initialValue) {   IOBObjType result = IOBObjType.get(initialValue);   if (result == null) throw new IllegalArgumentException(""The value '"" + initialValue + ""' is not a valid enumerator of '"" + eDataType.getName() + ""'"");   return result;  }
public static String underscore(String word) {     String firstPattern = ""([A-Z]+)([A-Z][a-z])"";     String secondPattern = ""([a-z\\d])([A-Z])"";     String replacementPattern = ""$1_$2"";     // Replace package separator with slash.     word = word.replaceAll(""\\."", ""/"");     // Replace $ with two underscores for inner classes.     word = word.replaceAll(""\\$"", ""__"");     // Replace capital letter with _ plus lowercase letter.     word = word.replaceAll(firstPattern, replacementPattern);     word = word.replaceAll(secondPattern, replacementPattern);     word = word.replace('-', '_');     word = word.toLowerCase();     return word;   }
public CompletableFuture<NewFile> run() {         LOG.log(Level.FINE, ""starting optimized file creation for {0} files"", files.size());         CompletableFuture<NewFile> fileCreation = new CompletableFuture<>();         final List<TSData> fjpFiles = this.files;  // We clear out files below, which makes createTmpFile see an empty map if we don't use a separate variable.         TASK_POOL.execute(() -> createTmpFile(fileCreation, destDir, fjpFiles, getCompression()));         synchronized (OUTSTANDING) {             OUTSTANDING.add(fileCreation);         }         this.files = new LinkedList<>();  // Do not use clear! This instance is now shared with the createTmpFile task.         return fileCreation;     }
protected void finalizeProfileResponse(final AccessToken accessTokenTicket, final Map<String, Object> map, final Principal principal) {         val service = accessTokenTicket.getService();         val registeredService = servicesManager.findServiceBy(service);         if (registeredService instanceof OAuthRegisteredService) {             val oauth = (OAuthRegisteredService) registeredService;             map.put(OAuth20Constants.CLIENT_ID, oauth.getClientId());             map.put(CasProtocolConstants.PARAMETER_SERVICE, service.getId());         }     }
public static String getBaseUrl(final String aUrl) {      if (aUrl != null) {        int index = aUrl.indexOf(""//"");        if (index > 0) {          index = aUrl.indexOf('/', index + 2);        } else {          index = aUrl.indexOf('/');        }          if (index > 0) {          return aUrl.substring(0, index);        }      }        return aUrl;    }
public boolean isEquivalent(CrystalTransform other) {   Matrix4d mul = new Matrix4d();   mul.mul(this.matTransform,other.matTransform);    if (mul.epsilonEquals(IDENTITY, 0.0001)) {    return true;   }   return false;  }
@Override     public <T extends GedObject> Collection<T> find(final FinderObject owner,             final Class<T> clazz) {         return owner.findInParent(clazz);     }
public static void assertIOThread(Thread t, boolean flag) {         if (flag) {             assert t.equals(Thread.currentThread()) : ""Management NOT on IO thread when expected"";  // XXX testing         } else {             assert !(t.equals(Thread.currentThread())) : ""Management on IO thread when not expected"";  // XXX testing         }     }
public static Number parseInteger(AST reportNode, String text) {         // remove place holder underscore before starting         text = text.replace(""_"", """");          char c = ' ';         int length = text.length();           //         // Strip off the sign, if present          boolean negative = false;         if ((c = text.charAt(0)) == '-' || c == '+') {             negative = (c == '-');             text = text.substring(1, length);             length -= 1;         }           //         // Determine radix (default is 10).          int radix = 10;         if (text.charAt(0) == '0' && length > 1) {             c = text.charAt(1);             if (c == 'X' || c == 'x') {                 radix = 16;                 text = text.substring(2, length);                 length -= 2;             } else if (c == 'B' || c == 'b') {                 radix = 2;                 text = text.substring(2, length);                 length -= 2;             } else {                 radix = 8;             }         }           //         // Strip off any type specifier and convert it to lower         // case, if present.          char type = 'x';  // pick best fit         if (isNumericTypeSpecifier(text.charAt(length - 1), false)) {             type = Character.toLowerCase(text.charAt(length - 1));             text = text.substring(0, length - 1);              length -= 1;         }           //         // Add the sign back, if necessary          if (negative) {             text = ""-"" + text;         }           //         // Build the specified type or, if no type was specified, the         // smallest type in which the number will fit.          BigInteger value = new BigInteger(text, radix);          switch (type) {             case 'i':                 if (radix == 10 && (value.compareTo(MAX_INTEGER) > 0 || value.compareTo(MIN_INTEGER) < 0)) {                     throw new ASTRuntimeException(reportNode, ""Number of value "" + value + "" does not fit in the range of int, but int was enforced."");                 } else {                     return value.intValue();                 }             case 'l':                 if (radix == 10 && (value.compareTo(MAX_LONG) > 0 || value.compareTo(MIN_LONG) < 0)) {                     throw new ASTRuntimeException(reportNode, ""Number of value "" + value + "" does not fit in the range of long, but long was enforced."");                 } else {                     return value.longValue();                 }             case 'g':                 return value;             default:                 // If not specified, we will return the narrowest possible                 // of Integer, Long, and BigInteger.                 if (value.compareTo(MAX_INTEGER) <= 0 && value.compareTo(MIN_INTEGER) >= 0) {                     return value.intValue();                 } else if (value.compareTo(MAX_LONG) <= 0 && value.compareTo(MIN_LONG) >= 0) {                     return value.longValue();                 }                 return value;         }     }
public AnnotationSegment getSegmentList(int i) {     if (MMAXAnnotation_Type.featOkTst && ((MMAXAnnotation_Type)jcasType).casFeat_segmentList == null)       jcasType.jcas.throwFeatMissing(""segmentList"", ""de.julielab.jules.types.mmax.MMAXAnnotation"");     jcasType.jcas.checkArrayBounds(jcasType.ll_cas.ll_getRefValue(addr, ((MMAXAnnotation_Type)jcasType).casFeatCode_segmentList), i);     return (AnnotationSegment)(jcasType.ll_cas.ll_getFSForRef(jcasType.ll_cas.ll_getRefArrayValue(jcasType.ll_cas.ll_getRefValue(addr, ((MMAXAnnotation_Type)jcasType).casFeatCode_segmentList), i)));}
public DescribeLaunchTemplateVersionsResult withLaunchTemplateVersions(LaunchTemplateVersion... launchTemplateVersions) {         if (this.launchTemplateVersions == null) {             setLaunchTemplateVersions(new com.amazonaws.internal.SdkInternalList<LaunchTemplateVersion>(launchTemplateVersions.length));         }         for (LaunchTemplateVersion ele : launchTemplateVersions) {             this.launchTemplateVersions.add(ele);         }         return this;     }
public void onSaveInstanceState(Bundle outState) {     hasSavedState = true;     outState.putParcelable(KEY_STATE, new State(observableManager.id(), group.id()));   }
public List<MappedClass> getSubTypes(final MappedClass mc) {         List<MappedClass> subtypes = new ArrayList<MappedClass>();         for (MappedClass mappedClass : getMappedClasses()) {             if (mappedClass.isSubType(mc)) {                 subtypes.add(mappedClass);             }         }          return subtypes;     }
static public double cosine(Angle angle) {         double result = lock(Math.cos(angle.value));         return result;     }
public CurrencyUnit getCurrency(String currencyCode, String... providers) {         Objects.requireNonNull(currencyCode, ""Currency Code may not be null"");         Collection<CurrencyUnit> found =                 getCurrencies(CurrencyQueryBuilder.of().setCurrencyCodes(currencyCode).setProviderNames(providers).build());         if (found.isEmpty()) {             throw new UnknownCurrencyException(currencyCode);         }         if (found.size() > 1) {             throw new MonetaryException(""Ambiguous CurrencyUnit for code: "" + currencyCode + "": "" + found);         }         return found.iterator().next();     }
public synchronized TextBox setValidationPattern(Pattern validationPattern) {         if(validationPattern != null) {             for(String line: lines) {                 if(!validated(line)) {                     throw new IllegalStateException(""TextBox validation pattern "" + validationPattern + "" does not match existing content"");                 }             }         }         this.validationPattern = validationPattern;         return this;     }
@Override     public T read(Serializable id) throws InvalidKeyException {         ensureOpen();          String sql = ""SELECT "" + COLUMN_DATA + "" FROM "" + TABLE_NAME + "" WHERE "" + COLUMN_ID + "" = ?"";         Cursor cursor = getReadableDatabase().rawQuery(sql, new String[]{id.toString()});         cursor.moveToFirst();          if (cursor.getCount() == 0) {             return null;         }          try {             byte[] encryptedData = cursor.getBlob(0);             return cryptoEntityUtil.decrypt(encryptedData);         } finally {             cursor.close();         }     }
private static boolean isValid(String stValue) {         int scan;         boolean bValid = true;          for (scan = 0; scan < stValue.length(); scan++) {             if (scan == 0)                 bValid = XMLChar.isNCNameStart(stValue.charAt(scan));             else                 bValid = XMLChar.isNCName(stValue.charAt(scan));             if (!bValid)                 break;         }         return bValid;     }
@Deprecated   public final Assignment intersection(Collection<Integer> varNums) {     return intersection(Ints.toArray(varNums));   }
public DimensionKeyDescription withDimensions(java.util.Map<String, String> dimensions) {         setDimensions(dimensions);         return this;     }
public final LogExclusion createExclusion(ParentName parent, LogExclusion exclusion) {      CreateExclusionRequest request =         CreateExclusionRequest.newBuilder()             .setParent(parent == null ? null : parent.toString())             .setExclusion(exclusion)             .build();     return createExclusion(request);   }
@Override  public List<CommercePriceListUserSegmentEntryRel> getCommercePriceListUserSegmentEntryRelsByUuidAndCompanyId(   String uuid, long companyId, int start, int end,   OrderByComparator<CommercePriceListUserSegmentEntryRel> orderByComparator) {   return commercePriceListUserSegmentEntryRelPersistence.findByUuid_C(uuid,    companyId, start, end, orderByComparator);  }
static long getClassHashCode(Class cls) {         // The simple cases         if (cls.isInterface())             return 0;         if (!Serializable.class.isAssignableFrom(cls))             return 0;         if (Externalizable.class.isAssignableFrom(cls))             return 1;          // Try cache         Long l = (Long) classHashCodeCache.get(cls);         if (l != null)             return l.longValue();          // Has to calculate the hash.          ByteArrayOutputStream baos = new ByteArrayOutputStream(256);         DataOutputStream dos = new DataOutputStream(baos);          // Step 1         Class superClass = cls.getSuperclass();         if (superClass != null && superClass != Object.class) {             try {                 dos.writeLong(getClassHashCode(superClass));             } catch (IOException ex) {                 throw IIOPLogger.ROOT_LOGGER.unexpectedException(ex);             }         }          // Step 2         boolean hasWriteObject = false;         try {             Method m;             int mods;              m = cls.getDeclaredMethod(""writeObject"",                     new Class[]{ObjectOutputStream.class});             mods = m.getModifiers();              if (!Modifier.isPrivate(mods) && !Modifier.isStatic(mods))                 hasWriteObject = true;         } catch (NoSuchMethodException ex) {             // ignore         }         try {             dos.writeInt(hasWriteObject ? 2 : 1);         } catch (IOException ex) {             throw IIOPLogger.ROOT_LOGGER.unexpectedException(ex);         }          // Step 3         Field[] fields = cls.getDeclaredFields();         SortedSet set = new TreeSet(new FieldComparator());          for (int i = 0; i < fields.length; ++i) {             int mods = fields[i].getModifiers();              if (!Modifier.isStatic(mods) && !Modifier.isTransient(mods))                 set.add(fields[i]);         }         Iterator iter = set.iterator();         try {             while (iter.hasNext()) {                 Field f = (Field) iter.next();                  dos.writeUTF(f.getName());                 dos.writeUTF(getSignature(f.getType()));             }         } catch (IOException ex) {             throw IIOPLogger.ROOT_LOGGER.unexpectedException(ex);         }          // Convert to byte[]         try {             dos.flush();         } catch (IOException ex) {             throw IIOPLogger.ROOT_LOGGER.unexpectedException(ex);         }         byte[] bytes = baos.toByteArray();          // Calculate SHA digest         MessageDigest digest;         try {             digest = MessageDigest.getInstance(""SHA"");         } catch (NoSuchAlgorithmException ex) {             throw IIOPLogger.ROOT_LOGGER.unavailableSHADigest(ex);         }         digest.update(bytes);         byte[] sha = digest.digest();          // Calculate hash as per section 10.6.2         long hash = 0;         for (int i = 0; i < Math.min(8, sha.length); i++) {             hash += (long) (sha[i] & 255) << (i * 8);         }          // Save in cache         classHashCodeCache.put(cls, new Long(hash));          return hash;     }
public AtomicValue<Integer>       next() throws Exception     {         MutableAtomicValue<Integer> result = new MutableAtomicValue<Integer>(0, 0);          if ( currentValue == null )         {             currentValue = number.add(cacheFactor);             if ( !currentValue.succeeded() )             {                 currentValue = null;                 result.succeeded = false;                 return result;             }             currentIndex = 0;         }          result.succeeded = true;         result.preValue = currentValue.preValue() + currentIndex;         result.postValue = result.preValue + 1;          if ( ++currentIndex >= cacheFactor )         {             currentValue = null;         }          return result;     }
public static ByteBuffer decodeMOVPacket(ByteBuffer result, AvcCBox avcC) {         if (avcC.getNalLengthSize() == 4) {             decodeMOVPacketInplace(result, avcC);             return result;         }         return joinNALUnits(splitMOVPacket(result, avcC));     }
public static String toPinyin(String str, PinyinFormat format) {   return Pinyin.INSTANCE.convert(str, format);  }
@Override     public DBSnapshotAttributesResult describeDBSnapshotAttributes(DescribeDBSnapshotAttributesRequest request) {         request = beforeClientExecution(request);         return executeDescribeDBSnapshotAttributes(request);     }
@Override     public void sawOpcode(int seen) {         // System.out.println(getPC() + "" "" + Const.getOpcodeName(seen) + "" "" + state);          if (stack.getStackDepth() < stackDepth) {             state = FormatState.NONE;             stackDepth = 0;             arguments = null;         }         if (seen == Const.ANEWARRAY && stack.getStackDepth() >= 2) {             Object size = stack.getStackItem(0).getConstant();             Object formatStr = stack.getStackItem(1).getConstant();             if (size instanceof Integer && formatStr instanceof String) {                 arguments = new OpcodeStack.Item[(Integer) size];                 this.formatString = (String) formatStr;                 state = FormatState.READY_FOR_FORMAT;                 stackDepth = stack.getStackDepth();             }         } else if (state == FormatState.READY_FOR_FORMAT && seen == Const.DUP) {             state = FormatState.EXPECTING_ASSIGNMENT;         } else if (state == FormatState.EXPECTING_ASSIGNMENT && stack.getStackDepth() == stackDepth + 3 && seen == Const.AASTORE) {             Object pos = stack.getStackItem(1).getConstant();             OpcodeStack.Item value = stack.getStackItem(0);             if (pos instanceof Integer) {                 int index = (Integer) pos;                 if (index >= 0 && index < arguments.length) {                     arguments[index] = value;                     state = FormatState.READY_FOR_FORMAT;                 } else {                     state = FormatState.NONE;                 }             } else {                 state = FormatState.NONE;             }         } else if (state == FormatState.READY_FOR_FORMAT                 && (seen == Const.INVOKESPECIAL || seen == Const.INVOKEVIRTUAL || seen == Const.INVOKESTATIC || seen == Const.INVOKEINTERFACE)                 && stack.getStackDepth() == stackDepth) {              String cl = getClassConstantOperand();             String nm = getNameConstantOperand();             String sig = getSigConstantOperand();             XMethod m = getXMethodOperand();             if ((m == null || m.isVarArgs())                     && sig.indexOf(""Ljava/lang/String;[Ljava/lang/Object;)"") >= 0                     && (""java/util/Formatter"".equals(cl) && ""format"".equals(nm) || ""java/lang/String"".equals(cl)                             && ""format"".equals(nm) || ""java/io/PrintStream"".equals(cl) && ""format"".equals(nm)                             || ""java/io/PrintStream"".equals(cl) && ""printf"".equals(nm) || cl.endsWith(""Writer"")                             && ""format"".equals(nm) || cl.endsWith(""Writer"") && ""printf"".equals(nm)) || cl.endsWith(""Logger"")                             && nm.endsWith(""fmt"")) {                  if (formatString.indexOf('\n') >= 0) {                     bugReporter.reportBug(new BugInstance(this, ""VA_FORMAT_STRING_USES_NEWLINE"", NORMAL_PRIORITY)                     .addClassAndMethod(this).addCalledMethod(this).addString(formatString)                     .describe(StringAnnotation.FORMAT_STRING_ROLE).addSourceLine(this));                 }             }          }     }
public void writeInvocation(StoredProcedureInvocation invocation) throws IOException {         int len = invocation.getSerializedSize();         growIfNeeded(len);         invocation.flattenToBuffer(buffer.b());     }
private boolean _broadcastAll(FacesContext context,                                List<? extends FacesEvent> events,                                Collection<FacesEvent> eventsAborted)     {         assert events != null;          for (int i = 0; i < events.size(); i++)         {             FacesEvent event = events.get(i);             UIComponent source = event.getComponent();             UIComponent compositeParent = UIComponent.getCompositeComponentParent(source);             if (compositeParent != null)             {                 pushComponentToEL(context, compositeParent);             }             // Push the source as the current component             pushComponentToEL(context, source);              try             {                 // Actual event broadcasting                 if (!source.isCachedFacesContext())                 {                     try                     {                         source.setCachedFacesContext(context);                         source.broadcast(event);                     }                     finally                     {                         source.setCachedFacesContext(null);                     }                 }                 else                 {                     source.broadcast(event);                 }             }             catch (Exception e)             {                  Throwable cause = e;                 AbortProcessingException ape = null;                 do                 {                     if (cause != null && cause instanceof AbortProcessingException)                     {                         ape = (AbortProcessingException) cause;                         break;                     }                     cause = cause.getCause();                 }                 while (cause != null);                                  // for any other exception publish ExceptionQueuedEvent                 // publish the Exception to be handled by the ExceptionHandler                 // to publish or to not publish APE? That is the question : MYFACES-3199. We publish it,                 // because user can handle it in custom exception handler then.                  if (ape != null)                 {                     e = ape;                 }                 ExceptionQueuedEventContext exceptionContext                          = new ExceptionQueuedEventContext(context, e, source, context.getCurrentPhaseId());                 context.getApplication().publishEvent(context, ExceptionQueuedEvent.class, exceptionContext);                                   if (ape != null)                 {                     // APE found,  abortion for this event only                     eventsAborted.add(event);                 }                 else                 {                     // We can't continue broadcast processing if other exception is thrown:                     return false;                 }             }             finally             {                 // Restore the current component                 source.popComponentFromEL(context);                 if (compositeParent != null)                 {                     compositeParent.popComponentFromEL(context);                 }             }         }         return true;     }
public Map<String, String> cloneVM(HttpInputs httpInputs, VmInputs vmInputs) throws Exception {         ConnectionResources connectionResources = new ConnectionResources(httpInputs, vmInputs);         try {             ManagedObjectReference vmMor = new MorObjectHandler().getMor(connectionResources,                     ManagedObjectType.VIRTUAL_MACHINE.getValue(), vmInputs.getVirtualMachineName());              if (vmMor != null) {                 VmUtils utils = new VmUtils();                 ManagedObjectReference folder = utils.getMorFolder(vmInputs.getFolderName(), connectionResources);                 ManagedObjectReference resourcePool = utils.getMorResourcePool(vmInputs.getCloneResourcePool(), connectionResources);                 ManagedObjectReference host = utils.getMorHost(vmInputs.getCloneHost(), connectionResources, vmMor);                 ManagedObjectReference dataStore = utils.getMorDataStore(vmInputs.getCloneDataStore(), connectionResources,                         vmMor, vmInputs);                  VirtualMachineRelocateSpec vmRelocateSpec = utils.getVirtualMachineRelocateSpec(resourcePool, host, dataStore, vmInputs);                  VirtualMachineCloneSpec cloneSpec = new VmConfigSpecs().getCloneSpec(vmInputs, vmRelocateSpec);                  ManagedObjectReference taskMor = connectionResources.getVimPortType()                         .cloneVMTask(vmMor, folder, vmInputs.getCloneName(), cloneSpec);                  return new ResponseHelper(connectionResources, taskMor).getResultsMap(""Success: The ["" +                         vmInputs.getVirtualMachineName() + ""] VM was successfully cloned. The taskId is: "" +                         taskMor.getValue(), ""Failure: The ["" + vmInputs.getVirtualMachineName() + ""] VM could not be cloned."");             } else {                 return ResponseUtils.getVmNotFoundResultsMap(vmInputs);             }         } catch (Exception ex) {             return ResponseUtils.getResultsMap(ex.toString(), Outputs.RETURN_CODE_FAILURE);         } finally {             if (httpInputs.isCloseSession()) {                 connectionResources.getConnection().disconnect();                 clearConnectionFromContext(httpInputs.getGlobalSessionObject());             }         }     }
public StringFormatter getFormatter() {   if (formatter == null) {                     ResourceBundle b = ResourceBundle.getBundle(UI_RESOURCE_BUNDLE_NAME, new UTF8Control());    formatter = new StringFormatter(b, getLocale());   }   return formatter;  }
@Override     public void deserializeInstance(SerializationStreamReader streamReader, OWLLiteralImplDouble instance) throws SerializationException {         deserialize(streamReader, instance);     }
public ServiceFuture<KeyOperationResult> wrapKeyAsync(String vaultBaseUrl, String keyName, String keyVersion, JsonWebKeyEncryptionAlgorithm algorithm, byte[] value, final ServiceCallback<KeyOperationResult> serviceCallback) {         return ServiceFuture.fromResponse(wrapKeyWithServiceResponseAsync(vaultBaseUrl, keyName, keyVersion, algorithm, value), serviceCallback);     }
public void initializeWorldGroup() {         if (worldGroupManager == null) {             worldGroupManager = new WorldGroupsManager();             sendConsoleMessage(Level.INFO, getLanguageManager().getString(""world_group_manager_loaded""));         }     }
private static String removeLeadingSlashPoints(String path) {   while (path.startsWith(""/.."")) {    path = path.substring(3);   }    return path;  }
static String toParamString(Class<?>[] params) {   if (params == null || params.length == 0) {    return ""()"";   }   StringBuilder s = new StringBuilder();   s.append('(');   for (int i = 0, max = params.length; i < max; i++) {    if (i > 0) {     s.append("", "");    }    if (params[i] == null) {     s.append(""null"");    }    else {     s.append(params[i].getName());    }   }   s.append(')');   return s.toString();  }
@Override     public ValueComparator compare(Value val) {         if (val == null || val.getType() != ValueType.VALUELIST) {             return ValueComparator.NOT_EQUAL_TO;         }         ValueList<?> vl = (ValueList<?>) val;         return vl.contains(this) ? ValueComparator.IN : ValueComparator.NOT_IN;     }
private void addRawSparseProbabilistic(final long rawValue) {         // p(w): position of the least significant set bit (one-indexed)         // By contract: p(w) <= 2^(registerValueInBits) - 1 (the max register value)         //         // By construction of pwMaxMask (see #Constructor()),         //      lsb(pwMaxMask) = 2^(registerValueInBits) - 2,         // thus lsb(any_long | pwMaxMask) <= 2^(registerValueInBits) - 2,         // thus 1 + lsb(any_long | pwMaxMask) <= 2^(registerValueInBits) -1.         final long substreamValue = (rawValue >>> log2m);         final byte p_w;          if(substreamValue == 0L) {             // The paper does not cover p(0x0), so the special value 0 is used.             // 0 is the original initialization value of the registers, so by             // doing this the multiset simply ignores it. This is acceptable             // because the probability is 1/(2^(2^registerSizeInBits)).             p_w = 0;         } else {             p_w = (byte)(1 + BitUtil.leastSignificantBit(substreamValue| pwMaxMask));         }          // Short-circuit if the register is being set to zero, since algorithmically         // this corresponds to an ""unset"" register, and ""unset"" registers aren't         // stored to save memory. (The very reason this sparse implementation         // exists.) If a register is set to zero it will break the #algorithmCardinality         // code.         if(p_w == 0) {             return;         }          // NOTE:  no +1 as in paper since 0-based indexing         final int j = (int)(rawValue & mBitsMask);          final byte currentValue = sparseProbabilisticStorage.get(j);         if(p_w > currentValue) {             sparseProbabilisticStorage.put(j, p_w);         }     }
public final boolean matches(final Collection<LabelAtom> labels) {         return matches(new VariableResolver<Boolean>() {             public Boolean resolve(String name) {                 for (LabelAtom a : labels)                     if (a.getName().equals(name))                         return true;                 return false;             }         });     }
public static boolean isMain(MethodGen mg) {     Type[] argTypes = mg.getArgumentTypes();     return mg.isStatic()         && (mg.getReturnType() == Type.VOID)         && mg.getName().equals(""main"")         && (argTypes.length == 1)         && argTypes[0].equals(stringArray);   }
public static BeanCopy fromMap(final Map source) {   BeanCopy beanCopy = new BeanCopy(source);    beanCopy.isSourceMap = true;    return beanCopy;  }
public DescribeRetentionConfigurationsRequest withRetentionConfigurationNames(String... retentionConfigurationNames) {         if (this.retentionConfigurationNames == null) {             setRetentionConfigurationNames(new com.amazonaws.internal.SdkInternalList<String>(retentionConfigurationNames.length));         }         for (String ele : retentionConfigurationNames) {             this.retentionConfigurationNames.add(ele);         }         return this;     }
public SqlApplicationConfiguration withOutputs(Output... outputs) {         if (this.outputs == null) {             setOutputs(new java.util.ArrayList<Output>(outputs.length));         }         for (Output ele : outputs) {             this.outputs.add(ele);         }         return this;     }
void clearPath(int path) {   int first_vertex = getFirstVertex(path);   if (first_vertex != -1) {    // TODO: can ve do this in one shot?    int vertex = first_vertex;    for (int i = 0, n = getPathSize(path); i < n; i++) {     int v = vertex;     vertex = getNextVertex(vertex);     freeVertex_(v);    }    int geometry = getGeometryFromPath(path);    setGeometryVertexCount_(geometry, getPointCount(geometry)      - getPathSize(path));   }   setPathSize_(path, 0);  }
public Observable<Page<ResourceMetricInner>> listMultiRolePoolInstanceMetricsAsync(final String resourceGroupName, final String name, final String instance, final Boolean details) {         return listMultiRolePoolInstanceMetricsWithServiceResponseAsync(resourceGroupName, name, instance, details)             .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {                 @Override                 public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {                     return response.body();                 }             });     }
private static List<String> loadClasspathResource(String resource, ResourceLoader resourceLoader, String resourcePaths) throws IOException{         List<String> result = new ArrayList<>();         LOGGER.info(""类路径资源：""+resource);         Enumeration<URL> ps = AutoDetector.class.getClassLoader().getResources(resource);         while(ps.hasMoreElements()) {             URL url=ps.nextElement();             LOGGER.info(""类路径资源URL：""+url);             if(url.getFile().contains("".jar!"")){                 //加载jar资源                 result.addAll(load(""classpath:""+resource));                 continue;             }             File file=new File(url.getFile());             boolean dir = file.isDirectory();             if(dir){                 //处理目录                 result.addAll(loadAndWatchDir(file.toPath(), resourceLoader, resourcePaths));             }else{                 //处理文件                 result.addAll(load(file.getAbsolutePath()));                 //监控文件                 watchFile(file, resourceLoader, resourcePaths);             }         }         return result;     }
@SuppressWarnings(""unchecked"")     private boolean isMethodAlreadyInjectedAnnotationPresent(MethodNode methodNode) {         AnnotationNode injectedTraceAnnotation = getAnnotation(INJECTED_TRACE_TYPE.getDescriptor(), methodNode.visibleAnnotations);         AnnotationNode manualTraceAnnotation = getAnnotation(MANUAL_TRACE_TYPE.getDescriptor(), methodNode.visibleAnnotations);         if (manualTraceAnnotation != null)             return true;          if (injectedTraceAnnotation != null) {             InjectedTraceAnnotationVisitor itav = new InjectedTraceAnnotationVisitor();             injectedTraceAnnotation.accept(itav);             List<String> methodAdapters = itav.getMethodAdapters();             if (methodAdapters.contains(LibertyTracingMethodAdapter.class.getName())) {                 return true;             }             if (methodAdapters.contains(WebSphereTrTracingMethodAdapter.class.getName())) {                 return true;             }             if (methodAdapters.contains(JSR47TracingMethodAdapter.class.getName())) {                 return true;             }         }         return false;     }
public static org.jsoup.nodes.Document getDocumentFromUrl(String url) throws IOException {         return Jsoup.connect(url).get();     }
public Object getMethodAnalysis(Class<?> analysisClass, MethodDescriptor methodDescriptor) {         Map<MethodDescriptor, Object> objectMap = getObjectMap(analysisClass);         return objectMap.get(methodDescriptor);     }
private static StackLine getStackLine(SrcTree srcTree,             String classQualifiedName, String methodSimpleName, int line) {         StackLine rootStackLine = getStackLine(                 srcTree.getRootMethodTable(), classQualifiedName, methodSimpleName, line);         if (rootStackLine != null) {             return rootStackLine;         }         StackLine subStackLine = getStackLine(                 srcTree.getSubMethodTable(), classQualifiedName, methodSimpleName, line);         if (subStackLine != null) {             return subStackLine;         }         return null;     }
public Enumeration<E> elements() {         return new Enumeration<E>() {             int count = 0;              public boolean hasMoreElements() {                 return count < elementCount;             }              public E nextElement() {                 synchronized (Vector.this) {                     if (count < elementCount) {                         return elementData(count++);                     }                 }                 throw new NoSuchElementException(""Vector Enumeration"");             }         };     }
public static Object keyForPrefixMatch(Object key, int depth) {         if (depth < 1)             return key;         if (key instanceof String) {             return (key + ""\uFFFF"");         } else if (key instanceof List) {             ArrayList<Map<String, Object>> nuKey = new ArrayList<Map<String, Object>>((List<Map<String, Object>>) key);             if (depth == 1) {                 nuKey.add(new HashMap<String, Object>());             } else {                 Object lastObject = nuKey.get(nuKey.size() - 1);                 lastObject = keyForPrefixMatch(lastObject, depth - 1);                 nuKey.set(nuKey.size() - 1, (Map<String, Object>) lastObject);             }             return nuKey;         } else {             return key;         }     }
protected Object convertMapsToObjects(final JsonObject<String, Object> root)     {         final Deque<JsonObject<String, Object>> stack = new ArrayDeque<JsonObject<String, Object>>();         stack.addFirst(root);          while (!stack.isEmpty())         {             final JsonObject<String, Object> jsonObj = stack.removeFirst();              if (jsonObj.isArray())             {                 traverseArray(stack, jsonObj);             }             else if (jsonObj.isCollection())             {                 traverseCollection(stack, jsonObj);             }             else if (jsonObj.isMap())             {                 traverseMap(stack, jsonObj);             }             else             {                 Object special;                 if ((special = readIfMatching(jsonObj, null, stack)) != null)                 {                     jsonObj.target = special;                 }                 else                 {                     traverseFields(stack, jsonObj);                 }             }         }         return root.target;     }
public Object get(String strKey)     {         if (m_map != null)             return m_map.get(strKey);         return null;     }
public final TransferConfig updateTransferConfig(       TransferConfig transferConfig, FieldMask updateMask) {      UpdateTransferConfigRequest request =         UpdateTransferConfigRequest.newBuilder()             .setTransferConfig(transferConfig)             .setUpdateMask(updateMask)             .build();     return updateTransferConfig(request);   }
public static SetAclAction fromProto(File.PSetAclAction pSetAclAction) {     if (pSetAclAction == null) {       throw new IllegalStateException(""Null proto set acl action."");     }     switch (pSetAclAction) {       case REPLACE:         return SetAclAction.REPLACE;       case MODIFY:         return SetAclAction.MODIFY;       case REMOVE:         return SetAclAction.REMOVE;       case REMOVE_ALL:         return SetAclAction.REMOVE_ALL;       case REMOVE_DEFAULT:         return SetAclAction.REMOVE_DEFAULT;       default:         throw new IllegalStateException(""Unrecognized proto set acl action: "" + pSetAclAction);     }   }
@Override     public Set<Annotation> getQualifiers() {         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) {             Tr.entry(tc, ""getQualifiers"");         }          if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) {             Tr.exit(tc, ""getQualifiers"", qualifiers);         }         return qualifiers;     }
public String getPid() {         String arg = extraArgs.size() > 0 ? extraArgs.get(0) : null;         return arg != null && arg.matches(""^\\d+$"") ? arg : null;     }
void write(CallInfo callInfo, SimpleAssertion assertion) {     Element rootNode = root(callInfo);     if (assertion.getSource() != null) {       write(rootNode, assertion.getSource());     }     Element saNode = createNode(rootNode, SIMPLE_ASSERTION_TAG);     if (! assertion.passed()) {       Element errorsNode = createNode(saNode, ERRORS_TAG);       createNode(errorsNode, EXPECTED_TAG)         .setAttribute(VALUE_ATTR, assertion.getExpectedResult().toString());       createNode(errorsNode, ACTUAL_TAG)         .setAttribute(VALUE_ATTR, assertion.getActualResult().toString());     }     flush(rootNode);   }
public boolean addDataUsage(DataAttribute attribute, DataUsage usage) throws ParameterException, LockingException {                 Validate.notNull(attribute);                  if (isFieldLocked(EntryField.DATA)) {                         if (!dataUsage.containsKey(attribute)) {                                 throw new LockingException(EntryField.DATA);                         }                         return false;                 } else {                         if (dataUsage.get(attribute) == null) {                                 dataUsage.put(attribute, new HashSet<>());                         }                         if (usage != null) {                                 dataUsage.get(attribute).add(usage);                         }                         return true;                 }         }
public void actionReport() throws JspException {          // save initialized instance of this class in request attribute for included sub-elements         getJsp().getRequest().setAttribute(SESSION_WORKPLACE_CLASS, this);         switch (getAction()) {             case ACTION_CONFIRMED:             default:                 try {                     Map params = new HashMap();                     params.put(PARAM_MODULE, getParamModule());                     // set style to display report in correct layout                     params.put(PARAM_STYLE, CmsToolDialog.STYLE_NEW);                     // set close link to get back to overview after finishing the import                     params.put(PARAM_CLOSELINK, CmsToolManager.linkForToolPath(getJsp(), ""/modules""));                     // redirect to the report output JSP                     getToolManager().jspForwardPage(this, DELETE_ACTION_REPORT, params);                      actionCloseDialog();                 } catch (Throwable e) {                     // create a new Exception with custom message                     includeErrorpage(this, e);                 }                 break;         }     }
public void checkMaxAllowedLength(int length) throws MaxAllowedPacketException {     if (cmdLength + length >= maxAllowedPacket && cmdLength == 0) {       //launch exception only if no packet has been send.       throw new MaxAllowedPacketException(""query size ("" + (cmdLength + length)           + "") is >= to max_allowed_packet ("" + maxAllowedPacket + "")"", false);     }   }
private void add_yubikey_to_user(String publicId, String username, String filename) {   try {    File file = new File(filename);    FileWriter writer = new FileWriter(file, true);    writer.write(""yk."" + publicId + "".user = "" + username      + System.getProperty(""line.separator""));    writer.close();   } catch (IOException ex) {    log.error(""Failed appending entry to file {}"", filename, ex);   }  }
@Override     public <B> EitherT<M, L, R> discardR(Applicative<B, MonadT<M, Either<L, ?>, ?>> appB) {         return MonadT.super.discardR(appB).coerce();     }
private String getMetricNamesFromES(final String tenant, final String regexMetricName) throws IOException {         String metricNamesFromElasticsearchQueryString = String.format(queryToFetchMetricNamesFromElasticsearchFormat,                 tenant, regexMetricName, regexMetricName);          return elasticsearchRestHelper.fetchDocuments(                 ELASTICSEARCH_INDEX_NAME_READ,                 ELASTICSEARCH_DOCUMENT_TYPE,                 tenant,                 metricNamesFromElasticsearchQueryString);     }
public void setCurve (IQuadCurve curve) {         setCurve(curve.x1(), curve.y1(), curve.ctrlX(), curve.ctrlY(),                  curve.x2(), curve.y2());     }
@Override     public String getCssText() {         final StringBuilder sb = new StringBuilder();         sb.append(""@import"");          final String href = getHref();         if (null != href) {             sb.append("" url("").append(href).append("")"");         }          final MediaListImpl ml = getMedia();         if (null != ml && ml.getLength() > 0) {             sb.append("" "").append(getMedia().getMediaText());         }         sb.append("";"");         return sb.toString();     }
public void setRowId(String parameterName, RowId x) {         recordByName(parameterName, getDeclaredMethod(CallableStatement.class, ""setRowId"", String.class, RowId.class), parameterName, x);     }
public EEnum getIfcDimensionExtentUsage() {    if (ifcDimensionExtentUsageEEnum == null) {     ifcDimensionExtentUsageEEnum = (EEnum) EPackage.Registry.INSTANCE.getEPackage(Ifc2x3tc1Package.eNS_URI)       .getEClassifiers().get(810);    }    return ifcDimensionExtentUsageEEnum;   }
public static void hash(byte[] data, byte[] output) {     int len = output.length;     if (len == 0)       return;     int[] code = calculate(data);     for (int outIndex = 0, codeIndex = 0, shift = 24;             outIndex < len && codeIndex < 5;                 ++outIndex, shift -= 8) {       output[outIndex] = (byte) (code[codeIndex] >>> shift);       if (shift == 0) {         shift = 32;     // will be decremented by 8 before next iteration         ++codeIndex;       }     }   }
@ConditionalOnClass({Context.class, DataLinkType.class})     //@ConditionalOnBean(Context.class)     @Bean(DATALINK_TYPE_BEAN_NAME)     public DataLinkType dataLinkType(@Qualifier(CONTEXT_BEAN_NAME) Context context) {         DataLinkType dataLinkType = context.pcapDataLink();         if (LOGGER.isDebugEnabled()) {             LOGGER.debug(""Datalink type: {}."", dataLinkType);         }         return dataLinkType;     }
@Override     public <T> T getValueOrDefault(String key, Class<T> type, T defaultValue) {         return data.getValueOrDefault(key, type, defaultValue);     }
@Override     public synchronized void authenticate() throws PortalSecurityException {         if (this.remoteUser != null) {             // Set the UID for the principal             this.myPrincipal.setUID(this.remoteUser);              // Check that the principal UID matches the remote user             final String newUid = this.myPrincipal.getUID();              if (this.remoteUser.equals(newUid)) {                 if (log.isInfoEnabled()) {                     log.info(""Authentication REMOTE_USER("" + this.remoteUser + "")."");                 }                  this.isauth = true;             } else if (log.isInfoEnabled()) {                 log.info(                         ""Authentication failed. REMOTE_USER(""                                 + this.remoteUser                                 + "") != user(""                                 + newUid                                 + "")."");             }         } else if (log.isInfoEnabled()) {             log.info(                     ""Authentication failed. REMOTE_USER not set for(""                             + this.myPrincipal.getUID()                             + "")."");         }          super.authenticate();         return;     }
public static File.PSetAclAction toProto(SetAclAction aclAction) {     switch (aclAction) {       case REPLACE:         return File.PSetAclAction.REPLACE;       case MODIFY:         return File.PSetAclAction.MODIFY;       case REMOVE:         return File.PSetAclAction.REMOVE;       case REMOVE_ALL:         return File.PSetAclAction.REMOVE_ALL;       case REMOVE_DEFAULT:         return File.PSetAclAction.REMOVE_DEFAULT;       default:         throw new IllegalStateException(""Unrecognized set acl action: "" + aclAction);     }   }
private String parseCellInlineStringText(XMLEventReader xer)    throws XMLStreamException, FormatNotUnderstoodException {   String result = """";   XMLEvent xe;   while ((xe = xer.nextTag()).isStartElement()) {    String elementName = xe.asStartElement().getName().getLocalPart().toUpperCase();    switch (elementName) {    case ""T"": // normal text     result = xer.getElementText();     break;    case ""R"": // rich text (returned as normal text)     result = this.parseCellInlineStringRichText(xer);     break;    case ""RPH"": // phonetic (ignored)    case ""PHONETICPR"": // phonetic properties (ignored)     this.skipXMLElementHierarchy(xer);     break;    default:     LOG.error(""Unknown inline string tag: "" + elementName);     throw new FormatNotUnderstoodException(""Unknown inline string tag: "" + elementName);     }   }   return result;  }
@SuppressWarnings(""deprecation"")     public static LocalDateTime fromDateFields(Date date) {         if (date == null) {             throw new IllegalArgumentException(""The date must not be null"");         }         if (date.getTime() < 0) {             // handle years in era BC             GregorianCalendar cal = new GregorianCalendar();             cal.setTime(date);             return fromCalendarFields(cal);         }         return new LocalDateTime(             date.getYear() + 1900,             date.getMonth() + 1,             date.getDate(),             date.getHours(),             date.getMinutes(),             date.getSeconds(),             (((int) (date.getTime() % 1000)) + 1000) % 1000         );     }
@Override     public StorageUri transformUri(StorageUri resourceUri, OperationContext opContext) throws URISyntaxException,             StorageException {         return new StorageUri(this.transformUri(resourceUri.getPrimaryUri(), opContext), this.transformUri(                 resourceUri.getSecondaryUri(), opContext));     }
@Override     public void writeExternal(ObjectOutput out) throws IOException     {        super.writeExternal(out);        byte[] buf = wsId.getBytes(Constants.DEFAULT_ENCODING);        out.writeInt(buf.length);        out.write(buf);     }
public Integer add(MtasToken token) {     Integer id = token.getId();     tokenCollection.put(id, token);     return id;   }
public static Generator<Vector2F> create()   {     return new Vector2FGenerator(PrimitiveGenerators.doubles(       GeneratorConstants.BOUND_LARGE_FLOAT_LOWER,       GeneratorConstants.BOUND_LARGE_FLOAT_UPPER     ));   }
public void filterOnAllData( final ALasDataManager lasHandler ) throws Exception {         final ConcurrentSkipListSet<Double> angleSet = new ConcurrentSkipListSet<Double>();         final ConcurrentSkipListSet<Double> distanceSet = new ConcurrentSkipListSet<Double>();          if (isFirstStatsCalculation) {             pm.beginTask(""Calculating initial statistics..."", tinGeometries.length);         } else {             pm.beginTask(""Filtering all data on seeds tin..."", tinGeometries.length);         }         try {             final List<Coordinate> newTotalLeftOverCoordinateList = new ArrayList<Coordinate>();             if (threadsNum > 1) {                 // multithreaded                 ThreadedRunnable tRun = new ThreadedRunnable(threadsNum, null);                 for( final Geometry tinGeom : tinGeometries ) {                     tRun.executeRunnable(new Runnable(){                         public void run() {                             List<Coordinate> leftOverList = runFilterOnAllData(lasHandler, angleSet, distanceSet, tinGeom);                             synchronized (newTotalLeftOverCoordinateList) {                                 newTotalLeftOverCoordinateList.addAll(leftOverList);                             }                         }                     });                 }                 tRun.waitAndClose();             } else {                 for( final Geometry tinGeom : tinGeometries ) {                     List<Coordinate> leftOverList = runFilterOnAllData(lasHandler, angleSet, distanceSet, tinGeom);                     newTotalLeftOverCoordinateList.addAll(leftOverList);                 }             }             pm.done();              leftOverCoordinateList.clear();             leftOverCoordinateList.addAll(newTotalLeftOverCoordinateList);              /*              * now recalculate the thresholds              */             if (angleSet.size() > 1) {                 calculatedAngleThreshold = getMedianFromSet(angleSet);                 pm.message(""Calculated angle threshold: "" + calculatedAngleThreshold + "" (range: "" + angleSet.first() + "" to ""                         + angleSet.last() + "")"");             } else if (angleSet.size() == 0) {                 return;             } else {                 calculatedAngleThreshold = angleSet.first();                 pm.message(""Single angle left: "" + calculatedAngleThreshold);             }              if (distanceSet.size() > 1) {                 calculatedDistanceThreshold = getMedianFromSet(distanceSet);                 pm.message(""Calculated distance threshold: "" + calculatedDistanceThreshold + "" (range: "" + distanceSet.first()                         + "" to "" + distanceSet.last() + "")"");             } else if (distanceSet.size() == 0) {                 return;             } else {                 calculatedDistanceThreshold = distanceSet.first();                 pm.message(""Single distance left: "" + calculatedDistanceThreshold);             }             if (isFirstStatsCalculation) {                 isFirstStatsCalculation = false;             }         } catch (Exception e) {             e.printStackTrace();         }     }
public void setRegularExpression(String regularExpression) {   if (regularExpression != null)    this.regularExpression = Pattern.compile(regularExpression);   else    this.regularExpression = null;  }
public static <G extends PartiallyOrdered<?>> Context antichain(final List<G> set) {         return new Context(set, set, new Equal());     }
private IAtomContainerSet readAtomContainerSet(IAtomContainerSet som) {         try {             String line = input.readLine().trim();             while (line != null) {                 logger.debug(""Line: "", line);                  final String name = suffix(line);                  try {                     IAtomContainer molecule = sp.parseSmiles(line);                     molecule.setProperty(""SMIdbNAME"", name);                     som.addAtomContainer(molecule);                 } catch (CDKException exception) {                     logger.warn(""This SMILES could not be parsed: "", line);                     logger.warn(""Because of: "", exception.getMessage());                     logger.debug(exception);                     IAtomContainer empty = som.getBuilder().newInstance(IAtomContainer.class, 0, 0, 0, 0);                     empty.setProperty(IteratingSMILESReader.BAD_SMILES_INPUT, line);                     som.addAtomContainer(empty);                 }                 if (input.ready()) {                     line = input.readLine();                 } else {                     line = null;                 }             }         } catch (Exception exception) {             logger.error(""Error while reading SMILES line: "", exception.getMessage());             logger.debug(exception);         }         return som;     }
public void validate(File objectAsFile,                          String format,                          int validationType,                          String phase) throws ServerException {         dov.validate(objectAsFile, format, validationType, phase);     }
@Override     public void solve(DefaultSolverScope<Solution_> solverScope) {         PartitionedSearchPhaseScope<Solution_> phaseScope = new PartitionedSearchPhaseScope<>(solverScope);         List<Solution_> partList = solutionPartitioner.splitWorkingSolution(                 solverScope.getScoreDirector(), runnablePartThreadLimit);         int partCount = partList.size();         phaseScope.setPartCount(partCount);         phaseStarted(phaseScope);         ExecutorService executor = createThreadPoolExecutor(partCount);         ChildThreadPlumbingTermination childThreadPlumbingTermination = new ChildThreadPlumbingTermination();         PartitionQueue<Solution_> partitionQueue = new PartitionQueue<>(partCount);         Semaphore runnablePartThreadSemaphore                 = runnablePartThreadLimit == null ? null : new Semaphore(runnablePartThreadLimit, true);         try {             for (ListIterator<Solution_> it = partList.listIterator(); it.hasNext();) {                 int partIndex = it.nextIndex();                 Solution_ part = it.next();                 PartitionSolver<Solution_> partitionSolver = buildPartitionSolver(                         childThreadPlumbingTermination, runnablePartThreadSemaphore, solverScope);                 partitionSolver.addEventListener(event -> {                     InnerScoreDirector<Solution_> childScoreDirector = partitionSolver.solverScope.getScoreDirector();                     PartitionChangeMove<Solution_> move = PartitionChangeMove.createMove(childScoreDirector, partIndex);                     InnerScoreDirector<Solution_> parentScoreDirector = solverScope.getScoreDirector();                     move = move.rebase(parentScoreDirector);                     partitionQueue.addMove(partIndex, move);                 });                 executor.submit(() -> {                     try {                         partitionSolver.solve(part);                         long partCalculationCount = partitionSolver.getScoreCalculationCount();                         partitionQueue.addFinish(partIndex, partCalculationCount);                     } catch (Throwable throwable) {                         // Any Exception or even Error that happens here (on a partition thread) must be stored                         // in the partitionQueue in order to be propagated to the solver thread.                         logger.trace(""{}            Part thread ({}) exception that will be propagated to the solver thread."",                                 logIndentation, partIndex, throwable);                         partitionQueue.addExceptionThrown(partIndex, throwable);                     }                 });             }             for (PartitionChangeMove<Solution_> step : partitionQueue) {                 PartitionedSearchStepScope<Solution_> stepScope = new PartitionedSearchStepScope<>(phaseScope);                 stepStarted(stepScope);                 stepScope.setStep(step);                 if (logger.isDebugEnabled()) {                     stepScope.setStepString(step.toString());                 }                 doStep(stepScope);                 stepEnded(stepScope);                 phaseScope.setLastCompletedStepScope(stepScope);             }             phaseScope.addChildThreadsScoreCalculationCount(partitionQueue.getPartsCalculationCount());         } finally {             // In case one of the partition threads threw an Exception, it is propagated here             // but the other partition threads are not aware of the failure and may continue solving for a long time,             // so we need to ask them to terminate. In case no exception was thrown, this does nothing.             childThreadPlumbingTermination.terminateChildren();             ThreadUtils.shutdownAwaitOrKill(executor, logIndentation, ""Partitioned Search"");         }         phaseEnded(phaseScope);     }
public static BufferedImage resizeScreenshotIfNeeded(WebDriver driver, BufferedImage screenshotImage) {         Double devicePixelRatio = 1.0;          try {             devicePixelRatio = ((Number) ((JavascriptExecutor) driver).executeScript(JS_RETRIEVE_DEVICE_PIXEL_RATIO)).doubleValue();         } catch (Exception ex) {             ex.printStackTrace();         }          if (devicePixelRatio > 1.0 && screenshotImage.getWidth() > 0) {             Long screenSize = ((Number) ((JavascriptExecutor) driver).executeScript(""return Math.max("" +                             ""document.body.scrollWidth, document.documentElement.scrollWidth,"" +                             ""document.body.offsetWidth, document.documentElement.offsetWidth,"" +                             ""document.body.clientWidth, document.documentElement.clientWidth);""             )).longValue();              Double estimatedPixelRatio = ((double)screenshotImage.getWidth()) / ((double)screenSize);              if (estimatedPixelRatio > 1.0) {                  int newWidth = (int) (screenshotImage.getWidth() / estimatedPixelRatio);                 int newHeight = (int) (screenshotImage.getHeight() / estimatedPixelRatio);                  Image tmp = screenshotImage.getScaledInstance(newWidth, newHeight, Image.SCALE_SMOOTH);                 BufferedImage scaledImage = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_INT_RGB);                  Graphics2D g2d = scaledImage.createGraphics();                 g2d.drawImage(tmp, 0, 0, null);                 g2d.dispose();                  return scaledImage;             }             else return screenshotImage;         }         else return screenshotImage;     }
protected String resolveHelpText(Locale locale) {          String helpText = getHelpText().key(locale);         if ((getColumnForTexts() != null) && (getItem().get(getColumnForTexts()) != null)) {             helpText = new MessageFormat(helpText, locale).format(new Object[] {getItem().get(getColumnForTexts())});         }         return helpText;     }
private void setContentTypeHeader(final HttpResponse response, final URLConnection connection) {     response.headers().set(CONTENT_TYPE, mimeTypesMap.getContentType(connection.getURL().getPath()));   }
public Flowable<Transformed> one(String id) {     try {       return baseQuery()           .one(id)           .filter(new Predicate<CDAEntry>() {             @Override             public boolean test(CDAEntry entry) {               return entry.contentType().id()                   .equals(contentTypeId);             }           })           .map(new Function<CDAEntry, Transformed>() {             @Override             public Transformed apply(CDAEntry entry) throws Exception {               return TransformQuery.this.transform(entry);             }           });     } catch (NullPointerException e) {       throw new CDAResourceNotFoundException(CDAEntry.class, id);     }   }
public ServiceFuture<Void> verifyDomainOwnershipAsync(String resourceGroupName, String certificateOrderName, final ServiceCallback<Void> serviceCallback) {         return ServiceFuture.fromResponse(verifyDomainOwnershipWithServiceResponseAsync(resourceGroupName, certificateOrderName), serviceCallback);     }
@Override  public int compareTo(final Object o) {   DbEntityColumnDescriptor that = (DbEntityColumnDescriptor) o;   if (this.isId != that.isId) {    return this.isId ? -1 : 1;      // IDs should be the first in the array   }   return this.columnName.compareTo(that.columnName);  }
public TableIdx getTableIdx(final String _tableName,                                 final String... _keys)     {         TableIdx ret = null;         final String key = _tableName + ""-"" + StringUtils.join(_keys, ""-"");         final Optional<TableIdx> val = this.tableidxs.stream().filter(t -> t.getKey().equals(key)).findFirst();         if (val.isPresent()) {             ret = val.get();             ret.setCreated(false);         } else {             ret = new TableIdx().setCreated(true).setTable(_tableName).setIdx(this.currentIdx++).setKey(key);             this.tableidxs.add(ret);         }         return ret;     }
public static <L, K> void addListener (Map<K, ListenerList<L>> map, K key, L listener)     {         ListenerList<L> list = map.get(key);         if (list == null) {             map.put(key, list = new ListenerList<L>());         }         list.add(listener);     }
public static List<String> contentAsList( Iterable<Example> cells )     {         return new ArrayList<String>( Arrays.asList( content( cells ) ) );     }
Object readResolve() throws ObjectStreamException {         Bean<?> bean = Container.instance(contextId).services().get(ContextualStore.class).<Bean<Object>, Object>getContextual(beanId);         if (bean == null) {             throw BeanLogger.LOG.proxyDeserializationFailure(beanId);         }         return Container.instance(contextId).deploymentManager().getClientProxyProvider().getClientProxy(bean);     }
public void subscriber(String path,                         @Pin ServiceRefAmp serviceRef,                         Result<? super Cancel> result)   {     if (path.isEmpty()) {       result.fail(new ServiceException(L.l(""Invalid event location '{0}'"", path)));       return;     }      String address = address(path);      EventNodeAsset node = lookupPubSubNode(address);      Cancel cancel = node.subscribeImpl(serviceRef);      result.ok(cancel);   }
private void handleContextMenu(JTree tree, int x, int y) {   TreePath path = tree.getPathForLocation(x, y);   tree.setSelectionPath(path);   DefaultMutableTreeNode node = (DefaultMutableTreeNode) tree.getLastSelectedPathComponent();    if (node == null)    return;   if (!node.isLeaf()) {    tree.setSelectionPath(null);    return;   }   final AppInfo info = (AppInfo) node.getUserObject();    JMenuItem copyname = new JMenuItem(""Copy Name"");   copyname.addActionListener(e -> {    Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();    clipboard.setContents(new StringSelection(info.app.getSimpleName()), null);   });    JMenuItem copypath = new JMenuItem(""Copy Path"");   copypath.addActionListener(e -> {    String path1 = UtilIO.getSourcePath(info.app.getPackage().getName(), info.app.getSimpleName());    Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();    clipboard.setContents(new StringSelection(path1), null);   });    JMenuItem github = new JMenuItem(""Go to Github"");   github.addActionListener(e -> openInGitHub(info));    JPopupMenu submenu = new JPopupMenu();   submenu.add(copyname);   submenu.add(copypath);   submenu.add(github);   submenu.show(tree, x, y);  }
public void setESidCP(Integer newESidCP) {   Integer oldESidCP = eSidCP;   eSidCP = newESidCP;   if (eNotificationRequired())    eNotify(new ENotificationImpl(this, Notification.SET, AfplibPackage.ENCODING_SCHEME_ID__ESID_CP, oldESidCP, eSidCP));  }
public JobSpecMonitor forConfig(Config localScopeConfig, MutableJobCatalog jobCatalog) throws IOException {        Preconditions.checkArgument(localScopeConfig.hasPath(TEMPLATE_KEY));       Preconditions.checkArgument(localScopeConfig.hasPath(TOPIC_KEY));        String topic = localScopeConfig.getString(TOPIC_KEY);        URI baseUri;       try {         baseUri = new URI(localScopeConfig.getString(BASE_URI_KEY));       } catch (URISyntaxException use) {         throw new IOException(""Invalid base URI "" + localScopeConfig.getString(BASE_URI_KEY), use);       }        String templateURIString = localScopeConfig.getString(TEMPLATE_KEY);       URI template;       try {         template = new URI(templateURIString);       } catch (URISyntaxException uri) {         throw new IOException(""Invalid template URI "" + templateURIString);       }        ImmutableMap.Builder<String, String> mapBuilder = ImmutableMap.builder();       if (localScopeConfig.hasPath(EXTRACT_KEYS)) {         Config extractKeys = localScopeConfig.getConfig(EXTRACT_KEYS);         for (Map.Entry<String, ConfigValue> entry : extractKeys.entrySet()) {           Object unwrappedValue = entry.getValue().unwrapped();           if (unwrappedValue instanceof String) {             mapBuilder.put(entry.getKey(), (String) unwrappedValue);           }         }       }       Map<String, String> extractKeys = mapBuilder.build();        Optional<Pattern> urnFilter = localScopeConfig.hasPath(DATASET_URN_FILTER_KEY)           ? Optional.of(Pattern.compile(localScopeConfig.getString(DATASET_URN_FILTER_KEY)))           : Optional.<Pattern>absent();       Optional<Pattern> nameFilter = localScopeConfig.hasPath(EVENT_NAME_FILTER_KEY)           ? Optional.of(Pattern.compile(localScopeConfig.getString(EVENT_NAME_FILTER_KEY)))           : Optional.<Pattern>absent();        SchemaVersionWriter versionWriter;       try {         versionWriter = (SchemaVersionWriter) GobblinConstructorUtils.             invokeLongestConstructor(Class.forName(localScopeConfig.getString(SCHEMA_VERSION_READER_CLASS)), localScopeConfig);       } catch (ReflectiveOperationException roe) {         throw new IllegalArgumentException(roe);       }        return new SLAEventKafkaJobMonitor(topic, jobCatalog, baseUri, localScopeConfig, versionWriter,           urnFilter, nameFilter, template, extractKeys);     }
public static List<CommercePriceListUserSegmentEntryRel> toModels(   CommercePriceListUserSegmentEntryRelSoap[] soapModels) {   if (soapModels == null) {    return null;   }    List<CommercePriceListUserSegmentEntryRel> models = new ArrayList<CommercePriceListUserSegmentEntryRel>(soapModels.length);    for (CommercePriceListUserSegmentEntryRelSoap soapModel : soapModels) {    models.add(toModel(soapModel));   }    return models;  }
public final N adjacentNode(Object node) {     if (node.equals(nodeU)) {       return nodeV;     } else if (node.equals(nodeV)) {       return nodeU;     } else {       throw new IllegalArgumentException(""EndpointPair "" + this + "" does not contain node "" + node);     }   }
private void importResource(Node parentNode, InputStream file_in, String resourceType, ArtifactDescriptor artifact)             throws RepositoryException    {       // Note that artifactBean been initialized within constructor       // resourceType can be jar, pom, metadata        String filename;       if (resourceType.equals(""metadata""))       {          filename = ""maven-metadata.xml"";       }       else       {          filename = String.format(""%s-%s.%s"", artifact.getArtifactId(), artifact.getVersionId(), resourceType);       }        OutputStream fout = null;       File tmp_file = null;       try       {          String tmpFilename = getUniqueFilename(filename);          tmp_file = File.createTempFile(tmpFilename, null);          fout = new FileOutputStream(tmp_file);          IOUtils.copy(file_in, fout);          fout.flush();       }       catch (FileNotFoundException e)       {          LOG.error(""Cannot create .tmp file for storing artifact"", e);       }       catch (IOException e)       {          LOG.error(""IO exception on .tmp file for storing artifact"", e);       }       finally       {          IOUtils.closeQuietly(file_in);          IOUtils.closeQuietly(fout);       }        writePrimaryContent(parentNode, filename, resourceType, tmp_file);       writeChecksum(parentNode, filename, tmp_file, ""SHA1"");        try       {          // and collect all garbage : temporary files          FileUtils.forceDelete(tmp_file);       }       catch (IOException e)       {          LOG.error(""Cannot delete tmp file"", e);       }     }
public void setViewHeight(int newHeight) {     if (newHeight > 0) {       originalHeight = newHeight;       RelativeLayout.LayoutParams layoutParams =           (RelativeLayout.LayoutParams) view.getLayoutParams();       layoutParams.height = newHeight;       view.setLayoutParams(layoutParams);     }   }
@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<Boolean> all(Predicate<? super T> predicate) {         ObjectHelper.requireNonNull(predicate, ""predicate is null"");         return RxJavaPlugins.onAssembly(new ObservableAllSingle<T>(this, predicate));     }
public IIsotope[] getIsotopes(double exactMass, double difference) {         List<IIsotope> list = new ArrayList<>();         for (List<IIsotope> isotopes : this.isotopes) {             if (isotopes == null) continue;             for (IIsotope isotope : isotopes) {                 if (Math.abs(isotope.getExactMass() - exactMass) <= difference) {                     list.add(clone(isotope));                 }             }         }         return list.toArray(new IIsotope[list.size()]);     }
protected void connect(SocketAddress address, int timeout)             throws IOException {         boolean connected = false;         try {             if (address == null || !(address instanceof InetSocketAddress))                 throw new IllegalArgumentException(""unsupported address type"");             InetSocketAddress addr = (InetSocketAddress) address;             if (addr.isUnresolved())                 throw new UnknownHostException(addr.getHostName());             this.port = addr.getPort();             this.address = addr.getAddress();              connectToAddress(this.address, port, timeout);             connected = true;         } finally {             if (!connected) {                 try {                     close();                 } catch (IOException ioe) {                     /* Do nothing. If connect threw an exception then                        it will be passed up the call stack */                 }             }         }     }
public static Matrix readMatrix(File matrix, Format format)              throws IOException {          switch (format) {              // Assume all sparse formats will fit in memory.              case SVDLIBC_SPARSE_TEXT:              case SVDLIBC_SPARSE_BINARY:              case MATLAB_SPARSE:              case CLUTO_SPARSE:                  return readMatrix(matrix, format,                                     Type.SPARSE_IN_MEMORY, false);              // Assume all dense formats will fit in memory.              case SVDLIBC_DENSE_TEXT:              case SVDLIBC_DENSE_BINARY:              case DENSE_TEXT:              case CLUTO_DENSE:                  return readMatrix(matrix, format,                                    Type.DENSE_IN_MEMORY, false);              default:                  throw new Error(                          ""Reading matrices of "" + format + "" format is not ""+                          ""currently supported. Email "" +                          ""s-space-research-dev@googlegroups.com to request "" +                          ""its inclusion and it will be quickly added"");          }      }
public static String getContentFromUrlAsString(String url, Map inCookies, Map outCookies, boolean trustAllCerts)     {         byte[] bytes = getContentFromUrl(url, inCookies, outCookies, trustAllCerts);         return bytes == null ? null : StringUtilities.createString(bytes, ""UTF-8"");     }
public final void setAdditionalProperties(final Map<String, String> additionalProperties) {          // no need for validation, the method will create a new (empty) object if the provided parameter is null.          // create a defensive copy of the map and all its properties         if (additionalProperties == null) {             // create a new (empty) properties map if the provided parameter was null             this.additionalProperties = new ConcurrentHashMap<>();         } else {             // create a defensive copy of the map and all its properties             // the code looks a little more complicated than a simple ""putAll()"", but it catches situations             // where a Map is provided that supports null values (e.g. a HashMap) vs Map implementations             // that do not (e.g. ConcurrentHashMap).             this.additionalProperties = new ConcurrentHashMap<>();             for (final Map.Entry<String, String> entry : additionalProperties.entrySet()) {                 final String key = entry.getKey();                 final String value = entry.getValue();                  if (value != null) {                     this.additionalProperties.put(key, value);                 }             }         }     }
private Type findType(String typeString) throws UnknownDashletTypeException {   if (""viewReport"".equalsIgnoreCase(typeString)) {    return Type.VIEW;   } else if (""textContent"".equalsIgnoreCase(typeString)) {    return Type.TEXT;   }   throw new UnknownDashletTypeException(typeString);  }
public static boolean isSuperSenseFeatures(final TrainingParameters params) {     final String mfsFeatures = getSuperSenseFeatures(params);     return !mfsFeatures.equalsIgnoreCase(Flags.DEFAULT_FEATURE_FLAG);   }
protected void shutdown() throws InterruptedException {         if (m_deadConnectionFuture != null) {             m_deadConnectionFuture.cancel(false);             try {m_deadConnectionFuture.get();} catch (Throwable t) {}         }         if (m_topologyCheckFuture != null) {             m_topologyCheckFuture.cancel(false);             try {m_topologyCheckFuture.get();} catch (Throwable t) {}         }         if (m_maxConnectionUpdater != null) {             m_maxConnectionUpdater.cancel(false);         }         if (m_acceptor != null) {             m_acceptor.shutdown();         }         if (m_adminAcceptor != null)         {             m_adminAcceptor.shutdown();         }         if (m_snapshotDaemon != null) {             m_snapshotDaemon.shutdown();         }          if (m_migratePartitionLeaderExecutor != null) {             m_migratePartitionLeaderExecutor.shutdown();         }         m_notifier.shutdown();     }
public static FloatBinding nextAfter(final float start, final ObservableFloatValue direction) {         return createFloatBinding(() -> Math.nextAfter(start, direction.get()), direction);     }
private URI computeEndpoint() {         String endpoint = this.config.getEndpoint();         try {             if (endpoint == null) {                 if (this.isRegionSupported()) {                     endpoint = String.format(""%s://%s.%s.%s"", this.config.getProtocol(), this.serviceId,                             this.config.getRegion(), AbstractBceClient.DEFAULT_SERVICE_DOMAIN);                 } else {                     endpoint = String.format(""%s://%s.%s"", this.config.getProtocol(), this.serviceId,                             AbstractBceClient.DEFAULT_SERVICE_DOMAIN);                 }             }             return new URI(endpoint);         } catch (URISyntaxException e) {             // only if the endpoint specified in the client configuration is not a valid URI, which is not expected.             throw new IllegalArgumentException(""Invalid endpoint."" + endpoint, e);         }     }
public final synchronized void stop() {   LaunchingMessageKind.IJMX0003.format();   unRegisterMBeans();    try {    if (this.jmxConnectorServer != null) {     this.jmxConnectorServer.stop();    }   } catch (IOException e1) {    // Do nothing   }   try {    UnicastRemoteObject.unexportObject(register, true);   } catch (NoSuchObjectException e) {    // Do nothing   }  }
public void setButtons(java.util.Collection<Button> buttons) {         if (buttons == null) {             this.buttons = null;             return;         }          this.buttons = new java.util.ArrayList<Button>(buttons);     }
@SuppressWarnings({ ""resource"" })  protected boolean runJavaCompiler(File classDirectory, Iterable<File> sourcePathDirectories,    Iterable<File> classPathEntries, boolean enableCompilerOutput,    boolean enableOptimization, IProgressMonitor progress) {   String encoding = this.encodingProvider.getDefaultEncoding();   if (Strings.isEmpty(encoding)) {    encoding = null;   }   if (progress.isCanceled()) {    return false;   }   final PrintWriter outWriter = getStubCompilerOutputWriter();   final PrintWriter errWriter;   if (enableCompilerOutput) {    errWriter = getErrorCompilerOutputWriter();   } else {    errWriter = getStubCompilerOutputWriter();   }   if (progress.isCanceled()) {    return false;   }   return getJavaCompiler().compile(     classDirectory,     sourcePathDirectories,     classPathEntries,     getBootClassPath(),     getJavaSourceVersion(),     encoding,     isJavaCompilerVerbose(),     enableOptimization ? getOptimizationLevel() : null,     outWriter,     errWriter,     getLogger(),     progress);  }
public FastBuildTree putUnsafe(String name, Object value) {    map.put(name, value);    return this;   }
@Override   public final Field[] retrieveFields(final Class<?> clazz) {     Set<Field> fieldsSet = new HashSet<Field>();     for (Field fld : clazz.getDeclaredFields()) {       int modifiersMask = fld.getModifiers();       if ((modifiersMask & Modifier.PRIVATE) > 0             && (modifiersMask & Modifier.STATIC) == 0) {         fieldsSet.add(fld);       }     }     final Class<?> superClazz = clazz.getSuperclass();     if (superClazz != null && superClazz != java.lang.Object.class) {       for (Field fld : retrieveFields(superClazz)) {         fieldsSet.add(fld);       }     }     return fieldsSet.toArray(new Field[fieldsSet.size()]);   }
private DockerSlave provisionWithWait(DockerSlaveTemplate template, ProvisioningActivity.Id id)             throws Exception {         final DockerContainerLifecycle dockerContainerLifecycle = template.getDockerContainerLifecycle();         final String imageId = dockerContainerLifecycle.getImage();         final DockerComputerLauncher computerLauncher = template.getLauncher();          //pull image         dockerContainerLifecycle.getPullImage().exec(getClient(), imageId, new StreamTaskListener(new NullStream()));          // set the operating system if it's not already cached         if (template.getOsType() == null) {             template.setOsType(determineOsType(imageId));         }          LOG.debug(""Trying to run container for {}, operating system {}"", imageId, template.getOsType());         final String containerId = runContainer(template);          InspectContainerResponse ir;         try {             ir = getClient().inspectContainerCmd(containerId).exec();         } catch (ProcessingException ex) {             LOG.error(""Failed to run container for {}, clean-up container"", imageId);             dockerContainerLifecycle.getRemoveContainer().exec(getClient(), containerId);             throw ex;         }          // Build a description up:         String nodeDescription = ""Docker Node ["" + imageId + "" on "";         try {             nodeDescription += getDisplayName();         } catch (Exception ex) {             nodeDescription += ""???"";         }         nodeDescription += ""]"";          String slaveName = String.format(""%s-%s"", getDisplayName(), containerId.substring(0, 12));          if (computerLauncher.waitUp(getDisplayName(), template, ir)) {             LOG.debug(""Container {} is ready for slave connection"", containerId);         } else {             LOG.error(""Container {} is not ready for slave connection."", containerId);         }          final DockerComputerLauncher launcher = computerLauncher.getPreparedLauncher(getDisplayName(), template, ir);         return new DockerSlave(slaveName, nodeDescription, launcher, containerId, template, getDisplayName(), id);     }
@Override  public List<CommerceWishList> findByG_U_D(long groupId, long userId,   boolean defaultWishList, int start, int end) {   return findByG_U_D(groupId, userId, defaultWishList, start, end, null);  }
protected static SecurityContext createSC(String user, String... roles) {         final Subject subject = new Subject();          final Principal principal = new SimplePrincipal(user);         subject.getPrincipals().add(principal);          if (roles != null) {             for (final String role : roles) {                 subject.getPrincipals().add(new SimplePrincipal(role));             }         }         return new DefaultSecurityContext(principal, subject);     }
@Override  public List<CommercePriceEntry> findByGroupId(long groupId, int start,   int end) {   return findByGroupId(groupId, start, end, null);  }
public String getLabel() {    if (log.isLoggable(Level.FINER)) {     final String methodName = ""getLabel""; //$NON-NLS-1$     log.entering(DependencyList.class.getName(), methodName);     log.exiting(DependencyList.class.getName(), methodName, label);    }    return label;   }
public static boolean execute(     final File source, final File destination, boolean renameEmptyFiles) {     if (renameEmptyFiles || (source.length() > 0)) {       return source.renameTo(destination);     }      return source.delete();   }
public void addSuggestions(final @NonNull SuggestionsResult result,                                final @NonNull String bucket,                                final @NonNull TokenSource source) {         // Add result to proper bucket and remove from waiting         QueryToken query = result.getQueryToken();         synchronized (mLock) {             mResultMap.put(bucket, result);             Set<String> waitingForBuckets = mWaitingForResults.get(query);             if (waitingForBuckets != null) {                 waitingForBuckets.remove(bucket);                 if (waitingForBuckets.size() == 0) {                     mWaitingForResults.remove(query);                 }             }         }          // Rebuild the list of suggestions in the appropriate order         String currentTokenString = source.getCurrentTokenString();         synchronized (mLock) {             mSuggestions.clear();             List<Suggestible> suggestions = mSuggestionsListBuilder.buildSuggestions(mResultMap, currentTokenString);              // If we have suggestions, add them to the adapter and display them             if (suggestions.size() > 0) {                 mSuggestions.addAll(suggestions);                 mSuggestionsVisibilityManager.displaySuggestions(true);             } else {                 hideSuggestionsIfNecessary(result.getQueryToken(), source);             }         }          notifyDataSetChanged();     }
void fireMemberAdded(AsteriskQueueMemberImpl member)     {         synchronized (listeners)         {             for (AsteriskQueueListener listener : listeners)             {                 try                 {                     listener.onMemberAdded(member);                 }                 catch (Exception e)                 {                     logger.warn(""Exception in onMemberAdded()"", e);                 }             }         }     }
public static JMXServiceURL getLocalConnectorAddress(Process p, boolean startAgent) {         return getLocalConnectorAddress(Integer.toString(getPid(p)), startAgent);     }
public boolean removeBusLine(String name) {   final Iterator<BusLine> iterator = this.busLines.iterator();   BusLine busLine;   int i = 0;   while (iterator.hasNext()) {    busLine = iterator.next();    if (name.equals(busLine.getName())) {     iterator.remove();     busLine.setContainer(null);     busLine.setEventFirable(true);     fireShapeChanged(new BusChangeEvent(this,       BusChangeEventType.LINE_REMOVED,       busLine,       i,       ""shape"", //$NON-NLS-1$       null,       null));     checkPrimitiveValidity();     return true;    }    ++i;   }   return false;  }
@Override     public final SubmitterDocument findByRootAndString(             final RootDocument rootDocument, final String string) {         final SubmitterDocument submitterDocument =                 findByFileAndString(rootDocument.getFilename(), string);         if (submitterDocument == null) {             return null;         }         final Submitter submitter = submitterDocument.getGedObject();         submitter.setParent(rootDocument.getGedObject());         return submitterDocument;     }
public static CassandraThriftFacade forSeedsAndPort(String seeds, int defaultPort) {         final String seed = seeds.contains("","") ? seeds.substring(0, seeds.indexOf(',')) : seeds;         HostAndPort host = HostAndPort.fromString(seed).withDefaultPort(defaultPort);         return new CassandraThriftFacade(new TFramedTransport(new TSocket(host.getHostText(), host.getPort())));     }
public XmlWriter createXMLWriter(final String systemId) throws KNXMLException  {   final XmlResolver res = new XmlResolver();   final OutputStream os = res.resolveOutput(systemId);   return create(os, true);  }
public void cmdProc(Interp interp, TclObject argv[])     throws TclException {         int currentObjIndex, len, i;         int objc = argv.length - 1;         boolean doBackslashes = true;         boolean doCmds = true;         boolean doVars = true;         StringBuffer result = new StringBuffer();         String s;         char c;          for (currentObjIndex = 1; currentObjIndex < objc; currentObjIndex++) {             if (!argv[currentObjIndex].toString().startsWith(""-"")) {                 break;             }             int opt = TclIndex.get(interp, argv[currentObjIndex],                             validCmds, ""switch"", 0);             switch (opt) {                 case OPT_NOBACKSLASHES:                     doBackslashes = false;                     break;                 case OPT_NOCOMMANDS:                     doCmds = false;                     break;                 case OPT_NOVARS:                     doVars = false;                     break;                 default:                     throw new TclException(interp,                                     ""SubstCrCmd.cmdProc: bad option "" + opt                                     + "" index to cmds"");             }         }         if (currentObjIndex != objc) {             throw new TclNumArgsException(interp, currentObjIndex, argv,                             ""?-nobackslashes? ?-nocommands? ?-novariables? string"");         }          /*          * Scan through the string one character at a time, performing          * command, variable, and backslash substitutions.          */          s = argv[currentObjIndex].toString();         len = s.length();         i = 0;         while (i < len) {             c = s.charAt(i);              if ((c == '[') && doCmds) {                 ParseResult res;                 try {                     interp.evalFlags = Parser.TCL_BRACKET_TERM;                     interp.eval(s.substring(i + 1, len));                     TclObject interp_result = interp.getResult();                     interp_result.preserve();                     res = new ParseResult(interp_result,                                     i + interp.termOffset);                 } catch (TclException e) {                     i = e.errIndex + 1;                     throw e;                 }                 i = res.nextIndex + 2;                 result.append( res.value.toString() );                 res.release();                 /**                  * Removed                  (ToDo) may not be portable on Mac                 } else if (c == '\r') {                    i++;                  */             } else if ((c == '$') && doVars) {                 ParseResult vres = Parser.parseVar(interp,                                 s.substring(i, len));                 i += vres.nextIndex;                 result.append( vres.value.toString() );                 vres.release();             } else if ((c == '\\') && doBackslashes) {                 BackSlashResult bs = Interp.backslash(s, i, len);                 i = bs.nextIndex;                 if (bs.isWordSep) {                     break;                 } else {                     result.append( bs.c );                 }             } else {                 result.append( c );                 i++;             }         }          interp.setResult(result.toString());     }
public boolean addGrant(       ClusterNode node, String sessionId, ResourceRequestInfo req) {     synchronized (node) {       if (node.deleted) {         return false;       }       if (!node.checkForGrant(Utilities.getUnitResourceRequest(         req.getType()), resourceLimit)) {         return false;       }        node.addGrant(sessionId, req);       loadManager.incrementLoad(req.getType());       hostsToSessions.get(node).add(sessionId);       if (!node.checkForGrant(Utilities.getUnitResourceRequest(         req.getType()), resourceLimit)) {         RunnableIndices r = typeToIndices.get(req.getType());         r.deleteRunnable(node);       }     }     return true;   }
public DataSetIterator getTrainIterator() {         return new DataSetIterator() {             @Override             public DataSet next(int i) {                 throw new UnsupportedOperationException();             }              @Override             public List<String> getLabels() {                 return backedIterator.getLabels();             }              @Override             public int inputColumns() {                 return backedIterator.inputColumns();             }              @Override             public void remove() {                 throw new UnsupportedOperationException();             }              @Override             public int totalOutcomes() {                 return backedIterator.totalOutcomes();             }              @Override             public boolean resetSupported() {                 return backedIterator.resetSupported();             }              @Override             public boolean asyncSupported() {                 return backedIterator.asyncSupported();             }              @Override             public void reset() {                 resetPending.set(true);             }              @Override             public int batch() {                 return backedIterator.batch();             }              @Override             public void setPreProcessor(DataSetPreProcessor dataSetPreProcessor) {                 backedIterator.setPreProcessor(dataSetPreProcessor);             }              @Override             public DataSetPreProcessor getPreProcessor() {                 return backedIterator.getPreProcessor();             }               @Override             public boolean hasNext() {                 if (resetPending.get()) {                     if (resetSupported()) {                         backedIterator.reset();                         counter.set(0);                         resetPending.set(false);                     } else                         throw new UnsupportedOperationException(""Reset isn't supported by underlying iterator"");                 }                  val state = backedIterator.hasNext();                 if (state && counter.get() < numTrain)                     return true;                 else                     return false;             }              @Override             public DataSet next() {                 counter.incrementAndGet();                 val p = backedIterator.next();                  if (counter.get() == 1 && firstTrain == null) {                     // first epoch ever, we'll save first dataset and will use it to check for equality later                     firstTrain =  p.copy();                     firstTrain.detach();                 } else if (counter.get() == 1) {                     // epoch > 1, comparing first dataset to previously stored dataset. they should be equal                     int cnt = 0;                     if (!p.getFeatures().equalsWithEps(firstTrain.getFeatures(), 1e-5))                         throw new ND4JIllegalStateException(""First examples do not match. Randomization was used?"");                 }                  return p;             }         };     }
public void sign(PrivateKey key, String digest) throws NoSuchAlgorithmException, NoSuchPaddingException,         InvalidKeyException, BadPaddingException, IllegalBlockSizeException {         add(Feature.Create.stringFeature(DIGEST_KEY, digest));         final var digester = MessageDigest.getInstance(digest);         final var ser = unsigned();         final var digestValue = digester.digest(ser);         final var cipher = Cipher.getInstance(key.getAlgorithm());         cipher.init(Cipher.ENCRYPT_MODE, key);         final var signature = cipher.doFinal(digestValue);         add(signature);     }
