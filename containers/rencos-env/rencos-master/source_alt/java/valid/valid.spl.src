public static MediaTable create(String tableName, String idColumnName,    List<UserCustomColumn> additionalColumns) {    List<UserCustomColumn> columns = new ArrayList<>();   columns.addAll(createRequiredColumns(idColumnName));    if (additionalColumns != null) {    columns.addAll(additionalColumns);   }    return new MediaTable(tableName, columns, idColumnName);  }
public boolean isAsync() {         return invokeType != null && (RpcConstants.INVOKER_TYPE_CALLBACK.equals(invokeType)             || RpcConstants.INVOKER_TYPE_FUTURE.equals(invokeType));     }
protected final static int getConversionFnid(int authoritative_type, int new_type) {         if (new_type == authoritative_type) return 0;         switch (new_type) {             case AS_TYPE.null_value:                 assert( authoritative_type == AS_TYPE.string_value );                 return from_string_conversion[AS_TYPE.null_value];             case AS_TYPE.boolean_value:                 assert( authoritative_type == AS_TYPE.string_value );                 return from_string_conversion[AS_TYPE.boolean_value];             case AS_TYPE.int_value:                 return to_int_conversion[authoritative_type];             case AS_TYPE.long_value:                 return to_long_conversion[authoritative_type];             case AS_TYPE.bigInteger_value:                 return to_bigInteger_conversion[authoritative_type];             case AS_TYPE.decimal_value:                 return to_decimal_conversion[authoritative_type];             case AS_TYPE.double_value:                 return to_double_conversion[authoritative_type];             case AS_TYPE.string_value:                 return to_string_conversions[authoritative_type];             case AS_TYPE.date_value:                 assert( authoritative_type == AS_TYPE.timestamp_value );                 return FNID_FROM_TIMESTAMP_TO_DATE;             case AS_TYPE.timestamp_value:                 assert( authoritative_type == AS_TYPE.date_value );                 return FNID_FROM_DATE_TO_TIMESTAMP;         }         String message = ""can't convert from ""                        + getValueTypeName(authoritative_type)                        + "" to ""                        + getValueTypeName(new_type);         throw new CantConvertException(message);     }
protected void setNextValue(final long pValue, final int pLength, final int pMaxSize) {    long value = pValue;    // Set to max value if pValue cannot be stored on pLength bits.    long bitMax = (long) Math.pow(2, Math.min(pLength, pMaxSize));    if (pValue > bitMax) {     value = bitMax - 1;    }    // size to wrote    int writeSize = pLength;    while (writeSize > 0) {     // modulo     int mod = currentBitIndex % BYTE_SIZE;     byte ret = 0;     if (mod == 0 && writeSize <= BYTE_SIZE || pLength < BYTE_SIZE - mod) {      // shift left value      ret = (byte) (value << BYTE_SIZE - (writeSize + mod));     } else {      // shift right      long length = Long.toBinaryString(value).length();      ret = (byte) (value >> writeSize - length - (BYTE_SIZE - length - mod));     }     byteTab[currentBitIndex / BYTE_SIZE] |= ret;     long val = Math.min(writeSize, BYTE_SIZE - mod);     writeSize -= val;     currentBitIndex += val;    }   }
@SafeVarargs     public static Function<CharSequence, TemporalAccessor> orderedParseAttempter(Function<CharSequence, TemporalAccessor>... parsers) {         return date -> {             RuntimeException first = null;             for (Function<CharSequence, TemporalAccessor> parser : parsers) {                 try { return parser.apply(date); }                 catch (RuntimeException ex) {                     if (first == null) first = ex;                 }             }             if (first == null) throw new IllegalStateException(""Empty parse attempter"");             throw first;         };     }
@Override     public Predicate lt(Expression<? extends Number> arg0, Number arg1)     {         return new ComparisonPredicate(arg0, arg1, ConditionalOperator.LT);     }
protected Map<String, WeakReference<T>> getClassLoaderCache(ClassLoader cl)    {       synchronized (cache)       {          Map<String, WeakReference<T>> result = cache.get(cl);          if (result == null)          {             result = CollectionsFactory.createConcurrentReaderMap();             cache.put(cl, result);          }          return result;       }    }
protected final Value decodeNumberLax(boolean minus) {         char[] array = charArray;          final int startIndex = __index;         int index = __index;         char currentChar;         boolean doubleFloat = false;         boolean foundDot = false;         boolean foundSign = false;         boolean foundExp = false;          if (minus && index + 1 < array.length) {             index++;         }          while (true) {             currentChar = array[index];             if (isNumberDigit(currentChar)) {                 //noop             } else if (currentChar <= 32) { //white                 break;             } else if (isDelimiter(currentChar)) {                 break;             } else if (isDecimalChar(currentChar)) {                 switch (currentChar) {                     case DECIMAL_POINT:                         if (foundDot || foundExp) { return decodeStringLax(); }                         foundDot = true;                         break;                     case LETTER_E:                     case LETTER_BIG_E:                         if (foundExp) { return decodeStringLax(); }                         foundExp = true;                         break;                     case MINUS:                     case PLUS:                         if (foundSign || !foundExp) { return decodeStringLax(); }                         if (foundExp && array[index - 1] != LETTER_E && array[index - 1] != LETTER_BIG_E) {                             return decodeStringLax();                         }                         foundSign = true;                         break;                 }                 doubleFloat = true;             } else {                 return decodeStringLax();             }             index++;             if (index >= array.length) break;         }          // Handle the case where the exponential number ends without the actual exponent         if (foundExp) {             char prevChar = array[index - 1];             if (prevChar == LETTER_E || prevChar == LETTER_BIG_E || prevChar == MINUS || prevChar == PLUS) {                 return decodeStringLax();             }         }          __index = index;         __currentChar = currentChar;          Type type = doubleFloat ? Type.DOUBLE : Type.INTEGER;          return new NumberValue(chop, type, startIndex, __index, this.charArray);     }
public CandidateList getStatewide(String stateId) throws VoteSmartException, VoteSmartErrorException {    return api.query(""Officials.getStatewide"", new ArgMap(""stateId"", stateId), CandidateList.class );   }
public com.google.privacy.dlp.v2.FixedSizeBucketingConfigOrBuilder       getFixedSizeBucketingConfigOrBuilder() {     if (transformationCase_ == 5) {       return (com.google.privacy.dlp.v2.FixedSizeBucketingConfig) transformation_;     }     return com.google.privacy.dlp.v2.FixedSizeBucketingConfig.getDefaultInstance();   }
private static int parseOffsetISO8601(String text, ParsePosition pos, boolean extendedOnly, Output<Boolean> hasDigitOffset) {         if (hasDigitOffset != null) {             hasDigitOffset.value = false;         }         int start = pos.getIndex();         if (start >= text.length()) {             pos.setErrorIndex(start);             return 0;         }          char firstChar = text.charAt(start);         if (Character.toUpperCase(firstChar) == ISO8601_UTC.charAt(0)) {             // ""Z"" - indicates UTC             pos.setIndex(start + 1);             return 0;         }          int sign;         if (firstChar == '+') {             sign = 1;         } else if (firstChar == '-') {             sign = -1;         } else {             // Not an ISO 8601 offset string             pos.setErrorIndex(start);             return 0;         }         ParsePosition posOffset = new ParsePosition(start + 1);         int offset = parseAsciiOffsetFields(text, posOffset, ':', OffsetFields.H, OffsetFields.HMS);         if (posOffset.getErrorIndex() == -1 && !extendedOnly && (posOffset.getIndex() - start <= 3)) {             // If the text is successfully parsed as extended format with the options above, it can be also parsed             // as basic format. For example, ""0230"" can be parsed as offset 2:00 (only first digits are valid for             // extended format), but it can be parsed as offset 2:30 with basic format. We use longer result.             ParsePosition posBasic = new ParsePosition(start + 1);             int tmpOffset = parseAbuttingAsciiOffsetFields(text, posBasic, OffsetFields.H, OffsetFields.HMS, false);             if (posBasic.getErrorIndex() == -1 && posBasic.getIndex() > posOffset.getIndex()) {                 offset = tmpOffset;                 posOffset.setIndex(posBasic.getIndex());             }         }          if (posOffset.getErrorIndex() != -1) {             pos.setErrorIndex(start);             return 0;         }          pos.setIndex(posOffset.getIndex());         if (hasDigitOffset != null) {             hasDigitOffset.value = true;         }         return sign * offset;     }
@Generated(value = ""com.sun.tools.xjc.Driver"", date = ""2018-10-12T02:54:50+02:00"", comments = ""JAXB RI v2.2.11"")     public void setBueroTyp(BueroPraxen.BueroTyp value) {         this.bueroTyp = value;     }
@Override     public boolean isConnectedTo(IBond bond) {         for (IAtom atom : atoms) {             if (bond.contains(atom)) return true;         }         return false;     }
private Locale getLocale() {         Locale userlocale = null;         if (localeName.length() > 0) {             int firstuscore = localeName.indexOf('_');             int seconduscore = -1;             String language = null;             String country = null;             String variant = null;             if (firstuscore == 2) {                 language = localeName.substring(0, firstuscore);                 seconduscore = localeName.indexOf('_', firstuscore + 1);                 if (seconduscore > 0) {                     if (seconduscore != firstuscore + 3 ||                            localeName.length() <= seconduscore + 1) {                         docenv.error(null, ""main.malformed_locale_name"", localeName);                         return null;                     }                     country = localeName.substring(firstuscore + 1,                                                    seconduscore);                     variant = localeName.substring(seconduscore + 1);                 } else if (localeName.length() == firstuscore + 3) {                     country = localeName.substring(firstuscore + 1);                 } else {                     docenv.error(null, ""main.malformed_locale_name"", localeName);                     return null;                 }             } else if (firstuscore == -1 && localeName.length() == 2) {                 language = localeName;             } else {                 docenv.error(null, ""main.malformed_locale_name"", localeName);                 return null;             }             userlocale = searchLocale(language, country, variant);             if (userlocale == null) {                 docenv.error(null, ""main.illegal_locale_name"", localeName);                 return null;             } else {                 return userlocale;             }         } else {             return Locale.getDefault();         }     }
@Override     public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {         if (handshakeOccurred.get()) {             return super.onHeadersReceived(headers);         }         return STATE.CONTINUE;     }
public void addChildrenOf(CSTNode of) {         for (int i = 1; i < of.size(); i++) {             add(of.get(i));         }     }
public void setDestinationResolver(DestinationResolver destinationResolver) {         Assert.notNull(destinationResolver, ""destinationResolver must not be null"");         this.jmsTemplate.setDestinationResolver(destinationResolver);         this.messageListenerContainer.setDestinationResolver(destinationResolver);     }
public static String repeat(final String s, final int repeat) {         if (s == null) {             return null;         }         if (repeat <= 0) {             return """";         }         final int inputLength = s.length();         if (repeat == 1 || inputLength == 0) {             return s;         }          final int outputLength = inputLength * repeat;         switch (inputLength) {         case 1:             return repeat(s.charAt(0), repeat);         case 2:             final char ch0 = s.charAt(0);             final char ch1 = s.charAt(1);             final char[] output2 = new char[outputLength];             for (int i = repeat * 2 - 2; i >= 0; i--, i--) {                 output2[i] = ch0;                 output2[i + 1] = ch1;             }             return new String(output2);         default:             final StringBuilder buf = new StringBuilder(outputLength);             for (int i = 0; i < repeat; i++) {                 buf.append(s);             }             return buf.toString();         }     }
public int convertTo(StringToUniqueIntegerMap other, int localId) {         if (other == null) {             throw new IllegalStateException(""Other map is null"");         }         String localKey = store.reverseGet(localId);         if (localKey == null) {             throw new IllegalArgumentException(""Cannot convert an id that is not registered locally."");         }          Integer foreignId = null;          if (other == this) {             return localId;         } else if (other == parent) {             foreignId = thisToParentMap.get(localId);         } else if (other.parent == this) {             foreignId = other.parentToThisMap.get(localId);         }          // Cache hit         if (foreignId != null) {             return foreignId;         }          Integer integerForeignId = other.store.get(localKey);          // The other map doesn't have an entry for this key         if (integerForeignId == null) {             integerForeignId = other.register(localKey);         }          // Add the key/value pair to the cache         if (other == parent) {             thisToParentMap.set(localId, integerForeignId);             parentToThisMap.set(integerForeignId, localId);         } else if (other.parent == this) {             other.thisToParentMap.set(integerForeignId, localId);             other.parentToThisMap.set(localId, integerForeignId);         }          return integerForeignId;     }
@SuppressWarnings(""Unchecked"")     public static Object checkImmutable(String className, String fieldName, Object field) {         if (field == null || field instanceof Enum || inImmutableList(field.getClass().getName())) return field;         if (field instanceof Collection) return DefaultGroovyMethods.asImmutable((Collection) field);         if (field.getClass().getAnnotation(MY_CLASS) != null) return field;         final String typeName = field.getClass().getName();         throw new RuntimeException(createErrorMessage(className, fieldName, typeName, ""constructing""));     }
void markAsCollapsedCommand(HystrixCollapserKey collapserKey, int sizeOfBatch) {         eventNotifier.markEvent(HystrixEventType.COLLAPSED, this.commandKey);         executionResult = executionResult.markCollapsed(collapserKey, sizeOfBatch);     }
public <O extends BaseOption> ArgumentParser add(O option) {         if (option.getName() != null) {             if (longNameOptions.containsKey(option.getName())) {                 throw new IllegalArgumentException(""Option "" + option.getName() + "" already exists"");             }             if (parent != null && parent.longNameOptions.containsKey(option.getName())) {                 throw new IllegalArgumentException(""Option "" + option.getName() + "" already exists in parent"");             }              longNameOptions.put(option.getName(), option);         }          if (option instanceof Flag) {             String negate = ((Flag) option).getNegateName();             if (negate != null) {                 if (longNameOptions.containsKey(negate)) {                     throw new IllegalArgumentException(""Flag "" + negate + "" already exists"");                 }                 if (parent != null && parent.longNameOptions.containsKey(negate)) {                     throw new IllegalArgumentException(""Flag "" + negate + "" already exists in parent"");                 }                  longNameOptions.put(negate, option);             }         }          if (option.getShortNames()                   .length() > 0) {             for (char s : option.getShortNames()                                 .toCharArray()) {                 if (shortOptions.containsKey(s)) {                     throw new IllegalArgumentException(""Short option -"" + s + "" already exists"");                 }                 if (parent != null && parent.shortOptions.containsKey(s)) {                     throw new IllegalArgumentException(""Short option -"" + s + "" already exists in parent"");                 }                  shortOptions.put(s, option);             }         }          this.options.add(option);         return this;     }
public List<IAtom> getRgroupQueryAtoms(Integer rgroupNumber) {          List<IAtom> rGroupQueryAtoms = null;          if (rootStructure != null) {             rGroupQueryAtoms = new ArrayList<IAtom>();              for (int i = 0; i < rootStructure.getAtomCount(); i++) {                 IAtom atom = rootStructure.getAtom(i);                 if (atom instanceof IPseudoAtom) {                     IPseudoAtom rGroup = (IPseudoAtom) atom;                     if (!rGroup.getLabel().equals(""R"")                             && // just ""R"" is not a proper query atom                             rGroup.getLabel().startsWith(""R"")                             && (rgroupNumber == null || Integer.valueOf(rGroup.getLabel().substring(1)).equals(                                     rgroupNumber))) rGroupQueryAtoms.add(atom);                 }             }         }         return rGroupQueryAtoms;     }
public ServiceFuture<List<RecommendationInner>> listRecommendedRulesForWebAppAsync(final String resourceGroupName, final String siteName, final Boolean featured, final String filter, final ListOperationCallback<RecommendationInner> serviceCallback) {         return AzureServiceFuture.fromPageResponse(             listRecommendedRulesForWebAppSinglePageAsync(resourceGroupName, siteName, featured, filter),             new Func1<String, Observable<ServiceResponse<Page<RecommendationInner>>>>() {                 @Override                 public Observable<ServiceResponse<Page<RecommendationInner>>> call(String nextPageLink) {                     return listRecommendedRulesForWebAppNextSinglePageAsync(nextPageLink);                 }             },             serviceCallback);     }
@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)     public static boolean hasPortraitScreenFeature(Context context) {         return hasPortraitScreenFeature(context.getPackageManager());     }
public void close() throws IOException {   writer.write(""</rdf:RDF>"");   writer.write(""</x:xmpmeta>\n"");   for (int i = 0; i < extraSpace; i++) {    writer.write(EXTRASPACE);   }   writer.write(end == 'r' ? XPACKET_PI_END_R : XPACKET_PI_END_W);   writer.flush();   writer.close();  }
@Override     public DeploymentPlanBuilder andDeploy() {         String addedKey = getAddedContentKey();         DeploymentActionImpl deployMod = DeploymentActionImpl.getDeployAction(addedKey);         return new DeploymentPlanBuilderImpl(this, deployMod);     }
void set3(int newPrice, int optCur, int back2, int len2, int back) {         price = newPrice;         optPrev = optCur + len2 + 1;         backPrev = back;         prev1IsLiteral = true;         hasPrev2 = true;         optPrev2 = optCur;         backPrev2 = back2;     }
private synchronized ReceiveAllowedThread getReceiveAllowedThread(DestinationHandler destinationHandler)     {         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())             SibTr.entry(tc, ""getReceiveAllowedThread"", destinationHandler);          if (_receiveAllowedThread == null)         {             _receiveAllowedThread = new ReceiveAllowedThread(destinationHandler);             if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())                 SibTr.exit(tc, ""getReceiveAllowedThread"", _receiveAllowedThread);              return _receiveAllowedThread;         }          _receiveAllowedThread.markForUpdate();         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())             SibTr.exit(tc, ""getReceiveAllowedThread"", null);         return null;     }
public User get(String loginname, String password) {         Connection conn = null;         User user = null;         if (loginname == null || password == null) return null;         String cryptpassword = MD5.encodeString(password,null);         try {             conn = ConnectionUtils.getConnection();             user = userDAO.get(conn,loginname,cryptpassword);         } catch(SQLException e) {             logger.error(e.getMessage());         } finally {             DbUtils.closeQuietly(conn);         }         return user;     }
public static void elementPower(double a , DMatrixD1 B , DMatrixD1 C ) {          if( B.numRows != C.numRows || B.numCols != C.numCols ) {             throw new MatrixDimensionException(""All matrices must be the same shape"");         }          int size = B.getNumElements();         for( int i = 0; i < size; i++ ) {             C.data[i] = Math.pow(a, B.data[i]);         }     }
public void changePassword(String newPassword) throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {         if (!connection().isSecureConnection() && !allowSensitiveOperationOverInsecureConnection) {             throw new IllegalStateException(""Changing password over insecure connection."");         }         Map<String, String> map = new HashMap<>();         map.put(""username"",  connection().getUser().getLocalpart().toString());         map.put(""password"",newPassword);         Registration reg = new Registration(map);         reg.setType(IQ.Type.set);         reg.setTo(connection().getXMPPServiceDomain());         createStanzaCollectorAndSend(reg).nextResultOrThrow();     }
public boolean isTriggeringEvent(LoggingEvent event) {     //     //   in the abnormal case of no contained filters     //     always return true to avoid each logging event     //     from having its own file.     if (headFilter == null) {       return false;     }      //     //    otherwise loop through the filters     //     for (Filter f = headFilter; f != null; f = f.next) {       switch (f.decide(event)) {       case Filter.DENY:         return false;        case Filter.ACCEPT:         return true;       }     }      return true;    }
public static void readLine(final String line, final Map<Long, List<Pair<Long, Double>>> mapUserRecommendations) {         String[] toks = line.split(""\t"");         // mymedialite format: user \t [item:score,item:score,...]         if (line.contains("":"") && line.contains("","")) {             Long user = Long.parseLong(toks[0]);             String items = toks[1].replace(""["", """").replace(""]"", """");             for (String pair : items.split("","")) {                 String[] pairToks = pair.split("":"");                 Long item = Long.parseLong(pairToks[0]);                 Double score = Double.parseDouble(pairToks[1]);                 List<Pair<Long, Double>> userRec = mapUserRecommendations.get(user);                 if (userRec == null) {                     userRec = new ArrayList<Pair<Long, Double>>();                     mapUserRecommendations.put(user, userRec);                 }                 userRec.add(new Pair<Long, Double>(item, score));             }         } else {             Long user = Long.parseLong(toks[0]);             Long item = Long.parseLong(toks[1]);             Double score = Double.parseDouble(toks[2]);             List<Pair<Long, Double>> userRec = mapUserRecommendations.get(user);             if (userRec == null) {                 userRec = new ArrayList<Pair<Long, Double>>();                 mapUserRecommendations.put(user, userRec);             }             userRec.add(new Pair<Long, Double>(item, score));         }     }
public CmsGroup getParent(CmsDbContext dbc, String groupname) throws CmsException {          CmsGroup group = readGroup(dbc, groupname);         if (group.getParentId().isNullUUID()) {             return null;         }          // try to read from cache         CmsGroup parent = m_monitor.getCachedGroup(group.getParentId().toString());         if (parent == null) {             parent = getUserDriver(dbc).readGroup(dbc, group.getParentId());             m_monitor.cacheGroup(parent);         }         return parent;     }
@Override   public EClass getIfcCrewResource() {    if (ifcCrewResourceEClass == null) {     ifcCrewResourceEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)       .getEClassifiers().get(154);    }    return ifcCrewResourceEClass;   }
public synchronized void remove()   {     if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())       SibTr.entry(tc, ""remove"");      if(removable != null)     {       index.remove(removable);     }     else     {       if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())         SibTr.exit(tc, ""remove"", ""IllegalStateException"");       throw new IllegalStateException(         nls.getFormattedMessage(           ""NO_ELEMENTS_ERROR_CWSIP0602"",           null,           null));     }      if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())       SibTr.exit(tc, ""remove"");   }
public void write(File file, Integer indent) throws TransformerException, IOException {   write(file, indent, null);  }
public String getName(int i) {         if (i < 0 || i >= names.size()) {             return null;         }         return names.get(i);     }
@JsonProperty(""e"")     @JsonSerialize(using = Base64UrlJsonSerializer.class)     @JsonDeserialize(using = Base64UrlJsonDeserializer.class)     public byte[] e() {         return ByteExtensions.clone(this.e);     }
public static MozuUrl deleteAccountContactUrl(Integer accountId, Integer contactId)   {    UrlFormatter formatter = new UrlFormatter(""/api/commerce/customer/accounts/{accountId}/contacts/{contactId}"");    formatter.formatUrl(""accountId"", accountId);    formatter.formatUrl(""contactId"", contactId);    return new MozuUrl(formatter.getResourceUrl(), MozuUrl.UrlLocation.TENANT_POD) ;   }
protected ModalShownHandler createShownHandler(final DisplayerSettings settings) {          return new ModalShownHandler() {             @Override             public void onShown(ModalShownEvent modalShownEvent) {                 editor.init(settings);                 setTitle(editor.isBrandNewDisplayer() ? newDisplayerTitle : editDisplayerTitle);                 removeShownHandler();             }         };     }
@Override     public <T> void apply(final Query<T> query) {         pathProperties.each(props -> {             String path = props.getPath();             String propsStr = props.getPropertiesAsString();              if (path == null || path.isEmpty()) {                 query.select(propsStr);             } else {                 query.fetch(path, propsStr);             }         });     }
public static double convertFromCelsius(TemperatureScale to, double temperature) {          switch(to) {              case FARENHEIT:                 return convertCelsiusToFarenheit(temperature);             case CELSIUS:                 return temperature;             case KELVIN:                 return convertCelsiusToKelvin(temperature);             case RANKINE:                 return convertCelsiusToRankine(temperature);             default:                 throw(new RuntimeException(""Invalid termpature conversion""));         }     }
private void updateImageInfo() {          String crop = getCrop();         String point = getPoint();         m_imageInfoDisplay.fillContent(m_info, crop, point);     }
public Response createSystemProperty(SystemProperty property) {   return restClient.post(""system/properties"", property, new HashMap<String, String>());  }
public final void mUNION() throws RecognitionException {   try {    int _type = UNION;    int _channel = DEFAULT_TOKEN_CHANNEL;    // hql.g:67:7: ( 'union' )    // hql.g:67:9: 'union'    {    match(""union""); if (state.failed) return;     }     state.type = _type;    state.channel = _channel;   }   finally {    // do for sure before leaving   }  }
public static <T> TypeLiteral<T> get(Class<T> type) {     return new TypeLiteral<T>(type);   }
public final <A extends Number & Comparable<?>> BooleanExpression lt(Expression<A> right) {         return Expressions.booleanOperation(Ops.LT, this, right);     }
public static boolean parseBoolean(String bool, boolean defaultInt) {         if (bool == null) {             return defaultInt;         } else {             return Boolean.parseBoolean(bool);         }     }
protected <T> T getPropertyOrStaticPropertyOrFieldValue(String name, Class<T> type) {         return ClassPropertyFetcher.getStaticPropertyValue(getClazz(), name, type);     }
@Override     public int removeProperties(String pattern, Character escape) throws Exception {         StringBuilder delete = new StringBuilder(58)                         .append(""DELETE FROM Property WHERE ID LIKE :pattern"");         if (escape != null)             delete.append("" ESCAPE :escape"");          final boolean trace = TraceComponent.isAnyTracingEnabled();         if (trace && tc.isEntryEnabled())             Tr.entry(this, tc, ""removeProperties"", pattern, escape, delete);          EntityManager em = getPersistenceServiceUnit().createEntityManager();         try {             Query query = em.createQuery(delete.toString());             query.setParameter(""pattern"", pattern);             if (escape != null)                 query.setParameter(""escape"", escape);             int count = query.executeUpdate();              if (trace && tc.isEntryEnabled())                 Tr.exit(this, tc, ""removeProperties"", count);             return count;         } finally {             em.close();         }     }
public <E> E deserialize(final String str, final Class<E> type, final Collection<Converter<?>> converters) {         logger.debug(""deserialize(\""{}\"", {})"", str, type);          if (converters == null || converters.isEmpty()) {             // when possible, just reuse the base converter             @SuppressWarnings(""unchecked"") final E result = (E) _baseConverter.fromString(type, str);             return result;         }          final DelegatingConverter delegatingConverter = new DelegatingConverter();          if (converters != null) {             for (final Converter<?> converter : converters) {                 delegatingConverter.addConverter(converter);                 delegatingConverter.initialize(converter, _injectionManager);             }         }          final List<Converter<?>> baseconverters = _baseConverter.getConverters();         for (final Converter<?> converter : baseconverters) {             delegatingConverter.addConverter(converter);         }          @SuppressWarnings(""unchecked"") final E result = (E) delegatingConverter.fromString(type, str);         return result;     }
@SafeVarargs     public final PromiseAggregator<V, F> add(Promise<V>... promises) {         if (promises == null) {             throw new NullPointerException(""promises"");         }         if (promises.length == 0) {             return this;         }         synchronized (this) {             if (pendingPromises == null) {                 int size;                 if (promises.length > 1) {                     size = promises.length;                 } else {                     size = 2;                 }                 pendingPromises = new LinkedHashSet<Promise<V>>(size);             }             for (Promise<V> p : promises) {                 if (p == null) {                     continue;                 }                 pendingPromises.add(p);                 p.addListener(this);             }         }         return this;     }
public IfcWallTypeEnum createIfcWallTypeEnumFromString(EDataType eDataType, String initialValue) {    IfcWallTypeEnum result = IfcWallTypeEnum.get(initialValue);    if (result == null)     throw new IllegalArgumentException(       ""The value '"" + initialValue + ""' is not a valid enumerator of '"" + eDataType.getName() + ""'"");    return result;   }
@SuppressFBWarnings(value = ""DM_DEFAULT_ENCODING"", justification = ""Open TODO item for wider rework"")     @Override     protected void eol(byte[] bytes, int len) throws IOException {         String line = new String(bytes, 0, len);         if(passwordsAsPattern != null) {             line = passwordsAsPattern.matcher(line).replaceAll(MASKED_PASSWORD);         }         logger.write(line.getBytes());     }
public void setTerminal(AbstractUDPTerminal terminal) {         this.terminal = terminal;         if (terminal.isActive()) {             transport = terminal.getTransport();         }     }
protected int getTransactionIsolation() {   String val = props.get(PROPS_TRANSACTION_ISOLATION);   return val == null ? -1 : Integer.parseInt(val);  }
@Override     public String getText() {         String retType = AstToTextHelper.getClassText(returnType);         String exceptionTypes = AstToTextHelper.getThrowsClauseText(exceptions);         String parms = AstToTextHelper.getParametersText(parameters);         return AstToTextHelper.getModifiersText(modifiers) + "" "" + retType + "" "" + name + ""("" + parms + "") "" + exceptionTypes + "" { ... }"";     }
private void getImportResource() throws CmsVfsException {          // get the import resource         m_importResource = new File(m_importFolderName);         // check if this is a folder or a ZIP file         if (m_importResource.isFile()) {             try {                 m_zipStreamIn = new ZipInputStream(new FileInputStream(m_importResource));             } catch (IOException e) {                 // if file but no ZIP file throw an exception                 throw new CmsVfsException(                     Messages.get().container(Messages.ERR_NO_ZIPFILE_1, m_importResource.getName()),                     e);             }         }     }
public static ImmoXmlDocument newDocument(Immoxml immoxml) throws ParserConfigurationException, JAXBException {         if (immoxml.getUebertragung() == null)             immoxml.setUebertragung(ImmoXmlUtils.getFactory().createUebertragung());         if (StringUtils.isBlank(immoxml.getUebertragung().getVersion()))             immoxml.getUebertragung().setVersion(ImmoXmlUtils.VERSION.toReadableVersion());          Document document = XmlUtils.newDocument();         ImmoXmlUtils.createMarshaller(""UTF-8"", true).marshal(immoxml, document);         return new ImmoXmlDocument(document);     }
public static ResourceMeta withStream(final HasInputStream stream, final Map<String, String> meta) {         return new BaseStreamResource(meta,stream);     }
public InputStream getInputStream() {          if (m_requestEntity.length == 0) {              return null;          }          ByteArrayInputStream bis = new ByteArrayInputStream(m_requestEntity);          InputStream inStream = bis;          if (m_bEntityCompressed) {              try {                  inStream = new GZIPInputStream(bis);              } catch (IOException e) {                  throw new IllegalArgumentException(""Error decompressing input: "" + e.toString());              }          }          return inStream;      }
public boolean canFilter(Example example)     {         Example result = example;          if (result == null) return false;          if (isBeginTag(result) || isEndTag(result)) return true;         else if (!lazyMode) return false;          if (isEndTag(getNextTag(result)))             return false;                  return !isWithinBeginAndEndTags(result);     }
public static void cublasCherk(char uplo, char trans, int n, int k, float alpha, Pointer A, int lda, float beta, Pointer C, int ldc)      {          cublasCherkNative(uplo, trans, n, k, alpha, A, lda, beta, C, ldc);          checkResultBLAS();      }
private static boolean isCollectionMatching(Joinable mainSideJoinable, OgmCollectionPersister inverseSidePersister) {   boolean isSameTable = mainSideJoinable.getTableName().equals( inverseSidePersister.getTableName() );    if ( !isSameTable ) {    return false;   }    return Arrays.equals( mainSideJoinable.getKeyColumnNames(), inverseSidePersister.getElementColumnNames() );  }
void genCode() throws IOException {         if (!outputDirectory.exists()) {             if (!outputDirectory.mkdirs()) {                 throw new IOException(""unable to create output directory ""                         + outputDirectory);             }         }         FileWriter cc = new FileWriter(new File(outputDirectory, mName + "".cc""));         FileWriter hh = new FileWriter(new File(outputDirectory, mName + "".hh""));          hh.write(""/**\n"");         hh.write(""* Licensed to the Apache Software Foundation (ASF) under one\n"");         hh.write(""* or more contributor license agreements.  See the NOTICE file\n"");         hh.write(""* distributed with this work for additional information\n"");         hh.write(""* regarding copyright ownership.  The ASF licenses this file\n"");         hh.write(""* to you under the Apache License, Version 2.0 (the\n"");         hh.write(""* \""License\""); you may not use this file except in compliance\n"");         hh.write(""* with the License.  You may obtain a copy of the License at\n"");         hh.write(""*\n"");         hh.write(""*     http://www.apache.org/licenses/LICENSE-2.0\n"");         hh.write(""*\n"");         hh.write(""* Unless required by applicable law or agreed to in writing, software\n"");         hh.write(""* distributed under the License is distributed on an \""AS IS\"" BASIS,\n"");         hh.write(""* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"");         hh.write(""* See the License for the specific language governing permissions and\n"");         hh.write(""* limitations under the License.\n"");         hh.write(""*/\n"");         hh.write(""\n"");          cc.write(""/**\n"");         cc.write(""* Licensed to the Apache Software Foundation (ASF) under one\n"");         cc.write(""* or more contributor license agreements.  See the NOTICE file\n"");         cc.write(""* distributed with this work for additional information\n"");         cc.write(""* regarding copyright ownership.  The ASF licenses this file\n"");         cc.write(""* to you under the Apache License, Version 2.0 (the\n"");         cc.write(""* \""License\""); you may not use this file except in compliance\n"");         cc.write(""* with the License.  You may obtain a copy of the License at\n"");         cc.write(""*\n"");         cc.write(""*     http://www.apache.org/licenses/LICENSE-2.0\n"");         cc.write(""*\n"");         cc.write(""* Unless required by applicable law or agreed to in writing, software\n"");         cc.write(""* distributed under the License is distributed on an \""AS IS\"" BASIS,\n"");         cc.write(""* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"");         cc.write(""* See the License for the specific language governing permissions and\n"");         cc.write(""* limitations under the License.\n"");         cc.write(""*/\n"");         cc.write(""\n"");          hh.write(""#ifndef __"" + mName.toUpperCase().replace('.', '_') + ""__\n"");         hh.write(""#define __"" + mName.toUpperCase().replace('.', '_') + ""__\n"");          hh.write(""#include \""recordio.hh\""\n"");         for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext();) {             JFile f = i.next();             hh.write(""#include \"""" + f.getName() + "".hh\""\n"");         }         cc.write(""#include \"""" + mName + "".hh\""\n"");          for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext();) {             JRecord jr = i.next();             jr.genCppCode(hh, cc);         }          hh.write(""#endif //"" + mName.toUpperCase().replace('.', '_') + ""__\n"");          hh.close();         cc.close();     }
public UNode toDoc() {          // Root object is a MAP called ""batch"".          UNode batchNode = UNode.createMapNode(""batch"");                    // Add a ""docs"" node as an array.          UNode docsNode = batchNode.addArrayNode(""docs"");          for (DBObject dbObj : m_dbObjList) {              docsNode.addChildNode(dbObj.toDoc());          }          return batchNode;      }
public Link expand(Map<String, ? extends Object> arguments) {   return new Link(template.expand(arguments).toString(), getRel());  }
public List<Runnable> shutdownNow() {         List<Runnable> tasks;         final ReentrantLock mainLock = this.mainLock;         mainLock.lock();         try {             /* J2ObjC removed.             checkShutdownAccess();             */             advanceRunState(STOP);             interruptWorkers();             tasks = drainQueue();         } finally {             mainLock.unlock();         }         tryTerminate();         return tasks;     }
private String findContainerId(String imageNameOrAlias, boolean checkAllContainers) throws DockerAccessException {         String id = lookupContainer(imageNameOrAlias);          // check for external container. The image name is interpreted as a *container name* for that case ...         if (id == null) {             Container container = queryService.getContainer(imageNameOrAlias);             if (container != null && (checkAllContainers || container.isRunning())) {                 id = container.getId();             }         }         return id;     }
public String getOauthPageUrl(String redirectUrl, OauthScope scope, String state) {         BeanUtil.requireNonNull(redirectUrl, ""redirectUrl is null"");         BeanUtil.requireNonNull(scope, ""scope is null"");         String userState = StrUtil.isBlank(state) ? ""STATE"" : state;         String url = null;         try {             url = URLEncoder.encode(redirectUrl, ""UTF-8"");         } catch (UnsupportedEncodingException e) {             LOG.error(""异常"", e);         }         StringBuilder stringBuilder = new StringBuilder(""https://open.weixin.qq.com/connect/oauth2/authorize?"");         stringBuilder.append(""appid="").append(this.config.getAppid())                 .append(""&redirect_uri="").append(url)                 .append(""&response_type=code&scope="").append(scope.toString())                 .append(""&state="")                 .append(userState)                 .append(""#wechat_redirect"");         return stringBuilder.toString();     }
public static Scopes from(String... scopes)     {         if (scopes == null || scopes.length == 0) return NONE;         return new Scopes(scopes, true);     }
void compressNew(PointList points, int removed) {         int freeIndex = -1;         for (int currentIndex = 0; currentIndex < points.getSize(); currentIndex++) {             if (Double.isNaN(points.getLatitude(currentIndex))) {                 if (freeIndex < 0)                     freeIndex = currentIndex;                  continue;             } else if (freeIndex < 0) {                 continue;             }              points.set(freeIndex, points.getLatitude(currentIndex), points.getLongitude(currentIndex), points.getElevation(currentIndex));             points.set(currentIndex, Double.NaN, Double.NaN, Double.NaN);             // find next free index             int max = currentIndex;             int searchIndex = freeIndex + 1;             freeIndex = currentIndex;             for (; searchIndex < max; searchIndex++) {                 if (Double.isNaN(points.getLatitude(searchIndex))) {                     freeIndex = searchIndex;                     break;                 }             }         }         points.trimToSize(points.getSize() - removed);     }
@Override  public CPDefinition create(long CPDefinitionId) {   CPDefinition cpDefinition = new CPDefinitionImpl();    cpDefinition.setNew(true);   cpDefinition.setPrimaryKey(CPDefinitionId);    String uuid = PortalUUIDUtil.generate();    cpDefinition.setUuid(uuid);    cpDefinition.setCompanyId(companyProvider.getCompanyId());    return cpDefinition;  }
public AttributeDataset parse(InputStream stream) throws IOException, ParseException {         try (Reader r = new BufferedReader(new InputStreamReader(stream))) {             StreamTokenizer tokenizer = new StreamTokenizer(r);             initTokenizer(tokenizer);              List<Attribute> attributes = new ArrayList<>();             String relationName = readHeader(tokenizer, attributes);              if (attributes.isEmpty()) {                 throw new IOException(""no header information available"");             }                      Attribute response = null;             Attribute[] attr = new Attribute[attributes.size()];             attributes.toArray(attr);                      for (int i = 0; i < attributes.size(); i++) {                 if (responseIndex == i) {                     response = attributes.remove(i);                     break;                 }             }                      AttributeDataset data = new AttributeDataset(relationName, attributes.toArray(new Attribute[attributes.size()]), response);                      while (true) {                 // Check if end of file reached.                 getFirstToken(tokenizer);                 if (tokenizer.ttype == StreamTokenizer.TT_EOF) {                     break;                 }                  // Parse instance                 if (tokenizer.ttype == '{') {                     readSparseInstance(tokenizer, data, attr);                 } else {                     readInstance(tokenizer, data, attr);                 }             }                      for (Attribute attribute : attributes) {                 if (attribute instanceof NominalAttribute) {                     NominalAttribute a = (NominalAttribute) attribute;                     a.setOpen(false);                 }                              if (attribute instanceof StringAttribute) {                     StringAttribute a = (StringAttribute) attribute;                     a.setOpen(false);                 }             }                      return data;         }     }
public static void copyParagraphAnnotations(JCas source, JCas target)             throws IllegalArgumentException     {         if (!source.getDocumentText().equals(target.getDocumentText())) {             throw new IllegalArgumentException(                     ""source.documentText and target.documentText are not equal"");         }          Collection<Paragraph> targetParagraphs = JCasUtil.select(target, Paragraph.class);         if (!targetParagraphs.isEmpty()) {             throw new IllegalArgumentException(""target already contains paragraph annotations"");         }          for (Paragraph paragraph : JCasUtil.select(source, Paragraph.class)) {             Paragraph paragraphCopy = new Paragraph(target);             paragraphCopy.setBegin(paragraph.getBegin());             paragraphCopy.setEnd(paragraph.getEnd());             paragraphCopy.addToIndexes();         }     }
protected Object getValue(Object value, ComparisonType type) {         return type == ComparisonType.NODE_TYPE ? nodeType((Short) value) : value;     }
public final void mVOID() throws RecognitionException {         try {             int _type = VOID;             int _channel = DEFAULT_TOKEN_CHANNEL;             // com/dyuproject/protostuff/parser/ProtoLexer.g:223:5: ( 'void' )             // com/dyuproject/protostuff/parser/ProtoLexer.g:223:9: 'void'             {             match(""void"");                }              state.type = _type;             state.channel = _channel;         }         finally {         }     }
@SuppressWarnings(""unchecked"")  @Override  public void eSet(int featureID, Object newValue) {   switch (featureID) {    case AfplibPackage.PPORG__RG_LENGTH:     setRGLength((Integer)newValue);     return;    case AfplibPackage.PPORG__OBJ_TYPE:     setObjType((Integer)newValue);     return;    case AfplibPackage.PPORG__PROC_FLGS:     setProcFlgs((Integer)newValue);     return;    case AfplibPackage.PPORG__XOCA_OSET:     setXocaOset((Integer)newValue);     return;    case AfplibPackage.PPORG__YOCA_OSET:     setYocaOset((Integer)newValue);     return;    case AfplibPackage.PPORG__TRIPLETS:     getTriplets().clear();     getTriplets().addAll((Collection<? extends Triplet>)newValue);     return;   }   super.eSet(featureID, newValue);  }
private String getElementID(final String relativePath) {         final String fragment = getFragment(relativePath);         if (fragment != null) {             if (fragment.lastIndexOf(SLASH) != -1) {                 return fragment.substring(fragment.lastIndexOf(SLASH) + 1);             } else {                 return fragment;             }         }         return null;     }
public static SelectColumn includes(String[] cols, String... columns) {          return new SelectColumn(Utility.append(cols, columns), false);      }
@NullableDecl   static <T> T pollNext(Iterator<T> iterator) {     if (iterator.hasNext()) {       T result = iterator.next();       iterator.remove();       return result;     } else {       return null;     }   }
private void increment(final Calendar cal) {         // initialise interval..         final int calInterval = (getInterval() >= 1) ? getInterval() : 1;         cal.add(calIncField, calInterval);     }
@Override  public CommerceOrderNote fetchByC_R_Last(long commerceOrderId,   boolean restricted,   OrderByComparator<CommerceOrderNote> orderByComparator) {   int count = countByC_R(commerceOrderId, restricted);    if (count == 0) {    return null;   }    List<CommerceOrderNote> list = findByC_R(commerceOrderId, restricted,     count - 1, count, orderByComparator);    if (!list.isEmpty()) {    return list.get(0);   }    return null;  }
public static Point2i convert(Tuple2D<?> tuple) {   if (tuple instanceof Point2i) {    return (Point2i) tuple;   }   return new Point2i(tuple.getX(), tuple.getY());  }
protected Response getWithAccepts(MultivaluedMap<String, String> queryParams, URL url, String accepts) {         return (invocation(url, queryParams, accepts).get());     }
protected void stopJobAcquisitionThread() {     if (asyncJobAcquisitionThread != null) {       try {         asyncJobAcquisitionThread.join();       } catch (InterruptedException e) {         log.warn(""Interrupted while waiting for the async job acquisition thread to terminate"", e);       }       asyncJobAcquisitionThread = null;     }   }
public static Element getChild(Element element, String name) {          return (Element) element.getElementsByTagName(name).item(0);      }
protected void initMojoMultiValueParameters() {    // Set default values for 'checkFileSets' to ""src/main/resources/*.btdesign""   if (checkFileSets == null) {    FileSet defaultFileSet = new FileSet();    defaultFileSet.setDirectory(project.getBasedir() + ""/src/main/resources"");    defaultFileSet.addInclude(""*.btdesign"");    checkFileSets = new FileSet[] { defaultFileSet };   }  }
public Set<Class<? extends Exception>> getRecoverableExceptions() {     return recoverableExceptions != null ? recoverableExceptions : parent != null ? parent.getRecoverableExceptions()       : Collections.<Class<? extends Exception>>emptySet();   }
public Coordinate getCoordinateN(int n) {   if (isEmpty()) {    return null;   }   if (n >= 0 && n < coordinates.length) {    return coordinates[n];   }   return null;  }
@Override  public Integer next() {   if (!hasNext()) {    throw new NoSuchElementException(toString() + "" ended"");   }    current = next;   next = next + increment;    return current();  }
protected void writeIndent() throws IOException {   final int start = writeLineSepartor ? 0 : offsetNewLine;   final int level = (depth > maxIndentLevel) ? maxIndentLevel : depth;   out.write(indentationBuf, start, ((level - 1) * indentationJump) + offsetNewLine);  }
public final static String process(final File file, final Configuration configuration) throws IOException     {         final FileInputStream input = new FileInputStream(file);         final String ret = process(input, configuration);         input.close();         return ret;     }
@GetMapping(value = ""/{entityTypeId}/exist"", produces = APPLICATION_JSON_VALUE)   public boolean entityExists(@PathVariable(""entityTypeId"") String entityTypeId) {     return dataService.hasRepository(entityTypeId);   }
public ResultsWrapper<Issue> getIssues(Params parameters) throws RedmineException {         return transport.getObjectsListNoPaging(Issue.class, parameters.getList());     }
public void openGalleryDialog(CmsResource resource) {          try {             CmsObject cms = A_CmsUI.getCmsObject();             JSONObject conf = new JSONObject();             conf.put(I_CmsGalleryProviderConstants.CONFIG_GALLERY_MODE, GalleryMode.view.name());             conf.put(I_CmsGalleryProviderConstants.CONFIG_GALLERY_PATH, cms.getSitePath(resource));             conf.put(I_CmsGalleryProviderConstants.CONFIG_GALLERY_STORAGE_PREFIX, """");             conf.put(I_CmsGalleryProviderConstants.CONFIG_TAB_CONFIG, CmsGalleryTabConfiguration.TC_SELECT_ALL);             getRpcProxy(I_CmsGwtDialogClientRpc.class).openGalleryDialog(conf.toString());         } catch (JSONException e) {             CmsErrorDialog.showErrorDialog(e);         }     }
public final V set(int index, K key, V value) {     if (index < 0) {       throw new IndexOutOfBoundsException();     }     int minSize = index + 1;     ensureCapacity(minSize);     int dataIndex = index << 1;     V result = valueAtDataIndex(dataIndex + 1);     setData(dataIndex, key, value);     if (minSize > this.size) {       this.size = minSize;     }     return result;   }
public static VectorNd normalizeSafe(VectorNd v) {         try {             return v.normalize();         } catch (ArithmeticException ex) {             return new VectorNd(v.size());         }     }
public void setSecond(Integer newSecond) {   Integer oldSecond = second;   second = newSecond;   if (eNotificationRequired())    eNotify(new ENotificationImpl(this, Notification.SET, AfplibPackage.UNIVERSAL_DATE_AND_TIME_STAMP__SECOND, oldSecond, second));  }
<E> Observable<E> addLogging(@NonNull Observable<E> obs, @NonNull Logger log, final String msg) {         return obs.doOnNext(r -> log(log, (ComapiResult) r, msg))                 .doOnError(t -> log(log, t, msg));     }
private static List<MutableDoubleTuple> validate(          Collection<? extends DoubleTuple> inputs,          List<MutableDoubleTuple> results)      {          if (results == null)          {              results = new ArrayList<MutableDoubleTuple>(inputs.size());              for (DoubleTuple input : inputs)              {                  results.add(DoubleTuples.create(input.getSize()));              }          }          else          {              if (inputs.size() != results.size())              {                  throw new IllegalArgumentException(                      ""The number of inputs ("" + inputs.size() + "") must "" +                      ""be the same as the number of results "" +                      ""("" + results.size() + "")"");              }          }          return results;      }
public EvalError toEvalError(         String msg, SimpleNode node, CallStack callstack  )     {         if ( null == msg )             msg = this.getMessage();         else             msg += "": "" + this.getMessage();          return new TargetError( msg, this.getCause(), node, callstack, false );     }
public boolean isSet(_Fields field) {     if (field == null) {       throw new IllegalArgumentException();     }      switch (field) {     case NUM_CPUS:       return isSetNumCpus();     case NETWORK_MBPS:       return isSetNetworkMBps();     case MEMORY_MB:       return isSetMemoryMB();     case DISK_GB:       return isSetDiskGB();     }     throw new IllegalStateException();   }
public Object invokeMethod(String name, Object args) {         boolean notExpectedArgs = false;         if (args != null && Object[].class.isAssignableFrom(args.getClass())) {             Object[] arr = (Object[]) args;             try {                 switch(arr.length) {                     case 0:                         call(name);                     break;                     case 1:                         if (arr[0] instanceof Closure) {                             final Closure callable = (Closure) arr[0];                             call(name, callable);                         } else if (arr[0] instanceof Map) {                             final Map<String, Map> map = Collections.singletonMap(name, (Map) arr[0]);                             call(map);                         } else {                             notExpectedArgs = true;                         }                     break;                     case 2:                         final Object first = arr[0];                         final Object second = arr[1];                         final boolean isClosure = second instanceof Closure;                          if(isClosure && first instanceof Map ) {                             final Closure callable = (Closure) second;                             call(name, (Map)first, callable);                         }                         else if(isClosure && first instanceof Iterable) {                             final Iterable coll = (Iterable) first;                             final Closure callable = (Closure) second;                             call(name, coll, callable);                         }                         else if(isClosure && first.getClass().isArray()) {                             final Iterable coll = Arrays.asList((Object[])first);                             final Closure callable = (Closure) second;                             call(name, coll, callable);                         }                         else {                             notExpectedArgs = true;                         }                     break;                     default:                         notExpectedArgs = true;                 }             } catch (IOException ioe) {                 throw new JsonException(ioe);             }         } else {             notExpectedArgs = true;         }          if (!notExpectedArgs) {             return this;         } else {             throw new JsonException(""Expected no arguments, a single map, a single closure, or a map and closure as arguments."");         }     }
public ListApplicationVersionsResult withVersions(VersionSummary... versions) {         if (this.versions == null) {             setVersions(new java.util.ArrayList<VersionSummary>(versions.length));         }         for (VersionSummary ele : versions) {             this.versions.add(ele);         }         return this;     }
public Observable<Void> createOrUpdateAsync(String vaultName, String resourceGroupName, String fabricName, String containerName, String protectedItemName, ProtectedItemResourceInner parameters) {         return createOrUpdateWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName, protectedItemName, parameters).map(new Func1<ServiceResponse<Void>, Void>() {             @Override             public Void call(ServiceResponse<Void> response) {                 return response.body();             }         });     }
@Override     public void close() {         namedParamSqlCache.clear();         namedParamIndexPropCache.clear();         clearStatementCache();         if (useConnection != null) {             try {                 useConnection.close();             } catch (SQLException e) {                 LOG.finest(""Caught exception closing connection: "" + e.getMessage());             }         }     }
public static ThreeDSecure retrieve(String threeDSecure) throws StripeException {     return retrieve(threeDSecure, (Map<String, Object>) null, (RequestOptions) null);   }
@Override     public UpdatePullRequestStatusResult updatePullRequestStatus(UpdatePullRequestStatusRequest request) {         request = beforeClientExecution(request);         return executeUpdatePullRequestStatus(request);     }
void register(URL url, InMemoryMappingFile immf) {         _data.put(url.getFile(), immf);     }
protected void add(IIsotope isotope) {         Integer atomicNum = isotope.getAtomicNumber();         assert atomicNum != null;         List<IIsotope> isotopesForElement = isotopes[atomicNum];         if (isotopesForElement == null) {             isotopesForElement = new ArrayList<>();             isotopes[atomicNum] = isotopesForElement;         }         isotopesForElement.add(isotope);     }
protected X509Credential loadProxyCredential(String proxyPath) {      PEMCredential cred = null;      listener.notifyCredentialLookup(proxyPath);      try {        FilePermissionHelper.checkProxyPermissions(proxyPath);       cred = new PEMCredential(new FileInputStream(proxyPath), (char[]) null);       listener.notifyLoadCredentialSuccess(proxyPath);      } catch (Throwable t) {        listener.notifyLoadCredentialFailure(t, proxyPath);     }      return cred;   }
protected void checkAttribute(String attribute) {         if (!hasAttribute(attribute)) {             String sb = ""Attribute: '"" + attribute + ""' is not defined in model: '"" + getModelClass() + "". ""                     + ""Available attributes: "" +getAttributeNames();             throw new IllegalArgumentException(sb);         }     }
private void readConfig(){   AccumulatorsConfig config = MoskitoConfigurationHolder.getConfiguration().getAccumulatorsConfig();   AccumulatorConfig[] acs = config.getAccumulators();   if (acs!=null && acs.length>0){    for (AccumulatorConfig ac  : acs){     AccumulatorDefinition ad = new AccumulatorDefinition();     ad.setName(ac.getName());     ad.setIntervalName(ac.getIntervalName());     ad.setProducerName(ac.getProducerName());     ad.setStatName(ac.getStatName());     ad.setTimeUnit(TimeUnit.valueOf(ac.getTimeUnit()));     ad.setValueName(ac.getValueName());     Accumulator acc = createAccumulator(ad);     if (log.isDebugEnabled()){      log.debug(""Created accumulator ""+acc);     }    }   }    AutoAccumulatorConfig[] autoAccumulatorConfigs = config.getAutoAccumulators();   if (autoAccumulatorConfigs != null && autoAccumulatorConfigs.length>0){    for (AutoAccumulatorConfig aac : autoAccumulatorConfigs){     AutoAccumulatorDefinition aad = new AutoAccumulatorDefinition();     aad.setNamePattern(aac.getNamePattern());     aad.setProducerNamePattern(aac.getProducerNamePattern());     aad.setIntervalName(aac.getIntervalName());     aad.setValueName(aac.getValueName());     aad.setStatName(aac.getStatName());     aad.setTimeUnit(TimeUnit.fromString(aac.getTimeUnit()));     aad.setAccumulationAmount(aac.getAccumulationAmount());     autoAccumulatorDefinitions.add(aad);    }   }   }
@Override     public void contextRootAdded(String contextRoot, VirtualHost virtualHost) {         if (TraceComponent.isAnyTracingEnabled() && tc.isEventEnabled()) {             Tr.event(tc, ""Added contextRoot {0} to virtual host {1}"", contextRoot, virtualHost.getName());         }          // Check that our app got installed         if (contextRoot != null             && contextRoot.contains(APIConstants.JMX_CONNECTOR_API_ROOT_PATH)             && ""default_host"".equals(virtualHost.getName())) {             registeredContextRoot = contextRoot;              if (secureVirtualHost == virtualHost) {                 createJMXWorkAreaResourceIfChanged(virtualHost);             }         }     }
public static void bufferedToPlanar_U8(DataBufferInt buffer, WritableRaster src, Planar<GrayU8> dst) {   int[] srcData = buffer.getData();    int srcStride = stride(src);   int srcOffset = getOffset(src);    int numBands = src.getNumBands();   byte[] data1 = dst.getBand(0).data;   byte[] data2 = dst.getBand(1).data;   byte[] data3 = dst.getBand(2).data;    if( numBands == 3 ) {    //CONCURRENT_BELOW BoofConcurrency.loopFor(0, dst.height, y -> {    for (int y = 0; y < dst.height; y++) {     int indexSrc = srcOffset + y*srcStride;     int indexDst = dst.startIndex + y * dst.stride;     for (int x = 0; x < dst.width; x++, indexDst++) {       int rgb = srcData[indexSrc++];       data1[indexDst] = (byte) (rgb >>> 16);      data2[indexDst] = (byte) (rgb >>> 8);      data3[indexDst] = (byte) rgb;     }    }    //CONCURRENT_ABOVE });   } else if( numBands == 4 ) {    byte[] data4 = dst.getBand(3).data;     //CONCURRENT_BELOW BoofConcurrency.loopFor(0, dst.height, y -> {    for (int y = 0; y < dst.height; y++) {     int indexSrc = srcOffset + y*srcStride;     int indexDst = dst.startIndex + y * dst.stride;     for (int x = 0; x < dst.width; x++, indexDst++) {       int rgb = srcData[indexSrc++];       data1[indexDst] = (byte) (rgb >>> 24);      data2[indexDst] = (byte) (rgb >>> 16);      data3[indexDst] = (byte) (rgb >>> 8);      data4[indexDst] = (byte) rgb;     }    }    //CONCURRENT_ABOVE });   }  }
static Pair<String, Integer> getId(Annotation annot) {    if (annot instanceof DictTerm) {    DictTerm dt = (DictTerm) annot;    String[] split = dt.getEntityId().split("":"");    return Pair.of(split[0], parseInt(split[1]));     // } else if (annot instanceof Measure) {    // Measure m = (Measure) annot;    // return Pair.of(""""+m.getNormalizedUnit(), parseInt(split[1]));    } else    throw new RuntimeException(""NOT IMPLEMENTED xxx"");// FIXME  }
public void removeAndTryClose(Connection connection) {         if (null == connection) {             return;         }         boolean res = this.conns.remove(connection);         if (res) {             connection.decreaseRef();         }         if (connection.noRef()) {             connection.close();         }     }
private static boolean isCompatibleWithProvidedType(Class<?> providedClass,                                                       Class<?> replacementClass) {     if (Integer.class.isAssignableFrom(providedClass)) {       return (replacementClass == String.class ||           replacementClass == Integer.class ||           replacementClass == Long.class);     } else if (Long.class.isAssignableFrom(providedClass)) {       return (replacementClass == String.class ||           replacementClass == Long.class);     } else if (String.class.isAssignableFrom(providedClass)) {       return replacementClass == String.class;     }     return false;   }
public void addItem (int index, T item)     {         if (_items == null) {             return;         }         _items.add(index, item);     }
public static Observable<AsyncViewResult> mapToViewResult(final AsyncBucket bucket, final ViewQuery query,         final ViewQueryResponse response) {          return response             .info()             .singleOrDefault(null)             .map(new ByteBufToJsonObject())             .map(new BuildViewResult(bucket, query, response));     }
public static int setPrivate(int modifier, boolean b) {         if (b) {             return (modifier | PRIVATE) & (~PUBLIC & ~PROTECTED);         }         else {             return modifier & ~PRIVATE;         }     }
@Override     public <T> T getJsonProperty(String propertyName) {         return (T) getProperty(propertyName, String.class);     }
protected Element createTextElement(float width)     {         Element el = doc.createElement(""div"");         el.setAttribute(""id"", ""p"" + (textcnt++));         el.setAttribute(""class"", ""p"");         String style = curstyle.toString();         style += ""width:"" + width + UNIT + "";"";         el.setAttribute(""style"", style);         return el;     }
public void onCommandException(CommandResponse response) {   String message = I18nProvider.getGlobal().commandError() + "":"";   for (String error : response.getErrorMessages()) {    message += ""\n"" + error;   }   Log.logWarn(message);   if (response.getExceptions() == null || response.getExceptions().size() == 0) {    SC.warn(message);   } else {    // The error messaging window only supports 1 exception to display:    ExceptionWindow window = new ExceptionWindow(response.getExceptions().get(0));    window.show();   }  }
public void invalidate(Key... keys) {         for (Key key : keys) {             logger.debug(""Invalidating the response cache key : {} {} {} {}, {}"",                     key.getEntityType(), key.getName(), key.getVersion(), key.getType(), key.getEurekaAccept());              readWriteCacheMap.invalidate(key);             Collection<Key> keysWithRegions = regionSpecificKeys.get(key);             if (null != keysWithRegions && !keysWithRegions.isEmpty()) {                 for (Key keysWithRegion : keysWithRegions) {                     logger.debug(""Invalidating the response cache key : {} {} {} {} {}"",                             key.getEntityType(), key.getName(), key.getVersion(), key.getType(), key.getEurekaAccept());                     readWriteCacheMap.invalidate(keysWithRegion);                 }             }         }     }
@Override     public Money divide(Number divisor) {         if (NumberVerifier.isInfinityAndNotNaN(divisor)) {             return Money.of(0, getCurrency());         }         BigDecimal divisorBD = MoneyUtils.getBigDecimal(divisor);         if (divisorBD.equals(BigDecimal.ONE)) {             return this;         }         BigDecimal dec =                 this.number.divide(divisorBD, MoneyUtils.getMathContext(getContext(), RoundingMode.HALF_EVEN));         return new Money(dec, getCurrency());     }
public JSONObject linkToJSON(Link s) {         JSONObject o = new JSONObject();         o.put(""id"", s.id());         o.put(CAPACITY_LABEL, s.getCapacity());         o.put(SWITCH_LABEL, s.getSwitch().id());         o.put(""physicalElement"", physicalElementToJSON(s.getElement()));         return o;     }
public AVQuery<T> whereContainsAll(String key, Collection<?> values) {     conditions.whereContainsAll(key, values);     return this;   }
private final JSRemoteConsumerPoint findOrCreateJSRemoteConsumerPoint(String[] discriminators, int[] selectorDomains,                                                         String[] selectors)     throws ClosedException   {     if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())       SibTr.entry(tc, ""findOrCreateJSRemoteConsumerPoint"",           new Object[]{Arrays.toString(discriminators),                        Arrays.toString(selectorDomains),                        Arrays.toString(selectors)});      String selectionCriteriasAsString = parent.convertSelectionCriteriasToString(                                                   discriminators, selectorDomains, selectors);      JSRemoteConsumerPoint aock = (JSRemoteConsumerPoint) consumerKeyTable.get(selectionCriteriasAsString);     if (aock == null)     {       try       {         // create an JSRemoteConsumerPoint         aock = new JSRemoteConsumerPoint();         SelectionCriteria[] criterias = new SelectionCriteria[discriminators.length];         ConsumableKey[] consumerKeys = new ConsumableKey[discriminators.length];         OrderingContextImpl ocontext = null;         SIBUuid12 connectionUuid = new SIBUuid12();          if (discriminators.length > 1)           ocontext = new OrderingContextImpl(); // create a new ordering context         for (int i=0; i < discriminators.length; i++)         {           SelectorDomain domain = SelectorDomain.getSelectorDomain(selectorDomains[i]);           criterias[i] = parent.createSelectionCriteria(discriminators[i], selectors[i], domain);            // attach as many times as necessary           consumerKeys[i] =             (ConsumableKey) consumerDispatcher.attachConsumerPoint(               aock,               criterias[i],               connectionUuid,               false,               false,               null);            if (ocontext != null)             consumerDispatcher.joinKeyGroup(consumerKeys[i], ocontext);            consumerKeys[i].start(); // in case we use a ConsumerKeyGroup, this is essential          }          if (parent.getCardinalityOne() || consumerDispatcher.isPubSub())         {           // effectively infinite timeout, since don't want to close the ConsumerKey if RME is inactive for           // a while. Only close this ConsumerKey when start flushing this stream.           // NOTE shared durable subs might not be cardinality one but we still do not want the streams           // to flush on timeout           //           // Defect 516583, set the idleTimeout parameter to 0, not to Long.MAX_VALUE in order to have an           // ""infinite timeout"".           aock.init(this, selectionCriteriasAsString, consumerKeys, 0, am, criterias);         }         else         {           aock.init(             this,             selectionCriteriasAsString,             consumerKeys,             mp.getCustomProperties().get_ck_idle_timeout(),             am,             criterias);         }         consumerKeyTable.put(selectionCriteriasAsString, aock);       }       catch (Exception e)       {         // should not occur!         FFDCFilter.processException(           e,           ""com.ibm.ws.sib.processor.impl.AOStream.findOrCreateJSRemoteConsumerPoint"",           ""1:2942:1.80.3.24"",           this);         SibTr.exception(tc, e);          aock = null;         ClosedException e2 = new ClosedException(e.getMessage());         // just using the ClosedException as a convenience         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())           SibTr.exit(tc, ""findOrCreateJSRemoteConsumerPoint"", e2);          throw e2;       }     }      if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())       SibTr.exit(tc, ""findOrCreateJSRemoteConsumerPoint"", aock);      return aock;   }
String getPath() {     StringBuilder result = new StringBuilder();      boolean first = true;     for (String part : getSegments()) {       if (first) {         result.append(part);         first = false;       } else {         result.append(""/"").append(part);       }     }      return result.toString();   }
public static void writeIntegerLittleEndian(IO.WritableByteStream io, int value) throws IOException {    io.write((byte)(value & 0xFF));    io.write((byte)((value >> 8) & 0xFF));    io.write((byte)((value >> 16) & 0xFF));    io.write((byte)((value >> 24) & 0xFF));   }
private void setUpdateTimer(final String subscriptionId, final String serviceContextId, long ms) {      Date timeToRun = new Date(System.currentTimeMillis() + ms);      sendUpdatetimer.schedule(new TimerTask() {        public void run() {          try {            updateCharging(subscriptionId, serviceContextId, partialCallDurationCounter);          }          catch (Exception e) {            logger.error(""(( $ )) Failure trying to create/send CCR (UPDATE) message. (( $ ))"", e);          }        }      }, timeToRun);    }
@Override     public ListJobsByStatusResult listJobsByStatus(ListJobsByStatusRequest request) {         request = beforeClientExecution(request);         return executeListJobsByStatus(request);     }
public DescribeSessionsResult withSessions(Session... sessions) {         if (this.sessions == null) {             setSessions(new com.amazonaws.internal.SdkInternalList<Session>(sessions.length));         }         for (Session ele : sessions) {             this.sessions.add(ele);         }         return this;     }
@Override     public synchronized ServerBootstrap newServerBootstrap() throws Exception {         if (serverChannelFactory == null) {             Executor workerExecutor = executorServiceFactory.newExecutorService(""worker.server"");             NioDatagramWorkerPool workerPool = new NioDatagramWorkerPool(workerExecutor, 1);             serverChannelFactory = new UdpServerChannelFactory(workerPool, timer);              // unshared             channelFactories.add(serverChannelFactory);         }          return new ServerBootstrap(serverChannelFactory);     }
public static void copy(String in, Writer out) throws IOException {   Assert.notNull(in, ""No input String specified"");   Assert.notNull(out, ""No Writer specified"");   try {    out.write(in);   }   finally {    try {     out.close();    }    catch (IOException ex) {    }   }  }
public void startAuthActivity(Context context, Bundle extras) {         if (!startDelegateActivity(context, delegate.getAuthStartIntent(), extras)) {             startActivity(context, extras, AuthActivity.class);         }     }
@Override  public Statement apply(final Statement base, final Description description) {   return new Statement() {     @Override    public void evaluate() throws Throwable {     PactVerifications pactVerifications = description.getAnnotation(PactVerifications.class);     if (pactVerifications != null) {      evaluatePactVerifications(pactVerifications, base, description);      return;     }      PactVerification pactDef = description.getAnnotation(PactVerification.class);     // no pactVerification? execute the test normally     if (pactDef == null) {      base.evaluate();      return;     }      Message providedMessage = null;     Map<String, Message> pacts;     if (StringUtils.isNoneEmpty(pactDef.fragment())) {           Optional<Method> possiblePactMethod = findPactMethod(pactDef);           if (!possiblePactMethod.isPresent()) {             base.evaluate();             return;           }            pacts = new HashMap<>();           Method method = possiblePactMethod.get();           Pact pact = method.getAnnotation(Pact.class);           MessagePactBuilder builder = MessagePactBuilder.consumer(pact.consumer()).hasPactWith(provider);           messagePact = (MessagePact) method.invoke(testClassInstance, builder);           for (Message message : messagePact.getMessages()) {             pacts.put(message.getProviderStates().stream().map(ProviderState::getName).collect(Collectors.joining()),        message);           }         } else {           pacts = parsePacts();         }          if (pactDef.value().length == 2 && !pactDef.value()[1].trim().isEmpty()) {           providedMessage = pacts.get(pactDef.value()[1].trim());         } else if (!pacts.isEmpty()) {           providedMessage = pacts.values().iterator().next();         }      if (providedMessage == null) {      base.evaluate();      return;     }      setMessage(providedMessage, description);     try {      base.evaluate();      PactFolder pactFolder = testClassInstance.getClass().getAnnotation(PactFolder.class);      if (pactFolder != null) {       messagePact.write(pactFolder.value(), PactSpecVersion.V3);      } else {       messagePact.write(PactConsumerConfig.INSTANCE.getPactDirectory(), PactSpecVersion.V3);      }     } catch (Throwable t) {      throw t;     }    }   };  }
public static base_responses unset(nitro_service client, String groupname[], String args[]) throws Exception {   base_responses result = null;   if (groupname != null && groupname.length > 0) {    systemgroup unsetresources[] = new systemgroup[groupname.length];    for (int i=0;i<groupname.length;i++){     unsetresources[i] = new systemgroup();     unsetresources[i].groupname = groupname[i];    }    result = unset_bulk_request(client, unsetresources,args);   }   return result;  }
private static void setupCSSClasses(Object owner, CSSClassManager manager, StyleLibrary style) throws CSSNamingConflict {     if(!manager.contains(CSS_AXIS)) {       CSSClass axis = new CSSClass(owner, CSS_AXIS);       axis.setStatement(SVGConstants.CSS_STROKE_PROPERTY, style.getColor(StyleLibrary.AXIS));       axis.setStatement(SVGConstants.CSS_STROKE_WIDTH_PROPERTY, style.getLineWidth(StyleLibrary.AXIS));       manager.addClass(axis);     }     if(!manager.contains(CSS_AXIS_TICK)) {       CSSClass tick = new CSSClass(owner, CSS_AXIS_TICK);       tick.setStatement(SVGConstants.CSS_STROKE_PROPERTY, style.getColor(StyleLibrary.AXIS_TICK));       tick.setStatement(SVGConstants.CSS_STROKE_WIDTH_PROPERTY, style.getLineWidth(StyleLibrary.AXIS_TICK));       manager.addClass(tick);     }     if(!manager.contains(CSS_AXIS_LABEL)) {       CSSClass label = new CSSClass(owner, CSS_AXIS_LABEL);       label.setStatement(SVGConstants.CSS_FILL_PROPERTY, style.getTextColor(StyleLibrary.AXIS_LABEL));       label.setStatement(SVGConstants.CSS_FONT_FAMILY_PROPERTY, style.getFontFamily(StyleLibrary.AXIS_LABEL));       label.setStatement(SVGConstants.CSS_FONT_SIZE_PROPERTY, style.getTextSize(StyleLibrary.AXIS_LABEL));       manager.addClass(label);     }   }
@SuppressFBWarnings(""RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE"")     private C4Document save(Document document, C4Document base, boolean deletion)         throws LiteCoreException {         FLSliceResult body = null;         try {             int revFlags = 0;             if (deletion) { revFlags = C4Constants.RevisionFlags.DELETED; }             if (!deletion && !document.isEmpty()) {                 // Encode properties to Fleece data:                 body = document.encode();                 if (C4Document.dictContainsBlobs(body, sharedKeys.getFLSharedKeys())) {                     revFlags |= C4Constants.RevisionFlags.HAS_ATTACHMENTS;                 }             }              // Save to database:             final C4Document c4Doc = base != null ? base : document.getC4doc();             if (c4Doc != null) { return c4Doc.update(body, revFlags); }              return getC4Database().create(document.getId(), body, revFlags);         }         finally {             if (body != null) { body.free(); }         }     }
public LDIFChangeRecord nextRecord() {         if (entryIterator.hasNext()) {             try {                 final Node entryNode = entryIterator.next();                 final String dn = entryNode.valueOf(""@dn"");                 final List<Attribute> attributes = new ArrayList<Attribute>();                  final List<Node> objectClassList = (List<Node>) objectClassXPath.selectNodes(entryNode);                 final String[] objectClasses = new String[objectClassList.size()];                 for (int j = 0; j < objectClasses.length; ++j) {                     objectClasses[j] = objectClassList.get(j).getStringValue();                 }                 attributes.add(new Attribute(""objectclass"", objectClasses));                 for (final Node attributeNode : (List<Node>) attrXPath.selectNodes(entryNode)) {                     final String attributeName = attributeNode.valueOf(""@name"");                     final List<Node> attributeValueNodes = (List<Node>) attrValueXPath.selectNodes(attributeNode);                     switch (attributeValueNodes.size()) {                         case 0:                             break;                         case 1: {                             final String attributeValue = attributeValueNodes.get(0).getStringValue();                             attributes.add(new Attribute(attributeName, attributeValue));                             break;                         }                         default: {                             final String[] attributeValues = new String[attributeValueNodes.size()];                             for (int j = 0; j < attributeValueNodes.size(); ++j) {                                 attributeValues[j] = attributeValueNodes.get(j).getStringValue();                             }                             attributes.add(new Attribute(attributeName, attributeValues));                             break;                         }                     }                 }                 return new LDIFAddChangeRecord(dn, attributes);             } catch (final JaxenException e) {                 return null;             }         } else {             return null;         }     }
synchronized void checkLeases() {     int numPathsChecked = 0;     for(; sortedLeases.size() > 0; ) {       final Lease oldest = sortedLeases.first();       if (!oldest.expiredHardLimit()) {         return;       }              // internalReleaseLease() removes paths corresponding to empty files,       // i.e. it needs to modify the collection being iterated over       // causing ConcurrentModificationException       String[] leasePaths = new String[oldest.getPaths().size()];       oldest.getPaths().toArray(leasePaths);       LOG.info(""Lease "" + oldest           + "" has expired hard limit. Recovering lease for paths: ""           + Arrays.toString(leasePaths));       for(String p : leasePaths) {         if (++numPathsChecked > this.maxPathsPerCheck) {           return;         }         try {           fsnamesystem.getFSNamesystemMetrics().numLeaseRecoveries.inc();           fsnamesystem.internalReleaseLeaseOne(               oldest, p, this.discardLastBlockIfNoSync);         } catch (IOException e) {           LOG.error(""Cannot release the path ""+p+"" in the lease ""+oldest, e);           removeLease(oldest, p);           fsnamesystem.getFSNamesystemMetrics().numLeaseManagerMonitorExceptions.inc();         }       }     }   }
public void undelete(CmsUUID entryId, String sitePath) {          CmsSitemapChange change = new CmsSitemapChange(entryId, sitePath, ChangeType.undelete);         CmsSitemapClipboardData data = CmsSitemapView.getInstance().getController().getData().getClipboardData().copy();         data.getDeletions().remove(entryId);         change.setClipBoardData(data);         commitChange(change, null);     }
public Analyzer<Partition<T>> getOrCreateAnalyzer()    {       Node node = childNode.getOrCreate(""analyzer"");       Analyzer<Partition<T>> analyzer = new AnalyzerImpl<Partition<T>>(this, ""analyzer"", childNode, node);       return analyzer;    }
public static Window showCWF(BaseComponent root, String... excludedProperties) {         Window window = showXML(CWF2XML.toDocument(root, excludedProperties));         window.setTitle(""CWF Markup"");         return window;     }
protected String getValue(String arg) {         String[] split = arg.split(""="");         if (split.length <= 1) {             return null;         }         return split[1];     }
public final void success () {   Status previousStatus = status;   status = Status.SUCCEEDED;   if (tree.listeners != null && tree.listeners.size > 0) tree.notifyStatusUpdated(this, previousStatus);   end();   if (control != null) control.childSuccess(this);  }
public Future<IEvaluation[]> execute(IEvaluation[] evals, int evalWorkers, int evalBatchSize, Iterator<DataSet> ds, Iterator<MultiDataSet> mds,                                          boolean isCG, Broadcast<String> json, Broadcast<byte[]> params){         Preconditions.checkArgument(evalWorkers > 0, ""Invalid number of evaluation workers: must be > 0. Got: %s"", evalWorkers);         Preconditions.checkState(ds != null || mds != null, ""No data provided - both DataSet and MultiDataSet iterators were null"");          //For multi-GPU we'll use a round robbin approach for worker thread/GPU affinity         int numDevices = Nd4j.getAffinityManager().getNumberOfDevices();         if(numDevices <= 0)             numDevices = 1;          //Create the device local params if required         DeviceLocalNDArray deviceLocalParams;         synchronized (this){             if(!paramsMap.containsKey(params.getValue())){                 //Due to singleton pattern, this block should execute only once (first thread)                 //Initially put on device 0. For CPU, this means we only have a single copy of the params INDArray shared by                 // all threads, which is both safe and uses the least amount of memory                 //For CUDA, we can't share threads otherwise arrays will be continually relocated, causing a crash                 //Nd4j.getMemoryManager().releaseCurrentContext();                 //NativeOpsHolder.getInstance().getDeviceNativeOps().setDevice(0);                 //Nd4j.getAffinityManager().attachThreadToDevice(Thread.currentThread(), 0);                 byte[] pBytes = params.getValue();                 INDArray p;                 try{                     p = Nd4j.read(new ByteArrayInputStream(pBytes));                 } catch (IOException e){                     throw new RuntimeException(e);  //Should never happen                 }                 DeviceLocalNDArray dlp = new DeviceLocalNDArray(p);                 paramsMap.put(params.getValue(), dlp);                 //log.info(""paramsMap: size {}"", paramsMap.size());             }             deviceLocalParams = paramsMap.get(params.getValue());         }          int currentWorkerCount;         while((currentWorkerCount = workerCount.get()) < evalWorkers){             //For load balancing: we're relying on the fact that threads are mapped to devices in a round-robbin approach             // the first time they touch an INDArray. If we assume this method is called by new threads,             // then the first N workers will be distributed evenly across available devices.                  if (workerCount.compareAndSet(currentWorkerCount, currentWorkerCount + 1)) {                     log.debug(""Starting evaluation in thread {}"", Thread.currentThread().getId());                     //This thread is now a worker                     EvaluationFuture f = new EvaluationFuture();                     f.setResult(evals);                     try {                         Model m;                         if (isCG) {                             ComputationGraphConfiguration conf = ComputationGraphConfiguration.fromJson(json.getValue());                             ComputationGraph cg = new ComputationGraph(conf);                             cg.init(deviceLocalParams.get(), false);                             m = cg;                         } else {                             MultiLayerConfiguration conf = MultiLayerConfiguration.fromJson(json.getValue());                             MultiLayerNetwork net = new MultiLayerNetwork(conf);                             net.init(deviceLocalParams.get(), false);                             m = net;                         }                          //Perform eval on this thread's data                         try {                             doEval(m, evals, ds, mds, evalBatchSize);                         } catch (Throwable t) {                             f.setException(t);                         } finally {                             f.getSemaphore().release(1);                         }                          //Perform eval on other thread's data                         while (!queue.isEmpty()) {                             Eval e = queue.poll();  //Use poll not remove to avoid race condition on last element                             if (e == null)                                 continue;                             try {                                 doEval(m, evals, e.getDs(), e.getMds(), evalBatchSize);                             } catch (Throwable t) {                                 e.getFuture().setException(t);                             } finally {                                 e.getFuture().getSemaphore().release(1);                             }                         }                     } finally {                         workerCount.decrementAndGet();                         log.debug(""Finished evaluation in thread {}"", Thread.currentThread().getId());                     }                      Nd4j.getExecutioner().commit();                     return f;                 }         }          //At this point: not a worker thread (otherwise, would have returned already)         log.debug(""Submitting evaluation from thread {} for processing in evaluation thread"", Thread.currentThread().getId());         EvaluationFuture f = new EvaluationFuture();         queue.add(new Eval(ds, mds, evals, f));         return f;     }
public void marshall(CatalogImportStatus catalogImportStatus, ProtocolMarshaller protocolMarshaller) {          if (catalogImportStatus == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(catalogImportStatus.getImportCompleted(), IMPORTCOMPLETED_BINDING);             protocolMarshaller.marshall(catalogImportStatus.getImportTime(), IMPORTTIME_BINDING);             protocolMarshaller.marshall(catalogImportStatus.getImportedBy(), IMPORTEDBY_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public final void setValidField(final int field, final boolean valid)  {   if (field < 0 || field >= FIELD_MASKS.length)    throw new KNXIllegalArgumentException(""illegal field"");   setBit(0, FIELD_MASKS[field], !valid);  }
public static void append(StringBuilder buf, String s, int offset, int length) {          synchronized (buf) {              int end = offset + length;              for (int i = offset; i < end; i++) {                  if (i >= s.length())                      break;                  buf.append(s.charAt(i));              }          }      }
public void setFeature (String name, boolean value)     throws SAXNotRecognizedException, SAXNotSupportedException     {     if (name.equals(NAMESPACES)) {         checkNotParsing(""feature"", name);         namespaces = value;         if (!namespaces && !prefixes) {         prefixes = true;         }     } else if (name.equals(NAMESPACE_PREFIXES)) {         checkNotParsing(""feature"", name);         prefixes = value;         if (!prefixes && !namespaces) {         namespaces = true;         }     } else if (name.equals(XMLNS_URIs)) {         checkNotParsing(""feature"", name);         uris = value;     } else {         throw new SAXNotRecognizedException(""Feature: "" + name);     }     }
private void processMultipart(final Multipart mp) throws MessagingException, IOException {   final int count = mp.getCount();   for (int i = 0; i < count; i++) {    final Part innerPart = mp.getBodyPart(i);    processPart(innerPart);   }  }
public void instrumentClassFile(File classfile) throws IOException {         FileInputStream fis = new FileInputStream(classfile);         byte[] bytes = transform(fis);         fis.close();         fis = null;          // If the class was successfully transformed, rewrite it         if (bytes != null) {             FileOutputStream fos = new FileOutputStream(classfile);             fos.write(bytes);             fos.close();         }     }
@Override     protected XWikiSyntaxResourceRenderer createXWikiSyntaxLinkRenderer(ListenerChain listenerChain,         ResourceReferenceSerializer linkReferenceSerializer)     {         return new XWikiSyntaxResourceRenderer((XWikiSyntaxListenerChain) listenerChain, linkReferenceSerializer);     }
public static ThreadPoolExecutor getBoundedThreadPoolExecutor(int maxPoolSize, long keepAliveTime, TimeUnit unit, ThreadFactory tFactory) {         return new ThreadPoolExecutor(0, maxPoolSize, keepAliveTime, unit,                                       new SynchronousQueue<Runnable>(), tFactory);     }
public final void recycle(final T instance) {         if (instance != null) {             usedInstances.remove(instance);             if (instance instanceof Resettable) {                 ((Resettable) instance).reset();             }             unusedInstances.add(instance);         }     }
public Integer updateInfoByIdService(String id,Map requestParamMap,String tableName,String cusCondition,String cusSetStr) throws Exception{    return updateInfoServiceInner(id,requestParamMap,tableName,cusCondition,cusSetStr,null);   }
public static void onCreate(Context context) {         sContext = context;         context.registerReceiver(ALARM_BROADCAST_RECEIVER, new IntentFilter(PING_ALARM_ACTION));         sAlarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);         sPendingIntent = PendingIntent.getBroadcast(context, 0, new Intent(PING_ALARM_ACTION), 0);         sAlarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,                 SystemClock.elapsedRealtime() + AlarmManager.INTERVAL_HALF_HOUR,                 AlarmManager.INTERVAL_HALF_HOUR, sPendingIntent);     }
@Override   public void stopped() {      // Stop heartbeat timer    if (heartBeatTimer != null) {     heartBeatTimer.cancel(false);     heartBeatTimer = null;    }      // Stop timeout checker's timer    if (checkTimeoutTimer != null) {     checkTimeoutTimer.cancel(false);     checkTimeoutTimer = null;    }      // Send ""disconnected"" packet    sendDisconnectPacket();      // Clear all stored data    nodes.clear();   }
public synchronized <T extends Object> T register(Class<T> type) throws InvalidTypeException, TypeFilterException, DoubleIDException, InvalidMethodException, InvocationException, ControllerPersistenceException {  return register(type, null);     }
@Override   public void setPermission(Path path, FsPermission permission) throws IOException {     LOG.debug(""setMode({},{})"", path, permission.toString());     AlluxioURI uri = new AlluxioURI(HadoopUtils.getPathWithoutScheme(path));     SetAttributePOptions options = SetAttributePOptions.newBuilder()         .setMode(new Mode(permission.toShort()).toProto()).setRecursive(false).build();     try {       mFileSystem.setAttribute(uri, options);     } catch (AlluxioException e) {       throw new IOException(e);     }   }
public final void evalError() {     final List<EvaluationMonitor<POSSample>> listeners = new LinkedList<EvaluationMonitor<POSSample>>();     listeners.add(new POSEvaluationErrorListener());     final POSEvaluator evaluator = new POSEvaluator(this.posTagger,         listeners.toArray(new POSTaggerEvaluationMonitor[listeners.size()]));     try {       evaluator.evaluate(this.testSamples);     } catch (IOException e) {       e.printStackTrace();     }     System.out.println(evaluator.getWordAccuracy());   }
private void configureEvent(CacheEntryListenerInvocation listenerInvocation,                                EventImpl<K, V> e, K key, V value, Metadata metadata) {       e.setKey(convertKey(listenerInvocation, key));       e.setValue(convertValue(listenerInvocation, value));       e.setMetadata(metadata);       e.setOriginLocal(true);       e.setPre(false);    }
public void getDistributedObjects(Collection<DistributedObject> result) {         Collection<DistributedObjectFuture> futures = proxies.values();         for (DistributedObjectFuture future : futures) {             if (!future.isSetAndInitialized()) {                 continue;             }             try {                 DistributedObject object = future.get();                 result.add(object);             } catch (Throwable ignored) {                 // ignore if proxy creation failed                 ignore(ignored);             }         }     }
public static ProcessBuilder getProcessBuilder(String mainClass, List<URL> classPath, List<String> args) throws LauncherException  {   List<String> cmdList = new ArrayList<String>();   String[] cmdArray;      cmdList.add(getJavaPath());   if(classPath != null && classPath.size() > 0)   {    cmdList.add(""-cp"");    cmdList.add(mkPath(classPath));   }   cmdList.add(mainClass);   if(args!=null && args.size()>0)    cmdList.addAll(args);   cmdArray = cmdList.toArray(new String[cmdList.size()]);   if(logger.isDebugEnabled())    logger.debug(""cmdArray="" + Arrays.toString(cmdArray));   return new ProcessBuilder(cmdArray);  }
@Override  public CPOptionValue fetchByUUID_G(String uuid, long groupId) {   return fetchByUUID_G(uuid, groupId, true);  }
@Override     public CancelReservedInstancesListingResult cancelReservedInstancesListing(CancelReservedInstancesListingRequest request) {         request = beforeClientExecution(request);         return executeCancelReservedInstancesListing(request);     }
private List<TransformerChangeListener> getAllListeners() {         @SuppressWarnings(""deprecation"") final List<TransformerChangeListener> globalChangeListeners =                 getAnalysisJobBuilder().getTransformerChangeListeners();          final List<TransformerChangeListener> list =                 new ArrayList<>(globalChangeListeners.size() + _localChangeListeners.size());         list.addAll(globalChangeListeners);         list.addAll(_localChangeListeners);         return list;     }
public Future<AuthenticationResult> acquireTokenByAuthorizationCode(              final String authorizationCode, final URI redirectUri,              final AsymmetricKeyCredential credential,              final AuthenticationCallback callback)              throws AuthenticationException {          return this.acquireTokenByAuthorizationCode(authorizationCode,                  redirectUri, credential, null, callback);      }
@Override     public Request<DescribeBundleTasksRequest> getDryRunRequest() {         Request<DescribeBundleTasksRequest> request = new DescribeBundleTasksRequestMarshaller().marshall(this);         request.addParameter(""DryRun"", Boolean.toString(true));         return request;     }
public void setTau0(double tau0)     {         if(tau0 <= 0 || Double.isInfinite(tau0) || Double.isNaN(tau0))             throw new IllegalArgumentException(""Eta must be a positive constant, not "" + tau0);         this.tau0 = tau0;     }
public static void runExample(AdManagerServices adManagerServices, AdManagerSession session)       throws RemoteException {     // Get the NetworkService.     NetworkServiceInterface networkService =         adManagerServices.get(session, NetworkServiceInterface.class);      // Get all networks that you have access to with the current authentication     // credentials.     Network[] networks = networkService.getAllNetworks();      if (networks == null || networks.length == 0) {       System.out.printf(""No accessible networks found.%n"");       return;     }      int i = 0;     for (Network network : networks) {       System.out.printf(           ""%d) Network with network code '%s' and display name '%s' was found.%n"",           i++, network.getNetworkCode(), network.getDisplayName());     }      System.out.printf(""Number of networks found: %d%n"", networks.length);   }
@Nonnull   public static ICommonsList <IAuthToken> getAllTokensOfSubject (@Nonnull final IAuthSubject aSubject)   {     ValueEnforcer.notNull (aSubject, ""Subject"");      return s_aRWLock.readLocked ( () -> CommonsArrayList.createFiltered (s_aMap.values (),                                                                          aToken -> aToken.getIdentification ()                                                                                          .hasAuthSubject (aSubject)));   }
@Execute     public HtmlResponse index() {         esApiManager.saveToken();         return asHtml(path_AdminDashboard_AdminDashboardJsp).renderWith(data -> {             RenderDataUtil.register(data, ""serverPath"", esApiManager.getServerPath());         });     }
protected void sendExit2(final OtpErlangPid from, final OtpErlangPid dest,             final OtpErlangObject reason) throws IOException {         sendExit(exit2Tag, from, dest, reason);     }
public String getGlobusID(String userID) {         if (userID == null) {             throw new IllegalArgumentException(i18n.getMessage(""userIdNull""));         }          if (this.map == null) {             return null;         }          Iterator iter = this.map.entrySet().iterator();         Map.Entry mapEntry;         GridMapEntry entry;         while(iter.hasNext()) {             mapEntry = (Map.Entry)iter.next();             entry = (GridMapEntry)mapEntry.getValue();             if (entry.containsUserID(userID)) {                 return entry.getGlobusID();             }         }         return null;     }
public Formula getFormula() {   Reagent[] reagents = new Reagent[] {SOURCE, PARAMETER_NAME};   return new SimpleFormula(ServletContextInitParameterPhrase.class, reagents);  }
public List<J4pRemoteException> getRemoteExceptions() {         List<J4pRemoteException> ret = new ArrayList<J4pRemoteException>();         for (Object entry : results) {             if (entry instanceof J4pRemoteException) {                 ret.add((J4pRemoteException) entry);             }         }         return ret;     }
@Override    public void run() {      // Workaround for Issue #4 (http://code.google.com/p/jdiameter/issues/detail?id=4)      // BEGIN WORKAROUND // Give some time to initialization...      int sleepTime = 250;      logger.debug(""Sleeping for {}ms before starting transport so that listeners can all be added and ready for messages"", sleepTime);      try {        Thread.sleep(sleepTime);      }      catch (InterruptedException e) {        // ignore      }      logger.debug(""Finished sleeping for {}ms. By now, MutablePeerTableImpl should have added its listener"", sleepTime);        logger.debug(""Transport is started. Socket is [{}]"", socketDescription);      Selector selector = null;      try {        selector = Selector.open();        socketChannel.register(selector, SelectionKey.OP_READ);        while (!stop) {          selector.select(SELECT_TIMEOUT);          Iterator<SelectionKey> it = selector.selectedKeys().iterator();          while (it.hasNext()) {            // Get the selection key            SelectionKey selKey = it.next();            // Remove it from the list to indicate that it is being processed            it.remove();            if (selKey.isValid() && selKey.isReadable()) {              // Get channel with bytes to read              SocketChannel sChannel = (SocketChannel) selKey.channel();              int dataLength = sChannel.read(buffer);              logger.debug(""Just read [{}] bytes on [{}]"", dataLength, socketDescription);              if (dataLength == -1) {                stop = true;                break;              }              buffer.flip();              byte[] data = new byte[buffer.limit()];              buffer.get(data);              append(data);              buffer.clear();            }          }        }      }      catch (ClosedByInterruptException e) {        logger.error(""Transport exception "", e);      }      catch (AsynchronousCloseException e) {        logger.error(""Transport is closed"");      }      catch (Throwable e) {        logger.error(""Transport exception "", e);      }      finally {        try {          clearBuffer();          if (selector != null) {            selector.close();          }          if (socketChannel != null && socketChannel.isOpen()) {            socketChannel.close();          }          getParent().onDisconnect();        }        catch (Exception e) {          logger.error(""Error"", e);        }        stop = false;        logger.info(""Read thread is stopped for socket [{}]"", socketDescription);      }    }
private void checkPopup(MouseEvent e) {         if (e.isPopupTrigger()) {             popup.show(this, e.getX(), e.getY());         }     }
public static Set<String> lowercaseLines(final Class<?> origin, final String resource) throws IOException {         return ImmutableSet.copyOf(new HashSet<String>() {{             readResource(origin, resource, new NullReturnLineProcessor() {                 @Override                 public boolean processLine(@Nonnull final String line) {                     final String l = simplify(line);                     // add to the containing HashSet we are currently in the init block of                     if (!l.startsWith(""#"") && !l.isEmpty()) add(toEngLowerCase(l));                     return true;                 }             });         }});     }
private void syncVfsToRfs(String folder) throws CmsException {          int action = 0;         //get all resources in the given folder         List<CmsResource> resources = m_cms.getResourcesInFolder(folder, CmsResourceFilter.IGNORE_EXPIRATION);         // now look through all resources in the folder         for (int i = 0; i < resources.size(); i++) {             CmsResource res = resources.get(i);             // test if the resource is marked as deleted. if so,             // do nothing, the corresponding file in the FS will be removed later             if (!res.getState().isDeleted()) {                 // do a recursion if the current resource is a folder                 if (res.isFolder()) {                     // first check if this folder must be synchronized                     action = testSyncVfs(res);                     // do the correct action according to the test result                     if (action == EXPORT_VFS) {                         exportToRfs(res);                     } else if (action != DELETE_VFS) {                         skipResource(res);                     }                     // recurse into the sub folders. This must be done before                     // the folder might be deleted!                     syncVfsToRfs(m_cms.getSitePath(res));                     if (action == DELETE_VFS) {                         deleteFromVfs(res);                     }                 } else {                     // if the current resource is a file, check if it has to                     // be synchronized                     action = testSyncVfs(res);                     // do the correct action according to the test result                     switch (action) {                         case EXPORT_VFS:                             exportToRfs(res);                             break;                          case UPDATE_VFS:                             updateFromRfs(res);                             break;                          case DELETE_VFS:                             deleteFromVfs(res);                             break;                          default:                             skipResource(res);                      }                 }                 // free memory                 res = null;             }         }         //  free memory         resources = null;     }
public void addInheritedSummaryAnchor(ClassDoc cd, Content inheritedTree) {         inheritedTree.addContent(writer.getMarkerAnchor(                 SectionName.NESTED_CLASSES_INHERITANCE,                 cd.qualifiedName()));     }
public static void setPreferredRoadInternColor(Integer color) {   final Preferences prefs = Preferences.userNodeForPackage(RoadNetworkLayerConstants.class);   if (prefs != null) {    if (color == null) {     prefs.remove(""ROAD_INTERN_COLOR""); //$NON-NLS-1$    } else {     prefs.put(""ROAD_INTERN_COLOR"", Integer.toString(color.intValue())); //$NON-NLS-1$    }    try {     prefs.flush();    } catch (BackingStoreException exception) {     //    }   }  }
private void initDefaultLoginFilter(H http) {   DefaultLoginPageGeneratingFilter loginPageGeneratingFilter = http     .getSharedObject(DefaultLoginPageGeneratingFilter.class);   if (loginPageGeneratingFilter != null) {    loginPageGeneratingFilter.setRememberMeParameter(getRememberMeParameter());   }  }
public <T> void register(final Class<T> type, final TypeConverter<T> typeConverter) {   converters.put(type, typeConverter);  }
@Override     public R visitUnknown(TypeMirror t, P p) {         throw new UnknownTypeException(t, p);     }
public void removeAttributeNS(String namespaceURI, String localName)         throws DOMException {         throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, null);     }
@Override     public boolean isJobInstancePurgeable(long jobInstanceId) {         InstanceState instanceState = getJobInstance(jobInstanceId).getInstanceState();          if (instanceState.equals(InstanceState.SUBMITTED)             || instanceState.equals(InstanceState.JMS_QUEUED)             || instanceState.equals(InstanceState.JMS_CONSUMED)             || instanceState.equals(InstanceState.DISPATCHED)) {             return false;         } else {             return true;         }     }
public synchronized void putAll(SerialArrayList<U> data, int startIndex) {     ensureCapacity((startIndex * unitSize) + data.maxByte);     System.arraycopy(data.buffer, 0, this.buffer, startIndex * unitSize, data.maxByte);   }
@Override    public void doAction(char cha) {        if (cha == '\""') {          /* annotation for first section:simple polymer section */        if (sectionCounter == 1) {          LOG.info(""Add annotation to simple polymer:"");          PolymerNotation current = _parser.notationContainer.getCurrentPolymer();          _parser.notationContainer.changeLastPolymerNotation(new PolymerNotation(current.getPolymerID(),              current.getPolymerElements(), comment));          _parser.setState(new BetweenParser(_parser));        } /* annotation for second section:connection section */ else if (sectionCounter == 2) {          LOG.info(""Add annotation to connection section:"");          ConnectionNotation current = _parser.notationContainer.getCurrentConnection();          _parser.notationContainer.changeConnectionNotation(new ConnectionNotation(current.getSourceId(),              current.getTargetId(), current.getSourceUnit(), current.getTargetUnit(), current.getrGroupSource(),              current.getrGroupTarget(), comment));          _parser.setState(new BetweenInlineConnectionParser(_parser));        } /* annotation for a single monomer in the first section */ else if (sectionCounter == 11) {          LOG.info(""Add annotation to a single monomer:"");          _parser.notationContainer.getCurrentPolymer().getPolymerElements().getCurrentMonomerNotation().setAnnotation(comment);          _parser.setState(new BetweenInlineMonomerParser(_parser));        }        } else {        comment += (cha);      }    }
@Programmatic     public List<CommunicationChannelOwnerLink> findByOwner(final CommunicationChannelOwner owner) {         if(owner == null) {             return null;         }         final Bookmark bookmark = bookmarkService.bookmarkFor(owner);         if(bookmark == null) {             return null;         }         return container.allMatches(                 new QueryDefault<>(CommunicationChannelOwnerLink.class,                         ""findByOwner"",                         ""ownerObjectType"", bookmark.getObjectType(),                         ""ownerIdentifier"", bookmark.getIdentifier()));     }
public static NumberingSystem getInstance(ULocale locale) {         // Check for @numbers         boolean nsResolved = true;         String numbersKeyword = locale.getKeywordValue(""numbers"");         if (numbersKeyword != null ) {             for ( String keyword : OTHER_NS_KEYWORDS ) {                 if ( numbersKeyword.equals(keyword)) {                     nsResolved = false;                     break;                 }             }         } else {             numbersKeyword = ""default"";             nsResolved = false;         }          if (nsResolved) {             NumberingSystem ns = getInstanceByName(numbersKeyword);             if (ns != null) {                 return ns;             }             // If the @numbers keyword points to a bogus numbering system name,             // we return the default for the locale.             numbersKeyword = ""default"";         }          // Attempt to get the numbering system from the cache         String baseName = locale.getBaseName();         // TODO: Caching by locale+numbersKeyword could yield a large cache.         // Try to load for each locale the mappings from OTHER_NS_KEYWORDS and default         // to real numbering system names; can we get those from supplemental data?         // Then look up those mappings for the locale and resolve the keyword.         String key = baseName+""@numbers=""+numbersKeyword;         LocaleLookupData localeLookupData = new LocaleLookupData(locale, numbersKeyword);         return cachedLocaleData.getInstance(key, localeLookupData);     }
@NonNull   public Caffeine<K, V> weakKeys() {     requireState(keyStrength == null, ""Key strength was already set to %s"", keyStrength);     requireState(writer == null, ""Weak keys may not be used with CacheWriter"");      keyStrength = Strength.WEAK;     return this;   }
protected void validate(String operationType) throws Exception   {    super.validate(operationType);      MPSString id_validator = new MPSString();    id_validator.validate(operationType, id, ""\""id\"""");        MPSInt adapter_id_validator = new MPSInt();    adapter_id_validator.validate(operationType, adapter_id, ""\""adapter_id\"""");        MPSInt virtualdrive_validator = new MPSInt();    virtualdrive_validator.validate(operationType, virtualdrive, ""\""virtualdrive\"""");        MPSInt targetid_validator = new MPSInt();    targetid_validator.validate(operationType, targetid, ""\""targetid\"""");        MPSString name_validator = new MPSString();    name_validator.setConstraintMaxStrLen(MPSConstants.GENERIC_CONSTRAINT, 128);    name_validator.setConstraintMinStrLen(MPSConstants.GENERIC_CONSTRAINT, 1);    name_validator.validate(operationType, name, ""\""name\"""");        MPSString size_validator = new MPSString();    size_validator.setConstraintMaxStrLen(MPSConstants.GENERIC_CONSTRAINT, 128);    size_validator.setConstraintMinStrLen(MPSConstants.GENERIC_CONSTRAINT, 1);    size_validator.validate(operationType, size, ""\""size\"""");        MPSString state_validator = new MPSString();    state_validator.setConstraintMaxStrLen(MPSConstants.GENERIC_CONSTRAINT, 128);    state_validator.setConstraintMinStrLen(MPSConstants.GENERIC_CONSTRAINT, 1);    state_validator.validate(operationType, state, ""\""state\"""");        MPSString drives_validator = new MPSString();    drives_validator.setConstraintMaxStrLen(MPSConstants.GENERIC_CONSTRAINT, 128);    drives_validator.setConstraintMinStrLen(MPSConstants.GENERIC_CONSTRAINT, 1);    drives_validator.validate(operationType, drives, ""\""drives\"""");        MPSIPAddress host_ip_address_validator = new MPSIPAddress();    host_ip_address_validator.validate(operationType, host_ip_address, ""\""host_ip_address\"""");        MPSString physical_disk_slot_1_validator = new MPSString();    physical_disk_slot_1_validator.validate(operationType, physical_disk_slot_1, ""\""physical_disk_slot_1\"""");        MPSString physical_disk_slot_2_validator = new MPSString();    physical_disk_slot_2_validator.validate(operationType, physical_disk_slot_2, ""\""physical_disk_slot_2\"""");       }
public T put(YamlNode key, Long value) {         return put(key, getNodeFactory().longNode(value));     }
private static int scanDatePart(char prefix, int defaultValue, String str, AtomicInteger pos,                                      int minDigits, int maxDigits, int minValue, int maxValue)               throws IllegalArgumentException {          // If all characters are consumed, just return the default value.          if (pos.get() >= str.length()) {              return defaultValue;          }                    // If there's a prefix character, require it.          if (prefix != '\0') {              require(str.charAt(pos.getAndIncrement()) == prefix, ""'"" + prefix + ""' expected"");          }                    // Scan up to maxDigits into a numeric value.          int value = 0;          int digitsScanned = 0;          while (pos.get() < str.length() && digitsScanned < maxDigits) {              char ch = str.charAt(pos.get());              if (ch >= '0' && ch <= '9') {                  value = value * 10 + (ch - '0');                  digitsScanned++;                  pos.incrementAndGet();              } else {                  break;              }          }                    // Ensure we got the required minimum digits and the value is within range.          Utils.require(digitsScanned >= minDigits && value >= minValue && value <= maxValue,                        ""Invalid value for date/time part"");          return value;      }
public <T> T getValue(Class<T> type, String parameter, Message message, T uriParameterValue){         if(message==null && uriParameterValue!=null){             return uriParameterValue;         }         T value = message.getHeader(parameter, type);         if(value==null){             value = uriParameterValue;         }         return value;     }
private PatchingResult applyPatch(final String patchId, final Patch patch, final IdentityPatchContext context) throws PatchingException, IOException, XMLStreamException {          final Identity identity = patch.getIdentity();         final Patch.PatchType patchType = identity.getPatchType();         final InstallationManager.InstallationModification modification = context.getModification();         if (patchType == Patch.PatchType.CUMULATIVE) {             // Invalidate all installed patches (one-off, cumulative) - we never need to invalidate the release base             final List<String> invalidation = new ArrayList<String>(modification.getPatchIDs());             if (!invalidation.isEmpty()) {                 try {                     // Before rolling back the one-off patches, validate that the state until that point is consistent                     validateRollbackState(invalidation.get(invalidation.size() - 1),                             modification.getUnmodifiedInstallationState());                 } catch (PatchingException e) {                     throw e;                 } catch (Exception e) {                     throw new PatchingException(e);                 }                 // Invalidate the installed patches first                 for (final String rollback : invalidation) {                     rollback(rollback, context);                 }             }         }          // Add to installed patches list         modification.addInstalledPatch(patchId);          // Then apply the current patch         for (final PatchElement element : patch.getElements()) {             // Apply the content modifications             final IdentityPatchContext.PatchEntry target = context.resolveForElement(element);             final PatchElementProvider provider = element.getProvider();             final Patch.PatchType elementPatchType = provider.getPatchType();             final String elementPatchId = element.getId();             // See if we can skip this element             if (target.isApplied(elementPatchId)) {                 // TODO if it is already applied, we can just skip the entry (maybe based ont the type of the patch)                 // This needs some further testing, maybe we need to compare our history with the patch if they are consistent                 throw PatchLogger.ROOT_LOGGER.alreadyApplied(elementPatchId);             }             // Check upgrade conditions             checkUpgradeConditions(provider, target);             apply(elementPatchId, element.getModifications(), target);             target.apply(elementPatchId, elementPatchType);         }         // Apply the patch to the identity         final IdentityPatchContext.PatchEntry identityEntry = context.getIdentityEntry();         apply(patchId, patch.getModifications(), identityEntry);         identityEntry.apply(patchId, patchType);          // Port forward missing module changes         if (patchType == Patch.PatchType.CUMULATIVE) {             portForward(patch, context);         }          // We need the resulting version for rollback         if (patchType == Patch.PatchType.CUMULATIVE) {             final Identity.IdentityUpgrade upgrade = identity.forType(Patch.PatchType.CUMULATIVE, Identity.IdentityUpgrade.class);             identityEntry.setResultingVersion(upgrade.getResultingVersion());         }          // Execute the tasks         final IdentityApplyCallback callback = new IdentityApplyCallback(patch, identityEntry.getDirectoryStructure());         try {             return executeTasks(context, callback);         } catch (Exception e) {             context.cancel(callback);             throw rethrowException(e);         }     }
private Map<NodeId, NodeId> resolveAliases(Iterable<Alias> aliases) {         Map<NodeId, NodeId> resolved = Maps.newHashMap();         Map<NodeId, Set<NodeId>> inverse = Maps.newHashMap();          for (Alias alias : aliases) {             NodeId from = alias.getFromId();             NodeId to = alias.getToId();             if (resolved.containsKey(to)) {                 to = resolved.get(to);             }             resolved.put(from, to);             if (inverse.get(to) == null) {                 inverse.put(to, Sets.<NodeId> newHashSet());             }             inverse.get(to).add(from);              Set<NodeId> prev = inverse.get(from);             if (prev != null) {                 for (NodeId id : prev) {                     resolved.remove(id);                     inverse.get(from).remove(id);                     resolved.put(id, to);                     inverse.get(to).add(id);                 }             }         }          return resolved;     }
public List<InputColumn<?>> getAvailableInputColumns(final ComponentBuilder componentBuilder,             final Class<?> dataType) {         List<InputColumn<?>> result = getAvailableInputColumns(dataType);          final SourceColumnFinder finder = new SourceColumnFinder();         finder.addSources(this);          result = CollectionUtils.filter(result, new Predicate<InputColumn<?>>() {             @Override             public Boolean eval(InputColumn<?> inputColumn) {                 if (inputColumn.isPhysicalColumn()) {                     return true;                 }                  final InputColumnSourceJob origin = finder.findInputColumnSource(inputColumn);                 if (origin == null) {                     return true;                 }                  if (origin == componentBuilder) {                     // exclude columns from the component itself                     return false;                 }                  final Set<Object> sourceComponents = finder.findAllSourceJobs(origin);                 if (sourceComponents.contains(componentBuilder)) {                     // exclude columns that depend                     return false;                 }                  return true;             }         });          return result;     }
public static Member member(MemberId memberId, Address address) {     return builder(memberId)         .withAddress(address)         .build();   }
@Override  public void close() throws IOException {   for(int i=0;i<oss.length;++i) {    if(close[i]) {     oss[i].close();    }      }  }
public Object executeOutboundOperation(final Message<?> message) {    try {    String serializedMessage = messageMarshaller.serialize(message);     if (snsTestProxy == null) {     PublishRequest request = new PublishRequest();     PublishResult result = client.publish(request.withTopicArn(       topicArn).withMessage(serializedMessage));     log.debug(""Published message to topic: ""       + result.getMessageId());    } else {     snsTestProxy.dispatchMessage(serializedMessage);    }    } catch (MessageMarshallerException e) {    log.error(e.getMessage(), e);    throw new MessagingException(e.getMessage(), e.getCause());   }    return message.getPayload();  }
public static String formatDate(Date d, String fmt) {         return FastDateFormat.getInstance(fmt).format(d);     }
private boolean isInlineAppend(FQMethod fqm) {         if (!SignatureUtils.isPlainStringConvertableClass(fqm.getClassName())) {             return false;         }          if (stack.getStackDepth() <= 1) {             return true;         }          OpcodeStack.Item itm = stack.getStackItem(1);         return itm.getUserValue() == UCPMUserValue.INLINE;     }
@Override     public void clear() {         for (int i = 0; i < buckets.length; i++) {             buckets[i] = null;         }         size = 0;         lastDeletedKey = minKey;         currentMin = null;     }
@NotNull     public OptionalLong or(@NotNull Supplier<OptionalLong> supplier) {         if (isPresent()) return this;         Objects.requireNonNull(supplier);         return Objects.requireNonNull(supplier.get());     }
public static FSAHeader read(InputStream in) throws IOException {     if (in.read() != ((FSA_MAGIC >>> 24)       ) ||         in.read() != ((FSA_MAGIC >>> 16) & 0xff) ||         in.read() != ((FSA_MAGIC >>>  8) & 0xff) ||         in.read() != ((FSA_MAGIC       ) & 0xff)) {       throw new IOException(""Invalid file header, probably not an FSA."");     }      int version = in.read();     if (version == -1) {       throw new IOException(""Truncated file, no version number."");     }      return new FSAHeader((byte) version);   }
@Override   protected Variable[] createVariablesSub(int num) {    int[] tp = tpCreate(num);    Variable[] ret = new Variable[num];    for (int i = 0; i < tp.length; i++) {     ret[i] = tPoints[tp[i]];       }    return ret;   }
public JSON with(Feature feature, boolean state)     {         int f = _features;         if (state) {             f |= feature.mask();         } else {             f &= ~feature.mask();         }         return _with(f);     }
@BetaApi   public final Policy setIamPolicyImage(       ProjectGlobalImageResourceName resource,       GlobalSetPolicyRequest globalSetPolicyRequestResource) {      SetIamPolicyImageHttpRequest request =         SetIamPolicyImageHttpRequest.newBuilder()             .setResource(resource == null ? null : resource.toString())             .setGlobalSetPolicyRequestResource(globalSetPolicyRequestResource)             .build();     return setIamPolicyImage(request);   }
protected static String toLowerCase(String input) {         if(Character.isUpperCase(input.charAt(0)))             return input.substring(0, 1).toLowerCase() + input.substring(1);         return input;     }
public void marshall(ShareDetails shareDetails, ProtocolMarshaller protocolMarshaller) {          if (shareDetails == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(shareDetails.getSuccessfulShares(), SUCCESSFULSHARES_BINDING);             protocolMarshaller.marshall(shareDetails.getShareErrors(), SHAREERRORS_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public String toQueryString(Criteria criteria, CriteriaQueryBuilder queryBuilder) {      // query builder     StringBuilder builder = new StringBuilder();      // build the basic query     builder.append( queryBuilder.getAbsolutePath(criteria, relativePath) );     builder.append( "" IN ("");          // We must add each value as a parameter, because not all JPA     // implementations allow lists or arrays as parameters.     if( values != null ) {       for( int i = 0; i < values.length; i++) {         builder.append( queryBuilder.createPositionalParameter() );         if( i < values.length - 1 ) {           builder.append(',');         }       }     }     builder.append("")"");          // return result     return builder.toString();   }
public static ClassFinder instance(Context context) {         ClassFinder instance = context.get(classFinderKey);         if (instance == null)             instance = new ClassFinder(context);         return instance;     }
@Override  public void close() throws IOException {   if (upload != null) {    flush();    // close the connection    try {     upload.close();    } catch (SQLException e) {     LOG.info(""JDBC statement could not be closed: "" + e.getMessage());    } finally {     upload = null;    }   }    if (dbConn != null) {    try {     dbConn.close();    } catch (SQLException se) {     LOG.info(""JDBC connection could not be closed: "" + se.getMessage());    } finally {     dbConn = null;    }   }  }
protected void checkDiskError(Exception e ) throws IOException {     if (e instanceof ClosedByInterruptException         || e instanceof java.io.InterruptedIOException) {       return;     }     LOG.warn(""checkDiskError: exception: "", e);          if (e.getMessage() != null &&         e.getMessage().startsWith(""No space left on device"")) {       throw new DiskOutOfSpaceException(""No space left on device"");     } else {       checkDiskError();     }   }
public static int ptb2Text(Reader ptbText, Writer w) throws IOException {      int numTokens = 0;      PTB2TextLexer lexer = new PTB2TextLexer(ptbText);      for (String token; (token = lexer.next()) != null; ) {        numTokens++;        w.write(token);      }      return numTokens;    }
public static String getDisplayName(String localeID, String displayLocaleID) {         return getDisplayNameInternal(new ULocale(localeID), new ULocale(displayLocaleID));     }
public List<MethodSymbol> interfaceCandidates(Type site, MethodSymbol ms) {         CandidatesCache.Entry e = candidatesCache.new Entry(site, ms);         List<MethodSymbol> candidates = candidatesCache.get(e);         if (candidates == null) {             Filter<Symbol> filter = new MethodFilter(ms, site);             List<MethodSymbol> candidates2 = List.nil();             for (Symbol s : membersClosure(site, false).getSymbols(filter)) {                 if (!site.tsym.isInterface() && !s.owner.isInterface()) {                     return List.of((MethodSymbol)s);                 } else if (!candidates2.contains(s)) {                     candidates2 = candidates2.prepend((MethodSymbol)s);                 }             }             candidates = prune(candidates2);             candidatesCache.put(e, candidates);         }         return candidates;     }
public ImmutableSet<ClassInfo> getTopLevelClassesRecursive(String packageName) {     checkNotNull(packageName);     String packagePrefix = packageName + '.';     ImmutableSet.Builder<ClassInfo> builder = ImmutableSet.builder();     ImmutableSet<ClassInfo> topLevelClasses = getTopLevelClasses();     List<String> debugData = Lists.newLinkedList();     for (ClassInfo classInfo : topLevelClasses) {       if (classInfo.getName().startsWith(packagePrefix)) {         builder.add(classInfo);         debugData.add(classInfo.getResourceName() + ""\n"");       }     }     return builder.build();   }
public GetDocumentTextDetectionResult withWarnings(Warning... warnings) {         if (this.warnings == null) {             setWarnings(new java.util.ArrayList<Warning>(warnings.length));         }         for (Warning ele : warnings) {             this.warnings.add(ele);         }         return this;     }
public File getFilteredVersion(File input) {         File out = getOutputFile(input);         if (!out.isFile()) {             return null;         }         return out;     }
public JobDetails getJobByJobID(String cluster, String jobId)       throws IOException {     return getJobByJobID(cluster, jobId, false);   }
public boolean markMigrated(VectorClock vectorClock) {         stateWriteLock.lock();         try {             if (stateVectorClock.equals(vectorClock)) {                 migrated = true;             }             return migrated;         } finally {             stateWriteLock.unlock();         }     }
public static WxaUserInfo validateUserInfo(String session_key, String rawData, String signature) {    try {     if (DigestUtils.shaHex(rawData + session_key).equals(signature)) {      return JsonUtil.parseObject(rawData, WxaUserInfo.class);     }    } catch (Exception e) {     logger.error("""", e);    }    return null;   }
public static String getFilename(final URL url) throws UnsupportedEncodingException  {   if (isJar(url) || isEar(url))   {    String fileName = URLDecoder.decode(url.getFile(), ""UTF-8"");    fileName = fileName.substring(5, fileName.indexOf(""!""));    return fileName;   }   return URLDecoder.decode(url.getFile(), ""UTF-8"");  }
public static DZcsn cs_chol(DZcs A, DZcss S) {    double[] d, lki ;    DZcsa Lx = new DZcsa (), x, Cx = new DZcsa () ;    int top, i, p, k, n, Li[], Lp[], cp[], pinv[], s[], c[], parent[], Cp[], Ci[] ;    DZcs L, C, E ;    DZcsn N ;    if (!CS_CSC(A) || S == null || S.cp == null || S.parent == null) return (null) ;    n = A.n ;    N = new DZcsn () ;  /* allocate result */    c = new int [2*n] ;  /* get int workspace */    x = new DZcsa (n) ;  /* get complex workspace */    cp = S.cp ; pinv = S.pinv ; parent = S.parent ;    C = pinv != null ? cs_symperm (A, pinv, true) : A ;    E = pinv != null ? C : null ; /* E is alias for A, or a copy E=A(p,p) */    if (N == null || c == null || x == null || C == null) return (cs_ndone (N, E, c, x, false)) ;    s = c ;    int s_offset = n ;    Cp = C.p ; Ci = C.i ; Cx.x = C.x ;    N.L = L = cs_spalloc (n, n, cp[n], true, false); /* allocate result */    if (L == null) return (cs_ndone (N, E, c, x, false)) ;    Lp = L.p ; Li = L.i ; Lx.x = L.x ;    for (k = 0 ; k < n ; k++) Lp [k] = c [k] = cp [k] ;    for (k = 0 ; k < n ; k++) /* compute L(k,:) for L*L' = C */    {     /* --- Nonzero pattern of L(k,:) ------------------------------------ */     top = cs_ereach (C, k, parent, s, s_offset, c) ;  /* find pattern of L(k,:) */     x.set(k, cs_czero ()) ;     /* x (0:k) is now zero */     for (p = Cp [k] ; p < Cp [k + 1] ; p++)   /* x = full(triu(C(:,k))) */     {      if (Ci [p] <= k) x.set(Ci [p], Cx.get(p)) ;     }     d = x.get(k) ;    /* d = C(k,k) */     x.set(k, cs_czero ()) ;   /* clear x for k+1st iteration */     /* --- Triangular solve --------------------------------------------- */     for ( ; top < n ; top++)  /* solve L(0:k-1,0:k-1) * x = C(:,k) */     {      i = s [s_offset + top] ; /* s [top..n-1] is pattern of L(k,:) */      lki = cs_cdiv (x.get(i), Lx.get(Lp [i])) ; /* L(k,i) = x (i) / L(i,i) */      x.set(i, cs_czero ()) ;  /* clear x for k+1st iteration */      for (p = Lp [i] + 1 ; p < c [i] ; p++)      {       x.set(Li [p], cs_cminus (x.get(Li [p]), cs_cmult (Lx.get(p), lki))) ;      }      d = cs_cminus (d, cs_cmult (lki, cs_conj (lki))) ; /* d = d - L(k,i)*L(k,i) */      p = c [i]++ ;      Li [p] = k ;   /* store L(k,i) in column i */      Lx.set(p, cs_conj (lki)) ;     }     /* --- Compute L(k,k) ----------------------------------------------- */     if (d[0] <= 0 || d[1] != 0)      return (cs_ndone (N, E, c, x, false)) ; /* not pos def */     p = c [k]++ ;     Li [p] = k ;    /* store L(k,k) = sqrt (d) in column k */     Lx.set(p, cs_csqrt (d)) ;    }    Lp [n] = cp [n] ;    /* finalize L */    return (cs_ndone (N, E, c, x, true)) ;  /* success: free E,s,x; return N */   }
public static Map<Object, int[]> countAnnotationsPerCategory(     final ICodingAnnotationStudy study) {    Map<Object, int[]> result = new HashMap<Object, int[]>();    for (ICodingAnnotationItem item : study.getItems()) {              for (IAnnotationUnit unit : item.getUnits()) {      Object category = unit.getCategory();      if (category == null) {                      continue;                  }        int[] counts = result.get(category);      if (counts == null) {                      counts = new int[study.getRaterCount()];                  }      counts[unit.getRaterIdx()]++;      result.put(category, counts);     }          }    return result;   }
@SuppressWarnings(""unchecked"")   void registerConsumer(Inspector<? super OutT> subInspector) {     consumers.add((Inspector<OutT>) subInspector);   }
void logOrphans(final List<Map<String, Object>> toLog) {         try {             String result = pretty                     ? prettyWriter().writeValueAsString(toLog)                     : writer().writeValueAsString(toLog);             LOGGER.warn(""Orphan responses observed: {}"", result);         } catch (Exception ex) {             LOGGER.warn(""Could not write orphan log."", ex);         }     }
public void setRefreshType(com.google.api.ads.admanager.axis.v201902.RefreshType refreshType) {         this.refreshType = refreshType;     }
protected void resolvePropertyReplacements(Api api) {         if (api == null) {             return;         }         String endpoint = api.getEndpoint();         endpoint = resolveProperties(endpoint);         api.setEndpoint(endpoint);          Map<String, String> properties = api.getEndpointProperties();         for (Entry<String, String> entry : properties.entrySet()) {             String value = entry.getValue();             value = resolveProperties(value);             entry.setValue(value);         }          resolvePropertyReplacements(api.getApiPolicies());     }
private static Method accessible(Method method) {         if (method != null) {             method.setAccessible(true);         }         return method;     }
public static boolean isISODate(final String val) throws BadDateException {     try {       if (val.length() != 8) {         return false;       }       fromISODate(val);       return true;     } catch (Throwable t) {       return false;     }   }
public void setFragment(boolean newFragment)   {     boolean oldFragment = fragment;     fragment = newFragment;     if (eNotificationRequired())       eNotify(new ENotificationImpl(this, Notification.SET, SimpleAntlrPackage.RULE__FRAGMENT, oldFragment, fragment));   }
@NonNull     private static ObservableTransformer<byte[], PresenterEvent> transformToPresenterEvent(Type type) {         return observable -> observable.map(writtenBytes -> ((PresenterEvent) new ResultEvent(writtenBytes, type)))                 .onErrorReturn(throwable -> new ErrorEvent(throwable, type));     }
private List<String> searchTokens(SNode n, long cnr)   {     List<String> result = new LinkedList<String>();     if (n instanceof SToken)     {       result.add(n.getId());       if (componentOfToken.get(n.getId()) == null)       {         List<Long> newlist = new LinkedList<Long>();         newlist.add(cnr);         componentOfToken.put(n.getId(), newlist);       }       else       {         List<Long> newlist = componentOfToken.get(n.getId());         if (!newlist.contains(cnr))         {           newlist.add(cnr);         }       }     }     else     {       List<SRelation<SNode, SNode>> outgoing = n.getGraph().getOutRelations(n.getId());       if(outgoing != null)       {         for (SRelation<? extends SNode,? extends SNode> e : outgoing)         {           if(!(e instanceof SPointingRelation) && e.getSource() instanceof SNode && e.getTarget() instanceof SNode)           {             List<String> Med = searchTokens((SNode) e.getTarget(), cnr);             for (String s : Med)             {               if (!result.contains(s))               {                 result.add(s);               }             }           }         }       }     }     return result;   }
protected ResultSet getResultSet() {   if (table == null) {    throw new IllegalArgumentException(""missing parameter: table"");   }    String whereClause = """";   if (where != null) {             whereClause = "" WHERE "" + where;         }          try {    statement = connection.createStatement();    return statement.executeQuery(""SELECT * FROM "" + table + whereClause);   } catch (SQLException e) {    throw new RuntimeException(e);   }  }
public Observable<ServiceResponse<OperationStatus>> updatePrebuiltEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdatePrebuiltEntityRoleOptionalParameter updatePrebuiltEntityRoleOptionalParameter) {         if (this.client.endpoint() == null) {             throw new IllegalArgumentException(""Parameter this.client.endpoint() is required and cannot be null."");         }         if (appId == null) {             throw new IllegalArgumentException(""Parameter appId is required and cannot be null."");         }         if (versionId == null) {             throw new IllegalArgumentException(""Parameter versionId is required and cannot be null."");         }         if (entityId == null) {             throw new IllegalArgumentException(""Parameter entityId is required and cannot be null."");         }         if (roleId == null) {             throw new IllegalArgumentException(""Parameter roleId is required and cannot be null."");         }         final String name = updatePrebuiltEntityRoleOptionalParameter != null ? updatePrebuiltEntityRoleOptionalParameter.name() : null;          return updatePrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name);     }
@Override     public <T, A> AsyncFuture<T> executeRequest(final Integer operationId, final ManagementRequest<T, A> request) throws IOException {         final ActiveOperation<T, A> operation = super.getActiveOperation(operationId);         if(operation == null) {             throw ProtocolLogger.ROOT_LOGGER.responseHandlerNotFound(operationId);         }         return executeRequest(operation, request);     }
private static void assignKeyFromAddressNode(ModelNode payload, ModelNode address) {         List<Property> props = address.asPropertyList();         Property lastToken = props.get(props.size()-1);         payload.get(""entity.key"").set(lastToken.getValue().asString());     }
public void setNeedleBorderColor(final Color COLOR) {         if (null == needleBorderColor) {             _needleBorderColor = null == COLOR ? Color.TRANSPARENT : COLOR;             fireUpdateEvent(REDRAW_EVENT);         } else {             needleBorderColor.set(COLOR);         }     }
public String getReservedNickname() throws SmackException, InterruptedException {         try {             DiscoverInfo result =                 ServiceDiscoveryManager.getInstanceFor(connection).discoverInfo(                     room,                     ""x-roomuser-item"");             // Look for an Identity that holds the reserved nickname and return its name             for (DiscoverInfo.Identity identity : result.getIdentities()) {                 return identity.getName();             }         }         catch (XMPPException e) {             LOGGER.log(Level.SEVERE, ""Error retrieving room nickname"", e);         }         // If no Identity was found then the user does not have a reserved room nickname         return null;     }
private boolean isInjectorOrAssistedProvider(Dependency<?> dependency) {     Class<?> annotationType = dependency.getKey().getAnnotationType();     if (annotationType != null && annotationType.equals(Assisted.class)) { // If it's assisted..       if (dependency           .getKey()           .getTypeLiteral()           .getRawType()           .equals(Provider.class)) { // And a Provider...         return true;       }     } else if (dependency         .getKey()         .getTypeLiteral()         .getRawType()         .equals(Injector.class)) { // If it's the Injector...       return true;     }     return false;   }
private static void doInsert(CallInfo callInfo, Table table, DataSet data) {     StringBuilder sql = new StringBuilder(""INSERT INTO "");     List<String> tableColumns = table.getColumns();     int columnCount = tableColumns.size();     int[] paramIdx = new int[columnCount];     int param = 0;     Iterator<String> itr = tableColumns.iterator();     String col = itr.next();          paramIdx[param] = ++param;     sql.append(table.getName())        .append('(')        .append(col);          while (itr.hasNext()) {       paramIdx[param] = ++param;       col = itr.next();       sql.append(',')          .append(col);     }     sql.append("") VALUES (?"");     for (int i=1; i < columnCount; i++) {       sql.append("",?"");     }     sql.append(')');      dataSetOperation(callInfo, table, data, sql.toString(), paramIdx);   }
private Map<Key, Object> cacheGetAll(final Collection<Key> keys) {    try {     return this.memcache.getAll(keys);    } catch (Exception ex) {     // Some sort of serialization error, just wipe out the values     log.warn(""Error fetching values from memcache, deleting keys"", ex);       this.memcache.deleteAll(keys);       return new HashMap<>();    }   }
@Override  public HashMap<String, Object> getApplicationMap() {   return (HashMap<String, Object>) JKThreadLocal.getValue(JKContextConstants.APPLICATION_MAP);  }
@SuppressWarnings(""unchecked"")     private void readObject(java.io.ObjectInputStream s)         throws java.io.IOException, ClassNotFoundException     {         // Read in the key type and any hidden stuff         s.defaultReadObject();          keyUniverse = getKeyUniverse(keyType);         vals = new Object[keyUniverse.length];          // Read in size (number of Mappings)         int size = s.readInt();          // Read the keys and values, and put the mappings in the HashMap         for (int i = 0; i < size; i++) {             K key = (K) s.readObject();             V value = (V) s.readObject();             put(key, value);         }     }
public Set getSIBDestinationLocalitySet(String busName, String uuid,                                             boolean newSet) throws SIBExceptionDestinationNotFound,                     SIBExceptionBase {          /*          * if (TraceComponent.isAnyTracingEnabled() &&          * tc.isEntryEnabled()) SibTr.entry(tc, ""getSIBDestinationLocalitySet"",          * new Object[] { busName, uuid, new Boolean(newSet) });          *           * Set results = _engine.getSIBDestinationLocalitySet(busName, uuid,          * newSet);          *           * if (TraceComponent.isAnyTracingEnabled() &&          * tc.isEntryEnabled()) SibTr.exit(tc, ""getSIBDestinationLocalitySet"",          * results);          */          //Venu Liberty change:         //_localistySet is filled up with this ME Uuid in startInternal();         // This function would get called only after _localistySet is filled up at lease once          return _localistySet;     }
@Override     public List<Character> subList(int fromIndex, int toIndex) {         return new CharArrayList(a, fromIndex, toIndex - fromIndex);     }
public static Response get(URI uri, Credentials credentials, Header[] requestHeaders)         throws URISyntaxException, HttpException {         return send(new HttpGet(uri), credentials, requestHeaders);     }
private static String[][] resizeArray(String[][] array, int size)     {         if (array.length == size) return array;         String[][] nArray = new String[size][];         System.arraycopy(array, 0, nArray, 0, size);         return nArray;     }
static <T> Optional<T> findFirst(final Class<T> service) {         final ServiceLoader<T> loader = load(service);         if (loader == null) return empty();         final Iterator<T> services = loader.iterator();         return services.hasNext() ? of(services.next()) : empty();     }
public static double getDouble(String pStr) {         if (isEmpty(pStr)) {             return 0.0;         }         double value = 0.0;         pStr = pStr.substring(0, pStr.length() - 2) + ""."" + pStr.substring(pStr.length() - 2);         try {             value = Double.parseDouble(pStr);         } catch (NumberFormatException ex) {         }         return value;     }
public void marshall(ListUsersRequest listUsersRequest, ProtocolMarshaller protocolMarshaller) {          if (listUsersRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(listUsersRequest.getBrokerId(), BROKERID_BINDING);             protocolMarshaller.marshall(listUsersRequest.getMaxResults(), MAXRESULTS_BINDING);             protocolMarshaller.marshall(listUsersRequest.getNextToken(), NEXTTOKEN_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
private Mapper<K, V> addConstraint(MapConstraint<K, V> constraint) {   this.delegate = Optional.of(MapConstraints.constrainedMap(delegate.get(), constraint));   return this;  }
private static void inplace_merge(int first, int middle, int last, IntComparator comp, Swapper swapper) {   if (first >= middle || middle >= last)    return;   if (last - first == 2) {    if (comp.compare(middle, first)<0) {     swapper.swap(first,middle);    }    return;   }   int firstCut;   int secondCut;   if (middle - first > last - middle) {    firstCut = first + (middle - first) / 2;    secondCut = lower_bound(middle, last, firstCut, comp);   }    else {    secondCut = middle + (last - middle) / 2;    firstCut = upper_bound(first, middle, secondCut, comp);   }     // rotate(firstCut, middle, secondCut, swapper);   // is manually inlined for speed (jitter inlining seems to work only for small call depths, even if methods are ""static private"")   // speedup = 1.7   // begin inline   int first2 = firstCut; int middle2 = middle; int last2 = secondCut;   if (middle2 != first2 && middle2 != last2) {    int first1 = first2; int last1 = middle2;    while (first1 < --last1) swapper.swap(first1++,last1);    first1 = middle2; last1 = last2;    while (first1 < --last1) swapper.swap(first1++,last1);    first1 = first2; last1 = last2;    while (first1 < --last1) swapper.swap(first1++,last1);   }   // end inline     middle = firstCut + (secondCut - middle);   inplace_merge(first, firstCut, middle, comp, swapper);   inplace_merge(middle, secondCut, last, comp, swapper);  }
public Observable<ServiceResponse<RegexEntityExtractor>> getRegexEntityEntityInfoWithServiceResponseAsync(UUID appId, String versionId, UUID regexEntityId) {         if (this.client.endpoint() == null) {             throw new IllegalArgumentException(""Parameter this.client.endpoint() is required and cannot be null."");         }         if (appId == null) {             throw new IllegalArgumentException(""Parameter appId is required and cannot be null."");         }         if (versionId == null) {             throw new IllegalArgumentException(""Parameter versionId is required and cannot be null."");         }         if (regexEntityId == null) {             throw new IllegalArgumentException(""Parameter regexEntityId is required and cannot be null."");         }         String parameterizedHost = Joiner.on("", "").join(""{Endpoint}"", this.client.endpoint());         return service.getRegexEntityEntityInfo(appId, versionId, regexEntityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())             .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RegexEntityExtractor>>>() {                 @Override                 public Observable<ServiceResponse<RegexEntityExtractor>> call(Response<ResponseBody> response) {                     try {                         ServiceResponse<RegexEntityExtractor> clientResponse = getRegexEntityEntityInfoDelegate(response);                         return Observable.just(clientResponse);                     } catch (Throwable t) {                         return Observable.error(t);                     }                 }             });     }
public void setContent(IContent content)  {   this.content = content;   content.setParent(this);   content.setPosition(Position.middleCenter(content).plus(offsetPosition));  }
@Override     protected AstNode parseCreateViewStatement( DdlTokenStream tokens,                                                 AstNode parentNode ) throws ParsingException {         assert tokens != null;         assert parentNode != null;          markStartOfStatement(tokens);         // CREATE [OR REPLACE]         // [[NO] FORCE] VIEW [schema.] view         // [ ( { alias [ inline_constraint... ]         // | out_of_line_constraint         // }         // [, { alias [ inline_constraint...]         // | out_of_line_constraint         // }         // ]         // )         // | object_view_clause         // | XMLType_view_clause         // ]         // AS subquery [ subquery_restriction_clause ] ;          // NOTE: the query expression along with the CHECK OPTION clause require no SQL statement terminator.         // So the CHECK OPTION clause will NOT          String stmtType = ""CREATE"";         tokens.consume(""CREATE"");         if (tokens.canConsume(""OR"", ""REPLACE"")) {             stmtType = stmtType + SPACE + ""OR REPLACE"";         } else if (tokens.canConsume(""NO"", ""FORCE"")) {             stmtType = stmtType + SPACE + ""NO FORCE"";         } else if (tokens.canConsume(""FORCE"")) {             stmtType = stmtType + SPACE + ""FORCE"";         }          tokens.consume(""VIEW"");         stmtType = stmtType + SPACE + ""VIEW"";          String name = parseName(tokens);          AstNode createViewNode = nodeFactory().node(name, parentNode, TYPE_CREATE_VIEW_STATEMENT);          // CONSUME COLUMNS         parseColumnNameList(tokens, createViewNode, TYPE_COLUMN_REFERENCE);          // (object_view_clause)         //         // OF [ schema. ] type_name         // { WITH OBJECT IDENTIFIER         // { DEFAULT | ( attribute [, attribute ]... ) }         // | UNDER [ schema. ] superview         // }         // ( { out_of_line_constraint         // | attribute { inline_constraint }...         // } [, { out_of_line_constraint         // | attribute { inline_constraint }...         // }         // ]...         // )          // (XMLType_view_clause)         //         // OF XMLTYPE [ XMLSchema_spec ]         // WITH OBJECT IDENTIFIER         // { DEFAULT | ( expr [, expr ]...) }          // Basically, if next token matches ""OF"", then parse until token matches ""AS""          if (tokens.matches(""OF"")) {             do {                 tokens.consume();             } while (!tokens.matches(""AS""));         }          tokens.consume(""AS"");          String queryExpression = parseUntilTerminator(tokens);          createViewNode.setProperty(CREATE_VIEW_QUERY_EXPRESSION, queryExpression);          markEndOfStatement(tokens, createViewNode);          return createViewNode;     }
public byte[] getBytes(int size){          _checkForRead(size);         byte[] dst = new byte[size];        _buf.get(dst, 0, size);        return dst;     }
public static vpnglobal_authenticationlocalpolicy_binding[] get(nitro_service service) throws Exception{   vpnglobal_authenticationlocalpolicy_binding obj = new vpnglobal_authenticationlocalpolicy_binding();   vpnglobal_authenticationlocalpolicy_binding response[] = (vpnglobal_authenticationlocalpolicy_binding[]) obj.get_resources(service);   return response;  }
public void setTerms(java.util.Collection<Term> terms) {         if (terms == null) {             this.terms = null;             return;         }          this.terms = new java.util.ArrayList<Term>(terms);     }
public SslPolicy withSslProtocols(String... sslProtocols) {         if (this.sslProtocols == null) {             setSslProtocols(new java.util.ArrayList<String>(sslProtocols.length));         }         for (String ele : sslProtocols) {             this.sslProtocols.add(ele);         }         return this;     }
public int scanScalar(int req_width, Pointer _cursor, int len) {         byte[] cursorb = _cursor.buffer;         int cursor = _cursor.start;          int start = 0;         int flags = SCAN_NONE;         if(len < 1) {             return flags;         }          switch(cursorb[cursor]) {         case '[': case ']':         case '{': case '}':         case '!': case '*':         case '&': case '|':         case '>': case '\'':         case '""': case '#':         case '%': case '@':         case '`':             flags |= SCAN_INDIC_S;             break;         case '-': case ':':         case '?': case ',':             if(len == 1 || cursorb[cursor+1] == ' ' || cursorb[cursor+1] == '\n') {                 flags |= SCAN_INDIC_S;             }             break;         }          if(cursorb[cursor + len - 1] != '\n') {             flags |= SCAN_NONL_E;         } else if(len > 1 && cursorb[cursor + len - 2] == '\n') {             flags |= SCAN_MANYNL_E;         }          if(            (len>0 && (cursorb[cursor] == ' ' || cursorb[cursor] == '\t')) ||            (len>1 && (cursorb[cursor + len - 1] == ' ' || cursorb[cursor + len - 1] == '\t'))            ) {             flags |= SCAN_WHITEEDGE;         }          if(len >= 3 && cursorb[cursor] == '-' && cursorb[cursor+1] == '-' && cursorb[cursor+2] == '-') {             flags |= SCAN_DOCSEP;         }          for(int i=0; i<len; i++) {             int ci = (int)(cursorb[cursor+i]&0xFF);             if(! ( ci == 0x9 ||                    ci == 0xA ||                    ci == 0xD ||                    (ci >= 0x20 && ci <= 0x7E))) {                 flags |= SCAN_NONPRINT;             } else if(ci == '\n') {                 flags |= SCAN_NEWLINE;                 if(len - i >= 3 && cursorb[cursor+i+1] == '-' && cursorb[cursor+i+2] == '-' && cursorb[cursor+i+3] == '-' ) {                     flags |= SCAN_DOCSEP;                 }                 if(i+1 < len && (cursorb[cursor+i+1] == ' ' || cursorb[cursor+i+1] == '\t')) {                     flags |= SCAN_INDENTED;                 }                 if(req_width > 0 && (i - start) > req_width) {                     flags |= SCAN_WIDE;                 }                 start = i;             } else if(ci == '\'') {                 flags |= SCAN_SINGLEQ;             } else if(ci == '""') {                 flags |= SCAN_DOUBLEQ;             } else if(ci == ']') {                 flags |= SCAN_FLOWSEQ;             } else if(ci == '}') {                 flags |= SCAN_FLOWMAP;             } else if(((ci == ' ' && (i+1<len && cursorb[cursor+i+1] == '#') ) ||                        (ci == ':' && ((i+1<len && cursorb[cursor+i+1] == ' ') ||                                        (i+1<len && cursorb[cursor+i+1] == '\n') ||                                        i == len - 1 )))) {                 flags |= SCAN_INDIC_C;             } else if(ci == ',' && ((i == len - 1 ||                                      cursorb[cursor+i+1] == ' ' ||                                       cursorb[cursor+i+1] == '\n'))) {                 flags |= SCAN_FLOWMAP;                 flags |= SCAN_FLOWSEQ;             }         }          return flags;     }
private boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg) {     for (DiGraphEdge<Node, Branch> s : cfg.getImplicitReturn().getInEdges()) {       Node n = s.getSource().getValue();       // NOTE(dimvar): it is possible to change ControlFlowAnalysis.java, so       // that the calls that always throw are treated in the same way as THROW       // in the CFG. Then, we would not need to use the coding convention here.       if (!n.isReturn() && !convention.isFunctionCallThatAlwaysThrows(n)) {         return false;       }     }     return true;   }
public static Date dateStrToDate(final String dateStr) {      String paddedDateStr = padStartDateStr(dateStr);   try {    return ArchiveUtils.parse14DigitDate(paddedDateStr);   } catch (ParseException e) {    e.printStackTrace();    // TODO: This is certainly not the right thing, but padStartDateStr    // should ensure we *never* get here..    return new Date((long)SSE_YEAR_LOWER_LIMIT * 1000);   }  }
public QueryResult execute(Query query) throws QueryEngineException {         if (!(query instanceof QueryImpl)) {             throw new QueryEngineException(""Couldn't cast Query to QueryImpl."");         }         QueryImpl q = (QueryImpl) query;           // search for unbound results vars         resvarsLoop:         for (QueryArgument arg : q.getResultVars()) {             for (QueryAtomGroup g : q.getAtomGroups()) {                 for (QueryAtom a : g.getAtoms()) {                     if (a.getArguments().contains(arg)) {                         continue resvarsLoop;                     }                 }             } //   throw new QueryEngineException(""Query contains an unbound result argument "" + arg + ""."");         }          Queue<QueryResultImpl> results = new LinkedList<>();         for (QueryAtomGroup g : q.getAtomGroups()) {              QueryAtomGroupImpl group = (QueryAtomGroupImpl) g;              List<QueryAtomGroupImpl> components = findComponents(group);             Queue<QueryResultImpl> componentResults = new LinkedList<>();             boolean groupAsk = true;             for (QueryAtomGroupImpl component : components) {                  QueryAtomGroupImpl preorderedGroup = preorder(component);                  QueryResultImpl result = new QueryResultImpl(query);                 if (eval(q, preorderedGroup, result, new QueryBindingImpl(), BoundChecking.CHECK_BOUND)) {                     if (query.isSelectDistinct()) {                         result = eliminateDuplicates(result);                     }                      componentResults.add(result);                 }                 else {                     groupAsk = false;                     break;                 }             }              if (groupAsk) {                 results.add(combineResults(componentResults,                                            query.getType() == SELECT_DISTINCT));             }             else {                 // return only empty result with no solution for this group                 QueryResultImpl ret = new QueryResultImpl(query);                 ret.setAsk(false);                 results.add(ret);             }         }          return unionResults(q, results, query.getType() == SELECT_DISTINCT);     }
protected void addTagsAsChildren( Git git,                                       CallSpecification spec,                                       DocumentWriter writer ) throws GitAPIException {         // Generate the child references to the branches, which will be sorted by name (by the command).         ListTagCommand command = git.tagList();         List<Ref> tags = command.call();         // Reverse the sort of the branch names, since they might be version numbers ...         Collections.sort(tags, REVERSE_REF_COMPARATOR);         for (Ref ref : tags) {             String fullName = ref.getName();             String name = fullName.replaceFirst(TAG_PREFIX, """");             writer.addChild(spec.childId(name), name);         }     }
public void resume(UOWHandle handle) throws CSIException {         final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();         if (isTraceOn && tc.isEntryEnabled())             Tr.entry(tc, ""resume : "" + handle);          //A null handle indicates that during the execution of the corresponding suspend,         //there wasn't a Tx to suspend, so do nothing.         if (handle != null) {             //Cast the handle to a UOWHandleImpl in order to get the instance             //variables from it.             UOWHandleImpl handleImpl = (UOWHandleImpl) handle;              try {                 //From the handle we can determine if it is a local tx.  If so resume the local                 // tx, otherwise we have a global tx.                 if (handleImpl.suspendedLocalTx != null) {                     //Get the LocalTransactionCoordinator from the handle, and resume the local                     //Tx associated with it.                     resumeLocalTx(handleImpl.suspendedLocalTx);                 }                 else {                     //Get the suspended global tx from the handle, and resume the global                     //tx associated with it.                     resumeGlobalTx(handleImpl.suspendedGlobalTx, TIMEOUT_CLOCK_START);                 }             } catch (Throwable t) {                 FFDCFilter.processException(t, CLASS_NAME + "".resume"", ""1491"", this);                 if (isTraceOn && tc.isEntryEnabled())                     Tr.exit(tc, ""resume"", ""Error resuming tx in TransactionControlImpl: "" + t);                 throw new CSIException(""Error resuming tx in TransactionControlImpl."", t);             }         }          if (isTraceOn && tc.isEntryEnabled())             Tr.exit(tc, ""resume"");     }
public static Collection<AbstractAttribute> findAttributesByAttributeFilter(             final boolean parallel,             final Predicate<? super AbstractAttribute> filter,             final AbstractHtml... fromTags) throws NullValueException {          if (filter == null) {             throw new NullValueException(""The tagName should not be null"");         }          if (fromTags == null) {             throw new NullValueException(""The fromTags should not be null"");         }          final Collection<Lock> locks = getReadLocks(fromTags);         for (final Lock lock : locks) {             lock.lock();         }          try {             return getAllNestedChildrenIncludingParent(parallel, fromTags)                     .filter(child -> {                         return child.getAttributes() != null;                     }).map(child -> {                         return child.getAttributes();                     }).flatMap(attributes -> attributes.stream()).filter(filter)                     .collect(Collectors.toSet());         } finally {             for (final Lock lock : locks) {                 lock.unlock();             }         }     }
private void sendFile(final YokeRequest request, final String file, final FileProps props) {         // write content type         String contentType = MimeType.getMime(file);         String charset = MimeType.getCharset(contentType);         request.response().setContentType(contentType, charset);         request.response().putHeader(""Content-Length"", Long.toString(props.size()));          // head support         if (HttpMethod.HEAD.equals(request.method())) {             request.response().end();         } else {             request.response().sendFile(file);         }     }
public final String getValue() {         final StringBuilder b = new StringBuilder();         if (getMinVersion() != null) {             b.append(getMinVersion());             if (getMaxVersion() != null) {                 b.append(';');             }         }         if (getMaxVersion() != null) {             b.append(getMaxVersion());         }         return b.toString();     }
private static boolean keyIsValid(final BinaryRequest request) {         if (request.keyBytes() == null || request.keyBytes().length < MIN_KEY_BYTES) {             request.observable().onError(new IllegalArgumentException(""The Document ID must not be null or empty.""));             return false;         }          if (request.keyBytes().length > MAX_KEY_BYTES) {             request.observable().onError(new IllegalArgumentException(                 ""The Document ID must not be longer than 250 bytes.""));             return false;         }          return true;     }
public void setRfpType(com.google.api.ads.admanager.axis.v201811.RfpType rfpType) {         this.rfpType = rfpType;     }
private static void allocateNodeLengthsWithRelocation(final int[] array,                                                            final int nodesToMove, final int insertDepth) {         int firstNode = array.length - 2;         int nextNode = array.length - 1;         int currentDepth = insertDepth == 1 ? 2 : 1;         int nodesLeftToMove = insertDepth == 1 ? nodesToMove - 2 : nodesToMove;          for (int availableNodes = currentDepth << 1; availableNodes > 0; currentDepth++) {             final int lastNode = firstNode;             firstNode = firstNode <= nodesToMove ? firstNode : first(array, lastNode - 1, nodesToMove);              int offset = 0;             if (currentDepth >= insertDepth) {                 offset = Math.min(nodesLeftToMove, 1 << (currentDepth - insertDepth));             } else if (currentDepth == insertDepth - 1) {                 offset = 1;                 if (array[firstNode] == lastNode) {                     firstNode++;                 }             }              for (int i = availableNodes - (lastNode - firstNode + offset); i > 0; i--) {                 array[nextNode--] = currentDepth;             }              nodesLeftToMove -= offset;             availableNodes = (lastNode - firstNode + offset) << 1;         }     }
public Map<String, List<String>> listCommands() {         Map<String, List<String>> result = new HashMap<String, List<String>>();         for (String cat : restMetadataJson.keySet())  {             JsonObject commands = restMetadataJson.getJsonObject(cat);             List<String> names = new ArrayList<String>();             for (String commandName: commands.keySet()) {                 names.add(commandName);             }                    result.put(cat, names);         }         return result;     }
@Override  public void open(Configuration config) throws IOException {   streamer.open();   streamer.sendBroadCastVariables(config);  }
public List<JAXBElement<Object>> get_GenericApplicationPropertyOfSquare() {         if (_GenericApplicationPropertyOfSquare == null) {             _GenericApplicationPropertyOfSquare = new ArrayList<JAXBElement<Object>>();         }         return this._GenericApplicationPropertyOfSquare;     }
public static Object columnlist(PageContext pc, Object obj) throws PageException {  if (obj instanceof Query) {      Key[] columnNames = ((Query) obj).getColumnNames();       boolean upperCase = pc.getCurrentTemplateDialect() == CFMLEngine.DIALECT_CFML;       StringBuilder sb = new StringBuilder();      for (int i = 0; i < columnNames.length; i++) {   if (i > 0) sb.append(',');   sb.append(upperCase ? columnNames[i].getUpperString() : columnNames[i].getString());      }      return sb.toString();   }  return pc.getCollection(obj, KeyConstants._COLUMNLIST);     }
public static void exportevaluationCalibrationToHtmlFile(EvaluationCalibration ec, File file) throws IOException {         String asHtml = evaluationCalibrationToHtml(ec);         FileUtils.writeStringToFile(file, asHtml);     }
public static DrawBlock getDrawBlockFromBlockState(IBlockState state, List<IProperty> extraProperties)     {         if (state == null)             return null;          DrawBlock block = new DrawBlock();         Object blockName = Block.REGISTRY.getNameForObject(state.getBlock());         if (blockName instanceof ResourceLocation)         {             String name = ((ResourceLocation)blockName).getResourcePath();             BlockType type = BlockType.fromValue(name);             block.setType(type);         }          Colour col = null;         Variation var = null;         Facing face = null;          // Add properties:         for (IProperty prop : state.getProperties().keySet())         {             String propVal = state.getValue(prop).toString();             boolean matched = false;             // Try colour first:             if (col == null)             {                 col = attemptToGetAsColour(propVal);                 if (col != null)                     matched = true;             }             // Then variant:             if (!matched && var == null)             {                 var = attemptToGetAsVariant(propVal);                 if (var != null)                     matched = true;             }             // Then facing:             if (!matched && face == null)             {                 face = attemptToGetAsFacing(propVal);                 if (face != null)                     matched = true;             }             if (!matched)             {                 if (extraProperties != null)                     extraProperties.add(prop);             }         }         if (col != null)             block.setColour(col);         if (var != null)             block.setVariant(var);         if (face != null)             block.setFace(face);         return block;     }
protected SemanticSpace getSpace() {         Transform transform = null;         if (argOptions.hasOption('T'))             transform = ReflectionUtil.getObjectInstance(                     argOptions.getStringOption('T'));         else             transform = new NoTransform();         int bound = argOptions.getIntOption('b', 10000);         int windowSize = argOptions.getIntOption('w', 5);         return new OccurrenceCounter(transform, bound, windowSize);     }
public void setLastPoint(Point3d point) {   if (this.numCoordsProperty.get()>=3) {    this.coordsProperty[this.numCoordsProperty.get()-3] = point.xProperty;    this.coordsProperty[this.numCoordsProperty.get()-2] = point.yProperty;    this.coordsProperty[this.numCoordsProperty.get()-1] = point.zProperty;    this.graphicalBounds = null;    this.logicalBounds = null;   }  }
private void addListToTerm(List<NewWord> newWords) {    if (newWords.size() == 0) {     return;    }    for (NewWord newWord : newWords) {       TermNatures termNatures = new NatureRecognition(forests).getTermNatures(newWord.getName());       if (termNatures == TermNatures.NULL) {      addTerm(newWord);     }    }   }
private JsonToken scanUnquotedString(final char firstChar) {         StringBuilder sb = new StringBuilder();         sb.append(firstChar);         int c = buffer.read();         while (c == '$' || c == '_' || Character.isLetterOrDigit(c)) {             sb.append((char) c);             c = buffer.read();         }         buffer.unread(c);         String lexeme = sb.toString();         return new JsonToken(JsonTokenType.UNQUOTED_STRING, lexeme);     }
public Object getInfoFromHandle(Object bookmark, boolean bGetTable, int iHandleType) throws DBException     {         if (iHandleType == DBConstants.OBJECT_ID_HANDLE)         {             if (!(bookmark instanceof String))                 return null;             int iLastColon = ((String)bookmark).lastIndexOf(BaseTable.HANDLE_SEPARATOR);             if (iLastColon == -1)                 return null;             if (bGetTable)                 return ((String)bookmark).substring(0, iLastColon);             else                 return ((String)bookmark).substring(iLastColon+1);         }         return bookmark;     }
public static void writePng(Image image, OutputStream out) throws IORuntimeException {    write(image, IMAGE_TYPE_PNG, out);   }
public static int select(long w, int j) {     int part1 = (int) (w & 0xFFFFFFFF);     int wfirsthalf = Integer.bitCount(part1);     if (wfirsthalf > j) {       return select(part1, j);     } else {       return select((int) (w >>> 32), j - wfirsthalf) + 32;     }   }
public static boolean hasRoles(List<String> roleNames) throws Throwable     {         DEADBOLT_HANDLER.beforeRoleCheck();          RoleHolder roleHolder = getRoleHolder();          return roleHolder != null &&                roleHolder.getRoles() != null &&                hasAllRoles(roleHolder,                            roleNames.toArray(new String[roleNames.size()]));     }
public void drawCornerShadow(             Canvas canvas,             Matrix matrix,             RectF bounds,             int elevation,             float startAngle,             float sweepAngle) {          Path arcBounds = scratch;          // Calculate the arc bounds to prevent drawing shadow in the same part of the arc.         arcBounds.rewind();         arcBounds.moveTo(bounds.centerX(), bounds.centerY());         arcBounds.arcTo(bounds, startAngle, sweepAngle);         arcBounds.close();          bounds.inset(-elevation, -elevation);         cornerColors[0] = 0;         cornerColors[1] = shadowStartColor;         cornerColors[2] = shadowMiddleColor;         cornerColors[3] = shadowEndColor;          float startRatio = 1f - (elevation / (bounds.width() / 2f));         float midRatio = startRatio + ((1f - startRatio) / 2f);         cornerPositions[1] = startRatio;         cornerPositions[2] = midRatio;          cornerShadowPaint.setShader(                 new RadialGradient(                         bounds.centerX(),                         bounds.centerY(),                         bounds.width() / 2,                         cornerColors,                         cornerPositions,                         Shader.TileMode.CLAMP));          // TODO: handle oval bounds by scaling the canvas.          canvas.save();         canvas.concat(matrix);         cornerShadowPaint.setStyle(Paint.Style.STROKE);         cornerShadowPaint.setStrokeWidth(elevation * 2);         canvas.drawArc(bounds, startAngle, sweepAngle, false, cornerShadowPaint);         canvas.restore();     }
@Override   public StatementInfo[] getInfos(String CorpNum, int ItemCode,     String[] MgtKeyList) throws PopbillException {    if (MgtKeyList == null)     throw new PopbillException(-99999999, ""관리번호 배열이 입력되지 않았습니다."");        String PostData = toJsonString(MgtKeyList);        return httppost(""/Statement/"" + ItemCode, CorpNum,        PostData, null, StatementInfo[].class);   }
synchronized void close()    {       releaseWriterAndReaders();       if (directory != null)       {          try          {             directory.close();          }          catch (IOException e)          {             directory = null;          }       }    }
public static boolean isColumnNullable (Connection conn, String table,                                             String column)         throws SQLException     {         ResultSet rs = getColumnMetaData(conn, table, column);         try {             return rs.getString(""IS_NULLABLE"").equals(""YES"");         } finally {             rs.close();         }     }
@Override  public void cacheResult(   CommerceUserSegmentCriterion commerceUserSegmentCriterion) {   entityCache.putResult(CommerceUserSegmentCriterionModelImpl.ENTITY_CACHE_ENABLED,    CommerceUserSegmentCriterionImpl.class,    commerceUserSegmentCriterion.getPrimaryKey(),    commerceUserSegmentCriterion);    commerceUserSegmentCriterion.resetOriginalValues();  }
protected void prepareDataForNextChannel() {         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) {             Tr.entry(tc, ""prepareDataForNextChannel"");         }          // Ensure the output buffers are already set in place for the calling channel.         if (getJITAllocateAction()) {             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                 Tr.debug(tc, ""Allocation was done here, adjust and hand off buffers, JIT=""                              + getJITAllocateSize());             }              // Multiple cases to handle here. Remember, we allocated these buffers.             // 1 - decNetBuffers has only 1 buffer and it is <= the JIT size             // We can just send it up to the caller.             // 2 - decNetBuffers has only 1 buffer, but it is > the JIT size             // We need to copy it to a JIT sized buffer and save the rest of a future read.             // 3 - decNetBuffers has multiple buffers, the first of which has the matching JIT size.             // We should pass the first buffer back to the caller and save the rest of a future read.             // 4 - decNetBuffers has multiple buffers, the first of which does not match the JIT size.             // We have to check ensure the JIT size is honored. May have to do a buffer copy.             int decryptedDataSize = SSLUtils.lengthOf(decryptedNetBuffers, 0);             if (decryptedNetBuffers.length == 1) {                 if (decryptedDataSize <= getJITAllocateSize()) {                      // Case 1:                     // There is only one decryptedNetBuffer and the size is less than the JIT.                     // Therefore, we can return this buffer to the caller.                     if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                         Tr.debug(tc, ""single decNetBuffer is okay to pass to caller"");                     }                     // Data is currently between pos and lim. Adjust for calling channel.                     SSLUtils.positionToLimit(decryptedNetBuffers);                     // Reset the limits saved for the decryptedNetBuffers.                     SSLUtils.setBufferLimits(decryptedNetBuffers, decryptedNetLimitInfo);                     // Store the decrypted buffer to this context for reference by the caller.                     setBuffer(decryptedNetBuffers[0]);                  } else {                     // Case 2:                     // There is only one decryptedNetBuffer, but the size is greater than the JIT.                     // Therefore, we have to copy the buffer into a JIT sized buffer                     // and save the left overs.                     if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                         Tr.debug(tc, ""only one decNetBuffer, but too big (""                                      + decryptedDataSize + "") for JIT.  Need to copy."");                     }                     // Create a new buffer to hand to the caller.                     // We want to reuse copyDataToCallerBuffers.                     // It copies from decryptedNetBuffers to getBuffers() which                     // are currently the same, so change it.                     setBuffer(SSLUtils.allocateByteBuffer(getJITAllocateSize(), false));                     getBuffer().limit(getJITAllocateSize());                     // Copy from the decNetBuffers into the buffers to be sent to the caller.                     copyDataToCallerBuffers();                 }              } else {                 // There are > 1 decryptedNetBuffers.                 // Check if the first one matches the JIT size.                 // TODO this is wrong. should be using capacity() instead of                 // remaining I think since after decrypt, remaining is less than                 // buffer cap (decrypt 4 bytes and remaining is 8188 but buffer is                 // the 8192 that JIT size is by default), meaning it's fine                 // not sure about all cases though...                 if (decryptedNetBuffers[0].remaining() == getJITAllocateSize()) {                     // Case 3:                     // Found a match. Return the first buffer to the caller and                     // save the rest for a future read.                     if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                         Tr.debug(tc, ""multiple buffers, first of which matches the JIT size"");                     }                     // Data is currently between pos and lim. Adjust for calling channel.                     decryptedNetBuffers[0].position(decryptedNetBuffers[0].limit());                     // Store the decrypted buffer to this context for reference by the caller.                     setBuffer(decryptedNetBuffers[0]);                     // Now save the other buffers in the unconsumedDecData (which is null at this point)                     if (null != unconsumedDecData) {                         if (TraceComponent.isAnyTracingEnabled() && tc.isEventEnabled()) {                             Tr.event(tc, ""Expected null unconsumed array, but isn't: ""                                          + SSLUtils.getBufferTraceInfo(unconsumedDecData));                         }                         // shouldn't release buffers we might not own (especially since                         // they shouldn't even be here in the first place)                         // WsByteBufferUtils.releaseBufferArray(unconsumedDecData);                     }                     // figure out if any more buffers exist with actual data to save                     int size = 0;                     for (int i = 1; i < decryptedNetBuffers.length; i++) {                         // if there is nothing in this buffer, just release it                         if (0 == decryptedNetBuffers[i].remaining()) {                             decryptedNetBuffers[i].release();                         } else {                             size++;                         }                     }                     if (0 < size) {                         unconsumedDecData = new WsByteBuffer[size];                         for (int i = 1, x = 0; x < size; i++, x++) {                             unconsumedDecData[x] = decryptedNetBuffers[i];                         }                         if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                             Tr.debug(tc, ""unconsumedDecData: ""                                          + SSLUtils.getBufferTraceInfo(unconsumedDecData));                         }                     }                  } else {                     // Case 4:                     // Multiple buffers, first of which doesn't match the JIT. Need to copy.                     if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                         Tr.debug(tc, ""multiple buffers, first does not match the JIT size."");                     }                     // Create a new buffer to hand to the caller.                     // We want to reuse copyDataToCallerBuffers.                     // It copies from decryptedNetBuffers to getBuffers() which                     // are currently the same, so change it.                     setBuffer(SSLUtils.allocateByteBuffer(getJITAllocateSize(), false));                     getBuffer().limit(getJITAllocateSize());                     // Adjust the decryptedNetBuffers. Results from the JSSE keep                     // untouched buffers with their pos = lim. Buffers with data                     // have nonzero pos and lim. Unused buffers have zero                     // pos and lim. We need the data to be between pos and lim                     // for the copy. Zeroing out the pos enables this.                     for (int i = 0; i < decryptedNetBuffers.length; i++) {                         decryptedNetBuffers[i].position(0);                     }                     // Copy from the decNetBuffers into the buffers to be sent to the caller.                     copyDataToCallerBuffers();                 }             }          } else {             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                 Tr.debug(tc, ""Using channel provided buffers"");             }             // Calling channel provided buffers to read into.             if (decryptedNetBufferReleaseRequired) {                 // User provided buffers were not originally adequate. Temporary                 // buffers were allocated to hold the result.                 for (int i = 0; i < this.decryptedNetBuffers.length; i++) {                     if (null != this.decryptedNetBuffers[i]) {                         this.decryptedNetBuffers[i].position(0);                     }                 }                 copyDataToCallerBuffers();             } else {                 // User provided buffers were adequate                 SSLUtils.positionToLimit(decryptedNetBuffers);                 SSLUtils.setBufferLimits(decryptedNetBuffers, decryptedNetLimitInfo);             }         }         // The decryptedNetBuffers are being given to the next channel.         // Eliminate tracking of ownership.         decryptedNetBuffers = null;         if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {             Tr.debug(tc, ""Buffers being sent to next channel: ""                          + SSLUtils.getBufferTraceInfo(getBuffers()));         }          if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) {             Tr.exit(tc, ""prepareDataForNextChannel"");         }     }
@Indexable(type = IndexableType.DELETE)  @Override  public CommerceNotificationTemplate deleteCommerceNotificationTemplate(   long commerceNotificationTemplateId) throws PortalException {   return commerceNotificationTemplatePersistence.remove(commerceNotificationTemplateId);  }
public ReportRequest asReportRequest(ReportingRule rules, Clock clock) {     Preconditions.checkState(!Strings.isNullOrEmpty(getServiceName()),         ""a service name must be set"");      // Populate metrics and labels if they can be associated with a method/operation     Operation.Builder o = asOperation(clock).toBuilder();     if (!Strings.isNullOrEmpty(o.getOperationId())         && !Strings.isNullOrEmpty(o.getOperationName())) {       Map<String, String> addedLabels = Maps.newHashMap();       for (KnownLabels l : rules.getLabels()) {         l.performUpdate(this, addedLabels);       }       // Forcibly add platform reporting here, as the base service config does not specify it as a       // label.       if (!o.getLabelsMap().containsKey(KnownLabels.SCC_PLATFORM.getName())) {         KnownLabels.SCC_PLATFORM.performUpdate(this, addedLabels);       }       o.putAllLabels(getSystemLabels());       o.putAllLabels(addedLabels);       KnownMetrics[] metrics = rules.getMetrics();       for (KnownMetrics m : metrics) {         m.performUpdate(this, o);       }     }      String[] logs = rules.getLogs();     long timestampMillis = clock.currentTimeMillis();     for (String l : logs) {       o.addLogEntries(asLogEntry(l, timestampMillis));     }      return ReportRequest.newBuilder().addOperations(o).setServiceName(getServiceName()).build();   }
public PrintWriter getLogWriter() throws SQLException     {         if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())             Tr.debug(tc, ""getLogWriter : "" + ivPuId + "", "" + ivLogWriter);          return ivLogWriter;     }
public PhotoList<Photo> getPhotos(String photosetId, int perPage, int page) throws FlickrException {          return getPhotos(photosetId, Extras.MIN_EXTRAS, Flickr.PRIVACY_LEVEL_NO_FILTER, perPage, page);      }
public static <T, X extends Throwable> Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXWithError(             final Stream<T> stream, final long x, final Consumer<? super T> consumerElement, final Consumer<? super Throwable> consumerError) {         return forEachXEvents(stream, x, consumerElement, consumerError, () -> {         });     }
public static SSTableIndexIndex readIndex(final FileSystem fileSystem, final Path sstablePath) throws IOException {         final Closer closer = Closer.create();         final Path indexPath = sstablePath.suffix(SSTABLE_INDEX_SUFFIX);          // Detonate if we don't have an index.         final FSDataInputStream inputStream = closer.register(fileSystem.open(indexPath));          final SSTableIndexIndex indexIndex = new SSTableIndexIndex();         try {             while (inputStream.available() != 0) {                 indexIndex.add(inputStream.readLong(), inputStream.readLong());             }         } finally {             closer.close();         }          return indexIndex;     }
public <T> T unwrap(final Class<T> iface) throws SQLException {         if (!isWrapperFor(iface)) {             throw new SQLException();         } // end of if          @SuppressWarnings(""unchecked"")         final T proxy = (T) this;          return proxy;     }
private V binarySearch(final K iKey) {      int low = 0;      int high = getSize() - 1;      int mid = 0;        while (low <= high) {        mid = (low + high) >>> 1;        Object midVal = getKeyAt(mid);          if (tree.comparator != null)          tree.pageItemComparator = tree.comparator.compare((K) midVal, iKey);        else          tree.pageItemComparator = ((Comparable<? super K>) midVal).compareTo(iKey);          if (tree.pageItemComparator == 0) {          // FOUND: SET THE INDEX AND RETURN THE NODE          tree.pageItemFound = true;          tree.pageIndex = mid;          return getValueAt(tree.pageIndex);        }          if (low == high)          break;          if (tree.pageItemComparator < 0)          low = mid + 1;        else          high = mid;      }        tree.pageIndex = mid;      return null;    }
private static String initCreateEntityQuery(EntityKeyMetadata entityKeyMetadata) {   StringBuilder queryBuilder = new StringBuilder( ""CREATE "" );   appendEntityNode( ENTITY_ALIAS, entityKeyMetadata, queryBuilder );   queryBuilder.append( "" RETURN "" );   queryBuilder.append( ENTITY_ALIAS );   return queryBuilder.toString();  }
public void loadFolder(String folderPath) {    // Get the file path.    File path = null;    if(folderPath != null && folderPath.length() > 0) {     path = new File(folderPath);    }        this.loadFolder(path);   }
@Override  public void addDecorator(String clazzName, IDecorator decorator) {   registry.put(clazzName, decorator);  }
protected boolean setConnector() {     if (this.host == null) {       log.error(""No host value set, cannot set up socket connector."");       return false;     }     if (this.port < 0 || this.port > 65535) {       log.error(""Port value is invalid {}."", Integer.valueOf(this.port));       return false;     }     if (this.executors == null) {       this.executors = new ExecutorFilter(1);     }      this.connector = new NioSocketConnector();     this.connector.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE,         ClientWorldModelInterface.TIMEOUT_PERIOD / 2); //    this.connector.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, //        (int) (ClientWorldModelInterface.TIMEOUT_PERIOD * 1.1f));     if (!this.connector.getFilterChain().contains(         WorldModelClientProtocolCodecFactory.CODEC_NAME)) {       this.connector.getFilterChain().addLast(           WorldModelClientProtocolCodecFactory.CODEC_NAME,           new ProtocolCodecFilter(               new WorldModelClientProtocolCodecFactory(true)));     }     this.connector.getFilterChain().addLast(""ExecutorPool"", this.executors);     this.connector.setHandler(this.ioHandler);     log.debug(""Connector set up successful."");     return true;   }
public Observable<ServiceResponse<JobExecutionInner>> createWithServiceResponseAsync(String resourceGroupName, String serverName, String jobAgentName, String jobName) {         if (resourceGroupName == null) {             throw new IllegalArgumentException(""Parameter resourceGroupName is required and cannot be null."");         }         if (serverName == null) {             throw new IllegalArgumentException(""Parameter serverName is required and cannot be null."");         }         if (jobAgentName == null) {             throw new IllegalArgumentException(""Parameter jobAgentName is required and cannot be null."");         }         if (jobName == null) {             throw new IllegalArgumentException(""Parameter jobName is required and cannot be null."");         }         if (this.client.subscriptionId() == null) {             throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");         }         if (this.client.apiVersion() == null) {             throw new IllegalArgumentException(""Parameter this.client.apiVersion() is required and cannot be null."");         }         Observable<Response<ResponseBody>> observable = service.create(resourceGroupName, serverName, jobAgentName, jobName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());         return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<JobExecutionInner>() { }.getType());     }
public void updateSecurityMetadataWithRunAs(SecurityMetadata securityMetadataFromDD, IServletConfig servletConfig) {         String runAs = servletConfig.getRunAsRole();         if (runAs != null) {             String servletName = servletConfig.getServletName();             //only add if there is no run-as entry in web.xml             Map<String, String> servletNameToRunAsRole = securityMetadataFromDD.getRunAsMap();             if (servletNameToRunAsRole.get(servletName) == null) {                 servletNameToRunAsRole.put(servletName, runAs);                 List<String> allRoles = securityMetadataFromDD.getRoles();                 if (!allRoles.contains(runAs)) {                     allRoles.add(runAs);                 }                 if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                     Tr.debug(tc, ""Added runAs role: "" + runAs);                 }             }         }     }
static <K, V> WellBehavedMap<K, V> wrap(Map<K, V> delegate) {     return new WellBehavedMap<K, V>(delegate);   }
public void writeToFile(File file, String fileContent) {          if (!file.exists()) {              try {                  FileWriter writer = new FileWriter(file);                  writer.write(fileContent);                  writer.close();              } catch (FileNotFoundException e) {                  e.printStackTrace();              } catch (IOException e) {                  e.printStackTrace();              } finally {                }          }      }
@Override     public void visit(NodeVisitor v) {         if (v.visit(this)) {             for (AstNode var : variables) {                 var.visit(v);             }         }     }
public static void extractZip(final String path, final File dest, final String prefix, final String stripPrefix,                                   final streamCopier copier) throws IOException {         extractZip(path, dest, prefix, new PrefixStripper(stripPrefix), copier);     }
public Object allocateConnection(ManagedConnectionFactory mcf, ConnectionRequestInfo cri) throws ResourceException    {       if (shutdown.get())          throw new ResourceException();       Credential credential;       if (subjectFactory == null || cmConfiguration.getSecurityDomain() == null)       {          credential = new Credential(null, cri);       }       else       {          credential = new Credential(SecurityActions.createSubject(subjectFactory,                                                                    cmConfiguration.getSecurityDomain(),                                                                    mcf),                                      cri);       }       org.ironjacamar.core.connectionmanager.listener.ConnectionListener cl = getConnectionListener(credential);       Object connection = cl.getConnection();        if (ccm != null)          ccm.registerConnection(this, cl, connection);        return connection;    }
public I_CmsExtractionResult extractContent(CmsObject cms, CmsResource resource, I_CmsSearchIndex index)     throws CmsIndexException, CmsException {          logContentExtraction(resource, index);         CmsFile file = readFile(cms, resource);         try {             return CmsExtractorPdf.getExtractor().extractText(file.getContents());         } catch (Exception e) {             if (e.getClass().getSimpleName().equals(""EncryptedDocumentException"")) {                 throw new CmsIndexException(                     Messages.get().container(Messages.ERR_DECRYPTING_RESOURCE_1, resource.getRootPath()),                     e);             }             if (e instanceof InvalidPasswordException) {                 // default password """" was wrong.                 throw new CmsIndexException(                     Messages.get().container(Messages.ERR_PWD_PROTECTED_1, resource.getRootPath()),                     e);             }             throw new CmsIndexException(                 Messages.get().container(Messages.ERR_TEXT_EXTRACTION_1, resource.getRootPath()),                 e);         }     }
public static boolean delete(File file) {         if (!file.exists())             return false;         if (file.isDirectory()) {             File[] files = file.listFiles();             for (int i = 0; files != null && i < files.length; i++)                 delete(files[i]);         }         return file.delete();     }      /**      * Closes an arbitrary closable, and logs exceptions at ignore level      *      * @param closeable the closeable to close      */     public static void close(Closeable closeable) {         try {             if (closeable != null)                 closeable.close();         } catch (IOException ignore) {         }     }      /**      * closes an input stream, and logs exceptions      *      * @param is the input stream to close      */     public static void close(InputStream is) {         close((Closeable) is);     }      /**      * closes an output stream, and logs exceptions      *      * @param os the output stream to close      */     public static void close(OutputStream os) {         close((Closeable) os);     }      /**      * closes a reader, and logs exceptions      *      * @param reader the reader to close      */     public static void close(Reader reader) {         close((Closeable) reader);     }      /**      * closes a writer, and logs exceptions      *      * @param writer the writer to close      */     public static void close(Writer writer) {         close((Closeable) writer);     }      public static byte[] readBytes(InputStream in) throws IOException {         ByteArrayOutputStream bout = new ByteArrayOutputStream();         copy(in, bout);         return bout.toByteArray();     }      /**      * A gathering write utility wrapper.      * <p>      * This method wraps a gather write with a loop that handles the limitations      * of some operating systems that have a limit on the number of buffers      * written. The method loops on the write until either all the content is      * written or no progress is made.      *      * @param out     The GatheringByteChannel to write to      * @param buffers The buffers to write      * @param offset  The offset into the buffers array      * @param length  The length in buffers to write      * @return The total bytes written      * @throws IOException if unable write to the GatheringByteChannel      */     public static long write(GatheringByteChannel out, ByteBuffer[] buffers, int offset, int length)             throws IOException {         long total = 0;         write:         while (length > 0) {             // Write as much as we can             long wrote = out.write(buffers, offset, length);              // If we can't write any more, give up             if (wrote == 0)                 break;              // count the total             total += wrote;              // Look for unwritten content             for (int i = offset; i < buffers.length; i++) {                 if (buffers[i].hasRemaining()) {                     // loop with new offset and length;                     length = length - (i - offset);                     offset = i;                     continue write;                 }             }             length = 0;         }          return total;     }      /**      * @return An outputstream to nowhere      */     public static OutputStream getNullStream() {         return __nullStream;     }      /**      * @return An outputstream to nowhere      */     public static InputStream getClosedStream() {         return __closedStream;     }      private static class NullOS extends OutputStream {         @Override         public void close() {         }          @Override         public void flush() {         }          @Override         public void write(byte[] b) {         }          @Override         public void write(byte[] b, int i, int l) {         }          @Override         public void write(int b) {         }     }      private static NullOS __nullStream = new NullOS();      private static class ClosedIS extends InputStream {         @Override         public int read() throws IOException {             return -1;         }     }      private static ClosedIS __closedStream = new ClosedIS();      /**      * @return An writer to nowhere      */     public static Writer getNullWriter() {         return __nullWriter;     }      /**      * @return An writer to nowhere      */     public static PrintWriter getNullPrintWriter() {         return __nullPrintWriter;     }      private static class NullWrite extends Writer {         @Override         public void close() {         }          @Override         public void flush() {         }          @Override         public void write(char[] b) {         }          @Override         public void write(char[] b, int o, int l) {         }          @Override         public void write(int b) {         }          @Override         public void write(String s) {         }          @Override         public void write(String s, int o, int l) {         }     }      private static NullWrite __nullWriter = new NullWrite();     private static PrintWriter __nullPrintWriter = new PrintWriter(__nullWriter);  }
public static <T1, T2> BiFunction<T1, T2, Void> function(BiConsumer<T1, T2> adaptee) {         dbc.precondition(adaptee != null, ""cannot adapt a null consumer"");         return (first, second) -> {             adaptee.accept(first, second);             return null;         };     }
URI generateOutputFile(final URI ref) {         final FileInfo srcFi = job.getFileInfo(ref);         final URI newSrc = srcFi.src.resolve(generateFilename());         final URI tmp = tempFileNameScheme.generateTempFileName(newSrc);          if (job.getFileInfo(tmp) == null) {             job.add(new FileInfo.Builder()                     .result(newSrc)                     .uri(tmp)                     .build());         }          return job.tempDirURI.resolve(tmp);     }
@Override  public void stopped() {    // Stop timer   ScheduledFuture<?> task = callTimeoutTimer.get();   if (task != null) {    task.cancel(false);   }    // Stop pending invocations   Iterator<PendingPromise> pendingPromises = promises.values().iterator();   while (pendingPromises.hasNext()) {    PendingPromise pending = pendingPromises.next();    pendingPromises.remove();    try {     pending.promise.complete(new RequestRejectedError(nodeID, pending.action));    } catch (Throwable cause) {     logger.warn(""Unable to reject action \"""" + pending.action + ""\""!"", cause);    }   }    // Stop middlewares   for (Middleware middleware : middlewares) {    try {     middleware.stopped();    } catch (Throwable cause) {     logger.warn(""Unable to stop middleware \"""" + middleware.name + ""\""!"", cause);    }   }    // Stop registered services   stopAllLocalServices();    // Clear registries   final long stamp = lock.writeLock();   try {     // Delete strategies (and registered actions)    strategies.clear();     // Delete all service names    names.clear();     // Delete middlewares    middlewares.clear();     // Delete cached node descriptor    clearDescriptorCache();    } finally {    lock.unlockWrite(stamp);   }  }
public BufferedImage copyImage(BufferedImage image) {         BufferedImage newImage = new BufferedImage(image.getWidth(), image.getHeight(), image.getType());         Graphics2D g2d = newImage.createGraphics();         g2d.drawImage(image, 0, 0, null);         g2d.dispose();         return newImage;     }
public DepictionGenerator withMappedRxnAlign(boolean val) {         DepictionGenerator copy = new DepictionGenerator(this);         copy.alignMappedReactions = val;         return copy;     }
public static Consul consul(final String host, final int port) {         try {             return new Consul(new URL(""http"", host, port, """").toString());         } catch (MalformedURLException e) {             throw new ConsulException(""Bad Consul URL"", e);         }     }
public void setLocaterInfo(SourceLocator locator)   {      if (null != locator)     {       m_publicId = locator.getPublicId();       m_systemId = locator.getSystemId();        if (null != m_systemId)       {         try         {           m_href = SystemIDResolver.getAbsoluteURI(m_systemId, null);         }         catch (TransformerException se)         {            // Ignore this for right now         }       }        super.setLocaterInfo(locator);     }   }
public void setParameter(final String key, final String value) {   parameters.put(key, new String[]{value});  }
public T find(Object val, CacheLoader<T> loader) {         if( order.size() != 1 ) {             throw new CacheManagementException(""You may only call this method when the cache is managing one unique identifier."");         }         return find(order.get(0), val, loader);     }
public SoyMsgBundle createFromResource(URL inputResource) throws IOException {      try {       String inputFileContent = Resources.asCharSource(inputResource, UTF_8).read();       return msgPlugin.parseTranslatedMsgsFile(inputFileContent);      } catch (SoyMsgException sme) {       sme.setFileOrResourceName(inputResource.toString());       throw sme;     }   }
public static void buildFieldProperties(final Class<?> aClass, final DescriptionBuilder builder) {         for (final Field field : collectClassFields(aClass)) {             final PluginProperty annotation = field.getAnnotation(PluginProperty.class);             if (null == annotation) {                 continue;             }             final Property pbuild = propertyFromField(field, annotation);             if (null == pbuild) {                 continue;             }             builder.property(pbuild);         }     }
public void debug(Object message, Throwable t) {         differentiatedLog(null, CATEGORY_FQCN, LocationAwareLogger.DEBUG_INT, message, t);     }
public org.grails.datastore.mapping.query.api.ProjectionList sum(String propertyName, String alias) {         final AggregateProjection proj = Projections.sum(calculatePropertyName(propertyName));         addProjectionToList(proj, alias);         return this;     }
static SmileGenerator newSmileGenerator(OutputStream out, byte[] buf, int offset,             boolean bufferRecyclable, IOContext context)     {         return new SmileGenerator(context,                 DEFAULT_SMILE_FACTORY.getGeneratorFeatures(),                 DEFAULT_SMILE_FACTORY.getSmileGeneratorFeatures(),                 DEFAULT_SMILE_FACTORY.getCodec(),                 out,                 buf,                 offset,                 bufferRecyclable);     }
@SuppressWarnings(""WeakerAccess"")   public ApiFuture<List<Cluster>> listClustersAsync(String instanceId) {     String name = NameUtil.formatInstanceName(projectId, instanceId);     com.google.bigtable.admin.v2.ListClustersRequest request =         com.google.bigtable.admin.v2.ListClustersRequest.newBuilder().setParent(name).build();      return ApiFutures.transform(         stub.listClustersCallable().futureCall(request),         new ApiFunction<com.google.bigtable.admin.v2.ListClustersResponse, List<Cluster>>() {           @Override           public List<Cluster> apply(com.google.bigtable.admin.v2.ListClustersResponse proto) {             // NOTE: serverside pagination is not and will not be implemented, so remaining pages             // are not fetched. However, if that assumption turns out to be wrong, fail fast to             // avoid returning partial data.             Verify.verify(                 proto.getNextPageToken().isEmpty(),                 ""Server returned an unexpected paginated response"");              ImmutableList.Builder<Cluster> clusters = ImmutableList.builder();             for (com.google.bigtable.admin.v2.Cluster cluster : proto.getClustersList()) {               clusters.add(Cluster.fromProto(cluster));             }              ImmutableList.Builder<String> failedZones = ImmutableList.builder();             for (String locationStr : proto.getFailedLocationsList()) {               failedZones.add(NameUtil.extractZoneIdFromLocationName(locationStr));             }              if (!failedZones.build().isEmpty()) {               throw new PartialListClustersException(failedZones.build(), clusters.build());             }              return clusters.build();           }         },         MoreExecutors.directExecutor());   }
private void checkForEmptyIdentifier() {     Character la = chars.lookahead(1);     if (CharType.DOT.isMatchedBy(la) || CharType.PLUS.isMatchedBy(la)         || CharType.EOL.isMatchedBy(la)) {       throw new ParseException(""Identifiers MUST NOT be empty"", new UnexpectedCharacterException(la,           chars.currentOffset(), CharType.DIGIT, CharType.LETTER, CharType.HYPHEN));     }   }
static synchronized CatLog getDefaultCatLog() {         if (!PACKAGE_CAT_LOG_KEYS.isEmpty()) {             String callingPackage = CatUtil.getCallingPackage();             for (int i = PACKAGE_CAT_LOG_KEYS.size() - 1; i >= 0; i--) {                 String catLogPackage = PACKAGE_CAT_LOG_KEYS.get(i);                 if (callingPackage.startsWith(catLogPackage)) {                     return PACKAGE_CAT_LOGS.get(catLogPackage);                 }             }         }          return defaultCatLog;     }
private void cacheStream() {         try {             File fi = getTemproralCacheFile();             if (fi.exists()) {                 if (!fi.delete()) {                     throw new IllegalStateException(""Cannot delete file "" + fi.getAbsolutePath() + ""!"");                 }             }             FileOutputStream fout = new FileOutputStream(fi);             InputStream in = grabStream();             byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];             int n;             while (-1 != (n = in.read(buffer))) {                 fout.write(buffer, 0, n);             }             fout.flush();             fout.close();             in.close();                          File cacheFile = getCacheFile();             if (!fi.renameTo(cacheFile)) {                 throw new IllegalStateException(""Cannot rename file \"""" + fi.getAbsolutePath() + ""\"" to \"""" + cacheFile.getAbsolutePath() + ""\""!"");             }         } catch (Exception e) {             e.printStackTrace();         }     }
public void initializePackageContents()   {     if (isInitialized) return;     isInitialized = true;      // Initialize package     setName(eNAME);     setNsPrefix(eNS_PREFIX);     setNsURI(eNS_URI);      // Obtain other dependent packages     XtypePackage theXtypePackage = (XtypePackage)EPackage.Registry.INSTANCE.getEPackage(XtypePackage.eNS_URI);     XbasePackage theXbasePackage = (XbasePackage)EPackage.Registry.INSTANCE.getEPackage(XbasePackage.eNS_URI);      // Create type parameters      // Set bounds for type parameters      // Add supertypes to classes      // Initialize classes and features; add operations and parameters     initEClass(modelEClass, Model.class, ""Model"", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);     initEReference(getModel_ImportSection(), theXtypePackage.getXImportSection(), null, ""importSection"", null, 0, 1, Model.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);     initEReference(getModel_Block(), theXbasePackage.getXBlockExpression(), null, ""block"", null, 0, 1, Model.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);      // Create resource     createResource(eNS_URI);   }
public synchronized static boolean areConnectedUpstream(PfafstetterNumber p1,                                                             PfafstetterNumber p2) {          List<Integer> p1OrdersList = p1.getOrdersList();         List<Integer> p2OrdersList = p2.getOrdersList();          int levelDiff = p1OrdersList.size() - p2OrdersList.size();         if (levelDiff == 0) {             if (p1.toStringUpToLastLevel().equals(p2.toStringUpToLastLevel())) {                 int p1Last = p1OrdersList.get(p1OrdersList.size() - 1);                 int p2Last = p2OrdersList.get(p2OrdersList.size() - 1);                 if (p2Last == p1Last + 1 || p2Last == p1Last + 2) {                     return p1Last % 2 != 0;                 }             }         } else if (levelDiff == -1) {             if (p2.toString().startsWith(p1.toStringUpToLastLevel())) {                 int p2Last = p2OrdersList.get(p2OrdersList.size() - 1);                 if (p2Last != 1) {                     return false;                 }                 int p1Last = p1OrdersList.get(p1OrdersList.size() - 1);                 int p2LastMinus1 = p2OrdersList.get(p2OrdersList.size() - 2);                 if (p2LastMinus1 == p1Last + 1 || p2Last == p1Last + 2) {                     return p1Last % 2 != 0;                 }             }         }         return false;     }
@Nullable   @ReturnsMutableCopy   public static ICommonsList <String> readStreamLines (@Nullable final IHasInputStream aISP,                                                        @Nonnull final Charset aCharset,                                                        @Nonnegative final int nLinesToSkip,                                                        @CheckForSigned final int nLinesToRead)   {     if (aISP == null)       return null;      return readStreamLines (aISP.getInputStream (), aCharset, nLinesToSkip, nLinesToRead);   }
private Collection<org.ironjacamar.core.api.deploymentrepository.ConfigProperty>       injectConfigProperties(Object o,                              Collection<org.ironjacamar.common.api.metadata.spec.ConfigProperty> configProperties,                              Map<String, String> overrides,                              ClassLoader classLoader)       throws Throwable    {       Collection<org.ironjacamar.core.api.deploymentrepository.ConfigProperty> dcps = null;       if (configProperties != null && !configProperties.isEmpty())       {          Injection injector = new Injection();           dcps = new ArrayList<org.ironjacamar.core.api.deploymentrepository.ConfigProperty>(configProperties.size());          for (org.ironjacamar.common.api.metadata.spec.ConfigProperty cp : configProperties)          {             String name = cp.getConfigPropertyName().getValue();             Class<?> type = Class.forName(cp.getConfigPropertyType().getValue(), true, classLoader);             boolean readOnly = cp.getConfigPropertySupportsDynamicUpdates() != null ?                cp.getConfigPropertySupportsDynamicUpdates().booleanValue() : true;             boolean confidential = cp.getConfigPropertyConfidential() != null ?                cp.getConfigPropertyConfidential().booleanValue() : false;             boolean declared = true;              Object value = cp.isValueSet() ? cp.getConfigPropertyValue().getValue() : null;             if (overrides != null)             {                if (overrides.containsKey(cp.getConfigPropertyName().getValue()))                {                   value = overrides.get(cp.getConfigPropertyName().getValue());                }                else                {                   String alternative = cp.getConfigPropertyName().getValue().substring(0, 1).toUpperCase();                   if (cp.getConfigPropertyName().getValue().length() > 1)                      alternative += cp.getConfigPropertyName().getValue().substring(1);                    if (overrides.containsKey(alternative))                   {                      value = overrides.get(alternative);                   }                   else                   {                      log.tracef(""%s: Override for %s not found"", o.getClass().getName(),                                 cp.getConfigPropertyName().getValue());                   }                }             }              if (value != null)             {                try                {                   injector.inject(o,                                   cp.getConfigPropertyName().getValue(),                                   value,                                   cp.getConfigPropertyType().getValue());                }                catch (Throwable t)                {                   type = convertType(type);                                         if (type != null)                   {                      injector.inject(o,                                      cp.getConfigPropertyName().getValue(),                                      value,                                      type.getName());                   }                   else                   {                      throw new DeployException(bundle.unableToInject(o.getClass().getName(),                            cp.getConfigPropertyName().getValue(),                            value.toString()), t);                   }                }             }              dcps.add(new ConfigPropertyImpl(o, name, type,                                             value, readOnly, confidential,                                             declared));          }       }       return dcps;    }
protected void writeVersion(WritableByteChannel channel) throws IOException {         ByteBuffer version = ByteBuffer.allocate(STORAGE_VERSION_LENGTH);         version.putInt(STORAGE_VERSION);         version.flip();         channel.write(version);     }
public static int nvgraphAllocateEdgeData(         nvgraphHandle handle,          nvgraphGraphDescr descrG,          long numsets,          Pointer settypes)     {         return checkResult(nvgraphAllocateEdgeDataNative(handle, descrG, numsets, settypes));     }
private static boolean criteriaListForcesUserLimitation(Set<String> userAndGroupIds, List<QueryCriteria> criteriaList) {         boolean userLimitiationIntersection = false;          if( criteriaList.isEmpty() ) {             return false;         }         for( QueryCriteria criteria : criteriaList ) {           if( criteria.isUnion() && criteriaList.size() > 1) {               return false;           }           if( criteria.isGroupCriteria() ) {               if( criteriaListForcesUserLimitation(userAndGroupIds, criteria.getCriteria()) ) {                   return true;               }               continue;           }           // intersection criteria           if( taskUserRoleLimitingListIds.contains(criteria.getListId()) ) {               for( Object param : criteria.getParameters() ) {                   if( userAndGroupIds.contains(param) )  {                       return true;                   }               }           }         }         return userLimitiationIntersection;     }
String toTag(Archive source, String name, Archive target) {         if (source == target || !target.getModule().isNamed()) {             return target.getName();         }          Module module = target.getModule();         String pn = name;         if ((type == CLASS || type == VERBOSE)) {             int i = name.lastIndexOf('.');             pn = i > 0 ? name.substring(0, i) : """";         }          // exported API         if (module.isExported(pn) && !module.isJDKUnsupported()) {             return showProfileOrModule(module);         }          // JDK internal API         if (!source.getModule().isJDK() && module.isJDK()){             return ""JDK internal API ("" + module.name() + "")"";         }          // qualified exports or inaccessible         boolean isExported = module.isExported(pn, source.getModule().name());         return module.name() + (isExported ?  "" (qualified)"" : "" (internal)"");     }
public String newIndex(final String name,                          final String mappingPath) throws IndexException {     try {       final String newName = name + newIndexSuffix();        final IndicesAdminClient idx = getAdminIdx();        final CreateIndexRequestBuilder cirb = idx.prepareCreate(newName);        final File f = new File(mappingPath);        final byte[] sbBytes = Streams.copyToByteArray(f);        cirb.setSource(sbBytes);        final CreateIndexRequest cir = cirb.request();        final ActionFuture<CreateIndexResponse> af = idx.create(cir);        /*resp = */af.actionGet();        //index(new UpdateInfo());        info(""Index created"");        return newName;     } catch (final ElasticsearchException ese) {       // Failed somehow       error(ese);       return null;     } catch (final IndexException ie) {       throw ie;     } catch (final Throwable t) {       error(t);       throw new IndexException(t);     }   }
public Menu get() {          String url = WxEndpoint.get(""url.menu.get"");          String content = wxClient.get(url);          logger.debug(""get default menu: {}"", content);          MenuWrapper menuWrapper = JsonMapper.nonEmptyMapper().fromJson(content, MenuWrapper.class);          return menuWrapper.getMenu();      }
public float getScalarFloat(int recnum, StructureMembers.Member m) {      if (m.getDataType() != DataType.FLOAT)        throw new IllegalArgumentException(""Type is "" + m.getDataType() + "", must be float"");      Array data = m.getDataArray();      return data.getFloat(recnum * m.getSize()); // gets first one in the array    }
@Override     public DescribeBuildResult describeBuild(DescribeBuildRequest request) {         request = beforeClientExecution(request);         return executeDescribeBuild(request);     }
public static <T extends AccessibleObject> T makeAccessible(T accessibleObject) {         AccessController.doPrivileged((PrivilegedAction<Object>) () -> {             accessibleObject.setAccessible(true);             return null;         });         return accessibleObject;     }
protected final JSerializerType getKeySerializerFromType( JType type ) throws UnsupportedTypeException, UnableToCompleteException {         return getKeySerializerFromType( type, false, false );     }
public ByteBuffer get4x4(int index, ByteBuffer buffer) {         MemUtil.INSTANCE.put4x4(this, index, buffer);         return buffer;     }
public Observable<OperationStatus> deleteHierarchicalEntityChildAsync(UUID appId, String versionId, UUID hEntityId, UUID hChildId) {         return deleteHierarchicalEntityChildWithServiceResponseAsync(appId, versionId, hEntityId, hChildId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {             @Override             public OperationStatus call(ServiceResponse<OperationStatus> response) {                 return response.body();             }         });     }
private KeyScope cascadeChildKeys(final KeyScope rootScope) {         final Map<String, KeyDef> res = new HashMap<>(rootScope.keyDefinition);         cascadeChildKeys(rootScope, res, """");         return new KeyScope(rootScope.id, rootScope.name, res, new ArrayList<>(rootScope.childScopes));     }
public String getGroupName(final HttpServletRequest request) {     Validate.notNull(request);     String uri = request.getRequestURI();     // check if include or uri path are present and use one of these as request uri.     final String includeUriPath = (String) request.getAttribute(ATTR_INCLUDE_PATH);     uri = includeUriPath != null ? includeUriPath : uri;     final String groupName = FilenameUtils.getBaseName(stripSessionID(uri));     return StringUtils.isEmpty(groupName) ? null : groupName;   }
private void callOnMessageError(WebSocketException cause, List<WebSocketFrame> frames)     {         mWebSocket.getListenerManager().callOnMessageError(cause, frames);     }
public static Optional<Method> extractGetter(final Class<?> targetClass, final String propertyName, final Class<?> propertyType) {                    final String methodName = ""get"" + Utils.capitalize(propertyName);                    Method method;          try {              method = targetClass.getMethod(methodName);                        } catch (NoSuchMethodException | SecurityException e) {              return Optional.empty();          }                    method.setAccessible(true);                    if(method.getParameterCount() > 0) {              return Optional.empty();          }                    if(!method.getReturnType().equals(propertyType)) {              return Optional.empty();          }                    return Optional.of(method);      }
public static <F, T extends Iterable<S>, S> PropertyPattern<F, T> empty(Property<F, T> property)     {         return PropertyPattern.upcast(property.matching(Iterables::isEmpty));     }
@Override     public StreamT<W,T> iterate(UnaryOperator<T> fn, T alt) {          return super.iterate(fn,alt);     }
public ListStackSetOperationsResult withSummaries(StackSetOperationSummary... summaries) {         if (this.summaries == null) {             setSummaries(new com.amazonaws.internal.SdkInternalList<StackSetOperationSummary>(summaries.length));         }         for (StackSetOperationSummary ele : summaries) {             this.summaries.add(ele);         }         return this;     }
public void checkInactiveSession(Session session) {         if (session == null) {             return;         }         if (log.isDebugEnabled()) {             log.debug(""Checking for idle "" +  session.getId());         }         try (Lock ignored = session.lock()) {             if (getEvictionPolicy() > 0 && session.isIdleLongerThan(getEvictionPolicy()) &&                     session.isValid() && session.isResident() && session.getRequests() <= 0) {                 // Be careful with saveOnInactiveEviction - you may be able to re-animate a session that was                 // being managed on another node and has expired.                 try {                     if (log.isDebugEnabled()) {                         log.debug(""Evicting idle session "" + session.getId());                     }                      // save before evicting                     if (isSaveOnInactiveEviction() && sessionDataStore != null) {                         if (sessionDataStore.isPassivating()) {                             sessionHandler.willPassivate(session);                         }                         sessionDataStore.store(session.getId(), session.getSessionData());                     }                      doDelete(session.getId()); // detach from this cache                     session.setResident(false);                 } catch (Exception e) {                     log.warn(""Passivation of idle session"" + session.getId() + "" failed"", e);                     session.updateInactivityTimer();                 }             }         }     }
public static void throwIfRequestingUnknownFeatures(HColumnDescriptor columnDescriptor) {     List<String> unknownFeatures = getUnknownFeatures(columnDescriptor);     if (!unknownFeatures.isEmpty()) {       String featureString = String.format(           ""Unknown configuration options: [%s]"",           Joiner.on("", "").join(unknownFeatures));       throw new UnsupportedOperationException(featureString);     }   }
@Override     public void doExceptionCaughtListeners(final Throwable cause) {         runManagementTask(new Runnable() {             @Override             public void run() {                 try {                     List<SessionManagementListener> sessionListeners = getManagementListeners();                     for (final SessionManagementListener listener : sessionListeners) {                         listener.doExceptionCaught(SessionManagementBeanImpl.this, cause);                     }                      markChanged();                 } catch (Exception ex) {                     logger.warn(""Error during doExceptionCaught session listener notifications:"", ex);                 }             }         });     }
private static int toSeleniumCoordinate(Object openCVCoordinate) {         if (openCVCoordinate instanceof Long) {             return ((Long) openCVCoordinate).intValue();         }         if (openCVCoordinate instanceof Double) {             return ((Double) openCVCoordinate).intValue();         }         return (int) openCVCoordinate;     }
public Event withEventCategories(String... eventCategories) {         if (this.eventCategories == null) {             setEventCategories(new com.amazonaws.internal.SdkInternalList<String>(eventCategories.length));         }         for (String ele : eventCategories) {             this.eventCategories.add(ele);         }         return this;     }
private static MavenCoordinates findCompileDependency(String zipEntryPath, String groupId) {   int apiNameIndex = zipEntryPath.indexOf(groupId);   int extensionIndex = zipEntryPath.lastIndexOf("".jar"");   if (apiNameIndex >= 0 && extensionIndex >= 0) {    String fileNameWithoutExtension = zipEntryPath.substring(apiNameIndex, extensionIndex);     String artifactId = fileNameWithoutExtension.substring(0, fileNameWithoutExtension.lastIndexOf(""_""));    String versionId = fileNameWithoutExtension.substring(fileNameWithoutExtension.lastIndexOf(""_"")+1, fileNameWithoutExtension.length());    MavenCoordinates coordinates = new MavenCoordinates(groupId, artifactId, versionId);    System.out.println(""Found compile dependency: "" + coordinates);    return coordinates;   }   return null;  }
@Nonnull   public FineUploader5DeleteFile addParam (@Nonnull @Nonempty final String sKey, @Nonnull final String sValue)   {     ValueEnforcer.notEmpty (sKey, ""Key"");     ValueEnforcer.notNull (sValue, ""Value"");      m_aDeleteFileParams.put (sKey, sValue);     return this;   }
public GroovyRowResult firstRow(GString gstring) throws SQLException {         List<Object> params = getParameters(gstring);         String sql = asSql(gstring, params);         return firstRow(sql, params);     }
public void configure(JobConf job) {     this.longCounters = new TreeMap<Object, Long>();     this.doubleCounters = new TreeMap<Object, Double>();   }
public static MozuUrl getFileUrl(String applicationKey, String fileName)   {    UrlFormatter formatter = new UrlFormatter(""/api/platform/appdev/filebasedpackage/packages/{applicationKey}?fileName={fileName}"");    formatter.formatUrl(""applicationKey"", applicationKey);    formatter.formatUrl(""fileName"", fileName);    return new MozuUrl(formatter.getResourceUrl(), MozuUrl.UrlLocation.HOME_POD) ;   }
@Override     public final <D, E> Choice3<A, D, E> biMap(Function<? super B, ? extends D> lFn,                                                Function<? super C, ? extends E> rFn) {         return match(Choice3::a, b -> b(lFn.apply(b)), c -> c(rFn.apply(c)));     }
private void post(final String endpoint, final HttpContent body, final Class responseClass, final KickflipCallback cb) {         acquireAccessToken(new OAuthCallback() {             @Override             public void onSuccess(HttpRequestFactory requestFactory) {                 request(requestFactory, METHOD.POST, makeApiUrl(endpoint), body, responseClass, cb);             }              @Override             public void onFailure(Exception e) {                 postExceptionToCallback(cb, UNKNOWN_ERROR_CODE);             }         });     }
public void dispatch_event(final EventData eventData) {         final TangoInterfaceChange interfaceChange = this;         if (EventUtil.graphicAvailable()) {             //   Causes doRun.run() to be executed asynchronously             //      on the AWT event dispatching thread.             Runnable do_work_later = new Runnable() {                 public void run() {                     fireTangoInterfaceChangeEvent(interfaceChange, eventData);                 }             };             SwingUtilities.invokeLater(do_work_later);         }         else {             fireTangoInterfaceChangeEvent(interfaceChange, eventData);         }     }
public Collection<Set<Integer>> valueSets() {         // An IntSet _is_ a Set<Integer>, but the JVM doesn't recognize         // covaraince in the return type generics, so we must cast         Collection<?> c = map.valueCollection();         @SuppressWarnings(""unchecked"")         Collection<Set<Integer>> c2 = (Collection<Set<Integer>>)c;                     return c2;     }
public short getBlockReplication(BlockInfo block) {     if (storage.isSourceBlock(block)) {       return getReplication();     } else {       if (storage.getStorageType() == StorageType.RAID_STORAGE) {         return ((INodeRaidStorage)storage).getCodec().parityReplication;       } else {         throw new IllegalStateException(""parity block "" + block +             "" belongs to a non-raid file"");       }     }   }
@SuppressWarnings(""unchecked"")     public void restoreState(FacesContext context, Object state) {          if (context == null) {             throw new NullPointerException();         }          if (state != null) {              // Unchecked cast from Object to List<BehaviorListener>             listeners = (List<BehaviorListener>)UIComponentBase.restoreAttachedState(context, state);              // If we saved state last time, save state again next time.             clearInitialState();         }     }
private ByteBuffer getPartitionKey(List<Pair<String, Serializable>> equalsList, Serializable inValue) {          assert (equalsList.size() + 1) == ((CompositeType) keyValidator).componentsCount();          ByteBuffer[] serialized = new ByteBuffer[equalsList.size() + 1];         for (int i = 0; i < equalsList.size(); i++) {             ByteBuffer buffer = ((AbstractType) keyValidator.getComponents().get(i)).decompose(equalsList.get(i).right);             serialized[i] = buffer;         }         serialized[serialized.length - 1] = ((AbstractType) keyValidator.getComponents().get(serialized.length - 1))                 .decompose(inValue);          return CompositeType.build(serialized);     }
public String getInfo() {         ReportCreator reporter = new ReportCreator(this);         return reporter.msdosHeaderReport() + reporter.coffHeaderReport() +                 reporter.optHeaderReport() + reporter.secTableReport();     }
public java.util.List<String> getMemberNames() {     List<String> memberNames = new ArrayList<>();     for (Member m : members) {       memberNames.add(m.getName());     }     return memberNames;   }
@Nullable   public static <ENUMTYPE extends Enum <ENUMTYPE> & IHasName> ENUMTYPE getFromNameOrNull (@Nonnull final Class <ENUMTYPE> aClass,                                                                                           @Nullable final String sName)   {     return getFromNameOrDefault (aClass, sName, null);   }
private void validateFinishDate(Task task)    {       if (task.getFinish() == null)       {          Date startDate = task.getStart();          if (startDate != null)          {             if (task.getMilestone())             {                task.setFinish(startDate);             }             else             {                Duration duration = task.getDuration();                if (duration != null)                {                   ProjectCalendar calendar = task.getEffectiveCalendar();                   task.setFinish(calendar.getDate(startDate, duration, false));                }             }          }       }    }
public static long toLocalDate(TimeZone browserTZ, TimeZone targetTZ, Date utcDate) {         long utc = utcDate.getTime();         int targetOffsetFromUTC = targetTZ.getOffset(utc);         int browserOffsetFromUTC = browserTZ.getOffset(utc);          return utc + targetOffsetFromUTC - browserOffsetFromUTC;     }
public static base_response add(nitro_service client, nsip resource) throws Exception {   nsip addresource = new nsip();   addresource.ipaddress = resource.ipaddress;   addresource.netmask = resource.netmask;   addresource.type = resource.type;   addresource.arp = resource.arp;   addresource.icmp = resource.icmp;   addresource.vserver = resource.vserver;   addresource.telnet = resource.telnet;   addresource.ftp = resource.ftp;   addresource.gui = resource.gui;   addresource.ssh = resource.ssh;   addresource.snmp = resource.snmp;   addresource.mgmtaccess = resource.mgmtaccess;   addresource.restrictaccess = resource.restrictaccess;   addresource.dynamicrouting = resource.dynamicrouting;   addresource.ospf = resource.ospf;   addresource.bgp = resource.bgp;   addresource.rip = resource.rip;   addresource.hostroute = resource.hostroute;   addresource.hostrtgw = resource.hostrtgw;   addresource.metric = resource.metric;   addresource.vserverrhilevel = resource.vserverrhilevel;   addresource.ospflsatype = resource.ospflsatype;   addresource.ospfarea = resource.ospfarea;   addresource.state = resource.state;   addresource.vrid = resource.vrid;   addresource.icmpresponse = resource.icmpresponse;   addresource.ownernode = resource.ownernode;   addresource.arpresponse = resource.arpresponse;   addresource.td = resource.td;   return addresource.add_resource(client);  }
static List<Point> find(          String text, String query, boolean ignoreCase)      {          List<Point> appearances = new ArrayList<Point>();          int offset = StringUtils.indexOf(text, query, 0, ignoreCase);          int length = query.length();          while (offset != -1)          {              appearances.add(new Point(offset, offset + length));              offset = StringUtils.indexOf(text, query, offset + 1, ignoreCase);          }          return appearances;      }
@Override   public void cancelOperation(OperationHandle opHandle) throws HiveSQLException {     try {       TCancelOperationReq req = new TCancelOperationReq(opHandle.toTOperationHandle());       TCancelOperationResp resp = cliService.CancelOperation(req);       checkStatus(resp.getStatus());     } catch (HiveSQLException e) {       throw e;     } catch (Exception e) {       throw new HiveSQLException(e);     }   }
public <E extends Exception> void depthFirstSearch(Vertex<T> v, VisitorEX<T, E> visitor)       throws E    {       if( visitor != null )          visitor.visit(this, v);             v.visit();       for (int i = 0; i < v.getOutgoingEdgeCount(); i++)       {          Edge<T> e = v.getOutgoingEdge(i);          if (!e.getTo().visited())          {             depthFirstSearch(e.getTo(), visitor);          }       }    }
public Boolean deleteEntityPost(DeleteEntityRequest request) throws ApiException {         ApiResponse<Boolean> resp = deleteEntityPostWithHttpInfo(request);         return resp.getData();     }
public static CommerceSubscriptionEntry findByPrimaryKey(   long commerceSubscriptionEntryId)   throws com.liferay.commerce.exception.NoSuchSubscriptionEntryException {   return getPersistence().findByPrimaryKey(commerceSubscriptionEntryId);  }
public synchronized boolean statusUpdate(TaskAttemptID taskid,                                               TaskStatus taskStatus)   throws IOException {     TaskInProgress tip = tasks.get(taskid);     if (tip != null) {       tip.reportProgress(taskStatus);       myInstrumentation.statusUpdate(tip.getTask(), taskStatus);       return true;     } else {       if (LOG.isDebugEnabled()) {         LOG.debug(""Progress from unknown child task: ""+taskid);       }       return false;     }   }
public static synchronized AccountManager getInstance(XMPPConnection connection) {         AccountManager accountManager = INSTANCES.get(connection);         if (accountManager == null) {             accountManager = new AccountManager(connection);             INSTANCES.put(connection, accountManager);         }         return accountManager;     }
@Override     public ListRecordsResult listRecords(ListRecordsRequest request) {         request = beforeClientExecution(request);         return executeListRecords(request);     }
public static void get(String path, TemplateViewRoute route, TemplateEngine engine) {         getInstance().get(path, route, engine);     }
@InterfaceAudience.Private     private void addPending(RevisionInternal revisionInternal) {         synchronized (pendingSequencesLock) {             long seq = revisionInternal.getSequence();             pendingSequences.add(seq);             if (seq > maxPendingSequence) {                 maxPendingSequence = seq;             }         }     }
private void makeCellsFlowReady( int iteration, GridNode pitfillExitNode, List<GridNode> cellsToMakeFlowReady,             BitMatrix allPitsPositions, WritableRandomIter pitIter, float delta ) {         iteration++;          double exitElevation = pitfillExitNode.elevation;         List<GridNode> connected = new ArrayList<>();         for( GridNode checkNode : cellsToMakeFlowReady ) {             List<GridNode> validSurroundingNodes = checkNode.getValidSurroundingNodes();             for( GridNode gridNode : validSurroundingNodes ) {                 if (!pitfillExitNode.equals(gridNode) && allPitsPositions.isMarked(gridNode.col, gridNode.row)                         && gridNode.elevation == exitElevation) {                     if (!connected.contains(gridNode))                         connected.add(gridNode);                 }             }         }         if (connected.size() == 0) {             return;         }          for( GridNode gridNode : connected ) {             double newElev = (double) (gridNode.elevation + delta * (double) iteration);             gridNode.setValueInMap(pitIter, newElev);         }         List<GridNode> updatedConnected = new ArrayList<>();         for( GridNode gridNode : connected ) {             GridNode updatedNode = new GridNode(pitIter, gridNode.cols, gridNode.rows, gridNode.xRes, gridNode.yRes, gridNode.col,                     gridNode.row);             updatedConnected.add(updatedNode);         }         makeCellsFlowReady(iteration, pitfillExitNode, updatedConnected, allPitsPositions, pitIter, delta);     }
public void marshall(Notifications notifications, ProtocolMarshaller protocolMarshaller) {          if (notifications == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(notifications.getProgressing(), PROGRESSING_BINDING);             protocolMarshaller.marshall(notifications.getCompleted(), COMPLETED_BINDING);             protocolMarshaller.marshall(notifications.getWarning(), WARNING_BINDING);             protocolMarshaller.marshall(notifications.getError(), ERROR_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public Set<Location> getDerefLocationSet(ValueNumber vn) {         Set<Location> derefLocationSet = derefLocationSetMap.get(vn);         if (derefLocationSet == null) {             derefLocationSet = new HashSet<>();             derefLocationSetMap.put(vn, derefLocationSet);         }         return derefLocationSet;     }
@Override    protected void addColumnComponents(HtmlDataTable dataTable, Map<String, String> attributes, NodeList elements,             StaticXmlMetawidget metawidget)    {       super.addColumnComponents(dataTable, attributes, elements, metawidget);        if (dataTable.getChildren().isEmpty())       {          return;       }        if (!attributes.containsKey(N_TO_MANY) || metawidget.isReadOnly())       {          return;       }        HtmlCommandLink removeLink = new HtmlCommandLink();       removeLink.putAttribute(""styleClass"", ""remove-button"");       String removeExpression = COLLECTION_VAR + "".remove("" + dataTable.getAttribute(""var"") + "")"";       removeLink.putAttribute(""action"", StaticFacesUtils.wrapExpression(removeExpression));        HtmlColumn column = new HtmlColumn();       column.putAttribute(""headerClass"", ""remove-column"");       column.putAttribute(""footerClass"", ""remove-column"");       column.getChildren().add(removeLink);       dataTable.getChildren().add(column);        // If bidirectional, an 'Add' button too        String inverseRelationship = attributes.get(INVERSE_RELATIONSHIP);        if (inverseRelationship != null)       {          String componentType = WidgetBuilderUtils.getComponentType(attributes);           if (componentType != null)          {             String controllerName = StringUtils.decapitalize(ClassUtils.getSimpleName(componentType));              HtmlCommandLink addLink = new HtmlCommandLink();             addLink.putAttribute(""styleClass"", ""add-button"");             String addExpression = COLLECTION_VAR + "".add("" + controllerName + ""Bean.added)"";             addLink.putAttribute(""action"", StaticFacesUtils.wrapExpression(addExpression));              // Use a f:setPropertyActionListener to initialize the bidirectional relationship              SetPropertyActionListener setPropertyActionListener = new SetPropertyActionListener();             setPropertyActionListener.putAttribute(                      ""target"",                      StaticFacesUtils.wrapExpression(controllerName + ""Bean.add."" + inverseRelationship));             StandardBindingProcessor bindingProcessor = metawidget.getWidgetProcessor(StandardBindingProcessor.class);              if (bindingProcessor != null)             {                bindingProcessor.processWidget(setPropertyActionListener, ENTITY, attributes,                         (StaticUIMetawidget) metawidget);             }             addLink.getChildren().add(setPropertyActionListener);              // (id is useful for unit tests)              String id = StaticFacesUtils.unwrapExpression(setPropertyActionListener.getValue())                      + StringUtils.SEPARATOR_DOT_CHAR + attributes.get(NAME) + StringUtils.SEPARATOR_DOT_CHAR + ""Add"";              addLink.putAttribute(""id"", StringUtils.camelCase(id, StringUtils.SEPARATOR_DOT_CHAR));              Facet footerFacet = new Facet();             footerFacet.putAttribute(""name"", ""footer"");             footerFacet.getChildren().add(addLink);             column.getChildren().add(footerFacet);          }       }    }
public boolean register(final Object pProvider) {          Iterator<Class<?>> categories = compatibleCategories(pProvider);          boolean registered = false;          while (categories.hasNext()) {              Class<?> category = categories.next();              if (registerImpl(pProvider, category) && !registered) {                  registered = true;              }          }          return registered;      }
@Bean     @Scope(value = org.springframework.web.context.WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.INTERFACES)     HttpService httpService() {         return new VaadinHttpService();     }
private void destroyConnectionFactories(boolean destroyImmediately) {          lock.writeLock().lock();         try {             if (isInitialized.get()) {                 // Mark all connection factories as disabled                 isInitialized.set(false);                  // Destroy the connection factories                 conMgrSvc.deleteObserver(this);                 conMgrSvc.destroyConnectionFactories();                  conMgrSvc = null;             }         } finally {             lock.writeLock().unlock();         }     }
public List<Group> getTopGroups() {          if (root != null && root.getGroups() != null && root.getGroups().size() == 1) {              return root.getGroups().get(0).getGroups();          }          return new ArrayList<Group>();      }
public void buildSerializableMethods(XMLNode node, Content classContentTree) throws DocletException {         Content serializableMethodTree = methodWriter.getSerializableMethodsHeader();         SortedSet<ExecutableElement> members = utils.serializationMethods(currentTypeElement);         if (!members.isEmpty()) {             for (ExecutableElement member : members) {                 currentMember = member;                 Content methodsContentTree = methodWriter.getMethodsContentHeader(                         currentMember == members.last());                 buildChildren(node, methodsContentTree);                 serializableMethodTree.addContent(methodsContentTree);             }         }         if (!utils.serializationMethods(currentTypeElement).isEmpty()) {             classContentTree.addContent(methodWriter.getSerializableMethods(                     configuration.getText(""doclet.Serialized_Form_methods""),                     serializableMethodTree));             if (utils.isSerializable(currentTypeElement) && !utils.isExternalizable(currentTypeElement)) {                 if (utils.serializationMethods(currentTypeElement).isEmpty()) {                     Content noCustomizationMsg = methodWriter.getNoCustomizationMsg(                             configuration.getText(""doclet.Serializable_no_customization""));                     classContentTree.addContent(methodWriter.getSerializableMethods(                     configuration.getText(""doclet.Serialized_Form_methods""),                     noCustomizationMsg));                 }             }         }     }
public BasicTagList copy(String key, String value) {     return concat(this, Tags.newTag(key, value));   }
public Trigger createTriggerFromString(EDataType eDataType, String initialValue) {    Trigger result = Trigger.get(initialValue);    if (result == null)     throw new IllegalArgumentException(""The value '"" + initialValue + ""' is not a valid enumerator of '"" + eDataType.getName() + ""'"");    return result;   }
public EpollSocketChannelConfig setTcpMd5Sig(Map<InetAddress, byte[]> keys) {         try {             ((EpollSocketChannel) channel).setTcpMd5Sig(keys);             return this;         } catch (IOException e) {             throw new ChannelException(e);         }     }
private HttpAction generateRequest(int[] namespace, String rcstart) {      RequestBuilder requestBuilder =         new ApiRequestBuilder() //             .action(""query"") //             .formatXml() //             .param(""list"", ""recentchanges"") //             .param(""rclimit"", LIMIT) //         ;     if (namespace != null) {       requestBuilder.param(""rcnamespace"", MediaWiki.urlEncode(MWAction.createNsString(namespace)));     }     if (rcstart.length() > 0) {       requestBuilder.param(""rcstart"", rcstart);     }      return requestBuilder.buildGet();   }
@Override  public void open() {   synchronized (stateLock) {    if (!closed) {     throw new IllegalStateException(""currently not closed."");    }    closed = false;   }      // create the partitions   final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size());    createPartitions(partitionFanOut);      // set up the table structure. the write behind buffers are taken away, as are one buffer per partition   final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize,     partitionFanOut, this.avgRecordLen);      initTable(numBuckets, (byte) partitionFanOut);  }
public Job withOutputs(JobOutput... outputs) {         if (this.outputs == null) {             setOutputs(new com.amazonaws.internal.SdkInternalList<JobOutput>(outputs.length));         }         for (JobOutput ele : outputs) {             this.outputs.add(ele);         }         return this;     }
public static void setNumberOfThreads(Job job, int threads) {         job.getConfiguration().setInt(ConfigConstants.CONF_THREADS_PER_SPLIT,             threads);     }
protected void updateBorder (boolean modified)     {         if (modified) {             setBorder(BorderFactory.createMatteBorder(2, 2, 2, 2, Color.red));         } else {             setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));         }     }
private boolean isSetAttribute(PluralAttribute<? super X, ?, ?> attribute)     {         return attribute != null && attribute.getCollectionType().equals(CollectionType.SET);     }
public static CommerceOrder fetchByUserId_First(long userId,   OrderByComparator<CommerceOrder> orderByComparator) {   return getPersistence().fetchByUserId_First(userId, orderByComparator);  }
public void marshall(DescribeSimulationApplicationRequest describeSimulationApplicationRequest, ProtocolMarshaller protocolMarshaller) {          if (describeSimulationApplicationRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(describeSimulationApplicationRequest.getApplication(), APPLICATION_BINDING);             protocolMarshaller.marshall(describeSimulationApplicationRequest.getApplicationVersion(), APPLICATIONVERSION_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
@Override     public void forget(Xid xid) throws XAException {         try {             LOG.debug(""PhynixxXAResource["" + this.getId() + ""]:forget forget with Xid"");             if (xid == null)                 throw new XAException(XAException.XAER_INVAL);              XATransactionalBranch<C> transactionalBranch = this.xaConnection.toGlobalTransactionBranch();             // must find connection for this transaction             if (transactionalBranch == null) {                 return; //             }             this.xaConnection.closeTransactionalBranch(xid);              this.xaConnection.close();          } finally {             // stop monitoring the timeout             this.setTimeOutActive(false);          }     }
public FNCXfrUnits createFNCXfrUnitsFromString(EDataType eDataType, String initialValue) {   FNCXfrUnits result = FNCXfrUnits.get(initialValue);   if (result == null) throw new IllegalArgumentException(""The value '"" + initialValue + ""' is not a valid enumerator of '"" + eDataType.getName() + ""'"");   return result;  }
public Object getAttribute(String attrName) {         Lock lock = lockForRead();         try {             return attributes != null ? attributes.get(attrName) : null;         } finally {             lock.unlock();         }     }
@Override  public void eSet(int featureID, Object newValue) {   switch (featureID) {    case AfplibPackage.FONT_CODED_GRAPHIC_CHARACTER_SET_GLOBAL_IDENTIFIER__GCSGID:     setGCSGID((Integer)newValue);     return;    case AfplibPackage.FONT_CODED_GRAPHIC_CHARACTER_SET_GLOBAL_IDENTIFIER__CPGID:     setCPGID((Integer)newValue);     return;   }   super.eSet(featureID, newValue);  }
@Override     public SetStatusResult setStatus(SetStatusRequest request) {         request = beforeClientExecution(request);         return executeSetStatus(request);     }
public void deleteClassPipeProperties(String className,                                          String pipeName, String[] propertyNames) throws DevFailed {         ArrayList<String>   list = new ArrayList<String>(propertyNames.length);         Collections.addAll(list, propertyNames);         databaseDAO.deleteClassPipeProperties(this, className, pipeName, list);     }
public String getStatement()     {         StringBuilder  stmt = new StringBuilder();         _buildStatement( null, null, stmt );          return stmt.toString();     }
@Override     protected HTTPClientConfiguration createHTTPClientConfiguration()     {         CommonHTTPClientConfiguration configuration=new CommonHTTPClientConfiguration();         configuration.setHostName(""api.phaxio.com"");         configuration.setSSL(true);         configuration.setMethod(FaxActionType.SUBMIT_FAX_JOB,HTTPMethod.POST);         configuration.setMethod(FaxActionType.CANCEL_FAX_JOB,HTTPMethod.POST);         configuration.setMethod(FaxActionType.GET_FAX_JOB_STATUS,HTTPMethod.POST);          return configuration;     }
public FacesConfigNavigationRuleType<FacesConfigType<T>> getOrCreateNavigationRule()    {       List<Node> nodeList = childNode.get(""navigation-rule"");       if (nodeList != null &&  nodeList.size() > 0)       {          return new FacesConfigNavigationRuleTypeImpl<FacesConfigType<T>>(this, ""navigation-rule"", childNode, nodeList.get(0));       }       return createNavigationRule();    }
public java.util.TimeZone toTimeZone() {         String id = getID();         if (id.length() == 6 && (id.startsWith(""+"") || id.startsWith(""-""))) {             // standard format offset [+-]hh:mm             // our ID is without any prefix, so we need to add the GMT back             return java.util.TimeZone.getTimeZone(""GMT"" + getID());         }         // unusual offset, so setup a SimpleTimeZone as best we can         return new java.util.SimpleTimeZone(iWallOffset, getID());     }
@Override     public void awaitCompletion() {         while (!hydratedQueue.isEmpty()) {             HydratedPojo<?> hydratedPojo = hydratedQueue.remove();             if(!Futures.getUnchecked(hydratedPojo.getFuture())) {                 throw new PojoNotFoundException(hydratedPojo.getBinding(), hydratedPojo.getTableName(), hydratedPojo.getKeys());             }         }     }
@Override   protected void initializeVariableInstanceBackPointer(VariableInstanceEntity variableInstance) {     if (processInstanceId != null) {       variableInstance.setProcessInstanceId(processInstanceId);     } else {       variableInstance.setProcessInstanceId(id);     }     variableInstance.setExecutionId(id);   }
public void sendMediaQuery(SlotReference slot) throws IOException {         final DeviceAnnouncement announcement = DeviceFinder.getInstance().getLatestAnnouncementFrom(slot.player);         if (announcement == null) {             throw new IllegalArgumentException(""Device for "" + slot + "" not found on network."");         }         ensureRunning();         byte[] payload = new byte[MEDIA_QUERY_PAYLOAD.length];         System.arraycopy(MEDIA_QUERY_PAYLOAD, 0, payload, 0, MEDIA_QUERY_PAYLOAD.length);         payload[2] = getDeviceNumber();         System.arraycopy(announcementBytes, 44, payload, 5, 4);  // Copy in our IP address.         payload[12] = (byte)slot.player;         payload[16] = slot.slot.protocolValue;         assembleAndSendPacket(Util.PacketType.MEDIA_QUERY, payload, announcement.getAddress(), UPDATE_PORT);     }
public static boolean isLegalFile(String filePath) {         File file = new File(filePath);         if (!file.exists() || file.isDirectory() || !file.canRead()) {             return false;         }         return true;     }
public final static DateFormat getDateTimeInstance(         int dateStyle, int timeStyle, ULocale locale)     {         return get(dateStyle, timeStyle, locale, null);     }
public static String evalString(String propertyName, String propertyValue, Tag tag, PageContext pageContext) throws JspException{            return (String) ExpressionEvaluatorManager.evaluate(propertyName,        propertyValue, String.class, tag, pageContext);     }
@Override     protected void subscribeActual(SingleObserver<? super T> observer) {         source.subscribe(new LastSubscriber<T>(observer, defaultItem));     }
@Override     public DeleteVPCEConfigurationResult deleteVPCEConfiguration(DeleteVPCEConfigurationRequest request) {         request = beforeClientExecution(request);         return executeDeleteVPCEConfiguration(request);     }
public final CircuitBreakerStatus withTotalSuccessCount(long value) {     if (this.totalSuccessCount == value) return this;     long newValue = value;     return new CircuitBreakerStatus(         this.id,         this.timestamp,         this.state,         newValue,         this.totalFailureCount,         this.latencyMicros,         this.throughputOneMinute,         this.failedThroughputOneMinute);   }
public static IntStream buildRandomIntStream(int streamSize, Random random,             int inclusiveLowerBound, int exclusiveUpperBound) {         return buildRandomIntStream(streamSize,                 () -> getBoundedNumber(random, inclusiveLowerBound,                         exclusiveUpperBound));     }
public static <E> ProxyChannel<E> createSpscProxy(int capacity,              Class<E> iFace,              WaitStrategy waitStrategy) {         return createProxy(capacity,                  iFace,                  waitStrategy,                  SpscOffHeapFixedSizeRingBuffer.class);     }
public boolean findErrorLocations_BruteForce(GrowQueue_I8 errorLocator ,              int messageLength ,              GrowQueue_I32 locations )  {   locations.resize(0);   for (int i = 0; i < messageLength; i++) {    if( math.polyEval_S(errorLocator,math.power(2,i)) == 0 ) {     locations.add(messageLength-i-1);    }   }    // see if the expected number of errors were found   return locations.size == errorLocator.size - 1;  }
private static CreateRequestType checkType(final FormItemList formItemList,    final CreateResponse createResponse) {   final String sType = formItemList     .getField(ProtocolConstants.Parameters.Create.TYPE);   if (sType != null) {    if (CreateRequestType.USER.getIdentifier().equals(sType)) {     return CreateRequestType.USER;    } else if (CreateRequestType.FOLLOW.getIdentifier().equals(sType)) {     return CreateRequestType.FOLLOW;    } else if (CreateRequestType.STATUS_UPDATE.getIdentifier().equals(      sType)) {     return CreateRequestType.STATUS_UPDATE;    }     createResponse.typeInvalid(sType);   } else {    createResponse.typeMissing();   }    return null;  }
public Matrix predict(Matrix features) {         return MLLibUtil.toMatrix(network.output(MLLibUtil.toMatrix(features)));     }
private void deviceTokenDidRefresh(String token, PushType type) {         if (tokenRefreshListener != null) {             getConfigLogger().debug(getAccountId(), ""Notifying devicePushTokenDidRefresh: "" + token);             tokenRefreshListener.devicePushTokenDidRefresh(token, type);         }     }
private MethodSpec buildWrapTimeZoneGMTMethod(TimeZoneData data) {     String[] hourFormat = data.hourFormat.split("";"");     List<Node> positive = DATETIME_PARSER.parse(hourFormat[0]);     List<Node> negative = DATETIME_PARSER.parse(hourFormat[1]);     List<Node> format = WRAPPER_PARSER.parseWrapper(data.gmtFormat);          MethodSpec.Builder method = MethodSpec.methodBuilder(""wrapTimeZoneGMT"")         .addModifiers(PROTECTED)         .addParameter(StringBuilder.class, ""b"")         .addParameter(boolean.class, ""neg"")         .addParameter(int.class, ""hours"")         .addParameter(int.class, ""mins"")         .addParameter(boolean.class, ""_short"");      // Special format for zero     method.beginControlFlow(""if (hours == 0 && mins == 0)"");     method.addStatement(""b.append($S)"", data.gmtZeroFormat);     method.addStatement(""return"");     method.endControlFlow();      method.addStatement(""boolean emitMins = !_short || mins > 0"");      for (Node node : format) {       if (node instanceof Text) {         Text text = (Text) node;         method.addStatement(""b.append($S)"", text.text());       } else {         method.beginControlFlow(""if (neg)"");         appendHourFormat(method, negative);         method.endControlFlow();         method.beginControlFlow(""else"");         appendHourFormat(method, positive);         method.endControlFlow();       }     }     return method.build();   }
public static String parseErrorMessage(String errorMessage) {         StringBuilder response = new StringBuilder();          Pattern pattern = Pattern.compile("".*?/series/(\\d*?)/default/(\\d*?)/(\\d*?)/.*?"");         Matcher matcher = pattern.matcher(errorMessage);          // See if the error message matches the pattern and therefore we can decode it         if (matcher.find() && matcher.groupCount() == ERROR_MSG_GROUP_COUNT) {             int seriesId = Integer.parseInt(matcher.group(ERROR_MSG_SERIES));             int seasonId = Integer.parseInt(matcher.group(ERROR_MSG_SEASON));             int episodeId = Integer.parseInt(matcher.group(ERROR_MSG_EPISODE));              response.append(""Series Id: "").append(seriesId);             response.append("", Season: "").append(seasonId);             response.append("", Episode: "").append(episodeId);             response.append("": "");              if (episodeId == 0) {                 // We should probably try an scrape season 0/episode 1                 response.append(""Episode seems to be a misnamed pilot episode."");             } else if (episodeId > MAX_EPISODE) {                 response.append(""Episode number seems to be too large."");             } else if (seasonId == 0 && episodeId > 1) {                 response.append(""This special episode does not exist."");             } else if (errorMessage.toLowerCase().contains(ERROR_NOT_ALLOWED_IN_PROLOG)) {                 response.append(ERROR_RETRIEVE_EPISODE_INFO);             } else {                 response.append(""Unknown episode error: "").append(errorMessage);             }         } else // Don't recognise the error format, so just return it         {             if (errorMessage.toLowerCase().contains(ERROR_NOT_ALLOWED_IN_PROLOG)) {                 response.append(ERROR_RETRIEVE_EPISODE_INFO);             } else {                 response.append(""Episode error: "").append(errorMessage);             }         }          return response.toString();     }
@Override   public EClass getIfcClassification() {    if (ifcClassificationEClass == null) {     ifcClassificationEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)       .getEClassifiers().get(96);    }    return ifcClassificationEClass;   }
public INDArray textsToMatrix(String[] texts, TokenizerMode mode) {         Integer[][] sequences = textsToSequences(texts);         return sequencesToMatrix(sequences, mode);     }
public static AjaxRequestTarget findOrCreateNewAjaxRequestTarget(   final WebApplication application, final Page page)  {   final AjaxRequestTarget target = findAjaxRequestTarget();   if (target != null)   {    return target;   }   return newAjaxRequestTarget(application, page);  }
protected void processObjectField(final Object obj, final Field field, final Bin annotation, final Object customFieldProcessor) {     if (annotation.custom()) {       this.onFieldCustom(obj, field, annotation, customFieldProcessor, readFieldValue(obj, field));     } else {       final Class<?> fieldType = field.getType();        final BinType type;       if (annotation.type() == BinType.UNDEFINED) {         type = BinType.findCompatible(fieldType);       } else {         type = annotation.type();       }        final boolean reverseBits = annotation.bitOrder() == JBBPBitOrder.MSB0;        switch (type) {         case BIT: {           final JBBPBitNumber bitNumber = annotation.outBitNumber();           if (fieldType == boolean.class) {             this.onFieldBits(obj, field, annotation, bitNumber, ((Boolean) readFieldValue(obj, field)) ? 0xFF : 0x00);           } else {             byte value = ((Number) readFieldValue(obj, field)).byteValue();             if (reverseBits) {               value = JBBPUtils.reverseBitsInByte(bitNumber, value);             }             this.onFieldBits(obj, field, annotation, bitNumber, value);           }         }         break;         case BOOL: {           if (fieldType == boolean.class) {             onFieldBool(obj, field, annotation, (Boolean) readFieldValue(obj, field));           } else {             onFieldBool(obj, field, annotation, ((Number) readFieldValue(obj, field)).longValue() != 0);           }         }         break;         case BYTE:         case UBYTE: {           byte value = ((Number) readFieldValue(obj, field)).byteValue();           if (reverseBits) {             value = JBBPUtils.reverseBitsInByte(value);           }           this.onFieldByte(obj, field, annotation, type == BinType.BYTE, value);         }         break;         case SHORT:         case USHORT: {           short value;           if (fieldType == char.class) {             value = (short) ((Character) readFieldValue(obj, field)).charValue();           } else {             value = ((Number) readFieldValue(obj, field)).shortValue();           }           if (reverseBits) {             value = (short) JBBPFieldShort.reverseBits(value);           }           this.onFieldShort(obj, field, annotation, type == BinType.SHORT, value);         }         break;         case INT: {           int value;           value = ((Number) readFieldValue(obj, field)).intValue();           if (reverseBits) {             value = (int) JBBPFieldInt.reverseBits(value);           }           this.onFieldInt(obj, field, annotation, value);         }         break;         case FLOAT: {           float value;           if (float.class == fieldType) {             value = (Float) readFieldValue(obj, field);           } else {             value = ((Number) readFieldValue(obj, field)).floatValue();           }           if (reverseBits) {             value = Float.intBitsToFloat((int) JBBPFieldInt.reverseBits(Float.floatToIntBits(value)));           }           this.onFieldFloat(obj, field, annotation, value);         }         break;         case STRING: {           String value;           final Object valueAsObject = readFieldValue(obj, field);           if (valueAsObject != null) {             value = String.valueOf(valueAsObject);             if (reverseBits) {               value = JBBPFieldString.reverseBits(value);             }           } else {             value = null;           }           this.onFieldString(obj, field, annotation, value);         }         break;         case LONG: {           long value = ((Number) readFieldValue(obj, field)).longValue();           if (reverseBits) {             value = JBBPFieldLong.reverseBits(value);           }           this.onFieldLong(obj, field, annotation, value);         }         break;         case DOUBLE: {           double value;           if (float.class == fieldType) {             value = (Float) readFieldValue(obj, field);           } else if (double.class == fieldType) {             value = (Double) readFieldValue(obj, field);           } else {             value = ((Number) readFieldValue(obj, field)).doubleValue();           }            if (reverseBits) {             value = Double.longBitsToDouble(JBBPFieldLong.reverseBits(Double.doubleToLongBits(value)));           }           this.onFieldDouble(obj, field, annotation, value);         }         break;         case STRUCT: {           processObject(readFieldValue(obj, field), field, customFieldProcessor);         }         break;         default: {           final Object array = readFieldValue(obj, field);           switch (type) {             case BIT_ARRAY: {               assertFieldArray(field);                final int len = Array.getLength(array);               this.onArrayStart(obj, field, annotation, len);                final JBBPBitNumber bitNumber = annotation.outBitNumber();                if (fieldType.getComponentType() == boolean.class) {                 for (int i = 0; i < len; i++) {                   this.onFieldBits(obj, field, annotation, bitNumber, (Boolean) Array.get(array, i) ? 0xFF : 0x00);                 }               } else {                 for (int i = 0; i < len; i++) {                   byte value = ((Number) Array.get(array, i)).byteValue();                   if (reverseBits) {                     value = JBBPUtils.reverseBitsInByte(bitNumber, value);                   }                   this.onFieldBits(obj, field, annotation, bitNumber, value);                 }               }                this.onArrayEnd(obj, field, annotation);             }             break;             case BOOL_ARRAY: {               assertFieldArray(field);                final int len = Array.getLength(array);               this.onArrayStart(obj, field, annotation, len);                for (int i = 0; i < len; i++) {                 this.onFieldBool(obj, field, annotation, (Boolean) Array.get(array, i));               }                this.onArrayEnd(obj, field, annotation);             }             break;             case UBYTE_ARRAY:             case BYTE_ARRAY: {               final boolean signed = type == BinType.BYTE_ARRAY;                if (fieldType == String.class) {                 final String strValue = (String) readFieldValue(obj, field);                 this.onArrayStart(obj, field, annotation, strValue.length());                  for (int i = 0; i < strValue.length(); i++) {                   byte value = (byte) strValue.charAt(i);                   if (reverseBits) {                     value = JBBPUtils.reverseBitsInByte(value);                   }                   this.onFieldByte(obj, field, annotation, signed, value);                 }               } else {                 assertFieldArray(field);                 final int len = Array.getLength(array);                 this.onArrayStart(obj, field, annotation, len);                 for (int i = 0; i < len; i++) {                   byte value = ((Number) Array.get(array, i)).byteValue();                   if (reverseBits) {                     value = JBBPUtils.reverseBitsInByte(value);                   }                   this.onFieldByte(obj, field, annotation, signed, value);                 }               }                this.onArrayEnd(obj, field, annotation);             }             break;             case SHORT_ARRAY:             case USHORT_ARRAY: {               final boolean signed = type == BinType.SHORT_ARRAY;                if (fieldType == String.class) {                 final String str = (String) readFieldValue(obj, field);                 this.onArrayStart(obj, field, annotation, str.length());                  for (int i = 0; i < str.length(); i++) {                   short value = (short) str.charAt(i);                   if (reverseBits) {                     value = (short) JBBPFieldShort.reverseBits(value);                   }                   this.onFieldShort(obj, field, annotation, signed, value);                 }               } else {                 assertFieldArray(field);                  final int len = Array.getLength(array);                 this.onArrayStart(obj, field, annotation, len);                  if (fieldType.getComponentType() == char.class) {                   for (int i = 0; i < len; i++) {                     short value = (short) ((Character) Array.get(array, i)).charValue();                     if (reverseBits) {                       value = (short) JBBPFieldShort.reverseBits(value);                     }                     this.onFieldShort(obj, field, annotation, signed, value);                   }                 } else {                   for (int i = 0; i < len; i++) {                     short value = ((Number) Array.get(array, i)).shortValue();                     if (reverseBits) {                       value = (short) JBBPFieldShort.reverseBits(value);                     }                     this.onFieldShort(obj, field, annotation, signed, value);                   }                 }                  this.onArrayEnd(obj, field, annotation);               }             }             break;             case FLOAT_ARRAY: {               assertFieldArray(field);               final int len = Array.getLength(array);               this.onArrayStart(obj, field, annotation, len);               for (int i = 0; i < len; i++) {                 float value = Array.getFloat(array, i);                 if (reverseBits) {                   value = Float.intBitsToFloat((int) JBBPFieldInt.reverseBits(Float.floatToIntBits(value)));                 }                 this.onFieldFloat(obj, field, annotation, value);               }               this.onArrayEnd(obj, field, annotation);             }             break;             case INT_ARRAY: {               assertFieldArray(field);               final int len = Array.getLength(array);               this.onArrayStart(obj, field, annotation, len);               for (int i = 0; i < len; i++) {                 int value = ((Number) Array.get(array, i)).intValue();                 if (reverseBits) {                   value = (int) JBBPFieldInt.reverseBits(value);                 }                 this.onFieldInt(obj, field, annotation, value);               }                this.onArrayEnd(obj, field, annotation);             }             break;             case LONG_ARRAY: {               assertFieldArray(field);               final int len = Array.getLength(array);               this.onArrayStart(obj, field, annotation, len);               for (int i = 0; i < len; i++) {                 long value = ((Number) Array.get(array, i)).longValue();                 if (reverseBits) {                   value = JBBPFieldLong.reverseBits(value);                 }                 this.onFieldLong(obj, field, annotation, value);               }               this.onArrayEnd(obj, field, annotation);             }             break;             case STRING_ARRAY: {               assertFieldArray(field);               final int len = Array.getLength(array);               this.onArrayStart(obj, field, annotation, len);               for (int i = 0; i < len; i++) {                 final Object value = Array.get(array, i);                 String nullableStrValue = value == null ? null : String.valueOf (value);                 if (nullableStrValue != null && reverseBits) {                   nullableStrValue = JBBPFieldString.reverseBits(nullableStrValue);                 }                 this.onFieldString(obj, field, annotation, nullableStrValue);               }               this.onArrayEnd(obj, field, annotation);             }             break;             case DOUBLE_ARRAY: {               assertFieldArray(field);               final int len = Array.getLength(array);               this.onArrayStart(obj, field, annotation, len);               for (int i = 0; i < len; i++) {                 double value = ((Number) Array.get(array, i)).doubleValue();                 if (reverseBits) {                   value = Double.longBitsToDouble(JBBPFieldLong.reverseBits(Double.doubleToLongBits(value)));                 }                 this.onFieldDouble(obj, field, annotation, value);               }               this.onArrayEnd(obj, field, annotation);             }             break;             case STRUCT_ARRAY: {               assertFieldArray(field);               final int len = Array.getLength(array);               this.onArrayStart(obj, field, annotation, len);               for (int i = 0; i < len; i++) {                 this.processObject(Array.get(array, i), field, customFieldProcessor);               }               this.onArrayEnd(obj, field, annotation);             }             break;             default: {               throw new Error(""Unexpected situation for field type, contact developer ["" + type + ']');             }           }         }         break;       }     }   }
public static IGeoPoint computeOffsetOrigin(IGeoPoint to, double distance, double heading) {         heading = toRadians(heading);         distance /= EARTH_RADIUS;         // http://lists.maptools.org/pipermail/proj/2008-October/003939.html         double n1 = cos(distance);         double n2 = sin(distance) * cos(heading);         double n3 = sin(distance) * sin(heading);         double n4 = sin(toRadians(to.getLatitude()));         // There are two solutions for b. b = n2 * n4 +/- sqrt(), one solution results         // in the latitude outside the [-90, 90] range. We first try one solution and         // back off to the other if we are outside that range.         double n12 = n1 * n1;         double discriminant = n2 * n2 * n12 + n12 * n12 - n12 * n4 * n4;         if (discriminant < 0) {             // No real solution which would make sense in IGeoPoint-space.             return null;         }         double b = n2 * n4 + sqrt(discriminant);         b /= n1 * n1 + n2 * n2;         double a = (n4 - n2 * b) / n1;         double fromLatRadians = atan2(a, b);         if (fromLatRadians < -PI / 2 || fromLatRadians > PI / 2) {             b = n2 * n4 - sqrt(discriminant);             b /= n1 * n1 + n2 * n2;             fromLatRadians = atan2(a, b);         }         if (fromLatRadians < -PI / 2 || fromLatRadians > PI / 2) {             // No solution which would make sense in IGeoPoint-space.             return null;         }         double fromLngRadians = toRadians(to.getLongitude()) -             atan2(n3, n1 * cos(fromLatRadians) - n2 * sin(fromLatRadians));         return new GeoPoint(toDegrees(fromLatRadians), toDegrees(fromLngRadians));     }
public static void diag( DMatrix3x3 input , DMatrix3 out ) {         out.a1 = input.a11;         out.a2 = input.a22;         out.a3 = input.a33;     }
public static CountableValueRange<LocalDate> createLocalDateValueRange(             LocalDate from, LocalDate to, long incrementUnitAmount, TemporalUnit incrementUnitType) {         return createTemporalValueRange(from, to, incrementUnitAmount, incrementUnitType);     }
public static void createTables( Connection connection ) throws IOException, SQLException {         StringBuilder sB = new StringBuilder();         sB.append(""CREATE TABLE "");         sB.append(TABLE_NOTES);         sB.append("" ("");         sB.append(NotesTableFields.COLUMN_ID.getFieldName());         sB.append("" INTEGER PRIMARY KEY, "");         sB.append(NotesTableFields.COLUMN_LON.getFieldName()).append("" REAL NOT NULL, "");         sB.append(NotesTableFields.COLUMN_LAT.getFieldName()).append("" REAL NOT NULL,"");         sB.append(NotesTableFields.COLUMN_ALTIM.getFieldName()).append("" REAL NOT NULL,"");         sB.append(NotesTableFields.COLUMN_TS.getFieldName()).append("" DATE NOT NULL,"");         sB.append(NotesTableFields.COLUMN_DESCRIPTION.getFieldName()).append("" TEXT, "");         sB.append(NotesTableFields.COLUMN_TEXT.getFieldName()).append("" TEXT NOT NULL, "");         sB.append(NotesTableFields.COLUMN_FORM.getFieldName()).append("" CLOB, "");         sB.append(NotesTableFields.COLUMN_STYLE.getFieldName()).append("" TEXT,"");         sB.append(NotesTableFields.COLUMN_ISDIRTY.getFieldName()).append("" INTEGER"");         sB.append("");"");         String CREATE_TABLE_NOTES = sB.toString();          sB = new StringBuilder();         sB.append(""CREATE INDEX notes_ts_idx ON "");         sB.append(TABLE_NOTES);         sB.append("" ( "");         sB.append(NotesTableFields.COLUMN_TS.getFieldName());         sB.append("" );"");         String CREATE_INDEX_NOTES_TS = sB.toString();          sB = new StringBuilder();         sB.append(""CREATE INDEX notes_x_by_y_idx ON "");         sB.append(TABLE_NOTES);         sB.append("" ( "");         sB.append(NotesTableFields.COLUMN_LON.getFieldName());         sB.append("", "");         sB.append(NotesTableFields.COLUMN_LAT.getFieldName());         sB.append("" );"");         String CREATE_INDEX_NOTES_X_BY_Y = sB.toString();          sB = new StringBuilder();         sB.append(""CREATE INDEX notes_isdirty_idx ON "");         sB.append(TABLE_NOTES);         sB.append("" ( "");         sB.append(NotesTableFields.COLUMN_ISDIRTY.getFieldName());         sB.append("" );"");         String CREATE_INDEX_NOTES_ISDIRTY = sB.toString();          try (Statement statement = connection.createStatement()) {             statement.setQueryTimeout(30); // set timeout to 30 sec.              statement.executeUpdate(CREATE_TABLE_NOTES);             statement.executeUpdate(CREATE_INDEX_NOTES_TS);             statement.executeUpdate(CREATE_INDEX_NOTES_X_BY_Y);             statement.executeUpdate(CREATE_INDEX_NOTES_ISDIRTY);         } catch (Exception e) {             throw new IOException(e.getLocalizedMessage());         }     }
protected void clearPartitions() {   for (int i = this.partitionsBeingBuilt.size() - 1; i >= 0; --i) {    final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i);    try {     p.clearAllMemory(this.availableMemory);    } catch (Exception e) {     LOG.error(""Error during partition cleanup."", e);    }   }   this.partitionsBeingBuilt.clear();  }
protected ClipBuffer getClip (ClipProvider provider, String path, Observer observer)     {         String ckey = ClipBuffer.makeKey(provider, path);         ClipBuffer buffer = _clips.get(ckey);         try {             if (buffer == null) {                 // check to see if this clip is currently loading                 buffer = _loading.get(ckey);                 if (buffer == null) {                     buffer = new ClipBuffer(this, provider, path);                     _loading.put(ckey, buffer);                 }             }             buffer.resolve(observer);             return buffer;          } catch (Throwable t) {             log.warning(""Failure resolving buffer [key="" + ckey + ""]."", t);             return null;         }     }
public VarSet addMember( IVarDef var)     {     assert var != null;     assert var.getName() != null;      if( findMember( var.getName()) >= 0)       {       throw new IllegalStateException( ""Member="" + var.getName() + "" already defined for varSet="" + getPathName());       }      members_.add( var);     var.setParent( this);     var.setSeqNum( getNextSeqNum());      return this;     }
private long getJobFireInterval(){      if(jobFireInterval == 0){          try {            Date nextFireTime = getTrigger().getNextFireTime();        Date previousFireTime = getTrigger().getPreviousFireTime();        jobFireInterval = nextFireTime.getTime() - previousFireTime.getTime();    } catch (Exception e) {}      }      return jobFireInterval;     }
@Override     public DisableSsoResult disableSso(DisableSsoRequest request) {         request = beforeClientExecution(request);         return executeDisableSso(request);     }
public static UserGroupInformation getProxyUser(     String user,                    // Hadoop user (HDFS User, HBase user, generally the to-be-impersonated user in component's configuration)     Stage.Context context,          // Stage context object     UserGroupInformation loginUser, // Login UGI (sdc user)     List<Stage.ConfigIssue> issues, // Reports errors     String configGroup,             // Group where ""HDFS User"" is present     String configName               // Config name of ""HDFS User""   ) {     // Should we always impersonate current user?     boolean alwaysImpersonate = context.getConfiguration().get(       HadoopConfigConstants.IMPERSONATION_ALWAYS_CURRENT_USER,       false     );      // If so, propagate current user to ""user"" (the one to be impersonated)     if(alwaysImpersonate) {       if(!StringUtils.isEmpty(user)) {         issues.add(context.createConfigIssue(configGroup, configName, Errors.HADOOP_00001));       }       user = context.getUserContext().getAliasName();     }      // If impersonated user is empty, simply return login UGI (no impersonation performed)     if(StringUtils.isEmpty(user)) {       return loginUser;     }      // Optionally lower case the user name     boolean lowerCase = context.getConfiguration().get(       HadoopConfigConstants.LOWERCASE_USER,       false     );     if(lowerCase) {       user = user.toLowerCase();     }     return UserGroupInformation.createProxyUser(user, loginUser);   }
private void addWhere4ObjectPrint(final ObjectPrint _print)     {         final SQLWhere where = sqlSelect.getWhere();         where.addCriteria(0, ""ID"", Comparison.EQUAL, String.valueOf(_print.getInstance().getId()), Connection.AND);     }
@Override     public GetRegistrationCodeResult getRegistrationCode(GetRegistrationCodeRequest request) {         request = beforeClientExecution(request);         return executeGetRegistrationCode(request);     }
public static double roundDoubleToClosest (double value, double steps) {         final double down = DMatrixUtils.roundDoubleDownTo(value, steps);         final double up = DMatrixUtils.roundDoubleUpTo(value, steps);         if (Math.abs(value - down) < Math.abs(value - up)) {             return down;         }         return up;     }
public void setObjects(Object injectionObject, Reference bindingObject)                     throws InjectionException     {         final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();         if (isTraceOn && tc.isDebugEnabled())             Tr.debug(tc, ""setObjects"", injectionObject, bindingObjectToString(bindingObject));          ivInjectedObject = injectionObject; // d392996.3          if (bindingObject != null)         {             ivBindingObject = bindingObject;             ivObjectFactoryClassName = bindingObject.getFactoryClassName(); // F48603.4             if (ivObjectFactoryClassName == null) // F54050             {                 throw new IllegalArgumentException(""expected non-null getFactoryClassName"");             }         }         else         {             ivBindingObject = injectionObject;         }     }
@Override   public FileStatus getFileStatus(Path f)  throws IOException {     INode inode = store.retrieveINode(makeAbsolute(f));     if (inode == null) {       throw new FileNotFoundException(f + "": No such file or directory."");     }     return new S3FileStatus(f.makeQualified(this), inode);   }
@Override     public void reload(ResourceConfig configuration) {         ApplicationHandler applicationHandler = new ApplicationHandler(configuration, null, locator);         applicationHandlerDelegate = new DefaultApplicationHandlerDelegate(applicationHandler);         getApplicationHandler().onReload(this);         applicationHandler.onStartup(this);     }
public static void main(String[] args) throws Exception {     Builder processingGraphBuilder = Builder.newBuilder();      /**      * A Pulsar source is constructed for a specific Pulsar installation, topic, and      * subsecription.      */     Source<String> pulsarSource = new PulsarSource(         ""pulsar://localhost:6650"", // Pulsar connection URL         ""persistent://sample/standalone/ns1/heron-pulsar-test-topic"", // Pulsar topic         ""subscription-1"" // Subscription name for the Pulsar topic     );      /**      * In this processing graph, the source streamlet consists of messages on a      * Pulsar topic. Those messages are simply logged without any processing logic      * applied to them.      */     processingGraphBuilder.newSource(pulsarSource)         .setName(""incoming-pulsar-messages"")         .consume(s -> LOG.info(String.format(""Message received from Pulsar: \""%s\"""", s)));      Config config = Config.defaultConfig();      // Fetches the topology name from the first command-line argument     String topologyName = StreamletUtils.getTopologyName(args);      // Finally, the processing graph and configuration are passed to the Runner, which converts     // the graph into a Heron topology that can be run in a Heron cluster.     new Runner().run(topologyName, config, processingGraphBuilder);   }
public static boolean hasBeanMethods(Class<?> type, String propertyName, Class<?> propertyType, boolean caseSensitive) {         try {             // if this succeeds without an exception, then the properties exist!             @SuppressWarnings(""unused"")             Method[] methods = getBeanMethods(type, propertyName, propertyType, caseSensitive);             return true;         } catch (Exception e) {             return false;         }     }
public void updateFaxJob(FaxJob faxJob,HTTPResponse httpResponse,FaxActionType faxActionType)     {         //get path         String path=this.getPathToResponseData(faxActionType);          //get fax job ID         String id=this.findValue(httpResponse,path);                  if(id!=null)         {             faxJob.setID(id);         }     }
@Override     public void fit(DataSet dataSet) {         featureStats = (S) newBuilder().addFeatures(dataSet).build();         if (isFitLabel()) {             labelStats = (S) newBuilder().addLabels(dataSet).build();         }     }
public static void loopBlocks(int start , int endExclusive , IntRangeConsumer consumer ) {   final ForkJoinPool pool = BoofConcurrency.pool;   int numThreads = pool.getParallelism();    int range = endExclusive-start;   if( range == 0 ) // nothing to do here!    return;   if( range < 0 )    throw new IllegalArgumentException(""end must be more than start. ""+start+"" -> ""+endExclusive);    // Did some experimentation here. Gave it more threads than were needed or exactly what was needed   // exactly seemed to do better in the test cases   int blockSize = Math.max(1,range/numThreads);    try {    pool.submit(new IntRangeTask(start,endExclusive,blockSize,consumer)).get();   } catch (InterruptedException | ExecutionException e) {    throw new RuntimeException(e);   }  }
@Override     public void write(IChemObject object) throws CDKException {         if (!(object instanceof IRGroupQuery)) {             throw new CDKException(""Only IRGroupQuery input is accepted."");         }         try {              IRGroupQuery rGroupQuery = (IRGroupQuery) object;             String now = new SimpleDateFormat(""MMddyyHHmm"").format(System.currentTimeMillis());             IAtomContainer rootAtc = rGroupQuery.getRootStructure();              //Construct header             StringBuffer rootBlock = new StringBuffer();             String header = ""$MDL  REV  1   "" + now + LSEP + ""$MOL"" + LSEP + ""$HDR"" + LSEP                     + ""  Rgroup query file (RGFile)"" + LSEP + ""  CDK    "" + now + ""2D"" + LSEP + LSEP + ""$END HDR""                     + LSEP + ""$CTAB"";             rootBlock.append(header).append(LSEP);              //Construct the root structure, the scaffold             String rootCTAB = getCTAB(rootAtc);             rootCTAB = rootCTAB.replaceAll(LSEP + ""M  END"" + LSEP, """");             rootBlock.append(rootCTAB).append(LSEP);              //Write the root's LOG lines             for (Integer rgrpNum : rGroupQuery.getRGroupDefinitions().keySet()) {                 RGroupList rgList = rGroupQuery.getRGroupDefinitions().get(rgrpNum);                 int restH = rgList.isRestH() ? 1 : 0;                 String logLine = ""M  LOG"" + MDLV2000Writer.formatMDLInt(1, 3) + MDLV2000Writer.formatMDLInt(rgrpNum, 4)                         + MDLV2000Writer.formatMDLInt(rgList.getRequiredRGroupNumber(), 4)                         + MDLV2000Writer.formatMDLInt(restH, 4) + ""   "" + rgList.getOccurrence();                 rootBlock.append(logLine).append(LSEP);             }              //AAL lines are optional, they are needed for R-atoms with multiple bonds to the root             //for which the order of the attachment points can not be implicitly derived             //from the order in the atom block. See CT spec for more on that.             for (IAtom rgroupAtom : rGroupQuery.getRootAttachmentPoints().keySet()) {                 Map<Integer, IBond> rApo = rGroupQuery.getRootAttachmentPoints().get(rgroupAtom);                 if (rApo.size() > 1) {                     int prevPos = -1;                     int apoIdx = 1;                     boolean implicitlyOrdered = true;                     while (rApo.get(apoIdx) != null && implicitlyOrdered) {                         IAtom partner = rApo.get(apoIdx).getOther(rgroupAtom);                         for (int atIdx = 0; atIdx < rootAtc.getAtomCount(); atIdx++) {                             if (rootAtc.getAtom(atIdx).equals(partner)) {                                 if (atIdx < prevPos) implicitlyOrdered = false;                                 prevPos = atIdx;                                 break;                             }                         }                         apoIdx++;                     }                     if (!implicitlyOrdered) {                         StringBuffer aalLine = new StringBuffer(""M  AAL"");                         for (int atIdx = 0; atIdx < rootAtc.getAtomCount(); atIdx++) {                             if (rootAtc.getAtom(atIdx).equals(rgroupAtom)) {                                 aalLine.append(MDLV2000Writer.formatMDLInt((atIdx + 1), 4));                                 aalLine.append(MDLV2000Writer.formatMDLInt(rApo.size(), 3));                                  apoIdx = 1;                                 while (rApo.get(apoIdx) != null) {                                     IAtom partner = rApo.get(apoIdx).getOther(rgroupAtom);                                      for (int a = 0; a < rootAtc.getAtomCount(); a++) {                                         if (rootAtc.getAtom(a).equals(partner)) {                                             aalLine.append(MDLV2000Writer.formatMDLInt(a + 1, 4));                                             aalLine.append(MDLV2000Writer.formatMDLInt(apoIdx, 4));                                         }                                     }                                     apoIdx++;                                 }                             }                         }                         rootBlock.append(aalLine.toString()).append(LSEP);                     }                 }             }              rootBlock.append(""M  END"").append(LSEP).append(""$END CTAB"").append(LSEP);              //Construct each R-group block             StringBuffer rgpBlock = new StringBuffer();             for (Integer rgrpNum : rGroupQuery.getRGroupDefinitions().keySet()) {                 List<RGroup> rgrpList = rGroupQuery.getRGroupDefinitions().get(rgrpNum).getRGroups();                 if (rgrpList != null && rgrpList.size() != 0) {                     rgpBlock.append(""$RGP"").append(LSEP);;                     rgpBlock.append(MDLV2000Writer.formatMDLInt(rgrpNum, 4)).append(LSEP);                      for (RGroup rgroup : rgrpList) {                         //CTAB block                         rgpBlock.append(""$CTAB"").append(LSEP);                         String ctab = getCTAB(rgroup.getGroup());                         ctab = ctab.replaceAll(LSEP + ""M  END"" + LSEP, """");                         rgpBlock.append(ctab).append(LSEP);                          //The APO line                         IAtom firstAttachmentPoint = rgroup.getFirstAttachmentPoint();                         IAtom secondAttachmentPoint = rgroup.getSecondAttachmentPoint();                         int apoCount = 0;                         if (firstAttachmentPoint != null) {                             StringBuffer apoLine = new StringBuffer();                             for (int atIdx = 0; atIdx < rgroup.getGroup().getAtomCount(); atIdx++) {                                 if (rgroup.getGroup().getAtom(atIdx).equals(firstAttachmentPoint)) {                                     apoLine.append(MDLV2000Writer.formatMDLInt((atIdx + 1), 4));                                     apoCount++;                                     if (secondAttachmentPoint != null                                             && secondAttachmentPoint.equals(firstAttachmentPoint)) {                                         apoLine.append(MDLV2000Writer.formatMDLInt(3, 4));                                     } else {                                         apoLine.append(MDLV2000Writer.formatMDLInt(1, 4));                                     }                                 }                             }                             if (secondAttachmentPoint != null && !secondAttachmentPoint.equals(firstAttachmentPoint)) {                                 for (int atIdx = 0; atIdx < rgroup.getGroup().getAtomCount(); atIdx++) {                                     if (rgroup.getGroup().getAtom(atIdx).equals(secondAttachmentPoint)) {                                         apoCount++;                                         apoLine.append(MDLV2000Writer.formatMDLInt((atIdx + 1), 4));                                         apoLine.append(MDLV2000Writer.formatMDLInt(2, 4));                                     }                                 }                             }                             if (apoCount > 0) {                                 apoLine.insert(0, ""M  APO"" + MDLV2000Writer.formatMDLInt(apoCount, 3));                                 rgpBlock.append(apoLine).append(LSEP);                             }                         }                          rgpBlock.append(""M  END"").append(LSEP);                         rgpBlock.append(""$END CTAB"").append(LSEP);                     }                     rgpBlock.append(""$END RGP"").append(LSEP);                 }             }             rgpBlock.append(""$END MOL"").append(LSEP);              writer.write(rootBlock.toString());             writer.write(rgpBlock.toString());             writer.flush();          } catch (IOException e) {             e.printStackTrace();             throw new CDKException(""Unexpected exception when writing RGFile"" + LSEP + e.getMessage());         }      }
public AlluxioURI joinUnsafe(String suffix) {     String path = getPath();     StringBuilder sb = new StringBuilder(path.length() + 1 + suffix.length());      return new AlluxioURI(this,         sb.append(path).append(AlluxioURI.SEPARATOR).append(suffix).toString(), false);   }
public void delete_attribute_property(String attname, String[] propnames) throws DevFailed {         database.delete_device_attribute_property(deviceName, attname, propnames);     }
protected void switchToCurrentProject() throws CmsException {          if (m_currentProjectId != null) {             // switch back to the current users project             getCms().getRequestContext().setCurrentProject(getCms().readProject(m_currentProjectId));         }     }
public static XWPFRun getNewRun(ParagraphAlignment alignment) {         createXwpfDocumentIfNull();         XWPFParagraph paragraph = xwpfDocument.createParagraph();         paragraph.setAlignment(alignment);         return paragraph.createRun();     }
@Override   public void trimContexts()   {     for (int index = 0; index < this.frames.length; ++index) {       final Frame f = this.frames[index];       f.trimRecursive();     }      this.frame_index = 0;   }
public List<SystemEventListener> getListenersForEventClass(Class<? extends SystemEvent> facesEventClass) {          if (null == listener) {             List<SystemEventListener> list = new ArrayList<SystemEventListener>(1);             list.add(context.getExceptionHandler());             listener = Collections.unmodifiableList(list);         }         return listener;      }
public void marshall(AddLayerVersionPermissionRequest addLayerVersionPermissionRequest, ProtocolMarshaller protocolMarshaller) {          if (addLayerVersionPermissionRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(addLayerVersionPermissionRequest.getLayerName(), LAYERNAME_BINDING);             protocolMarshaller.marshall(addLayerVersionPermissionRequest.getVersionNumber(), VERSIONNUMBER_BINDING);             protocolMarshaller.marshall(addLayerVersionPermissionRequest.getStatementId(), STATEMENTID_BINDING);             protocolMarshaller.marshall(addLayerVersionPermissionRequest.getAction(), ACTION_BINDING);             protocolMarshaller.marshall(addLayerVersionPermissionRequest.getPrincipal(), PRINCIPAL_BINDING);             protocolMarshaller.marshall(addLayerVersionPermissionRequest.getOrganizationId(), ORGANIZATIONID_BINDING);             protocolMarshaller.marshall(addLayerVersionPermissionRequest.getRevisionId(), REVISIONID_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public static WritableDoubleDataStore makeDoubleStorage(DBIDs ids, int hints) {     return DataStoreFactory.FACTORY.makeDoubleStorage(ids, hints);   }
@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static Completable fromFuture(final Future<?> future) {         ObjectHelper.requireNonNull(future, ""future is null"");         return fromAction(Functions.futureAction(future));     }
public static int copyWriterCount(final Reader in, final Writer out) throws IOException {         final char[] buffer = new char[10240];         int tot=0;         int c;         c = in.read(buffer);         while (c >= 0) {             if (c > 0) {                 out.write(buffer, 0, c);                 tot += c;             }             c = in.read(buffer);         }         return tot;     }
private Asciidoctor getAsciidoctor() {         if (asciidoctor == null) {             asciidoctor = AsciidoctorFactory.getAsciidoctor();             treeprocessor = new Treeprocessor();             IgnoreIncludeProcessor includeProcessor = new IgnoreIncludeProcessor();             JavaExtensionRegistry extensionRegistry = asciidoctor.javaExtensionRegistry();             extensionRegistry.treeprocessor(treeprocessor);             extensionRegistry.includeProcessor(includeProcessor);         }         return asciidoctor;     }
public GetDomainStatisticsResponse getDomainStatistics(GetDomainStatisticsRequest request) {         checkNotNull(request, ""The parameter request should NOT be null."");          checkStringNotEmpty(request.getDomain(), ""Domain should NOT be empty."");         InternalRequest internalRequest = createRequest(HttpMethodName.GET, request, STATISTICS,                 LIVE_DOMAIN, request.getDomain());         if (request.getStartDate() != null) {             internalRequest.addParameter(""startDate"", request.getStartDate());         }         if (request.getEndDate() != null) {             internalRequest.addParameter(""endDate"", request.getEndDate());         }         if (request.getAggregate() != null) {             internalRequest.addParameter(""aggregate"", request.getAggregate().toString());         }         return invokeHttpClient(internalRequest, GetDomainStatisticsResponse.class);     }
@PostMapping(       value = ""/{entityTypeId}/{id}"",       params = ""_method=GET"",       produces = APPLICATION_JSON_VALUE)   @ResponseBody   public Map<String, Object> retrieveEntity(       @PathVariable(""entityTypeId"") String entityTypeId,       @PathVariable(""id"") String untypedId,       @Valid @RequestBody EntityTypeRequest request) {     Set<String> attributesSet = toAttributeSet(request != null ? request.getAttributes() : null);     Map<String, Set<String>> attributeExpandSet =         toExpandMap(request != null ? request.getExpand() : null);      EntityType meta = dataService.getEntityType(entityTypeId);     Object id = getTypedValue(untypedId, meta.getIdAttribute());     Entity entity = dataService.findOneById(entityTypeId, id);      if (entity == null) {       throw new UnknownEntityException(meta, untypedId);     }      return getEntityAsMap(entity, meta, attributesSet, attributeExpandSet);   }
public static Long parseLong(String param) {   try {    if (!StringUtils.isBlank(param)) {     return Long.valueOf(param);    }   } catch (Exception e) {    throw new IllegalArgumentException(""Parameter "" + param + "" is not a number."");   }   return null;  }
protected void redraw() {     long tstart = System.currentTimeMillis();      java.awt.Graphics2D gNP = np.getBufferedImageGraphics();     if (gNP == null) // panel not drawn on screen yet       return;      // clear it     gNP.setBackground(np.getBackgroundColor());     java.awt.Rectangle r = gNP.getClipBounds();     gNP.clearRect(r.x, r.y, r.width, r.height);      if (regionSelect && geoSelectionMode) {       if (geoSelection != null) drawBB(gNP, geoSelection, Color.cyan);       if (geoBounds != null) drawBB(gNP, geoBounds, null);       // System.out.println(""GeoRegionChooser.redraw geoBounds= ""+geoBounds);        if (geoSelection != null) {         // gNP.setColor( Color.orange);         Navigation navigate = np.getNavigation();         double handleSize = RubberbandRectangleHandles.handleSizePixels / navigate.getPixPerWorld();         Rectangle2D rect = new Rectangle2D.Double(geoSelection.getX(), geoSelection.getY(), geoSelection.getWidth(), geoSelection.getHeight());         RubberbandRectangleHandles.drawHandledRect(gNP, rect, handleSize);         if (debug) System.out.println(""GeoRegionChooser.drawHandledRect="" + handleSize + "" = "" + geoSelection);       }     }      for (int i = 0; i < renderers.size(); i++) {       ucar.nc2.ui.util.Renderer rend = (Renderer) renderers.get(i);       rend.draw(gNP, atI);     }     gNP.dispose();      if (debug) {       long tend = System.currentTimeMillis();       System.out.println(""StationRegionDateChooser draw time = "" + (tend - tstart) / 1000.0 + "" secs"");     }      // copy buffer to the screen     np.repaint();   }
@javax.annotation.Nonnull   public com.simiacryptus.util.data.DoubleStatistics combine(@javax.annotation.Nonnull final com.simiacryptus.util.data.DoubleStatistics other) {     super.combine(other);     simpleSumOfSquare += other.simpleSumOfSquare;     sumOfSquareWithCompensation(other.sumOfSquare);     sumOfSquareWithCompensation(other.sumOfSquareCompensation);     return this;   }
@NonNull     public Intent build() {         Uri mailtoUri = constructMailtoUri();         return new Intent(Intent.ACTION_SENDTO, mailtoUri);     }
@Override  public RandomVariable getValue(double evaluationTime, AssetModelMonteCarloSimulationModel model) throws CalculationException {   if(exerciseMethod == ExerciseMethod.UPPER_BOUND_METHOD) {    // Find optimal lambda    GoldenSectionSearch optimizer = new GoldenSectionSearch(-1.0, 1.0);    while(!optimizer.isDone()) {     double lambda = optimizer.getNextPoint();     double value = this.getValues(evaluationTime, model, lambda).getAverage();     optimizer.setValue(value);    }    return getValues(evaluationTime, model, optimizer.getBestPoint());   }   else {    return getValues(evaluationTime, model, 0.0);   }  }
private <T> Creator<T> register(ConstructorKey key, Constructor<T> constructor, CreationModifier<T> modifier) {          Creator<T> creator = new ReflectionCreator<T>(constructor);          if (modifier != null) creator = new ModifiedCreator<T>(creator, modifier);          return register(key, creator);     }
public void set( List<Point2D_F64> list ) {   vertexes.resize(list.size());   for (int i = 0; i < list.size(); i++) {    vertexes.data[i].set( list.get(i));   }  }
public void setExportIds(java.util.Collection<String> exportIds) {         if (exportIds == null) {             this.exportIds = null;             return;         }          this.exportIds = new java.util.ArrayList<String>(exportIds);     }
public UrlChain moreUrl(Object... urlParts) {         final String argTitle = ""urlParts"";         assertArgumentNotNull(argTitle, urlParts);         checkWrongUrlChainUse(argTitle, urlParts);         this.urlParts = urlParts;         return this;     }
@Override     protected void compareData(ITable expectedTable, ITable actualTable, ComparisonColumn[] comparisonCols, FailureHandler failureHandler) throws DataSetException {         logger.debug(""compareData(expectedTable={}, actualTable={}, ""                         + ""comparisonCols={}, failureHandler={}) - start"",                 new Object[]{expectedTable, actualTable, comparisonCols,                         failureHandler});          if (expectedTable == null) {             throw new NullPointerException(                     ""The parameter 'expectedTable' must not be null"");         }         if (actualTable == null) {             throw new NullPointerException(                     ""The parameter 'actualTable' must not be null"");         }         if (comparisonCols == null) {             throw new NullPointerException(                     ""The parameter 'comparisonCols' must not be null"");         }         if (failureHandler == null) {             throw new NullPointerException(                     ""The parameter 'failureHandler' must not be null"");         }          // iterate over all rows         for (int i = 0; i < expectedTable.getRowCount(); i++) {             // iterate over all columns of the current row             for (int j = 0; j < comparisonCols.length; j++) {                 ComparisonColumn compareColumn = comparisonCols[j];                  String columnName = compareColumn.getColumnName();                 DataType dataType = compareColumn.getDataType();                  Object expectedValue = expectedTable.getValue(i, columnName);                 Object actualValue = actualTable.getValue(i, columnName);                  // Compare the values                 if (skipCompare(columnName, expectedValue, actualValue)) {                     if (logger.isTraceEnabled()) {                         logger.trace(""ignoring comparison "" + expectedValue + ""="" +                                 actualValue + "" on column "" + columnName);                     }                     continue;                 }                  if(expectedValue != null && expectedValue.toString().startsWith(""regex:"")){                     if(!regexMatches(expectedValue.toString(),actualValue.toString())){                         Difference diff = new Difference(                                 expectedTable, actualTable,                                 i, columnName,                                 expectedValue, actualValue);                          // Handle the difference (throw error immediately or something else)                         failureHandler.handle(diff);                     }                 }                 else if (dataType.compare(expectedValue, actualValue) != 0) {                      Difference diff = new Difference(                             expectedTable, actualTable,                             i, columnName,                             expectedValue, actualValue);                      // Handle the difference (throw error immediately or something else)                     failureHandler.handle(diff);                 }             }         }     }
public Response addItem( HttpServletRequest request,                              String repositoryName,                              String workspaceName,                              String path,                              String requestBody ) throws JSONException, RepositoryException {         JSONObject requestBodyJSON = stringToJSONObject(requestBody);          String parentAbsPath = parentPath(path);         String newNodeName = newNodeName(path);          Session session = getSession(request, repositoryName, workspaceName);         Node parentNode = (Node)session.getItem(parentAbsPath);         Node newNode = addNode(parentNode, newNodeName, requestBodyJSON);          session.save();         RestItem restNewNode = createRestItem(request, 0, session, newNode);         return Response.status(Response.Status.CREATED).entity(restNewNode).build();     }
@Override     public void warning(String message, String sourceName, int offset, int length)     {         errors.add(new ParseProblem(ParseProblem.Type.Warning,                                     message, sourceName,                                     offset, length));     }
private void parameterize(Parameterized parameterized) {   try {    parameterized.configure(parameters);   } catch (RuntimeException ex) {    throw new ProgramParametrizationException(ex.getMessage());   }  }
public void moveResource(CmsDbContext dbc, CmsResource source, String destination, boolean internal)     throws CmsException {          CmsFolder destinationFolder = readFolder(dbc, CmsResource.getParentFolder(destination), CmsResourceFilter.ALL);         m_securityManager.checkPermissions(             dbc,             destinationFolder,             CmsPermissionSet.ACCESS_WRITE,             false,             CmsResourceFilter.ALL);          if (source.isFolder()) {             m_monitor.flushCache(CmsMemoryMonitor.CacheType.HAS_ROLE, CmsMemoryMonitor.CacheType.ROLE_LIST);         }         getVfsDriver(dbc).moveResource(dbc, dbc.getRequestContext().getCurrentProject().getUuid(), source, destination);          if (!internal) {             CmsResourceState newState = CmsResource.STATE_CHANGED;             if (source.getState().isNew()) {                 newState = CmsResource.STATE_NEW;             } else if (source.getState().isDeleted()) {                 newState = CmsResource.STATE_DELETED;             }             source.setState(newState);             // safe since this operation always uses the ids instead of the resource path             getVfsDriver(dbc).writeResourceState(                 dbc,                 dbc.currentProject(),                 source,                 CmsDriverManager.UPDATE_STRUCTURE_STATE,                 false);             // log it             log(                 dbc,                 new CmsLogEntry(                     dbc,                     source.getStructureId(),                     CmsLogEntryType.RESOURCE_MOVED,                     new String[] {source.getRootPath(), destination}),                 false);         }          CmsResource destRes = readResource(dbc, destination, CmsResourceFilter.ALL);         // move lock         m_lockManager.moveResource(source.getRootPath(), destRes.getRootPath());          // flush all relevant caches         m_monitor.clearAccessControlListCache();         m_monitor.flushCache(             CmsMemoryMonitor.CacheType.PROPERTY,             CmsMemoryMonitor.CacheType.PROPERTY_LIST,             CmsMemoryMonitor.CacheType.PROJECT_RESOURCES);          List<CmsResource> resources = new ArrayList<CmsResource>(4);         // source         resources.add(source);         try {             resources.add(readFolder(dbc, CmsResource.getParentFolder(source.getRootPath()), CmsResourceFilter.ALL));         } catch (Exception e) {             if (LOG.isDebugEnabled()) {                 LOG.debug(e);             }         }         // destination         resources.add(destRes);         resources.add(destinationFolder);          Map<String, Object> eventData = new HashMap<String, Object>();         eventData.put(I_CmsEventListener.KEY_RESOURCES, resources);         eventData.put(I_CmsEventListener.KEY_DBCONTEXT, dbc);          // fire the events         OpenCms.fireCmsEvent(new CmsEvent(I_CmsEventListener.EVENT_RESOURCE_MOVED, eventData));     }
public List<Object> getClauseValue(String paramString) {         if (typedParameter != null && typedParameter.getParameters() != null) {             List<FilterClause> clauses = typedParameter.getParameters().get(paramString);             if (clauses != null) {                 return clauses.get(0).getValue();             } else {                 throw new IllegalArgumentException(""parameter is not a parameter of the query"");             }         }          logger.error(""Parameter {} is not a parameter of the query."", paramString);         throw new IllegalArgumentException(""Parameter is not a parameter of the query."");     }
public ClientStatsContext fetch() {         m_current = m_distributor.getStatsSnapshot();         m_currentIO = m_distributor.getIOStatsSnapshot();         m_currentTS = System.currentTimeMillis();         m_currentAffinity = m_distributor.getAffinityStatsSnapshot();         return this;     }
public DeleteVpcEndpointServiceConfigurationsRequest withServiceIds(String... serviceIds) {         if (this.serviceIds == null) {             setServiceIds(new com.amazonaws.internal.SdkInternalList<String>(serviceIds.length));         }         for (String ele : serviceIds) {             this.serviceIds.add(ele);         }         return this;     }
protected void initializeClient(JestClient client, String indexName, String defaultIndexName) {         try {             client.execute(new Health.Builder().build());             Action<JestResult> action = new IndicesExists.Builder(indexName).build();             // There was occasions where a race occurred here when multiple threads try to             // create the index simultaneously. This caused a non-fatal, but annoying, exception.             synchronized(AbstractClientFactory.class) {                 JestResult result = client.execute(action);                 if (!result.isSucceeded()) {                     createIndex(client, indexName, defaultIndexName + ""-settings.json""); //$NON-NLS-1$                 }             }         } catch (Exception e) {             throw new RuntimeException(e);         }     }
public final static double roundToDecimals(double d, int c) {   if(c < 0) return d;   double p = Math.pow(10,c);   d = d * p;   double tmp = Math.round(d);   return tmp/p;  }
private static boolean incrementLexicographically(          MutableLongTuple current, LongTuple min, LongTuple max, int index)      {          if (index == -1)          {              return false;          }          long oldValue = current.get(index);          long newValue = oldValue + 1;          current.set(index, newValue);          if (newValue >= max.get(index))          {              current.set(index, min.get(index));              return incrementLexicographically(current, min, max, index-1);          }          return true;      }
public static <T> PVectorByteBufferedIntegral2s64<T> createWithBase(     final ByteBuffer b,     final MutableLongType base,     final int offset)   {     return new PVectorByteBufferedIntegral2s64<>(b, base, offset);   }
public T loadXml(String locationUrl) {      DataResource resource = this.resourceFactory.createDataResource(locationUrl);     return loadXml(resource);   }
@Override   public char[] transformIn(String inStr) throws CpoException {     char[] retChars = null;      if (inStr != null) {       retChars = inStr.toCharArray();     }      return retChars;   }
public int executeUpdate() throws SQLException {         return executeUpdate(new Updater() {                          @Override             public int executeUpdate(final Statement statement, final String sql) throws SQLException {                 return statement.executeUpdate(sql);             }         });     }
public com.google.appengine.v1.UrlMap getHandlers(int index) {     return handlers_.get(index);   }
@XmlElementDecl(namespace = """", name = ""stp_duplex"")     public JAXBElement<Stellplatz> createStpDuplex(Stellplatz value) {         return new JAXBElement<Stellplatz>(_StpDuplex_QNAME, Stellplatz.class, null, value);     }
public void changeFile(File file) throws FileNotFoundException {         if (isTailing()) {             throw new IllegalStateException(""Cannot Change FileTailer.file while current instance is tailing"");         } else {             if (file == null) {                 throw new NullPointerException(""changeFile(File argument) cannot be null"");             } else if (!file.exists()) {                 throw new FileNotFoundException(""File does not exist: "" + file.getAbsolutePath());             }             this.file = file;         }     }
public void addFilter(final ItemFilter filter) {         if (filters == null) {             filters = new ArrayList<ItemFilter>();         }          filters.add(filter);     }
public DynamicImageField<T> addDynamicImageField(int viewResId, StringExtractor<T> extractor,                                                      DynamicImageLoader dynamicImageLoader) {          DynamicImageField<T> field =                 new DynamicImageField<T>(viewResId, extractor, dynamicImageLoader);          mDynamicImageFields.add(field);          return field;     }
public void setBinding(String binding)          throws JspException {         if (binding!= null && !UIComponentTag.isValueReference(binding)) {             // PENDING i18n             throw new JspException(""Invalid Expression:""+binding);         }         this.binding = binding;     }
protected void commitResponse(final SecurityContext securityContext, final HttpServletRequest request, final HttpServletResponse response, final RestMethodResult result, final boolean wrapSingleResultInArray) {    final String outputDepthSrc       = request.getParameter(REQUEST_PARAMTER_OUTPUT_DEPTH);   final int outputDepth             = Services.parseInt(outputDepthSrc, config.getOutputNestingDepth());   final String baseUrl              = request.getRequestURI();   final Map<String, String> headers = result.getHeaders();    // set headers   for (final Entry<String, String> header : headers.entrySet()) {    response.setHeader(header.getKey(), header.getValue());   }    // set  response code   response.setStatus(result.getResponseCode());    try {     final List<Object> content = result.getContent();    if (content != null) {      writeJson(securityContext, response, new PagingIterable(content), baseUrl, outputDepth, wrapSingleResultInArray);     } else {      final String message = result.getMessage();     if (message != null) {       writeStatus(response, result.getResponseCode(), message);      } else {       final Object nonGraphObjectResult = result.getNonGraphObjectResult();      writeJson(securityContext, response, new PagingIterable(Arrays.asList(nonGraphObjectResult)), baseUrl, outputDepth, wrapSingleResultInArray);     }     }    } catch (JsonIOException | IOException t) {     logger.warn(""Unable to commit HttpServletResponse"", t);   }  }
public final void mT__141() throws RecognitionException {         try {             int _type = T__141;             int _channel = DEFAULT_TOKEN_CHANNEL;             // InternalSARL.g:127:8: ( 'finally' )             // InternalSARL.g:127:10: 'finally'             {             match(""finally"");                }              state.type = _type;             state.channel = _channel;         }         finally {         }     }
public final Ix<T> skipWhile(IxPredicate<? super T> predicate) {         return new IxSkipWhile<T>(this, nullCheck(predicate, ""predicate is null""));     }
public static <T, U> Function<T, U> memoize(final Function<T, U> function) {     return new Memoizer<T, U>().doMemoize(function);   }
public T xpath(String expression, String value) {         if (xpathMessageConstructionInterceptor == null) {             xpathMessageConstructionInterceptor = new XpathMessageConstructionInterceptor();              if (getAction().getMessageBuilder() != null) {                 (getAction().getMessageBuilder()).add(xpathMessageConstructionInterceptor);             } else {                 PayloadTemplateMessageBuilder messageBuilder = new PayloadTemplateMessageBuilder();                 messageBuilder.getMessageInterceptors().add(xpathMessageConstructionInterceptor);                  getAction().setMessageBuilder(messageBuilder);             }         }          xpathMessageConstructionInterceptor.getXPathExpressions().put(expression, value);         return self;     }
public Iterable<DConnection> queryByUpdatedBy(java.lang.String updatedBy) {     return queryByField(null, DConnectionMapper.Field.UPDATEDBY.getFieldName(), updatedBy);   }
Description validate(Tree tree, VisitorState state) {     GuardedByValidationResult result = GuardedByUtils.isGuardedByValid(tree, state);     if (result.isValid()) {       return Description.NO_MATCH;     }     return buildDescription(tree)         .setMessage(String.format(""Invalid @GuardedBy expression: %s"", result.message()))         .build();   }
public Table getTable(String tableName) {     // [START ]     Table table = dataset.get(tableName);     // [END ]     return table;   }
private CmsADEConfigData getConfigData(String pageRootPath) {          if (m_configData == null) {             m_configData = OpenCms.getADEManager().lookupConfiguration(getCmsObject(), pageRootPath);         }         return m_configData;     }
public static File getOwnCacheDirectory(Context context, String cacheDir) {   File appCacheDir = null;   if (MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) && hasExternalStoragePermission(context)) {    appCacheDir = new File(Environment.getExternalStorageDirectory(), cacheDir);   }   if (appCacheDir == null || (!appCacheDir.exists() && !appCacheDir.mkdirs())) {    appCacheDir = context.getCacheDir();   }   return appCacheDir;  }
public void marshall(SamplingRuleRecord samplingRuleRecord, ProtocolMarshaller protocolMarshaller) {          if (samplingRuleRecord == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(samplingRuleRecord.getSamplingRule(), SAMPLINGRULE_BINDING);             protocolMarshaller.marshall(samplingRuleRecord.getCreatedAt(), CREATEDAT_BINDING);             protocolMarshaller.marshall(samplingRuleRecord.getModifiedAt(), MODIFIEDAT_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
protected static String getFirstSpecifiedKeyID(final JWKMatcher jwkMatcher) {    Set<String> keyIDs = jwkMatcher.getKeyIDs();    if (keyIDs == null || keyIDs.isEmpty()) {    return null;   }    for (String id: keyIDs) {    if (id != null) {     return id;    }   }   return null; // No kid in matcher  }
public void log(LogLevel level, String msg, Throwable t)   {    if (level != LogLevel.OFF && level.level <= logLevel.level)     logger.add(writers, name, level, msg, t);   }
private String getEmailAddresses() {          List<String> emails = new ArrayList<String>();         Iterator<String> itIds = idsList().iterator();         while (itIds.hasNext()) {             String id = itIds.next();             CmsSessionInfo session = OpenCms.getSessionManager().getSessionInfo(id);             if (session != null) {                 try {                     String emailAddress = getCms().readUser(session.getUserId()).getEmail();                     if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(emailAddress) && !emails.contains(emailAddress)) {                         emails.add(emailAddress);                     }                 } catch (Exception e) {                     LOG.error(e.getLocalizedMessage(), e);                 }             }         }         StringBuffer result = new StringBuffer(256);         Iterator<String> itEmails = emails.iterator();         while (itEmails.hasNext()) {             result.append(itEmails.next());             if (itEmails.hasNext()) {                 result.append(""; "");             }         }         return result.toString();     }
public static long delayResponse() {     Call call = CurCall.get();     long res = 0;     if (call != null) {       call.delayResponse();       res = delayedRpcId.getAndIncrement();       delayedCalls.put(res, call);     }     return res;   }
public <T> T safeGet(String fieldName){    try {     return get(fieldName);    } catch (Exception e) {     return null;    }   }
@XmlElementDecl(namespace = """", name = ""anzahl_badezimmer"")     @XmlJavaTypeAdapter(Adapter2 .class)     public JAXBElement<BigDecimal> createAnzahlBadezimmer(BigDecimal value) {         return new JAXBElement<BigDecimal>(_AnzahlBadezimmer_QNAME, BigDecimal.class, null, value);     }
protected void readHeader(ByteBuffer buffer) {     super.readHeader(buffer);     if (this.responseStatus == ResponseStatus.NO_ERROR) {       this.decodeStatus = BinaryDecodeStatus.DONE;     }   }
@Override     public UpdateXssMatchSetResult updateXssMatchSet(UpdateXssMatchSetRequest request) {         request = beforeClientExecution(request);         return executeUpdateXssMatchSet(request);     }
private static void verifyAncestry(Class<?> tClass) {     if (!TBase.class.isAssignableFrom(tClass)) {       Utils.ensureClassLoaderConsistency(TBase.class, tClass.getClassLoader());       throw new ClassCastException(tClass.getName() + "" is not a Thrift class"");     }   }
public static InstrumentedThreadFactory defaultThreadFactory(MetricRegistry registry, String name) {         return new InstrumentedThreadFactory(Executors.defaultThreadFactory(), registry, name);     }
public AbucoinsOrderBook getAbucoinsOrderBook(String productID, AbucoinsOrderBookLevel level)       throws IOException {     return abucoins.getBook(productID, level.name());   }
static boolean isSignatureAssignable( Class[] from, Class[] to, int round )     {         if ( round != JAVA_VARARGS_ASSIGNABLE && from.length != to.length )             return false;          switch ( round )         {             case JAVA_BASE_ASSIGNABLE:                 for( int i=0; i<from.length; i++ )                     if ( !isJavaBaseAssignable( to[i], from[i] ) )                         return false;                 return true;             case JAVA_BOX_TYPES_ASSIGABLE:                 for( int i=0; i<from.length; i++ )                     if ( !isJavaBoxTypesAssignable( to[i], from[i] ) )                         return false;                 return true;             case JAVA_VARARGS_ASSIGNABLE:                 return isSignatureVarargsAssignable( from, to );             case BSH_ASSIGNABLE:                 for( int i=0; i<from.length; i++ )                     if ( !isBshAssignable( to[i], from[i] ) )                         return false;                 return true;             default:                 throw new InterpreterError(""bad case"");         }     }
public void start() {         application = new CitrusRemoteApplication(configuration);         port(configuration.getPort());         application.init();          if (!configuration.isSkipTests()) {             new RunController(configuration).run();         }          if (configuration.getTimeToLive() == 0) {             stop();         }     }
private CmsInternalLinksValidator getValidator() {          if (m_validator == null) {             // get the content check result object             Map objects = (Map)getSettings().getDialogObject();             Object o = objects.get(CmsInternalLinkValidationDialog.class.getName());             List resources = new ArrayList();             if ((o != null) && (o instanceof List)) {                 resources = (List)o;             }             m_validator = new CmsInternalLinksValidator(getCms(), resources);         }         return m_validator;     }
public static SqlExpressionGroup exps(String name, String op, Object value) {          return exps(exp(name, op, value));      }
public static ClassFile buildClassFile(String className, Class<?>[] classes)         throws IllegalArgumentException     {         return buildClassFile(className, classes, null, null, OBSERVER_DISABLED);     }
public static Document readXML(Reader reader) throws IOException, SAXException, ParserConfigurationException {   assert reader != null : AssertMessages.notNullParameter();   try {    final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();    final DocumentBuilder builder = factory.newDocumentBuilder();    return builder.parse(new InputSource(reader));   } finally {    reader.close();   }  }
public static clusternodegroup_nslimitidentifier_binding[] get(nitro_service service, String name) throws Exception{   clusternodegroup_nslimitidentifier_binding obj = new clusternodegroup_nslimitidentifier_binding();   obj.set_name(name);   clusternodegroup_nslimitidentifier_binding response[] = (clusternodegroup_nslimitidentifier_binding[]) obj.get_resources(service);   return response;  }
protected final List<DCSubject> parseSubjects(final List<Element> eList) {          final List<DCSubject> subjects = new ArrayList<DCSubject>();          for (final Element eSubject : eList) {              final Element description = eSubject.getChild(""Description"", getRDFNamespace());              if (description != null) {                  final String taxonomy = getTaxonomy(description);                  final List<Element> values = description.getChildren(""value"", getRDFNamespace());                 for (final Element value : values) {                      final DCSubject subject = new DCSubjectImpl();                     subject.setTaxonomyUri(taxonomy);                     subject.setValue(value.getText());                     subjects.add(subject);                  }              } else {                 final DCSubject subject = new DCSubjectImpl();                 subject.setValue(eSubject.getText());                 subjects.add(subject);             }         }          return subjects;     }
public static INDArrayIndex[] createCoveringShape(int[] shape) {         INDArrayIndex[] ret = new INDArrayIndex[shape.length];         for (int i = 0; i < ret.length; i++) {             ret[i] = NDArrayIndex.interval(0, shape[i]);         }         return ret;     }
public WritableGridFileChannel getWritableChannel(String pathname, boolean append, int chunkSize) throws IOException {       GridFile file = (GridFile) getFile(pathname, chunkSize);       checkIsNotDirectory(file);       createIfNeeded(file);       return new WritableGridFileChannel(file, data, append);    }
public JobExecutionStatusDetails withDetailsMap(java.util.Map<String, String> detailsMap) {         setDetailsMap(detailsMap);         return this;     }
@Override     public void dereferenceConsumerManager()     {         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())             SibTr.entry(tc, ""dereferenceConsumerManager"");         setOutputHandler(null);         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())             SibTr.exit(tc, ""dereferenceConsumerManager"");     }
private BufferedImage rasterizeConvoLayers(@NonNull List<INDArray> tensors3D, BufferedImage sourceImage) {         long width = 0;         long height = 0;          int border = 1;         int padding_row = 2;         int padding_col = 80;          /*             We determine height of joint output image. We assume that first position holds maximum dimensionality          */         val shape = tensors3D.get(0).shape();         val numImages = shape[0];         height = (shape[2]);         width = (shape[1]);         //        log.info(""Output image dimensions: {height: "" + height + "", width: "" + width + ""}"");         int maxHeight = 0; //(height + (border * 2 ) + padding_row) * numImages;         int totalWidth = 0;         int iOffset = 1;          Orientation orientation = Orientation.LANDSCAPE;         /*             for debug purposes we'll use portait only now          */         if (tensors3D.size() > 3) {             orientation = Orientation.PORTRAIT;         }            List<BufferedImage> images = new ArrayList<>();         for (int layer = 0; layer < tensors3D.size(); layer++) {             INDArray tad = tensors3D.get(layer);             int zoomed = 0;              BufferedImage image = null;             if (orientation == Orientation.LANDSCAPE) {                 maxHeight = (int) ((height + (border * 2) + padding_row) * numImages);                 image = renderMultipleImagesLandscape(tad, maxHeight, (int) width, (int) height);                 totalWidth += image.getWidth() + padding_col;             } else if (orientation == Orientation.PORTRAIT) {                 totalWidth = (int) ((width + (border * 2) + padding_row) * numImages);                 image = renderMultipleImagesPortrait(tad, totalWidth, (int) width, (int) height);                 maxHeight += image.getHeight() + padding_col;             }              images.add(image);         }          if (orientation == Orientation.LANDSCAPE) {             // append some space for arrows             totalWidth += padding_col * 2;         } else if (orientation == Orientation.PORTRAIT) {             maxHeight += padding_col * 2;             maxHeight += sourceImage.getHeight() + (padding_col * 2);         }          BufferedImage output = new BufferedImage(totalWidth, maxHeight, BufferedImage.TYPE_INT_RGB);         Graphics2D graphics2D = output.createGraphics();          graphics2D.setPaint(bgColor);         graphics2D.fillRect(0, 0, output.getWidth(), output.getHeight());          BufferedImage singleArrow = null;         BufferedImage multipleArrows = null;          /*             We try to add nice flow arrow here          */         try {              if (orientation == Orientation.LANDSCAPE) {                 try {                     ClassPathResource resource = new ClassPathResource(""arrow_sing.PNG"");                     ClassPathResource resource2 = new ClassPathResource(""arrow_mul.PNG"");                      singleArrow = ImageIO.read(resource.getInputStream());                     multipleArrows = ImageIO.read(resource2.getInputStream());                 } catch (Exception e) {                 }                  graphics2D.drawImage(sourceImage, (padding_col / 2) - (sourceImage.getWidth() / 2),                                 (maxHeight / 2) - (sourceImage.getHeight() / 2), null);                  graphics2D.setPaint(borderColor);                 graphics2D.drawRect((padding_col / 2) - (sourceImage.getWidth() / 2),                                 (maxHeight / 2) - (sourceImage.getHeight() / 2), sourceImage.getWidth(),                                 sourceImage.getHeight());                  iOffset += sourceImage.getWidth();                  if (singleArrow != null)                     graphics2D.drawImage(singleArrow, iOffset + (padding_col / 2) - (singleArrow.getWidth() / 2),                                     (maxHeight / 2) - (singleArrow.getHeight() / 2), null);             } else {                 try {                     ClassPathResource resource = new ClassPathResource(""arrow_singi.PNG"");                     ClassPathResource resource2 = new ClassPathResource(""arrow_muli.PNG"");                      singleArrow = ImageIO.read(resource.getInputStream());                     multipleArrows = ImageIO.read(resource2.getInputStream());                 } catch (Exception e) {                 }                  graphics2D.drawImage(sourceImage, (totalWidth / 2) - (sourceImage.getWidth() / 2),                                 (padding_col / 2) - (sourceImage.getHeight() / 2), null);                  graphics2D.setPaint(borderColor);                 graphics2D.drawRect((totalWidth / 2) - (sourceImage.getWidth() / 2),                                 (padding_col / 2) - (sourceImage.getHeight() / 2), sourceImage.getWidth(),                                 sourceImage.getHeight());                  iOffset += sourceImage.getHeight();                 if (singleArrow != null)                     graphics2D.drawImage(singleArrow, (totalWidth / 2) - (singleArrow.getWidth() / 2),                                     iOffset + (padding_col / 2) - (singleArrow.getHeight() / 2), null);              }             iOffset += padding_col;         } catch (Exception e) {             // if we can't load images - ignore them         }            /*             now we merge all images into one big image with some offset         */           for (int i = 0; i < images.size(); i++) {             BufferedImage curImage = images.get(i);             if (orientation == Orientation.LANDSCAPE) {                 // image grows from left to right                 graphics2D.drawImage(curImage, iOffset, 1, null);                 iOffset += curImage.getWidth() + padding_col;                  if (singleArrow != null && multipleArrows != null) {                     if (i < images.size() - 1) {                         // draw multiple arrows here                         if (multipleArrows != null)                             graphics2D.drawImage(multipleArrows,                                             iOffset - (padding_col / 2) - (multipleArrows.getWidth() / 2),                                             (maxHeight / 2) - (multipleArrows.getHeight() / 2), null);                     } else {                         // draw single arrow                         //    graphics2D.drawImage(singleArrow, iOffset - (padding_col / 2) - (singleArrow.getWidth() / 2), (maxHeight / 2) - (singleArrow.getHeight() / 2), null);                     }                 }             } else if (orientation == Orientation.PORTRAIT) {                 // image grows from top to bottom                 graphics2D.drawImage(curImage, 1, iOffset, null);                 iOffset += curImage.getHeight() + padding_col;                  if (singleArrow != null && multipleArrows != null) {                     if (i < images.size() - 1) {                         // draw multiple arrows here                         if (multipleArrows != null)                             graphics2D.drawImage(multipleArrows, (totalWidth / 2) - (multipleArrows.getWidth() / 2),                                             iOffset - (padding_col / 2) - (multipleArrows.getHeight() / 2), null);                     } else {                         // draw single arrow                         //   graphics2D.drawImage(singleArrow, (totalWidth / 2) - (singleArrow.getWidth() / 2),  iOffset - (padding_col / 2) - (singleArrow.getHeight() / 2) , null);                     }                 }             }         }          return output;     }
public OperationStatus updateSettings(UUID appId, UpdateSettingsOptionalParameter updateSettingsOptionalParameter) {         return updateSettingsWithServiceResponseAsync(appId, updateSettingsOptionalParameter).toBlocking().single().body();     }
public synchronized StorableProperties put(String key, Object val) {         if (!key.equals(toLowerCase(key)))             throw new IllegalArgumentException(""Do not use upper case keys ("" + key + "") for StorableProperties since 0.7"");          map.put(key, val.toString());         return this;     }
public static ReportedData getReportedDataFrom(Stanza packet) {         // Check if the packet includes the DataForm extension         DataForm dataForm = DataForm.from(packet);         if (dataForm != null) {             if (dataForm.getReportedData() != null)                 return new ReportedData(dataForm);         }         // Otherwise return null         return null;     }
protected final void registerSession( AbstractSession sessionToAdd )     {      if (sessions.put(sessionToAdd.getId(),sessionToAdd) != null)       throw new IllegalArgumentException(""Session ""+sessionToAdd.getId()+"" already exists"");     }
public static byte[] readRAM(final File f) throws IOException {     final int total = (int) f.length();     final byte[] ret = new byte[total];     final InputStream in = new FileInputStream(f);     try {       int offset = 0;       int read = 0;       do {         read = in.read(ret, offset, total - read);         if (read > 0) {           offset += read;         }       } while ((read != -1) && (offset != total));       return ret;     } finally {       in.close();     }   }
void writeTransactionIdFile(StorageDirectory sd, long txid) throws IOException {     if (txid < -1) {       // -1 is valid when formatting       throw new IOException(""Bad txid: "" + txid);     }     File txIdFile = getStorageFile(sd, NameNodeFile.SEEN_TXID);     OutputStream fos = new AtomicFileOutputStream(txIdFile);     try {       fos.write(String.valueOf(txid).getBytes());       fos.write('\n');       fos.close();       fos = null;     } finally {       IOUtils.cleanup(LOG, fos);     }   }
@Override  public void setMedial2(double x, double y, double z) {   this.medial2.set(x, y, z);   ensureAIsLowerPoint();  }
private static Class<?> parameterizedReturnType(Method method) {     Type type = method.getGenericReturnType();     if (type instanceof ParameterizedType) {       try {         return Class.forName(             (((ParameterizedType) type).getActualTypeArguments()[0]).getTypeName());       } catch (ClassNotFoundException e) {         return Object.class;       }     } else {       return Object.class;     }   }
public XMLResource xml(URI anUri, AbstractContent requestContent) throws IOException {   return doPOSTOrPUT(anUri, requestContent, createXMLResource());  }
protected Dependency createDependency(Dependency dependency, String name, String version, String scope) {         final Dependency nodeModule = new Dependency(new File(dependency.getActualFile() + ""?"" + name), true);         nodeModule.setEcosystem(NPM_DEPENDENCY_ECOSYSTEM);         //this is virtual - the sha1 is purely for the hyperlink in the final html report         nodeModule.setSha1sum(Checksum.getSHA1Checksum(String.format(""%s:%s"", name, version)));         nodeModule.setSha256sum(Checksum.getSHA256Checksum(String.format(""%s:%s"", name, version)));         nodeModule.setMd5sum(Checksum.getMD5Checksum(String.format(""%s:%s"", name, version)));         nodeModule.addEvidence(EvidenceType.PRODUCT, ""package.json"", ""name"", name, Confidence.HIGHEST);         nodeModule.addEvidence(EvidenceType.VENDOR, ""package.json"", ""name"", name, Confidence.HIGH);         if (!StringUtils.isBlank(version)) {             nodeModule.addEvidence(EvidenceType.VERSION, ""package.json"", ""version"", version, Confidence.HIGHEST);             nodeModule.setVersion(version);         }         if (dependency.getName() != null) {             nodeModule.addProjectReference(dependency.getName() + "": "" + scope);         } else {             nodeModule.addProjectReference(dependency.getDisplayFileName() + "": "" + scope);         }         nodeModule.setName(name);          //TODO  - we can likely create a valid CPE as a low confidence guess using cpe:2.3:a:[name]_project:[name]:[version]         //(and add a targetSw of npm/node)         Identifier id;         try {             final PackageURL purl = PackageURLBuilder.aPackageURL().withType(StandardTypes.NPM)                     .withName(name).withVersion(version).build();             id = new PurlIdentifier(purl, Confidence.HIGHEST);         } catch (MalformedPackageURLException ex) {             LOGGER.debug(""Unable to generate Purl - using a generic identifier instead "" + ex.getMessage());             id = new GenericIdentifier(String.format(""npm:%s@%s"", dependency.getName(), version), Confidence.HIGHEST);         }         nodeModule.addSoftwareIdentifier(id);         return nodeModule;     }
public String buildPreparedStatementName() {   if (!StringUtils.hasText(preparedStatementName)) {    preparedStatementName = getParent().buildPreparedStatementName(getName());   }   return preparedStatementName;  }
public Observable<PublicIPAddressInner> createOrUpdateAsync(String resourceGroupName, String publicIpAddressName, PublicIPAddressInner parameters) {         return createOrUpdateWithServiceResponseAsync(resourceGroupName, publicIpAddressName, parameters).map(new Func1<ServiceResponse<PublicIPAddressInner>, PublicIPAddressInner>() {             @Override             public PublicIPAddressInner call(ServiceResponse<PublicIPAddressInner> response) {                 return response.body();             }         });     }
public static String getPippoVersion() {         // and the key inside the properties file.         String pippoVersionPropertyKey = ""pippo.version"";          String pippoVersion;          try {             Properties prop = new Properties();             URL url = ClasspathUtils.locateOnClasspath(PippoConstants.LOCATION_OF_PIPPO_BUILTIN_PROPERTIES);             InputStream stream = url.openStream();             prop.load(stream);              pippoVersion = prop.getProperty(pippoVersionPropertyKey);         } catch (Exception e) {             //this should not happen. Never.             throw new PippoRuntimeException(""Something is wrong with your build. Cannot find resource {}"",                 PippoConstants.LOCATION_OF_PIPPO_BUILTIN_PROPERTIES);         }          return pippoVersion;     }
@Override     public Page<Country> nextPage(final Page<Country> page,                                    final TwilioRestClient client) {         Request request = new Request(             HttpMethod.GET,             page.getNextPageUrl(                 Domains.VOICE.toString(),                 client.getRegion()             )         );         return pageForRequest(client, request);     }
public Boolean getAndDecryptBoolean(String name, String providerName) throws Exception {         return (Boolean) getAndDecrypt(name, providerName);     }
public void setAlertChannels(Collection<AlertChannel> channels)     {         for(AlertChannel channel : channels)         {             // Add the channel to any policies it is associated with             List<Long> policyIds = channel.getLinks().getPolicyIds();             for(long policyId : policyIds)             {                 AlertPolicy policy = policies.get(policyId);                 if(policy != null)                     alertChannels(policyId).add(channel);                 else                     logger.severe(String.format(""Unable to find policy for channel '%s': %d"", channel.getName(), policyId));             }         }     }
@Deprecated   public static URI getPath(String bucketName, String objectName) {     return LEGACY_PATH_CODEC.getPath(         bucketName, objectName, false /* do not allow empty object */);   }
public static URI getRootUri(final Archive<?> archive) throws IllegalArgumentException {         if (archive == null) {             throw new IllegalArgumentException(""Archive must be specified"");         }         final StringBuilder sb = new StringBuilder();         sb.append(PROTOCOL);         sb.append(URI_PROTOCOL_SUFFIX);         sb.append(archive.getId());         sb.append('/');         final URI uri = URI.create(sb.toString());         return uri;     }
public void init()             throws ServletException     {         org.slf4j.Logger logServerStartup = org.slf4j.LoggerFactory.getLogger(""serverStartup"");         logServerStartup.info(getClass().getName() + "" initialization start"");         try {             System.setProperty(""file.encoding"", ""UTF-8"");             Field charset = Charset.class.getDeclaredField(""defaultCharset"");             charset.setAccessible(true);             charset.set(null, null);             initialize();         } catch (Exception e) {             throw new ServletException(e);         }     }
@Override     public void storeTrigger(OperableTrigger trigger, boolean replaceExisting, JedisCluster jedis) throws JobPersistenceException {         final String triggerHashKey = redisSchema.triggerHashKey(trigger.getKey());         final String triggerGroupSetKey = redisSchema.triggerGroupSetKey(trigger.getKey());         final String jobTriggerSetKey = redisSchema.jobTriggersSetKey(trigger.getJobKey());          if (!(trigger instanceof SimpleTrigger) && !(trigger instanceof CronTrigger)) {             throw new UnsupportedOperationException(""Only SimpleTrigger and CronTrigger are supported."");         }         final boolean exists = jedis.exists(triggerHashKey);         if (exists && !replaceExisting) {             throw new ObjectAlreadyExistsException(trigger);         }          Map<String, String> triggerMap = mapper.convertValue(trigger, new TypeReference<HashMap<String, String>>() {         });         triggerMap.put(TRIGGER_CLASS, trigger.getClass().getName());          jedis.hmset(triggerHashKey, triggerMap);         jedis.sadd(redisSchema.triggersSet(), triggerHashKey);         jedis.sadd(redisSchema.triggerGroupsSet(), triggerGroupSetKey);         jedis.sadd(triggerGroupSetKey, triggerHashKey);         jedis.sadd(jobTriggerSetKey, triggerHashKey);         if (trigger.getCalendarName() != null && !trigger.getCalendarName().isEmpty()) {             final String calendarTriggersSetKey = redisSchema.calendarTriggersSetKey(trigger.getCalendarName());             jedis.sadd(calendarTriggersSetKey, triggerHashKey);         }         if (trigger.getJobDataMap() != null && !trigger.getJobDataMap().isEmpty()) {             final String triggerDataMapHashKey = redisSchema.triggerDataMapHashKey(trigger.getKey());             jedis.hmset(triggerDataMapHashKey, getStringDataMap(trigger.getJobDataMap()));         }          if (exists) {             // We're overwriting a previously stored instance of this trigger, so clear any existing trigger state.             unsetTriggerState(triggerHashKey, jedis);         }          Boolean triggerPausedResponse = jedis.sismember(redisSchema.pausedTriggerGroupsSet(), triggerGroupSetKey);         Boolean jobPausedResponse = jedis.sismember(redisSchema.pausedJobGroupsSet(), redisSchema.jobGroupSetKey(trigger.getJobKey()));          if (triggerPausedResponse || jobPausedResponse) {             final long nextFireTime = trigger.getNextFireTime() != null ? trigger.getNextFireTime().getTime() : -1;             final String jobHashKey = redisSchema.jobHashKey(trigger.getJobKey());             if (isBlockedJob(jobHashKey, jedis)) {                 setTriggerState(RedisTriggerState.PAUSED_BLOCKED, (double) nextFireTime, triggerHashKey, jedis);             } else {                 setTriggerState(RedisTriggerState.PAUSED, (double) nextFireTime, triggerHashKey, jedis);             }         } else if (trigger.getNextFireTime() != null) {             setTriggerState(RedisTriggerState.WAITING, (double) trigger.getNextFireTime().getTime(), triggerHashKey, jedis);         }     }
protected String getQueryFor(final String key) {         log.trace(""Trying to get query for {} "", key);         String query = queries.get(key);         log.trace(""Query found {} for key {}"", query, key);         if (query == null) {             log.error(""Query for {} key does not exist"", key);             throw new IllegalArgumentException(""Query for key "" + key + "" does not exist"");         } else if (StringUtils.isBlank(query)) {             log.error(""Query for key {} can't be blank or be only whitespace"", key);             throw new IllegalArgumentException(""Query for key "" + key + "" can't be blank or be only whitespace"");         }         return query.trim().replaceAll(""\\s+"", "" "");     }
static private String findParamValueFor(String s)  {   int endParamIndex = s.indexOf('=');   int endValueIndex = s.indexOf(']',endParamIndex);   if (endValueIndex<0) throw new IllegalStateException(""illegal class description '""+s+""'"");   return s.substring(endParamIndex+1,endValueIndex);  }
@Nullable   public String getListItemStartingWith (@Nullable final String sPrefix)   {     for (final Object aObj : m_aList)       if (aObj instanceof List <?>)         for (final Object aListItem : (List <?>) aObj)           if (((String) aListItem).startsWith (sPrefix))             return (String) aListItem;     return null;   }
public static Array convert( Array org, DataType wantType) {      if (org == null) return null;      Class wantClass = wantType.getPrimitiveClassType();      if (org.getElementType().equals(wantClass))        return org;        Array result = Array.factory(wantType, org.getShape());      copy(wantType, org.getIndexIterator(), result.getIndexIterator());      return result;    }
public void addTickLabelSection(final Section SECTION) {         if (null == SECTION) return;         tickLabelSections.add(SECTION);         Collections.sort(tickLabelSections, new SectionComparator());         fireUpdateEvent(REDRAW_EVENT);     }
public void log( final Priority priority, final Object message, final Throwable t )     {         if ( priority == null )         {             return;         }          switch (priority.level)         {             case Level.FATAL_INT:                 this.fatal( message, t );                 break;             case Level.ERROR_INT:                 this.error( message, t );                 break;             case Level.WARN_INT:                 this.warn( message, t );                 break;             case Level.INFO_INT:                 this.info( message, t );                 break;             case Level.DEBUG_INT:                 this.debug( message, t );                 break;             case Level.TRACE_INT:             case Level.ALL_INT:                 this.trace( message, t );                 break;             default:                 break;         }     }
public static void putServiceTicketInRequestScope(final RequestContext context, final ServiceTicket ticketValue) {         context.getRequestScope().put(PARAMETER_SERVICE_TICKET_ID, ticketValue.getId());     }
public ExportRequestResponse exportRequest(ExportRequestInfo exportRequestInfo) throws ApiException {         ApiResponse<ExportRequestResponse> resp = exportRequestWithHttpInfo(exportRequestInfo);         return resp.getData();     }
public boolean getBoolean(String key, boolean def) {         String value = getString(key);         if (value == null) {             return def;         }         else {             return ""true"".equalsIgnoreCase(value);         }     }
public HalCuriAugmenter register(String name, String href) {     Link link = new Link(href).setName(name);     return register(link);   }
@Override     public boolean offer(final WaitStrategy.Offerable o) throws InterruptedException {         while (!o.offer()) {             LockSupport.parkNanos(1l);         }         return true;     }
public static Bitmap getFrameSloppy(SeekableDemuxerTrack vt, ContainerAdaptor decoder, int frameNumber)             throws IOException, JCodecException {         return ((AndroidFrameGrab) new AndroidFrameGrab(vt, decoder).seekToFrameSloppy(frameNumber)).getFrame();     }
private VerticalLayout createEnableGoogleAuthButton() {   final VerticalLayout formLayout = new VerticalLayout();   formLayout.setSizeFull();    final Panel formPanel = new Panel();   formPanel.setSizeFull();    formLayout.addComponent(formPanel);    final FormLayout formContent = new FormLayout();   formPanel.setContent(formContent);    final SetGoogleAuthenticatorCredentialRequest request = new SetGoogleAuthenticatorCredentialRequest();   request.setSessionId(RequestContextHolder.currentRequestAttributes().getSessionId());   request.setUserpassword("""");   final ClickListener listener = new SetGoogleAuthenticatorCredentialClickListener(request);   getFormFactory().addRequestInputFormFields(formContent, request, SetGoogleAuthenticatorCredentialRequest.class,     AS_LIST, ENABLE_GOOGLE_AUTHENTICATOR, listener);    return formLayout;  }
private void processRunnableOperations(             final Consumer<WorkflowSystem.OperationResult<DAT, RES, OP>> resultConsumer,             final List<OP> shouldrun,             final List<OP> shouldskip,             final DAT inputData     )     {         for (final OP operation : shouldrun) {             if (shouldskip.contains(operation)) {                 continue;             }             pending.remove(operation);              workflowEngine.event(                     WorkflowSystemEventType.WillRunOperation,                     String.format(""operation starting: %s"", operation),                     operation             );             final ListenableFuture<RES> submit = executorService.submit(() -> operation.apply(inputData));             inProcess.add(operation);             futures.add(submit);             FutureCallback<RES> callback = new FutureCallback<RES>() {                 @Override                 public void onSuccess(final RES successResult) {                     workflowEngine.event(                             WorkflowSystemEventType.OperationSuccess,                             String.format(""operation succeeded: %s"", successResult),                             successResult                     );                     assert successResult != null;                     WorkflowSystem.OperationResult<DAT, RES, OP> result = result(successResult, operation);                     resultConsumer.accept(result);                     stateChangeQueue.add(successResult);                     inProcess.remove(operation);                 }                  @Override                 public void onFailure(final Throwable t) {                     workflowEngine.event(                             WorkflowSystemEventType.OperationFailed,                             String.format(""operation failed: %s"", t),                             t                     );                     WorkflowSystem.OperationResult<DAT, RES, OP> result = result(t, operation);                     resultConsumer.accept(result);                     StateObj newFailureState = operation.getFailureState(t);                     if (null != newFailureState && newFailureState.getState().size() > 0) {                         WorkflowSystem.OperationCompleted<DAT> objectOperationCompleted = WorkflowEngine.dummyResult(                                 newFailureState);                         stateChangeQueue.add(objectOperationCompleted);                     }                     inProcess.remove(operation);                 }             };              Futures.addCallback(submit, callback, manager);         }     }
@Override   public EClass getIfcStructuralLoadOrResult() {    if (ifcStructuralLoadOrResultEClass == null) {     ifcStructuralLoadOrResultEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)       .getEClassifiers().get(645);    }    return ifcStructuralLoadOrResultEClass;   }
public static void createLoadsBasedOnDescriptor(MethodVisitor mv, String descriptor, int startindex) {   int slot = startindex;   int descriptorpos = 1; // start after the '('   char ch;   while ((ch = descriptor.charAt(descriptorpos)) != ')') {    switch (ch) {     case '[':      mv.visitVarInsn(ALOAD, slot);      slot++;      // jump to end of array, could be [[[[I      while (descriptor.charAt(++descriptorpos) == '[') {      }      if (descriptor.charAt(descriptorpos) == 'L') {       descriptorpos = descriptor.indexOf(';', descriptorpos) + 1;      }      else {       // Just a primitive array       descriptorpos++;      }      break;     case 'L':      mv.visitVarInsn(ALOAD, slot);      slot++;      // jump to end of 'L' signature      descriptorpos = descriptor.indexOf(';', descriptorpos) + 1;      break;     case 'J':      mv.visitVarInsn(LLOAD, slot);      slot += 2; // double slotter      descriptorpos++;      break;     case 'D':      mv.visitVarInsn(DLOAD, slot);      slot += 2; // double slotter      descriptorpos++;      break;     case 'F':      mv.visitVarInsn(FLOAD, slot);      descriptorpos++;      slot++;      break;     case 'I':     case 'Z':     case 'B':     case 'C':     case 'S':      mv.visitVarInsn(ILOAD, slot);      descriptorpos++;      slot++;      break;     default:      throw new IllegalStateException(""Unexpected type in descriptor: "" + ch);    }   }  }
private void copy(ByteBuf src, ByteBuffer dst) {   // This branch is necessary, because an Exception is thrown if the   // destination buffer has more remaining (writable) bytes than   // currently readable from the Netty ByteBuf source.   if (src.isReadable()) {    if (src.readableBytes() < dst.remaining()) {     int oldLimit = dst.limit();      dst.limit(dst.position() + src.readableBytes());     src.readBytes(dst);     dst.limit(oldLimit);    }    else {     src.readBytes(dst);    }   }  }
public static Map<String, String> mergeDefaults(         CmsObject cms,         Map<String, CmsXmlContentProperty> propertyConfig,         Map<String, String> properties) {          Map<String, String> result = new HashMap<String, String>();         if (propertyConfig != null) {             for (Map.Entry<String, CmsXmlContentProperty> entry : propertyConfig.entrySet()) {                 CmsXmlContentProperty prop = entry.getValue();                 String value = getPropValueIds(cms, prop.getType(), prop.getDefault());                 if (value != null) {                     result.put(entry.getKey(), value);                 }             }         }         result.putAll(properties);         return result;     }
@GwtIncompatible // NavigableSet   public static <E> NavigableSet<E> unmodifiableNavigableSet(NavigableSet<E> set) {     if (set instanceof ImmutableSortedSet || set instanceof UnmodifiableNavigableSet) {       return set;     }     return new UnmodifiableNavigableSet<E>(set);   }
public static byte[] readBytes(File file) throws IOException {         FileInputStream fis = null;         ByteArrayOutputStream bos = null;         if (file == null) {             throw new FileNotFoundException(""No file specified"");         }         try {             fis = new FileInputStream(file);             bos = new ByteArrayOutputStream();             byte[] buffer = new byte[BUFFER_SIZE];             int remaining;             while ((remaining = fis.read(buffer)) > 0) {                 bos.write(buffer, 0, remaining);             }             return bos.toByteArray();         } finally {             Closeables.closeQuietly(fis);             Closeables.closeQuietly(bos);         }     }
public GridBagLayoutBuilder appendField(Component component, int colSpan) {         return append(component, colSpan, 1, true, false);     }
public void putClass(String key, Class<?> clazz) {   checkNotNull(key);   checkNotNull(clazz);   final String error = InstantiationUtil.checkForInstantiationError(clazz);   if (error != null) {    throw new ValidationException(""Class '"" + clazz.getName() + ""' is not supported: "" + error);   }   put(key, clazz.getName());  }
protected void removeSource (JComponent comp)     {         if (_sourceComp == comp) {             // reset cursors             clearComponentCursor();             _topComp.setCursor(_topCursor);             reset();         }         _draggers.remove(comp);         comp.removeMouseListener(_sourceListener);         comp.removeMouseMotionListener(_sourceListener);     }
public static Configuration getConfFromState(State state, Optional<String> encryptedPath) {     Config config = ConfigFactory.parseProperties(state.getProperties());     if (encryptedPath.isPresent()) {       config = ConfigUtils.resolveEncrypted(config, encryptedPath);     }     Configuration conf = newConfiguration();      for (Entry<String, ConfigValue> entry : config.entrySet()) {       conf.set(entry.getKey(), entry.getValue().unwrapped().toString());     }     return conf;   }
public void create() {     GeneticConfiguration cfg =       new GeneticConfiguration(config, mutation_rate, recombination_rate,                                evolve_comparators);     population = new ArrayList(size);     int ix = 0;     for (; ix < copies_of_original; ix++)       population.add(cfg.makeCopy());     for (; ix < size; ix++)       population.add(cfg.makeRandomCopy());   }    /**    * Returns all configurations in the current generation.    */   public List<GeneticConfiguration> getConfigs() {     return population;   }    public void setNewGeneration(List<GeneticConfiguration> nextgen) {     this.population = nextgen;   }    /**    * Sorts the population by their achieved F-numbers.    */   public void sort() {     Collections.sort(population);     for (int ix = 0; ix < population.size(); ix++)       population.get(ix).setRank(ix + 1);   }    /**    * Returns the best configuration.    */   public GeneticConfiguration getBestConfiguration() {     return population.get(0);   }    /**    * Returns the worst configuration.    */   public GeneticConfiguration getWorstConfiguration() {     return population.get(population.size() - 1);   }    /**    * Returns a random configuration.    */   public GeneticConfiguration pickRandomConfig() {     return population.get((int) Math.random() * population.size());   }    /**    * Runs a tournament among k individuals to find the most fit    * individual.    */   public GeneticConfiguration runTournament(int k) {     GeneticConfiguration best = pickRandomConfig();     for (int ix = 1; ix < k; ix++) {       GeneticConfiguration candidate = pickRandomConfig();       if (candidate.getFNumber() > best.getFNumber())         best = candidate;     }     return best;   }    /**    * Sets the size of the population.    */   public void setSize(int size) {     this.size = size;   }    public void setMutationRate(int mutation_rate) {     this.mutation_rate = mutation_rate;   }    public void setRecombinationRate(double recombination_rate) {     this.recombination_rate = recombination_rate;   }    public void setEvolveComparators(boolean evolve_comparators) {     this.evolve_comparators = evolve_comparators;   }    public void setCopiesOfOriginal(int copies) {     this.copies_of_original = copies;   }    /**    * Returns the size of the population.    */   public int size() {     return size;   } }
@Override  public CommerceVirtualOrderItem fetchByPrimaryKey(Serializable primaryKey) {   Serializable serializable = entityCache.getResult(CommerceVirtualOrderItemModelImpl.ENTITY_CACHE_ENABLED,     CommerceVirtualOrderItemImpl.class, primaryKey);    if (serializable == nullModel) {    return null;   }    CommerceVirtualOrderItem commerceVirtualOrderItem = (CommerceVirtualOrderItem)serializable;    if (commerceVirtualOrderItem == null) {    Session session = null;     try {     session = openSession();      commerceVirtualOrderItem = (CommerceVirtualOrderItem)session.get(CommerceVirtualOrderItemImpl.class,       primaryKey);      if (commerceVirtualOrderItem != null) {      cacheResult(commerceVirtualOrderItem);     }     else {      entityCache.putResult(CommerceVirtualOrderItemModelImpl.ENTITY_CACHE_ENABLED,       CommerceVirtualOrderItemImpl.class, primaryKey,       nullModel);     }    }    catch (Exception e) {     entityCache.removeResult(CommerceVirtualOrderItemModelImpl.ENTITY_CACHE_ENABLED,      CommerceVirtualOrderItemImpl.class, primaryKey);      throw processException(e);    }    finally {     closeSession(session);    }   }    return commerceVirtualOrderItem;  }
public List<U> getAll(final boolean readFromSession) {         final LinkedHashMap<String, U> profiles = retrieveAll(readFromSession);         return ProfileHelper.flatIntoAProfileList(profiles);     }
public void marshall(DescribeEventSubscriptionsRequest describeEventSubscriptionsRequest, ProtocolMarshaller protocolMarshaller) {          if (describeEventSubscriptionsRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(describeEventSubscriptionsRequest.getSubscriptionName(), SUBSCRIPTIONNAME_BINDING);             protocolMarshaller.marshall(describeEventSubscriptionsRequest.getFilters(), FILTERS_BINDING);             protocolMarshaller.marshall(describeEventSubscriptionsRequest.getMaxRecords(), MAXRECORDS_BINDING);             protocolMarshaller.marshall(describeEventSubscriptionsRequest.getMarker(), MARKER_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public static double skewnessSE(FlatDataCollection flatDataCollection) {      int n = count(flatDataCollection);         if(n<=2) {             throw new IllegalArgumentException(""The provided collection must have more than 2 elements."");         }                  double skewnessSE=Math.sqrt((6.0*n*(n-1.0))/((n-2.0)*(n+1.0)*(n+3.0)));                  return skewnessSE;     }
public void registerTaskConfig(String taskName, TedProcessorFactory tedProcessorFactory, TedRetryScheduler retryScheduler) {   tedDriverImpl.registerTaskConfig(taskName, tedProcessorFactory, null, retryScheduler, null);  }
public Cell<C,T> width (Value<C,T> width) {    minWidth = width;    prefWidth = width;    maxWidth = width;    return this;   }
public ArrayList<String> getFeatures() {    if (isFinalState())     return null;    ArrayList<String> featurelist = new ArrayList<String>();      int rightFocus = leftFocus + 1;    //  ISparseVector vec = new HashSparseVector();   //所有的联合feature    featurelist.add(combinedFeature(""+0+1"", POS, new int[]{0, 1}));   featurelist.add(combinedFeature(""-1+0+1"", POS, new int[]{-1, 0, 1}));   featurelist.add(combinedFeature(""+0+1+2"", POS, new int[]{0, 1, 2}));   featurelist.add(combinedFeature(""+1+2+3"", POS, new int[]{1, 2, 3}));   featurelist.add(combinedFeature(""-2+3+4"", POS, new int[]{2, 3, 4}));   featurelist.add(combinedFeature(""+0+1"", LEX, new int[]{0, 1}));   featurelist.add(combinedFeature(""-1+0+1"", LEX, new int[]{-1, 0, 1}));   featurelist.add(combinedFeature(""+0+1+2"", LEX, new int[]{0, 1, 2}));     // 设定上下文窗口大小    int l = 2;    int r = 4;    for (int i = 0; i <= l; i++) {     // 特征前缀     String posFeature = ""-"" + String.valueOf(i) + POS;     String lexFeature = ""-"" + String.valueOf(i) + LEX;       String lcLexFeature = ""-"" + String.valueOf(i)       + CH_L_LEX;     String lcPosFeature = ""-"" + String.valueOf(i)       + CH_L_POS;     String rcLexFeature = ""-"" + String.valueOf(i)       + CH_R_LEX;     String rcPosFeature = ""-"" + String.valueOf(i)       + CH_R_POS;    String lcDepFeature = ""-"" + String.valueOf(i)      + CH_L_DEP;       String rcDepFeature = ""-"" + String.valueOf(i)      + CH_R_DEP;       if (leftFocus - i < 0) {      featurelist.add(lexFeature + START + String.valueOf(i - leftFocus));      featurelist.add(posFeature + START + String.valueOf(i - leftFocus));     } else {      featurelist.add(lexFeature + sent.words[trees.get(leftFocus - i).id]);      featurelist.add(posFeature + sent.tags[trees.get(leftFocus - i).id]);        if (trees.get(leftFocus - i).leftChilds.size() != 0) {       for (int j = 0; j < trees.get(leftFocus - i).leftChilds         .size(); j++) {        int leftChildIndex = trees.get(leftFocus - i).leftChilds          .get(j).id;        featurelist.add(lcLexFeature          + sent.words[leftChildIndex]);        featurelist.add(lcPosFeature          + sent.tags[leftChildIndex]);       featurelist.add(lcDepFeature         + sent.getDepClass(leftChildIndex));       }      }else{       featurelist.add(lcLexFeature + NULL);       featurelist.add(lcPosFeature + NULL);      }        if (trees.get(leftFocus - i).rightChilds.size() != 0) {       for (int j = 0; j < trees.get(leftFocus - i).rightChilds         .size(); j++) {        int rightChildIndex = trees.get(leftFocus - i).rightChilds          .get(j).id;        featurelist.add(rcLexFeature          + sent.words[rightChildIndex]);        featurelist.add(rcPosFeature          + sent.tags[rightChildIndex]);       featurelist.add(rcDepFeature         + sent.getDepClass(rightChildIndex));       }      }else{       featurelist.add(rcLexFeature + NULL);       featurelist.add(rcPosFeature + NULL);      }     }    }      for (int i = 0; i <= r; i++) {     String posFeature = ""+"" + String.valueOf(i) + POS;     String lexFeature = ""+"" + String.valueOf(i) + LEX;       String lcLexFeature = ""+"" + String.valueOf(i)       + CH_L_LEX;     String rcLexFeature = ""+"" + String.valueOf(i)       + CH_R_LEX;     String lcPosFeature = ""+"" + String.valueOf(i)       + CH_L_POS;        String rcPosFeature = ""+"" + String.valueOf(i)       + CH_R_POS;     String lcDepFeature = ""+"" + String.valueOf(i)       + CH_L_DEP;        String rcDepFeature = ""+"" + String.valueOf(i)       + CH_R_DEP;       if (rightFocus + i >= trees.size()) {      featurelist.add(lexFeature+ END+ String.valueOf(rightFocus + i- trees.size() + 3));      featurelist.add(posFeature+ END+ String.valueOf(rightFocus + i- trees.size() + 3));     } else {      featurelist.add(lexFeature+ sent.words[trees.get(rightFocus + i).id]);      featurelist.add(posFeature+ sent.tags[trees.get(rightFocus + i).id]);        if (trees.get(rightFocus + i).leftChilds.size() != 0) {       for (int j = 0; j < trees.get(rightFocus + i).leftChilds         .size(); j++) {        int leftChildIndex = trees.get(rightFocus + i).leftChilds          .get(j).id;        featurelist.add(lcLexFeature+ sent.words[leftChildIndex]);        featurelist.add(lcPosFeature+ sent.tags[leftChildIndex]);        featurelist.add(lcDepFeature+ sent.getDepClass(leftChildIndex));       }      }else{       featurelist.add(lcLexFeature + NULL);       featurelist.add(lcPosFeature + NULL);      }        if (trees.get(rightFocus + i).rightChilds.size() != 0) {       for (int j = 0; j < trees.get(rightFocus + i).rightChilds         .size(); j++) {        int rightChildIndex = trees.get(rightFocus + i).rightChilds          .get(j).id;        featurelist.add(rcLexFeature+ sent.words[rightChildIndex]);        featurelist.add(rcPosFeature+ sent.tags[rightChildIndex]);        featurelist.add(rcDepFeature+ sent.getDepClass(rightChildIndex));       }      }else{       featurelist.add(rcLexFeature + NULL);       featurelist.add(rcPosFeature + NULL);      }     }    }            return featurelist;   }
public JavaScriptResourceReference[] getJavaScriptResourceReferences() {         final List<JavaScriptResourceReference> resources = new ArrayList<JavaScriptResourceReference>();          for (final String resource : jsResources) {             if (!resource.startsWith(""//"") && resource.startsWith(""http"")) {                 resources.add(new JavaScriptResourceReference(getResourcesRootClass(), resource));             }         }         return resources.toArray(new JavaScriptResourceReference[resources.size()]);     }
private void initialize() {          this.setLayout(new GridBagLayout());          if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {              this.setSize(375, 204);          }          this.setName(Constant.messages.getString(""pscan.options.policy.title""));       JPanel passiveScannersFilterPanel = new TableFilterPanel<JXTable>(getTableTest());                    // 'Apply to' controls          JPanel applyToPanel = new JPanel();          applyToPanel.setLayout(new GridBagLayout());          applyToPanel.add(new JLabel(Constant.messages.getString(""pscan.options.policy.apply.label"")),             LayoutHelper.getGBC(0, 0, 1, 0.0, new Insets(2, 2, 2, 2)));          applyToPanel.add(getApplyToThreshold(), LayoutHelper.getGBC(1, 0, 1, 0.0));          applyToPanel.add(new JLabel(Constant.messages.getString(""pscan.options.policy.thresholdTo.label"")),             LayoutHelper.getGBC(2, 0, 1, 0.0, new Insets(2, 2, 2, 2)));          applyToPanel.add(getApplyToThresholdTarget(), LayoutHelper.getGBC(3, 0, 1, 0.0));          applyToPanel.add(new JLabel(Constant.messages.getString(""pscan.options.policy.rules.label"")), LayoutHelper.getGBC(4, 0, 1, 0.0, new Insets(2, 2, 2, 2)));          JButton applyThresholdButton = new JButton(Constant.messages.getString(""pscan.options.policy.go.button""));          applyThresholdButton.addActionListener(new ActionListener() {     @Override     public void actionPerformed(ActionEvent e) {      applyThreshold (strToThreshold((String)getApplyToThreshold().getSelectedItem()),        (String)getApplyToThresholdTarget().getSelectedItem());      getPassiveScanTableModel().fireTableDataChanged();           }});          applyToPanel.add(applyThresholdButton, LayoutHelper.getGBC(5, 0, 1, 0.0));          applyToPanel.add(new JLabel(""""), LayoutHelper.getGBC(6, 0, 1, 1.0)); // Spacer                              this.add(applyToPanel,                  LayoutHelper.getGBC(0, 0, 3, 0.0D, 0.0D, GridBagConstraints.BOTH, new Insets(0, 0, 0, 0)));            this.add(passiveScannersFilterPanel,LayoutHelper.getGBC(0, 1, 1, 1.0D, 0.0D,                          GridBagConstraints.BOTH, GridBagConstraints.NORTHWEST, new Insets(0, 0, 0, 0)));            this.add(getJScrollPane(),             LayoutHelper.getGBC(0, 2, 1, 1.0, 1.0,              GridBagConstraints.BOTH, GridBagConstraints.NORTHWEST, new Insets(0, 0, 0, 0)));      }
private void verifyPathIsOEX(File path) {     checkNotNull(path);     checkArgument(path.exists(), ""%s does not exist"", path.getAbsolutePath());     checkArgument(!path.isDirectory(), ""%s is a directory"", path.getAbsolutePath());     checkArgument(path.getName().endsWith("".oex""), ""%s does not end with .oex"", path.getName());   }
@Override     public void removedBundle(Bundle bundle, BundleEvent event, List<I18nExtension> list) {         String current = Long.toString(System.currentTimeMillis());         for (I18nExtension extension : list) {             synchronized (this) {                 extensions.remove(extension);                 etags.put(extension.locale(), current);             }         }         LOGGER.info(""Bundle {} ({}) does not offer the {} resource bundle(s) anymore"",                 bundle.getSymbolicName(), bundle.getBundleId(), list.size());     }
private static byte[] toByteArray(InputStream is) throws IOException {     try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {       byte[] buffer = new byte[0x2000];       for (int len; (len = is.read(buffer)) != -1; )         os.write(buffer, 0, len);       return os.toByteArray();     }   }
private String insertFormats(final String pattern, final ArrayList<String> customPatterns) {         if (!containsElements(customPatterns)) {             return pattern;         }         final StringBuilder sb = new StringBuilder(pattern.length() * 2);         final ParsePosition pos = new ParsePosition(0);         int fe = -1;         int depth = 0;         while (pos.getIndex() < pattern.length()) {             final char c = pattern.charAt(pos.getIndex());             switch (c) {             case QUOTE:                 appendQuotedString(pattern, pos, sb);                 break;             case START_FE:                 depth++;                 sb.append(START_FE).append(readArgumentIndex(pattern, next(pos)));                 // do not look for custom patterns when they are embedded, e.g. in a choice                 if (depth == 1) {                     fe++;                     final String customPattern = customPatterns.get(fe);                     if (customPattern != null) {                         sb.append(START_FMT).append(customPattern);                     }                 }                 break;             case END_FE:                 depth--;                 //$FALL-THROUGH$             default:                 sb.append(c);                 next(pos);             }         }         return sb.toString();     }
private void setListEnabled(CmsList<? extends I_CmsListItem> list, boolean enabled, String disabledReason) {            for (Widget child : list) {              CmsTreeItem treeItem = (CmsTreeItem)child;              if (enabled) {                  treeItem.getCheckBox().enable();              } else {                  treeItem.getCheckBox().disable(disabledReason);              }              setListEnabled(treeItem.getChildren(), enabled, disabledReason);          }      }
public static String getVersion()     {          URL versionFile = SnappyLoader.class                 .getResource(""/META-INF/maven/org.xerial.snappy/snappy-java/pom.properties"");         if (versionFile == null) {             versionFile = SnappyLoader.class.getResource(""/org/xerial/snappy/VERSION"");         }          String version = ""unknown"";         try {             if (versionFile != null) {                 Properties versionData = new Properties();                 versionData.load(versionFile.openStream());                 version = versionData.getProperty(""version"", version);                 if (version.equals(""unknown"")) {                     version = versionData.getProperty(""SNAPPY_VERSION"", version);                 }                 version = version.trim().replaceAll(""[^0-9M\\.]"", """");             }         }         catch (IOException e) {             System.err.println(e);         }         return version;     }
public JBBPDslBuilder LongArray(final String name, final String sizeExpression) {     final Item item = new Item(BinType.LONG_ARRAY, name, this.byteOrder);     item.sizeExpression = assertExpressionChars(sizeExpression);     this.addItem(item);     return this;   }
private String getOtherGroup(Tile tile, Tile neighbor)      {          final String group = mapGroup.getGroup(tile);          for (final Tile shared : getSharedNeigbors(tile, neighbor))          {              final String sharedNeighborGroup = mapGroup.getGroup(shared);              if (!group.equals(sharedNeighborGroup) && !isTransition(shared))              {                  return sharedNeighborGroup;              }          }          return null;      }
public static <T> List<T> withEagerDefault(List<T> self, Closure init) {         return ListWithDefault.newInstance(self, false, init);     }
private void validateSubject(final Resource subject) {         final String subjectURI = subject.getURI();         // blank nodes are okay         if (!subject.isAnon()) {             // hash URIs with the same base as the topic are okay             final int hashIndex = subjectURI.lastIndexOf(""#"");             if (!(hashIndex > 0 && topic.getURI().equals(subjectURI.substring(0, hashIndex)))) {                 // the topic itself is okay                 if (!topic.equals(subject.asNode())) {                     // it's a bad subject, but it could still be in-domain                     if (idTranslator.inDomain(subject)) {                         LOGGER.error(""{} is not in the topic of this RDF, which is {}."", subject, topic);                         throw new IncorrectTripleSubjectException(subject +                                 "" is not in the topic of this RDF, which is "" + topic);                     }                     // it's not even in the right domain!                     LOGGER.error(""subject ({}) is not in repository domain."", subject);                     throw new OutOfDomainSubjectException(subject.asNode());                 }             }         }     }
@Override  public void mouseMoveOut() throws WidgetException {   try {          // TODO: Need to figure out whether 10 is sufficient          int offsetAmount = 10;           WebElement elem = getWebElement();          Dimension dim = elem.getSize();          int width = dim.getWidth();          Actions builder = new Actions(getGUIDriver().getWrappedDriver());          synchronized (InteractiveElement.class) {              getGUIDriver().focus();              builder.moveToElement(getWebElement(), width + offsetAmount, 0).build().perform();          }   } catch (Exception e) {    throw new WidgetException(""Error while performing mouse move out"",      getByLocator(), e);   }  }
public Object initModelIF(EventModel em, ModelForm form, HttpServletRequest request) throws Exception {    Object result = null;    try {     HandlerMetaDef hm = this.modelMapping.getHandlerMetaDef();     String serviceName = hm.getServiceRef();     Debug.logVerbose(""[JdonFramework] construct the CRUD method for the service:"" + serviceName, module);     MethodMetaArgs methodMetaArgs = maFactory.createinitMethod(hm, em);     RequestWrapper requestW = new HttpServletRequestWrapper(request);     Service service = serviceFacade.getService(requestW.getContextHolder().getAppContextHolder());     if (methodMetaArgs != null)      result = service.execute(serviceName, methodMetaArgs, requestW);    } catch (Exception e) {     Debug.logError(""[JdonFramework] initModel error: "" + e, module);     throw new Exception(e);    }    return result;   }
protected void updateLastCRLFInfo(int index, int pos, boolean isCR) {         this.lastCRLFBufferIndex = index;         this.lastCRLFPosition = pos;         this.lastCRLFisCR = isCR;     }
@Override     public void closeConnection(Conversation conversation) {         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())             SibTr.entry(this, tc, ""closeConnection"");          try {             conversation.close();         } catch (SIException e) {             FFDCFilter.processException(e,                                         CLASS_NAME + "".rejectHandshake"",                                         CommsConstants.SERVERTRANSPORTRECEIVELISTENER_CLOSECONN_01,                                         this);              if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())                 SibTr.debug(this, tc, ""Unable to close the conversation"", e);         }          if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())             SibTr.exit(this, tc, ""closeConnection"");     }
public java.util.List<String> getTagsToRemove() {         if (tagsToRemove == null) {             tagsToRemove = new com.amazonaws.internal.SdkInternalList<String>();         }         return tagsToRemove;     }
public void setSize(DBIDRef id, int size) {     if(csize == null) {       csize = DataStoreUtil.makeIntegerStorage(ids, DataStoreFactory.HINT_HOT | DataStoreFactory.HINT_TEMP, 1);     }     csize.putInt(id, size);   }
private IRingSet getRingSystemOfAtom(List ringSystems, IAtom ringAtom) {         IRingSet ringSet = null;         for (int f = 0; f < ringSystems.size(); f++) {             ringSet = (IRingSet) ringSystems.get(f);             if (ringSet.contains(ringAtom)) {                 return ringSet;             }         }         return null;     }
@Override   public void eUnset(int featureID)   {     switch (featureID)     {       case SimpleExpressionsPackage.NUMBER_LITERAL__VALUE:         setValue(VALUE_EDEFAULT);         return;     }     super.eUnset(featureID);   }
static boolean doRetry(FrameworkMethod method, Throwable thrown, AtomicInteger retryCounter) {          boolean doRetry = false;          if ((retryCounter.decrementAndGet() > -1) && isRetriable(method, thrown)) {              LOGGER.warn(""### RETRY ### {}"", method);              doRetry = true;          }          return doRetry;      }
protected void registerCommandHandlers ()     {         MessageBundle msg = _ctx.getMessageManager().getBundle(_bundle);         registerCommandHandler(msg, ""help"", new HelpHandler());         registerCommandHandler(msg, ""clear"", new ClearHandler());         registerCommandHandler(msg, ""speak"", new SpeakHandler());         registerCommandHandler(msg, ""emote"", new EmoteHandler());         registerCommandHandler(msg, ""think"", new ThinkHandler());         registerCommandHandler(msg, ""tell"", new TellHandler());         registerCommandHandler(msg, ""broadcast"", new BroadcastHandler());     }
public void abortDataTransfers() {         while(!dataConnections.isEmpty()) {             Socket socket = dataConnections.poll();             if(socket != null) Utils.closeQuietly(socket);         }     }
@GuardedBy(""lock"")   private void stopIfNecessary() {     if (!(goAwayStatus != null && streams.isEmpty() && pendingStreams.isEmpty())) {       return;     }     if (stopped) {       return;     }     stopped = true;      if (keepAliveManager != null) {       keepAliveManager.onTransportTermination();       // KeepAliveManager should stop using the scheduler after onTransportTermination gets called.       scheduler = SharedResourceHolder.release(TIMER_SERVICE, scheduler);     }      if (ping != null) {       ping.failed(getPingFailure());       ping = null;     }      if (!goAwaySent) {       // Send GOAWAY with lastGoodStreamId of 0, since we don't expect any server-initiated       // streams. The GOAWAY is part of graceful shutdown.       goAwaySent = true;       frameWriter.goAway(0, ErrorCode.NO_ERROR, new byte[0]);     }      // We will close the underlying socket in the writing thread to break out the reader     // thread, which will close the frameReader and notify the listener.     frameWriter.close();   }
public void setScheduledActionNames(java.util.Collection<String> scheduledActionNames) {         if (scheduledActionNames == null) {             this.scheduledActionNames = null;             return;         }          this.scheduledActionNames = new java.util.ArrayList<String>(scheduledActionNames);     }
public void setTextWithoutAnimation(CharSequence text, TextView.BufferType type) {         mSkipAnimation = true;         mEditText.setText(text, type);     }
public long getPermits(long requestedPermits, long minPermits, long timeoutMillis) {     PermitsAndDelay permitsAndDelay = getPermitsAndDelay(requestedPermits, minPermits, timeoutMillis);     if (permitsAndDelay.delay > 0) {       try {         Thread.sleep(permitsAndDelay.delay);       } catch (InterruptedException ie) {         return 0;       }     }     return permitsAndDelay.permits;   }
public static Between betweenExclusiveMax( String property, int minimum, int maximum)     {     return new Between( notLessThan( property, minimum), lessThan( property, maximum));     }
private void V(StringBuilder buf) {      Token t = getNextToken();     if (t.tokenType != TokenType.VALUE) {       throw new IllegalStateException(""Unexpected token "" + t);     }     buf.append(t.getValue());      t = getNextToken();     if (t.tokenType == TokenType.EOL) {       return;     } else if (t.tokenType == TokenType.TRAILING_BACKSLASH) {       Vopt(buf);      }   }
public void pullUpTo(Phase phase)  {   // get      if (!phase.contains(GET))   {    return;   }      T targetValue = target.getValue();      // validate-post-get      if (!phase.contains(VALIDATE_POST_GET))   {    return;   }      Collection<V> oldViolations = new ArrayList<V>(violations);   violations.clear();    if (validate(targetValidator, targetValue) && phase.contains(CONVERT))   {    // convert        boolean converted = true;    S sourceValue = null;        try    {     sourceValue = converter.unconvert(targetValue);    }    // TODO: catch all other exceptions and terminate too?    catch (UnsupportedOperationException exception)    {     converted = false;    }        // validate-pre-set       if (converted && phase.contains(VALIDATE_PRE_SET) && validate(sourceValidator, sourceValue)     && phase.contains(SET))    {     // set          source.setValue(sourceValue);    }   }      support.fireValueChanged(oldViolations, new ArrayList<V>(violations));  }
@Override     public R visitMemberReference(MemberReferenceTree node, P p) {         R r = scan(node.getQualifierExpression(), p);         r = scanAndReduce(node.getTypeArguments(), p, r);         return r;     }
@SuppressWarnings(""unchecked"")   public static <T> List<T> findAll(T[] array, Filter<T> filter) {      Assert.notNull(filter, ""Filter is required"");      return stream(nullSafeArray(array)).filter(filter::accept).collect(Collectors.toList());   }
@Override     public ReturnPathTypeDataflow analyze(IAnalysisCache analysisCache, MethodDescriptor descriptor)             throws CheckedAnalysisException {         CFG cfg = getCFG(analysisCache, descriptor);         DepthFirstSearch dfs = getDepthFirstSearch(analysisCache, descriptor);         ReverseDepthFirstSearch rdfs = getReverseDepthFirstSearch(analysisCache, descriptor);         ReturnPathTypeAnalysis analysis = new ReturnPathTypeAnalysis(cfg, rdfs, dfs);         ReturnPathTypeDataflow dataflow = new ReturnPathTypeDataflow(cfg, analysis);          dataflow.execute();          return dataflow;     }
public TouchActions scroll(WebElement onElement, int xOffset, int yOffset) {     if (touchScreen != null) {       action.addAction(new ScrollAction(touchScreen, (Locatable) onElement, xOffset, yOffset));     }     return this;   }
public static RubyRange<Double> range(double start, double end) {     String startStr = String.valueOf(start);     String endStr = String.valueOf(end);     int startPrecision = startStr.length() - startStr.lastIndexOf('.') - 1;     int endPrecision = endStr.length() - endStr.lastIndexOf('.') - 1;     return new RubyRange<>(         new DoubleSuccessor(Math.max(startPrecision, endPrecision)), start, end,         Interval.CLOSED);   }
public static boolean intArrayContains(int[] array, int numToCheck) {         for (int i = 0; i < array.length; i++) {             if (array[i] == numToCheck) {                 return true;             }         }         return false;     }
private void onRecord(Record message, ActorRef self, ActorRef sender) {         if (is(inProgress)) {             // Forward to media server controller             this.recording = true;             this.msController.tell(message, sender);         }     }
protected void doTrace(HttpServletRequest req, HttpServletResponse resp)          throws ServletException, IOException     {                  int responseLength;          String CRLF = ""\r\n"";         StringBuilder buffer = new StringBuilder(""TRACE "").append(req.getRequestURI())             .append("" "").append(req.getProtocol());          Enumeration<String> reqHeaderEnum = req.getHeaderNames();          while( reqHeaderEnum.hasMoreElements() ) {             String headerName = reqHeaderEnum.nextElement();             buffer.append(CRLF).append(headerName).append("": "")                 .append(req.getHeader(headerName));         }          buffer.append(CRLF);          responseLength = buffer.length();          resp.setContentType(""message/http"");         resp.setContentLength(responseLength);         ServletOutputStream out = resp.getOutputStream();         out.print(buffer.toString());     }
private Number convert(Class<? extends Number> type, Float value) {   if (int.class.isAssignableFrom(type) || Integer.class.isAssignableFrom(type)) {    return value.intValue();   }   if (float.class.isAssignableFrom(type) || Float.class.isAssignableFrom(type)) {    return value;   }   throw new IllegalArgumentException(""Use integer or float"");  }
public String getPublicIdentifier() throws DocumentStoreException {         Misc.checkState(this.isOpen(), ""Database is closed"");         try {             return get(queue.submit(new GetPublicIdentifierCallable()));         } catch (ExecutionException e) {             logger.log(Level.SEVERE, ""Failed to get public ID"", e);             throw new DocumentStoreException(""Failed to get public ID"", e);         }     }
public Serializer writeString(String value) throws IOException {         if (null == value) return writeNull();          writer.write('""');          char[] chars = value.toCharArray();          for (int i=0; i<chars.length; i++)         {             char c = chars[i];             switch (c)             {                 case  '""': writer.write(""\\\""""); break;                 case '\\': writer.write(""\\\\""); break;                 case    0: writer.write(""\\u0000""); break;                 case '\b': writer.write(""\\b""); break;                 case '\t': writer.write(""\\t""); break;                 case '\n': writer.write(""\\n""); break;                 case '\f': writer.write(""\\f""); break;                 case '\r': writer.write(""\\r""); break;                 case '/': writer.write(""\\/""); break;                 default:                     if ((c >= 32) && (c <= 126))                     {                         writer.write(c);                     }                     else                     {                         writer.write(""\\u"");                         writer.write(rightAlignedZero(Integer.toHexString(c),4));                     }             }         }          writer.write('""');          return this;     }
protected Response buildAuthenticationResponse(final OpenIdService service,                                                    final Map<String, String> parameters,                                                    final boolean successFullAuthentication,                                                    final String id,                                                    final ParameterList parameterList) {         val response = serverManager.authResponse(parameterList, id, id, successFullAuthentication, true);         parameters.putAll(response.getParameterMap());         LOGGER.debug(""Parameters passed for the OpenID response are [{}]"", parameters.keySet());         return buildRedirect(service, parameters);     }
public void setSynchronized(boolean newSynchronized)  {   boolean oldSynchronized = synchronized_;   synchronized_ = newSynchronized;   if (eNotificationRequired())    eNotify(new ENotificationImpl(this, Notification.SET, TypesPackage.JVM_OPERATION__SYNCHRONIZED, oldSynchronized, synchronized_));  }
public String[] segmenterExceptions(final String[] lines) {     final List<String> sentences = new ArrayList<>();     for (final String line : lines) {       final String segmentedLine = segmenterNonBreaker(line);       final String[] lineSentences = segmentedLine.split(""\n"");       for (final String lineSentence : lineSentences) {         sentences.add(lineSentence);       }     }     return sentences.toArray(new String[sentences.size()]);   }
@Nonnull   public static GenericodeWriter <com.helger.genericode.v04.CodeListDocument> gc04CodeList ()   {     return new GenericodeWriter<> (EGenericodeDocumentType.GC04_CODE_LIST);   }
private void setupUI(final String labelText) {   WButton dupBtn = new WButton(""Duplicate"");   dupBtn.setAction(new DuplicateAction());    WButton clrBtn = new WButton(""Clear"");   clrBtn.setAction(new ClearAction());    add(new WLabel(labelText, textFld));   add(textFld);   add(dupBtn);   add(clrBtn);   add(new WAjaxControl(dupBtn, this));   add(new WAjaxControl(clrBtn, this));  }
public static Intent newSmsIntent(Context context, String body, String phoneNumber) {         return newSmsIntent(context, body, new String[]{phoneNumber});     }
public static boolean cs_lsolve(DZcs L, DZcsa x)   {    int p, j, n, Lp[], Li[] ;    DZcsa Lx = new DZcsa() ;    if (!CS_CSC (L) || x == null) return (false); /* check inputs */    n = L.n ; Lp = L.p ; Li = L.i ; Lx.x = L.x ;    for (j = 0 ; j < n ; j++)    {     x.set(j, cs_cdiv(x.get(j), Lx.get(Lp [j]))) ;     for (p = Lp [j]+1 ; p < Lp [j+1] ; p++)     {      x.set(Li [p], cs_cminus(x.get(Li [p]), cs_cmult(Lx.get(p), x.get(j)))) ;     }    }    return (true) ;   }
private static <E> List<E> toList(Iterable<E> iterable)  {   List<E> list = new ArrayList<>();   iterable.forEach(list::add);   return list;  }
public static Map<String, String> transformMap(final Map<String, Object> paramMap) {         final Map<String, String> paramStrMap = new LinkedHashMap<String, String>();         for (final Map.Entry<String, Object> entry : paramMap.entrySet()) {             paramStrMap.put(entry.getKey(), entry.getValue().toString());         }          return paramStrMap;     }
public static int daysBetween(int year1, int month1, int day1, int year2, int month2, int day2) {   return fixedFromGregorian(year1, month1, day1) - fixedFromGregorian(year2, month2, day2);  }
private Class<?> loadGeneratedClass(ClassLoader classLoader,                                         String className,                                         NameUtil nameUtil) throws ClassNotFoundException {         if (className == null)             return null;          final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();         Class<?> loadedClass = null;         String loadClassName = className;          // Exception to throw if we can not load the class and we can not         // determine name of generated class. Not thrown if this method is         // able to return the loaded Class object.         ClassNotFoundException primaryException = new ClassNotFoundException(className); // F743-1752.1          // -----------------------------------------------------------------------         // First, try and load the class using the class name as specified.         //         // This is different than previous releases, where the hash suffix         // was first added for EJB 1.1 classes.  Instead, the hash suffix         // is being added automatically by NameUtil for EJB 1.1 class names,         // so it doesn't need to be done here any more.         // -----------------------------------------------------------------------         if (isTraceOn && tc.isDebugEnabled())             Tr.debug(tc, ""loadGeneratedClass: Loading class = "" + loadClassName);          try {             loadedClass = classLoader.loadClass(loadClassName);         } catch (ClassNotFoundException cnfe) {             // Do not FFDC log this, as this is a normal exception when the             // class was generated with an older version of EJBDeploy             // FFDCFilter.processException(ex, CLASS_NAME + "".loadGeneratedClass"", ""4458"");             primaryException = cnfe;             if (isTraceOn && tc.isDebugEnabled())                 Tr.debug(tc, ""loadGeneratedClass: load failed: "" + cnfe);         }          // -----------------------------------------------------------------------         // Second, try and load the class using the modified BuzzHash suffix.         //         // For performance, the call to NameUtil to get the modified hash suffix         // will change the state of the NameUtil instance so that subsequent         // names obtained for this EJB will use the modified suffix... and the         // subsequent classes will be loaded by the first attempt above,         // reducing the number of ClassNotFoundExceptions.         // -----------------------------------------------------------------------         if (loadedClass == null) {             loadClassName = nameUtil.updateFilenameHashCode(loadClassName);             if (loadClassName != null) {                 if (isTraceOn && tc.isDebugEnabled())                     Tr.debug(tc, ""loadGeneratedClass: Loading class = "" + loadClassName);                 try {                     loadedClass = classLoader.loadClass(loadClassName);                 } catch (ClassNotFoundException cnfe) {                     // Do not FFDC log this, as this is a normal exception when the                     // class was generated with an older version of EJBDeploy                     // FFDCFilter.processException(ex, CLASS_NAME + "".loadGeneratedClass"", ""378"");                     primaryException = cnfe; // F743-1752.1                     if (isTraceOn && tc.isDebugEnabled())                         Tr.debug(tc, ""loadGeneratedClass: load failed: "" + cnfe);                 }             }         }          // -----------------------------------------------------------------------         // Third, try and load the class using the EJB 1.1 original class name         // (i.e. contained no hashcode suffix). The updated name will be null         // for EJB 2.0 and later module levels.         //         // For performance, the call to NameUtil to remove the hash suffix         // will change the state of the NameUtil instance so that subsequent         // names obtained for this EJB will contain no suffix... and the         // subsequent classes will be loaded by the first attempt above,         // reducing the number of ClassNotFoundExceptions.         // -----------------------------------------------------------------------         if (loadedClass == null) {             loadClassName = nameUtil.updateFilenameHashCode(loadClassName);             if (loadClassName != null) {                 if (isTraceOn && tc.isDebugEnabled())                     Tr.debug(tc, ""loadGeneratedClass: Loading class = "" + loadClassName);                 try {                     loadedClass = classLoader.loadClass(loadClassName);                 } catch (ClassNotFoundException cnfe) {                     // Do not FFDC log this, as it will be logged by the caller                     // FFDCFilter.processException(ex, CLASS_NAME + "".loadGeneratedClass"", ""4520"");                     primaryException = cnfe; // F743-1752.1                     if (isTraceOn && tc.isDebugEnabled())                         Tr.debug(tc, ""loadGeneratedClass: load failed: "" + cnfe);                 }             }         }          // -----------------------------------------------------------------------         // Finally, insure an exception is thrown if none of the class load         // attempts were successful.         // -----------------------------------------------------------------------         if (loadedClass == null) {             if (isTraceOn && tc.isDebugEnabled())                 Tr.debug(tc, ""loadGeneratedClass: all attempts failed: "" + primaryException);              throw primaryException;         }          return loadedClass;      }
protected <T extends Persistable, ID extends Serializable> SimpleEbeanRepository<T, ID> getTargetRepository(              RepositoryInformation information, EbeanServer ebeanServer) {            return getTargetRepositoryViaReflection(information, information.getDomainType(), ebeanServer);      }
public void init(EvaluatePP inst, long nrf)  {   instance = inst;   act = new long[(int) nrf];   fin = new long[(int) nrf];   req = new long[(int) nrf];   active = new long[(int) nrf];   waiting = new long[(int) nrf];  }
@Override     public QAnd prepare(final AbstractTypeQuery _query,                         final AbstractQPart _part)         throws EFapsException     {         for (final AbstractQPart part : this.parts) {             part.prepare(_query, this);         }         return this;     }
public static void deleteCommerceNotificationQueueEntry(   long commerceNotificationQueueEntryId)   throws com.liferay.portal.kernel.exception.PortalException {   getService()    .deleteCommerceNotificationQueueEntry(commerceNotificationQueueEntryId);  }
public void info(Marker marker, String msg) {         if (!logger.isInfoEnabled(marker))             return;         if (instanceofLAL) {             ((LocationAwareLogger) logger).log(marker, fqcn, LocationAwareLogger.INFO_INT, msg, null, null);         } else {             logger.info(marker, msg);         }     }
public static String escapeForXML(String source) {         Args.nullNotPermitted(source, ""source"");         StringBuilder sb = new StringBuilder();         for (int i = 0; i < source.length(); i++) {             char c = source.charAt(i);             switch (c) {                 case '<' : {                     sb.append(""&lt;"");                     break;                 }                  case '>' : {                     sb.append(""&gt;"");                     break;                 }                  case '&' : {                     String next = source.substring(i, Math.min(i + 6,                              source.length()));                     if (next.startsWith(""&lt;"") || next.startsWith(""&gt;"")                              || next.startsWith(""&amp;"")                              || next.startsWith(""&apos;"")                             || next.startsWith(""&quot;"")) {                         sb.append(c);                      } else {                         sb.append(""&amp;"");                     }                     break;                 }                  case '\'' : {                     sb.append(""&apos;"");                     break;                 }                  case '\""' : {                     sb.append(""&quot;"");                     break;                 }                  default : sb.append(c);             }         }         return sb.toString();     }
@Override     public String getValue(ParsedCommandLine args, boolean required) throws CommandFormatException {         if(!required) {             return null;         }         if(isPresent(args)) {             return null;         }         throw new CommandFormatException(""Required argument '"" + fullName + ""' is missing value."");     }
private void flushBuffer() {     if (vertIndex == 0) {     return;    }    if (currentType == NONE) {     return;    }        if (vertIndex < TOLERANCE) {     GL11.glBegin(currentType);     for (int i=0;i<vertIndex;i++) {      GL11.glColor4f(cols[(i*4)+0], cols[(i*4)+1], cols[(i*4)+2], cols[(i*4)+3]);      GL11.glTexCoord2f(texs[(i*2)+0], texs[(i*2)+1]);      GL11.glVertex3f(verts[(i*3)+0], verts[(i*3)+1], verts[(i*3)+2]);     }     GL11.glEnd();     currentType = NONE;     return;    }    vertices.clear();    colors.clear();    textures.clear();        vertices.put(verts,0,vertIndex*3);    colors.put(cols,0,vertIndex*4);    textures.put(texs,0,vertIndex*2);        vertices.flip();     colors.flip();     textures.flip();         GL11.glVertexPointer(3,0,vertices);         GL11.glColorPointer(4,0,colors);         GL11.glTexCoordPointer(2,0,textures);             GL11.glDrawArrays(currentType, 0, vertIndex);    currentType = NONE;   }
public FrustumIntersection set(Matrix4fc m, boolean allowTestSpheres) {         float invl;         nxX = m.m03() + m.m00(); nxY = m.m13() + m.m10(); nxZ = m.m23() + m.m20(); nxW = m.m33() + m.m30();         if (allowTestSpheres) {             invl = (float) (1.0 / Math.sqrt(nxX * nxX + nxY * nxY + nxZ * nxZ));             nxX *= invl; nxY *= invl; nxZ *= invl; nxW *= invl;         }         planes[0].set(nxX, nxY, nxZ, nxW);         pxX = m.m03() - m.m00(); pxY = m.m13() - m.m10(); pxZ = m.m23() - m.m20(); pxW = m.m33() - m.m30();         if (allowTestSpheres) {             invl = (float) (1.0 / Math.sqrt(pxX * pxX + pxY * pxY + pxZ * pxZ));             pxX *= invl; pxY *= invl; pxZ *= invl; pxW *= invl;         }         planes[1].set(pxX, pxY, pxZ, pxW);         nyX = m.m03() + m.m01(); nyY = m.m13() + m.m11(); nyZ = m.m23() + m.m21(); nyW = m.m33() + m.m31();         if (allowTestSpheres) {             invl = (float) (1.0 / Math.sqrt(nyX * nyX + nyY * nyY + nyZ * nyZ));             nyX *= invl; nyY *= invl; nyZ *= invl; nyW *= invl;         }         planes[2].set(nyX, nyY, nyZ, nyW);         pyX = m.m03() - m.m01(); pyY = m.m13() - m.m11(); pyZ = m.m23() - m.m21(); pyW = m.m33() - m.m31();         if (allowTestSpheres) {             invl = (float) (1.0 / Math.sqrt(pyX * pyX + pyY * pyY + pyZ * pyZ));             pyX *= invl; pyY *= invl; pyZ *= invl; pyW *= invl;         }         planes[3].set(pyX, pyY, pyZ, pyW);         nzX = m.m03() + m.m02(); nzY = m.m13() + m.m12(); nzZ = m.m23() + m.m22(); nzW = m.m33() + m.m32();         if (allowTestSpheres) {             invl = (float) (1.0 / Math.sqrt(nzX * nzX + nzY * nzY + nzZ * nzZ));             nzX *= invl; nzY *= invl; nzZ *= invl; nzW *= invl;         }         planes[4].set(nzX, nzY, nzZ, nzW);         pzX = m.m03() - m.m02(); pzY = m.m13() - m.m12(); pzZ = m.m23() - m.m22(); pzW = m.m33() - m.m32();         if (allowTestSpheres) {             invl = (float) (1.0 / Math.sqrt(pzX * pzX + pzY * pzY + pzZ * pzZ));             pzX *= invl; pzY *= invl; pzZ *= invl; pzW *= invl;         }         planes[5].set(pzX, pzY, pzZ, pzW);         return this;     }
public void decrypt(File src, File dest) throws GeneralSecurityException, IOException {   InputStream is = null;   OutputStream os = null;   try {    is = encryptor.wrapInputStream(new FileInputStream(src));    os = new FileOutputStream(dest);    copy(is, os);   } finally {    if(is != null) {     is.close();    }    if(os != null) {     os.close();    }   }  }
public final void mRIGHT_PAREN() throws RecognitionException {   try {    int _type = RIGHT_PAREN;    int _channel = DEFAULT_TOKEN_CHANNEL;    // src/main/resources/org/drools/compiler/lang/DRL5Lexer.g:242:9: ( ')' )    // src/main/resources/org/drools/compiler/lang/DRL5Lexer.g:242:11: ')'    {    match(')'); if (state.failed) return;    }     state.type = _type;    state.channel = _channel;   }   finally {    // do for sure before leaving   }  }
public static GoogleCloudStorageItemInfo createNotFound(StorageResourceId resourceId) {     checkArgument(resourceId != null, ""resourceId must not be null"");     // Bucket or StorageObject.     return new GoogleCloudStorageItemInfo(         resourceId,         /* creationTime= */ 0,         /* size= */ -1,         /* location= */ null,         /* storageClass= */ null);   }
public void open(String strKeyArea, int iOpenMode, boolean bDirection, String strFields, Object objInitialKey, Object objEndKey, byte[] byBehaviorData) throws DBException, RemoteException     {         try   {             synchronized (this.getTask())             {   // In case two tasks are calling here                 this.getMainRecord().close();          // FROM is automatic, since the remote BaseRecord is exactly the same as this one         // ORDER BY                 KeyArea keyArea =  this.getMainRecord().getKeyArea();                 if (strKeyArea != null)                 {                     this.getMainRecord().setKeyArea(strKeyArea);                     keyArea = this.getMainRecord().getKeyArea(-1);                     // This next set of code deals with a special case where the caller wants a non-key area order                     if (this.getMainRecord().getDefaultOrder() == Constants.MAIN_KEY_AREA)                         if (!keyArea.getKeyName().equals(strKeyArea))                             if (!Constants.PRIMARY_KEY.equals(strKeyArea))                     {                         BaseField field = this.getMainRecord().getField(strKeyArea);                         if (field != null)                         {                             KeyArea tempKeyStart = this.getMainRecord().makeIndex(DBConstants.NOT_UNIQUE, null);  // Add temp key                             tempKeyStart.addKeyField(field, bDirection);                             this.getMainRecord().setKeyArea(this.getMainRecord().getKeyAreaCount() - 1);                         }                     }                     keyArea.setKeyOrder(bDirection);                 }         // Open mode                 this.getMainRecord().setOpenMode(iOpenMode);         // SELECT (fields to select)                 if (strFields != null)                     this.getMainRecord().setSelected(strFields);    // Select these fields                 else                 {                     Record recordBase = this.getMainRecord().getTable().getCurrentTable().getRecord();                     int iFieldTypes = this.getFieldTypes(recordBase);                     if (iFieldTypes == BaseBuffer.PHYSICAL_FIELDS)                         this.getMainRecord().setSelected(true);   // Select these fields (otherwise leave the selection alone)                 }         // WHERE XYZ >=                 FileListener listener = null;                 listener = (FileListener)this.getMainRecord().getListener();                 while (listener != null)                 {   // Clear inited flag from all Linked behaviors                     if ((listener.getMasterSlaveFlag() & FileListener.LINKED_TO_SLAVE) != 0)                         listener.setMasterSlaveFlag(listener.getMasterSlaveFlag() & ~FileListener.INITED_IN_SLAVE);    // Clear inited flag                     listener = (FileListener)listener.getNextListener();                 }                 if (objInitialKey != null)                 {                     VectorBuffer recBuff = new VectorBuffer((Vector)objInitialKey);                     int iLastModified = -1;                     keyArea.reverseKeyBuffer(recBuff, DBConstants.FILE_KEY_AREA);                     String strLastModified = recBuff.getNextString();                     try {                         if (strLastModified != null)                             iLastModified = Integer.parseInt(strLastModified);                     } catch (NumberFormatException ex)  {                         iLastModified = -1;                     }                     this.getMainRecord().addListener(listener = new SubCurrentFilter(iLastModified, true, false));   // Use current                     listener.setMasterSlaveFlag(listener.getMasterSlaveFlag() | FileListener.INITED_IN_SLAVE | FileListener.LINKED_TO_SLAVE | FileListener.RUN_IN_SLAVE);                 }         // WHERE XYZ >=                 if (objEndKey != null)                 {                     VectorBuffer recBuff = new VectorBuffer((Vector)objEndKey);                     keyArea.reverseKeyBuffer(recBuff, DBConstants.FILE_KEY_AREA);                     int iLastModified = -1;                     String strLastModified = recBuff.getNextString();                     try {                         if (strLastModified != null)                             iLastModified = Integer.parseInt(strLastModified);                     } catch (NumberFormatException ex)  {                         iLastModified = -1;                     }                     this.getMainRecord().addListener(listener = new SubCurrentFilter(iLastModified, false, true));   // Use current                     listener.setMasterSlaveFlag(listener.getMasterSlaveFlag() | FileListener.INITED_IN_SLAVE | FileListener.LINKED_TO_SLAVE | FileListener.RUN_IN_SLAVE);                 }         // WHERE XYZ         // The following code replicates the Behaviors for the server class.         // If the listener doesn't exist, it is created and the current params are set.         // If the listener does exist, the current params are set.         // Note: There is a special section of code to see that if two behaviors with the same         // name exist, they are set separately.                 if (byBehaviorData != null)                 {                     ByteArrayInputStream baIn = new ByteArrayInputStream(byBehaviorData);                     ObjectInputStream daIn = new ObjectInputStream(baIn);                     String strBehaviorName = null;                     try   {                             strBehaviorName = daIn.readUTF();                         } catch (IOException ex)    {                             strBehaviorName = null;                         }                     while (strBehaviorName != null)                     {                         listener = (FileListener)this.getMainRecord().getListener(strBehaviorName);                         while (listener != null)                         {   // Already set up this listener, find the next one or null                             if ((listener.getMasterSlaveFlag() & FileListener.LINKED_TO_SLAVE) != 0)                                 if ((listener.getMasterSlaveFlag() & FileListener.INITED_IN_SLAVE) == 0)                                     break;      // Use this listener (Linked, but not inited)                             listener = (FileListener)listener.getListener(strBehaviorName);                         }                         if (listener == null)                         {                          listener = (FileListener)ClassServiceUtility.getClassService().makeObjectFromClassName(strBehaviorName);                         }                         else                         {                             this.getMainRecord().removeListener(listener, false);                         }                         listener.initRemoteSkel(daIn);                         this.getMainRecord().addListener(listener);                         listener.setMasterSlaveFlag(listener.getMasterSlaveFlag() | FileListener.INITED_IN_SLAVE | FileListener.LINKED_TO_SLAVE);                         try   {                             strBehaviorName = daIn.readUTF();                         } catch (IOException ex)    {                             strBehaviorName = null;                         }                     }                     daIn.close();                     baIn.close();                 }                 listener = (FileListener)this.getMainRecord().getListener();                 while (listener != null)                 {   // Remove old created behaviors (linked, but not inited)                     FileListener behaviorToRemove = listener;                     listener = (FileListener)listener.getNextListener();                     if ((behaviorToRemove.getMasterSlaveFlag() & FileListener.LINKED_TO_SLAVE) != 0)                         if ((behaviorToRemove.getMasterSlaveFlag() & FileListener.INITED_IN_SLAVE) == 0)                             this.getMainRecord().removeListener(behaviorToRemove, true);                 }         // End                 Utility.getLogger().info(""EJB Open key: "" + strKeyArea);                 this.getMainRecord().open();             }         } catch (DBException ex)    {             throw ex;         } catch (Exception ex)  {             ex.printStackTrace();             throw new DBException(ex.getMessage());         }     }
public final void setUsagePolicy(Callback<Integer, Usage> policy) {         Objects.requireNonNull(policy);         this.usagePolicy.set(policy);     }
private static Object initializeEmbedded(EmbeddedMetadata embeddedMetadata, Object target) {     try {       // If instantiation of Entity instantiated the embeddable, we will       // use the pre-initialized embedded object.       Object embeddedObject = embeddedMetadata.getReadMethod().invoke(target);       if (embeddedObject == null) {         // Otherwise, we will instantiate the embedded object, which         // could be a Builder         embeddedObject = IntrospectionUtils.instantiate(embeddedMetadata);         ConstructorMetadata constructorMetadata = embeddedMetadata.getConstructorMetadata();         if (constructorMetadata.isBuilderConstructionStrategy()) {           // Build the Builder           embeddedObject = constructorMetadata.getBuildMethodHandle().invoke(embeddedObject);         } else {           // TODO we should not be doing this?? There is no equivalent           // of this for builder pattern           embeddedMetadata.getWriteMethod().invoke(target, embeddedObject);         }       }       return embeddedObject;     } catch (Throwable t) {       throw new EntityManagerException(t);     }   }
public PathTemplate subTemplate(String varName) {     List<Segment> sub = Lists.newArrayList();     boolean inBinding = false;     for (Segment seg : segments) {       if (seg.kind() == SegmentKind.BINDING && seg.value().equals(varName)) {         inBinding = true;       } else if (inBinding) {         if (seg.kind() == SegmentKind.END_BINDING) {           return PathTemplate.create(toSyntax(sub, true), urlEncoding);         } else {           sub.add(seg);         }       }     }     throw new ValidationException(         String.format(""Variable '%s' is undefined in template '%s'"", varName, this.toRawString()));   }
public void doLogout( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {         String user = getAuthentication().getName();         securityRealm.doLogout(req, rsp);         SecurityListener.fireLoggedOut(user);     }
public Packer setContainer(final Container cont) throws IllegalAccessException {         if (container != null) {             final Packer p = (Packer) clone();             container.setLayout(p);         }         container = cont;         cont.setLayout(this);         return this;     }
public void readArray(double[] data) throws IOException {         int size = data.length;         for (int i = 0; i < size; ++i)             data[i] = getDouble();     }
public Iterable<long[]> availableCoordinates() {   List<long[]> coordinates = new ArrayList<long[]>();   for (Long r : rows.keySet()) {    Matrix m = rows.get(r);    for (long[] c : m.availableCoordinates()) {     coordinates.add(Coordinates.plus(c, new long[] { r, 0 }));    }   }   return coordinates;  }
public Actions keyDown(WebElement target, CharSequence key) {     if (isBuildingActions()) {       action.addAction(new KeyDownAction(jsonKeyboard, jsonMouse, (Locatable) target, asKeys(key)));     }     return focusInTicks(target)         .addKeyAction(key, codepoint -> tick(defaultKeyboard.createKeyDown(codepoint)));   }
@Override     public ResourceSet<Task> read(final TwilioRestClient client) {         return new ResourceSet<>(this, client, firstPage(client));     }
public static List<DiscoveryIncomingMessage> sendQueryAndCollectAnswers(DiscoveryOutgoingMessage pOutMsg,                                                                             int pTimeout,                                                                             LogHandler pLogHandler) throws IOException {         final List<Future<List<DiscoveryIncomingMessage>>> futures = sendDiscoveryRequests(pOutMsg, pTimeout, pLogHandler);         return collectIncomingMessages(pTimeout, futures, pLogHandler);     }
public Job insertJobOrFetchDuplicate(String projectId, Job job) throws IOException {     Preconditions.checkArgument(         job.getJobReference() != null && job.getJobReference().getJobId() != null,         ""Require non-null JobReference and JobId inside; getJobReference() == '%s'"",         job.getJobReference());     Insert insert = service.jobs().insert(projectId, job);     Job response = null;     try {       response = insert.execute();       logger.atFine().log(""Successfully inserted job '%s'. Response: '%s'"", job, response);     } catch (IOException ioe) {       if (errorExtractor.itemAlreadyExists(ioe)) {         logger.atInfo().withCause(ioe).log(             ""Fetching existing job after catching exception for duplicate jobId '%s'"",             job.getJobReference().getJobId());         response = service.jobs().get(projectId, job.getJobReference().getJobId()).execute();       } else {         throw new IOException(             String.format(""Unhandled exception trying to insert job '%s'"", job), ioe);       }     }     checkJobIdEquality(job, response);     return response;   }
@Override     protected final Set<RegData> extendedLoad(FileInputStream fis) {         Set<RegData> regData = new HashSet<RegData>();         BufferedReader br = null;         try {             br = new BufferedReader(createReader(fis));             // Check magic sequence.             if (isMagicCorrect(br)) {                 // If magic is correct, load data.                 State state = newState();                 while (true) {                     String line = br.readLine();                     if (line == null) {                         break;                     }                     RegData regDatum = parseLine(state, line);                     // regDatum can be null if one line does not correspond to                     // one resource.                     if (regDatum != null) {                         regData.add(regDatum);                     }                 }             }         } catch (Exception ex) {             Log.e(""Loading coverage not successful"", ex);             // Make sure that test is rerun.             regData.clear();         } finally {             FileUtil.closeAndIgnoreExceptions(br);         }         return regData;     }
public Observable<ServiceResponse<ResourceHealthMetadataInner>> getBySiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {         if (resourceGroupName == null) {             throw new IllegalArgumentException(""Parameter resourceGroupName is required and cannot be null."");         }         if (name == null) {             throw new IllegalArgumentException(""Parameter name is required and cannot be null."");         }         if (slot == null) {             throw new IllegalArgumentException(""Parameter slot is required and cannot be null."");         }         if (this.client.subscriptionId() == null) {             throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");         }         if (this.client.apiVersion() == null) {             throw new IllegalArgumentException(""Parameter this.client.apiVersion() is required and cannot be null."");         }         return service.getBySiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())             .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResourceHealthMetadataInner>>>() {                 @Override                 public Observable<ServiceResponse<ResourceHealthMetadataInner>> call(Response<ResponseBody> response) {                     try {                         ServiceResponse<ResourceHealthMetadataInner> clientResponse = getBySiteSlotDelegate(response);                         return Observable.just(clientResponse);                     } catch (Throwable t) {                         return Observable.error(t);                     }                 }             });     }
@XmlElementDecl(namespace = ""http://www.opengis.net/citygml/generics/1.0"", name = ""intAttribute"", substitutionHeadNamespace = ""http://www.opengis.net/citygml/generics/1.0"", substitutionHeadName = ""_genericAttribute"")     public JAXBElement<IntAttributeType> createIntAttribute(IntAttributeType value) {         return new JAXBElement<IntAttributeType>(_IntAttribute_QNAME, IntAttributeType.class, null, value);     }
public MessageApp getMessageApplication(boolean bCreateIfNotFound, Map<String, Object> properties)     {      String strDBPrefix = null;      String strSubSystem = null;      String strDomain = null;      if (properties != null)       strDomain = (String)properties.get(DBParams.DOMAIN);      Map<String,Object> propDomain = null;   if (this.getDefaultApplication() instanceof MainApplication)   {       if (strDomain == null)        strDomain = this.getDefaultApplication().getProperty(DBParams.DOMAIN); // Default domain    propDomain = ((MainApplication)this.getDefaultApplication()).getDomainProperties(strDomain);    if (propDomain != null)    {     strDBPrefix = (String)propDomain.get(DBConstants.DB_USER_PREFIX);     strSubSystem = (String)propDomain.get(DBConstants.SYSTEM_NAME);    }          if ((properties != null) && (strDBPrefix == null))              strDBPrefix = (String)properties.get(DBConstants.DB_USER_PREFIX);             if ((properties != null) && (strSubSystem == null))                 strSubSystem = (String)properties.get(DBConstants.SYSTEM_NAME);             if (strSubSystem != null)                 strSubSystem = Utility.getSystemSuffix(strSubSystem, this.getProperty(DBConstants.DEFAULT_SYSTEM_NAME));   }   MessageApp messageApplication = this.getMessageApplication(strDBPrefix, strSubSystem);         if (bCreateIfNotFound)       if (messageApplication == null)         {       MessageApp defaultMessageApplication = this.getMessageApplication(null, null);             synchronized (this)             {              messageApplication = this.getMessageApplication(strDBPrefix, strSubSystem);           if (messageApplication != null)            return messageApplication;              Map<String,Object> propTemp = new HashMap<String,Object>();        if (defaultMessageApplication != null)         if (defaultMessageApplication.getProperties() != null)          propTemp.putAll(defaultMessageApplication.getProperties());           if (properties != null)      propTemp.putAll(properties);        if (propDomain != null)      propTemp.putAll(propDomain);        properties = propTemp;        String className = MessageInfoModel.THICK_APPLICATION;        messageApplication = (MessageApp)ClassServiceUtility.getClassService().makeObjectFromClassName(className);        messageApplication.init(this, properties, null);                 //messageApplication = new MessageInfoApplication(this, properties, null);                 if (this.getDefaultApplication() != null)                     if (this.getDefaultApplication() != messageApplication)                         if ((!DBConstants.TRUE.equalsIgnoreCase(messageApplication.getProperty(DBParams.MESSAGE_SERVER))) // JMSServer has no server                             && (!DBParams.LOCAL.equalsIgnoreCase(messageApplication.getProperty(DBParams.MESSAGE_SERVER))))                 {   // (remote)                     RemoteTask server = (RemoteTask)messageApplication.getRemoteTask(null);                     RemoteTask appServer = (RemoteTask)this.getDefaultApplication().getRemoteTask(null, null, false);                     if ((server != null) && (appServer != null))                     {                         try {                             // Tell the remote session who my main session is                             // so it can know where not to send server record                             // messages (to eliminate echos in the client).                             appServer.setRemoteMessageTask(server); // Should have done all the apps in this env!                         } catch (RemoteException ex)    {                             ex.printStackTrace();                         }                     }                 }             }         }         return messageApplication;     }
public static void initEnvironment() {    // init logging system if not specified    if (System.getProperty(""org.apache.commons.logging.Log"") == null)     System.setProperty(""org.apache.commons.logging.Log"", ""net.lecousin.framework.log.bridges.ApacheCommonsLogging"");        // register protocols    String protocols = System.getProperty(""java.protocol.handler.pkgs"");    if (protocols == null) protocols = """";    if (!protocols.contains(""net.lecousin.framework.protocols"")) {     if (protocols.length() > 0) protocols += ""|"";     protocols += ""net.lecousin.framework.protocols"";     System.setProperty(""java.protocol.handler.pkgs"", protocols);    }   }
public static void localListenByLine(    int port,                                             Map<String, SocketAction> actions,                                             ExecutorService service) {         localListen(port, actions, service, SocketAtom.class);     }
protected JSONArray callMethod(String method, Object ... args) throws Exception {         return new QueryBuilder().retrieveResult(storedId).call(method, args).storeResult(""LAST_"" + getStoredId()).execute();     }
public static Object invokeMethodN(Class senderClass, Object receiver, String messageName, Object[] messageArguments) throws Throwable {         try {                 return InvokerHelper.invokeMethod(receiver, messageName, messageArguments);         } catch (GroovyRuntimeException gre) {             throw unwrap(gre);         }     }
public void freeFiltersWithSource(Object objSource)     {         if (m_messageMap != null)         {             for (BaseMessageQueue messageQueue : m_messageMap.values())             {                 if (messageQueue != null)                     messageQueue.freeFiltersWithSource(objSource);             }         }     }
public static String getString(Object from, Field field)      {          PropertyAccessor<?> accessor = PropertyAccessorFactory.getPropertyAccessor(field);          Object object = getObject(from, field);          return object != null ? accessor.toString(object) : null;      }
public static double getEstimate(final Memory srcMem) {     checkIfValidThetaSketch(srcMem);     return Sketch.estimate(getThetaLong(srcMem), getRetainedEntries(srcMem), getEmpty(srcMem));   }
public void initialize(@Observes @Initialized(ApplicationScoped.class) Object ignore) {         log.debugf(""Initializing [%s]"", this.getClass().getName());         try {             feedSessionListenerProducer = new BiFunction<String, Session, WsSessionListener>() {                 @Override                 public WsSessionListener apply(String key, Session session) {                     // In the future, if we need other queues/topics that need to be listened to, we add them here.                     final Endpoint endpoint = Constants.FEED_COMMAND_QUEUE;                     BasicMessageListener<BasicMessage> busEndpointListener = new FeedBusEndpointListener(session, key,                             endpoint);                     return new BusWsSessionListener(Constants.HEADER_FEEDID, key, endpoint, busEndpointListener);                 }             };             wsEndpoints.getFeedSessions().addWsSessionListenerProducer(feedSessionListenerProducer);              uiClientSessionListenerProducer = new BiFunction<String, Session, WsSessionListener>() {                 @Override                 public WsSessionListener apply(String key, Session session) {                     // In the future, if we need other queues/topics that need to be listened to, we add them here.                     final Endpoint endpoint = Constants.UI_COMMAND_QUEUE;                     BasicMessageListener<BasicMessage> busEndpointListener = new UiClientBusEndpointListener(                             commandContextFactory, busCommands, endpoint);                     return new BusWsSessionListener(Constants.HEADER_UICLIENTID, key, endpoint, busEndpointListener);                 }             };             wsEndpoints.getUiClientSessions().addWsSessionListenerProducer(uiClientSessionListenerProducer);         } catch (Exception e) {             log.errorCouldNotInitialize(e, this.getClass().getName());         }      }
@Override  public CPDefinitionSpecificationOptionValue findByCPSpecificationOptionId_First(   long CPSpecificationOptionId,   OrderByComparator<CPDefinitionSpecificationOptionValue> orderByComparator)   throws NoSuchCPDefinitionSpecificationOptionValueException {   CPDefinitionSpecificationOptionValue cpDefinitionSpecificationOptionValue =    fetchByCPSpecificationOptionId_First(CPSpecificationOptionId,     orderByComparator);    if (cpDefinitionSpecificationOptionValue != null) {    return cpDefinitionSpecificationOptionValue;   }    StringBundler msg = new StringBundler(4);    msg.append(_NO_SUCH_ENTITY_WITH_KEY);    msg.append(""CPSpecificationOptionId="");   msg.append(CPSpecificationOptionId);    msg.append(""}"");    throw new NoSuchCPDefinitionSpecificationOptionValueException(msg.toString());  }
private void connectInSameElement(List<LineSegment2D_F32> lines ) {   for( int i = 0; i < lines.size(); i++ ) {    LineSegment2D_F32 a = lines.get(i);     int index = findBestCompatible(a,lines,i+1);    if( index == -1 )     continue;     // remove the line from the index which it is being connected to    LineSegment2D_F32 b = lines.remove(index);     // join the two lines by connecting the farthest points from each other    Point2D_F32 pt0 = farthestIndex < 2 ? a.a : a.b;    Point2D_F32 pt1 = (farthestIndex %2) == 0 ? b.a : b.b;     a.a.set(pt0);    a.b.set(pt1);   }  }
private String computeShortClassName() {         String name = this.getClass().getSimpleName();         if (name.endsWith(APP_SUFFIX_CLASSNAME)) {             name = name.substring(0, name.indexOf(APP_SUFFIX_CLASSNAME));         }         return name;     }
public ServiceFuture<VirtualNetworkInner> getByResourceGroupAsync(String resourceGroupName, String virtualNetworkName, final ServiceCallback<VirtualNetworkInner> serviceCallback) {         return ServiceFuture.fromResponse(getByResourceGroupWithServiceResponseAsync(resourceGroupName, virtualNetworkName), serviceCallback);     }
public Observable<PolicySetDefinitionInner> createOrUpdateAtManagementGroupAsync(String policySetDefinitionName, String managementGroupId, PolicySetDefinitionInner parameters) {         return createOrUpdateAtManagementGroupWithServiceResponseAsync(policySetDefinitionName, managementGroupId, parameters).map(new Func1<ServiceResponse<PolicySetDefinitionInner>, PolicySetDefinitionInner>() {             @Override             public PolicySetDefinitionInner call(ServiceResponse<PolicySetDefinitionInner> response) {                 return response.body();             }         });     }
public Matrix4f setRotationXYZ(float angleX, float angleY, float angleZ) {         float sinX = (float) Math.sin(angleX);         float cosX = (float) Math.cosFromSin(sinX, angleX);         float sinY = (float) Math.sin(angleY);         float cosY = (float) Math.cosFromSin(sinY, angleY);         float sinZ = (float) Math.sin(angleZ);         float cosZ = (float) Math.cosFromSin(sinZ, angleZ);         float m_sinX = -sinX;         float m_sinY = -sinY;         float m_sinZ = -sinZ;          // rotateX         float nm11 = cosX;         float nm12 = sinX;         float nm21 = m_sinX;         float nm22 = cosX;         // rotateY         float nm00 = cosY;         float nm01 = nm21 * m_sinY;         float nm02 = nm22 * m_sinY;         this._m20(sinY);         this._m21(nm21 * cosY);         this._m22(nm22 * cosY);         // rotateZ         this._m00(nm00 * cosZ);         this._m01(nm01 * cosZ + nm11 * sinZ);         this._m02(nm02 * cosZ + nm12 * sinZ);         this._m10(nm00 * m_sinZ);         this._m11(nm01 * m_sinZ + nm11 * cosZ);         this._m12(nm02 * m_sinZ + nm12 * cosZ);         properties = properties & ~(PROPERTY_PERSPECTIVE | PROPERTY_IDENTITY | PROPERTY_TRANSLATION);         return this;     }
@Override   public Long getValue(int pollerIndex) {     final long cnt = count.getCurrentCount(pollerIndex);     final long value = (long) (getTotal(pollerIndex) / cnt);     return (cnt == 0) ? 0L : value;   }
private static void registerRouteRoot(IRouteRoot routeRoot) {         markRegisteredByPlugin();         if (routeRoot != null) {             routeRoot.loadInto(Warehouse.groupsIndex);         }     }
private static Object tupleFieldToSingleField(FieldDescriptor fieldDescriptor, Object tupleField) {     // type convertion should match with ProtobufToPig.getPigScriptDataType     switch (fieldDescriptor.getType()) {     case ENUM:       return toEnumValueDescriptor(fieldDescriptor, (String) tupleField);     case BOOL:       return Boolean.valueOf((Integer)tupleField != 0);     case BYTES:       return ByteString.copyFrom(((DataByteArray)tupleField).get());     default:       return tupleField;     }   }
public void free()     {         if (m_sessionObjectParent != null)             ((BaseSession)m_sessionObjectParent).removeSessionObject(this);   // Have my parent remove me from their list.         // Remove all the session objects that I am responsible for         if (m_vSessionObjectList != null)         {             while (m_vSessionObjectList.size() > 0)             {                 BaseSession sessionObject = (BaseSession)m_vSessionObjectList.elementAt(0);                 sessionObject.free(); // They will automatically call me.removeSessionObject(them);             }              m_vSessionObjectList.removeAllElements();             m_vSessionObjectList = null;         }         super.free();     }
protected Converter createConverter(FaceletContext ctx)     {         if (this.converterId == null)         {             throw new TagException(this.tag,                                    ""Default behavior invoked of requiring a converter-id passed in the constructor, ""                                    + ""must override ConvertHandler(ConverterConfig)"");         }         return ctx.getFacesContext().getApplication().createConverter(this.converterId);     }
private boolean containsAnyInFactor(final String[] searchChars, final boolean ignoreCase) {                    for(Token token : tokens) {              if(!(token instanceof Token.Factor)) {                  continue;              }                            final Token.Factor factor = token.asFactor();              if(Utils.containsAny(factor.getValue(), searchChars, ignoreCase)) {                  return true;              }                        }                    return false;      }
private void appendOptionGroup(StringBuffer buff, OptionGroup group)     {         if (!group.isRequired())         {             buff.append(""["");         }          List<Option> optList = new ArrayList<Option>(group.getOptions());         if (getOptionComparator() != null)         {             Collections.sort(optList, getOptionComparator());         }         // for each option in the OptionGroup         for (Iterator<Option> it = optList.iterator(); it.hasNext();)         {             // whether the option is required or not is handled at group level             appendOption(buff, it.next(), true);              if (it.hasNext())             {                 buff.append("" | "");             }         }          if (!group.isRequired())         {             buff.append(""]"");         }     }
public void marshall(CodeGenNodeArg codeGenNodeArg, ProtocolMarshaller protocolMarshaller) {          if (codeGenNodeArg == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(codeGenNodeArg.getName(), NAME_BINDING);             protocolMarshaller.marshall(codeGenNodeArg.getValue(), VALUE_BINDING);             protocolMarshaller.marshall(codeGenNodeArg.getParam(), PARAM_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public static <T> Collection<T> addAll(Collection<T> collection, Iterator<T> iterator) {    if (null != collection && null != iterator) {     while (iterator.hasNext()) {      collection.add(iterator.next());     }    }    return collection;   }
public static String getRecurlySignature(String privateJsKey, List<String> extraParams) {         final long unixTime = System.currentTimeMillis() / 1000L;         final String uuid = UUID.randomUUID().toString().replaceAll(""-"", """");         return getRecurlySignature(privateJsKey, unixTime, uuid, extraParams);     }
protected String getPropStringValue(String aPropName, String aDefaultValue) {         return dbPoolingProperties.getProperty(aPropName,                 aDefaultValue);     }
public static Expression opacify(Generator generator, FunctionCall input) {         Color color = input.getExpectedColorParam(0);         float amount = input.getExpectedFloatParam(1);         return new Color(color.getR(), color.getG(), color.getB(), color.getA() + amount);     }
public static base_responses add(nitro_service client, streamidentifier resources[]) throws Exception {   base_responses result = null;   if (resources != null && resources.length > 0) {    streamidentifier addresources[] = new streamidentifier[resources.length];    for (int i=0;i<resources.length;i++){     addresources[i] = new streamidentifier();     addresources[i].name = resources[i].name;     addresources[i].selectorname = resources[i].selectorname;     addresources[i].interval = resources[i].interval;     addresources[i].samplecount = resources[i].samplecount;     addresources[i].sort = resources[i].sort;    }    result = add_bulk_request(client, addresources);   }   return result;  }
@Override  public CPOption removeByG_K(long groupId, String key)   throws NoSuchCPOptionException {   CPOption cpOption = findByG_K(groupId, key);    return remove(cpOption);  }
public void setSecondaryArtifactsOverride(java.util.Collection<ProjectArtifacts> secondaryArtifactsOverride) {         if (secondaryArtifactsOverride == null) {             this.secondaryArtifactsOverride = null;             return;         }          this.secondaryArtifactsOverride = new java.util.ArrayList<ProjectArtifacts>(secondaryArtifactsOverride);     }
private void processEntity(Entity entity, double latitude, double longitude) {         // Only add entities that fall within the bounding box (if set)         BoundingBox bb = this.configuration.getBboxConfiguration();         if (bb != null && !bb.contains(latitude, longitude)) {             return;         }          // Only add entities that have data         if (entity.getTags().isEmpty()) {             return;         }          // Only add named entities (if set)         if (this.configuration.isNames()) {             String name = getTagValue(entity.getTags(), ""name"");             if (name == null || name.isEmpty()) {                 return;             }         }          // Process entity         Map<String, String> tagMap = new TreeMap<>();         Set<PoiCategory> categories = new HashSet<>();         for (Tag tag : entity.getTags()) {             String key = tag.getKey().toLowerCase(Locale.ENGLISH);             if (this.tagMappingResolver.getMappingTags().contains(key)) {                 // Check if there is a POI category for this tag and add POI to DB                 String tagStr = key + ""="" + tag.getValue();                 try {                     // Get categories from tag                     List<PoiCategory> pcs = this.tagMappingResolver.getCategoriesFromTag(tagStr);                      // Get categories from key, if tag wasn't matched                     // Note: key categories should be parents of their value categories                     if (pcs == null) {                         pcs = this.tagMappingResolver.getCategoriesFromTag(key);                     }                      if (pcs != null) {                         for (PoiCategory pc : pcs) {                             // Add entity if its category matches                             if (this.categoryFilter.isAcceptedCategory(pc)) {                                 // Collect the POI tags in a sorted manner (once)                                 if (tagMap.isEmpty()) {                                     for (Tag t : entity.getTags()) {                                         tagMap.put(t.getKey().toLowerCase(Locale.ENGLISH), t.getValue());                                     }                                 }                                 categories.add(pc);                             }                         }                     }                 } catch (UnknownPoiCategoryException e) {                     LOGGER.warning(""The '"" + tagStr + ""' tag refers to a POI that does not exist: "" + e.getMessage());                 }             }         }          // Store POI         if (!tagMap.isEmpty()) {             writePOI(this.poiAdded++, latitude, longitude, tagMap, categories);         }     }
public QueryParameters set(int index, QueryParameters element) {         QueryParameters params = null;          if (getMaxCacheSize() != -1) {             throw new MjdbcRuntimeException(ERROR_NOT_ALLOWED + "". Cache update is allowed when Cache is not limited (used by Cached output handlers)"");         }          if (valueCached(index) == true) {             params = readCachedValue(index);             updateCache(index, element);         } else {             throw new MjdbcRuntimeException(ERROR_NOT_ALLOWED + "". Only cached(read) values can be replaced"");         }          return params;     }
public static AbstractMessage.Builder addDefaultInstanceToRepeatedField(final int repeatedFieldNumber, final AbstractMessage.Builder builder) throws CouldNotPerformException {         return addDefaultInstanceToRepeatedField(builder.getDescriptorForType().findFieldByNumber(repeatedFieldNumber), builder);     }
public final EObject entryRuleJvmWildcardTypeReference() throws RecognitionException {         EObject current = null;          EObject iv_ruleJvmWildcardTypeReference = null;           try {             // InternalXbaseWithAnnotations.g:6322:65: (iv_ruleJvmWildcardTypeReference= ruleJvmWildcardTypeReference EOF )             // InternalXbaseWithAnnotations.g:6323:2: iv_ruleJvmWildcardTypeReference= ruleJvmWildcardTypeReference EOF             {             if ( state.backtracking==0 ) {                newCompositeNode(grammarAccess.getJvmWildcardTypeReferenceRule());              }             pushFollow(FOLLOW_1);             iv_ruleJvmWildcardTypeReference=ruleJvmWildcardTypeReference();              state._fsp--;             if (state.failed) return current;             if ( state.backtracking==0 ) {                current =iv_ruleJvmWildcardTypeReference;              }             match(input,EOF,FOLLOW_2); if (state.failed) return current;              }          }              catch (RecognitionException re) {                 recover(input,re);                 appendSkippedTokens();             }         finally {         }         return current;     }
@Override     protected void destroyRepository() {          final RepositoryImpl repository = (RepositoryImpl) getRepository();         repository.shutdown();         LOG.info(""Destroyed repository at {}"", repository.getConfig().getHomeDir());     }
public void marshall(Datastore datastore, ProtocolMarshaller protocolMarshaller) {          if (datastore == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(datastore.getName(), NAME_BINDING);             protocolMarshaller.marshall(datastore.getArn(), ARN_BINDING);             protocolMarshaller.marshall(datastore.getStatus(), STATUS_BINDING);             protocolMarshaller.marshall(datastore.getRetentionPeriod(), RETENTIONPERIOD_BINDING);             protocolMarshaller.marshall(datastore.getCreationTime(), CREATIONTIME_BINDING);             protocolMarshaller.marshall(datastore.getLastUpdateTime(), LASTUPDATETIME_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
@Nullable   public static String[] convertToNames(UfsStatus[] children) {     if (children == null) {       return null;     }     String[] ret = new String[children.length];     for (int i = 0; i < children.length; ++i) {       ret[i] = children[i].getName();     }     return ret;   }
public boolean columnValueIsBinary(String namespace, String storeName) {         Boolean cachedValue = getCachedValueIsBinary(namespace, storeName);         if(cachedValue != null) return cachedValue.booleanValue();                  String cqlKeyspace = CQLService.storeToCQLName(namespace);         String tableName = CQLService.storeToCQLName(storeName);         KeyspaceMetadata ksMetadata = m_cluster.getMetadata().getKeyspace(cqlKeyspace);         TableMetadata tableMetadata = ksMetadata.getTable(tableName);         ColumnMetadata colMetadata = tableMetadata.getColumn(""value"");         boolean isBinary = colMetadata.getType().equals(DataType.blob());                  putCachedValueIsBinary(namespace, storeName, isBinary);         return isBinary;     }
private void ensureMetaCharsetElement() {         if (updateMetaCharset) {             OutputSettings.Syntax syntax = outputSettings().syntax();              if (syntax == OutputSettings.Syntax.html) {                 Element metaCharset = select(""meta[charset]"").first();                  if (metaCharset != null) {                     metaCharset.attr(""charset"", charset().displayName());                 } else {                     Element head = head();                      if (head != null) {                         head.appendElement(""meta"").attr(""charset"", charset().displayName());                     }                 }                  // Remove obsolete elements                 select(""meta[name=charset]"").remove();             } else if (syntax == OutputSettings.Syntax.xml) {                 Node node = childNodes().get(0);                  if (node instanceof XmlDeclaration) {                     XmlDeclaration decl = (XmlDeclaration) node;                      if (decl.name().equals(""xml"")) {                         decl.attr(""encoding"", charset().displayName());                          final String version = decl.attr(""version"");                          if (version != null) {                             decl.attr(""version"", ""1.0"");                         }                     } else {                         decl = new XmlDeclaration(""xml"", false);                         decl.attr(""version"", ""1.0"");                         decl.attr(""encoding"", charset().displayName());                          prependChild(decl);                     }                 } else {                     XmlDeclaration decl = new XmlDeclaration(""xml"", false);                     decl.attr(""version"", ""1.0"");                     decl.attr(""encoding"", charset().displayName());                      prependChild(decl);                 }             }         }     }
public Pipeline<T> set(String name, Predicate<T> predicate) {   return set(stages.size(), name, predicate);  }
public static <T> ImmutableListJsonDeserializer<T> newInstance( JsonDeserializer<T> deserializer ) {         return new ImmutableListJsonDeserializer<T>( deserializer );     }
public Observable<ServiceResponse<NameAvailabilityResponseInner>> checkChildrenNameAvailabilityWithServiceResponseAsync(String groupName, String serviceName, NameAvailabilityRequest parameters) {         if (this.client.subscriptionId() == null) {             throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");         }         if (groupName == null) {             throw new IllegalArgumentException(""Parameter groupName is required and cannot be null."");         }         if (serviceName == null) {             throw new IllegalArgumentException(""Parameter serviceName is required and cannot be null."");         }         if (this.client.apiVersion() == null) {             throw new IllegalArgumentException(""Parameter this.client.apiVersion() is required and cannot be null."");         }         if (parameters == null) {             throw new IllegalArgumentException(""Parameter parameters is required and cannot be null."");         }         Validator.validate(parameters);         return service.checkChildrenNameAvailability(this.client.subscriptionId(), groupName, serviceName, this.client.apiVersion(), parameters, this.client.acceptLanguage(), this.client.userAgent())             .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NameAvailabilityResponseInner>>>() {                 @Override                 public Observable<ServiceResponse<NameAvailabilityResponseInner>> call(Response<ResponseBody> response) {                     try {                         ServiceResponse<NameAvailabilityResponseInner> clientResponse = checkChildrenNameAvailabilityDelegate(response);                         return Observable.just(clientResponse);                     } catch (Throwable t) {                         return Observable.error(t);                     }                 }             });     }
public com.google.api.ads.admanager.axis.v201811.CompanionDeliveryOption getCompanionDeliveryOption() {         return companionDeliveryOption;     }
public static void fillPayMap(Map<String, Object> map, String key) {         // 首先确保有随机数         map.put(""nonce_str"", """" + R.random(10000000, 100000000));          // 填充签名         String sign = genPaySignMD5(map, key);         map.put(""sign"", sign);     }
public static String unqualify(String qualifiedName, char separator) {         return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);     }
public WrappedByteBuffer putIntAt(int index, int v) {         _checkForWriteAt(index, 4);         _buf.putInt(index, v);         return this;     }
public void applyToSourceUnits(SourceUnitOperation body) throws CompilationFailedException {         for (String name : names) {             SourceUnit source = sources.get(name);             if ((source.phase < phase) || (source.phase == phase && !source.phaseComplete)) {                 try {                     body.call(source);                 } catch (CompilationFailedException e) {                     throw e;                 } catch (Exception e) {                     GroovyBugError gbe = new GroovyBugError(e);                     changeBugText(gbe, source);                     throw gbe;                 } catch (GroovyBugError e) {                     changeBugText(e, source);                     throw e;                 }             }         }           getErrorCollector().failIfErrors();     }
public List<PendingEvent> refreshSegmentEventWriters(Consumer<Segment> segmentSealedCallBack) {         log.info(""Refreshing segments for stream {}"", stream);         return updateSegments(Futures.getAndHandleExceptions(                 controller.getCurrentSegments(stream.getScope(), stream.getStreamName()), RuntimeException::new),                 segmentSealedCallBack);     }
@SuppressWarnings(""unchecked"")  protected void executeOnCollections(List<IN> inputData, RuntimeContext ctx, ExecutionConfig executionConfig) throws Exception {   OutputFormat<IN> format = this.formatWrapper.getUserCodeObject();   TypeInformation<IN> inputType = getInput().getOperatorInfo().getOutputType();    if (this.localOrdering != null) {    int[] sortColumns = this.localOrdering.getFieldPositions();    boolean[] sortOrderings = this.localOrdering.getFieldSortDirections();     final TypeComparator<IN> sortComparator;    if (inputType instanceof CompositeType) {     sortComparator = ((CompositeType<IN>) inputType).createComparator(sortColumns, sortOrderings, 0, executionConfig);    } else if (inputType instanceof AtomicType) {     sortComparator = ((AtomicType<IN>) inputType).createComparator(sortOrderings[0], executionConfig);    } else {     throw new UnsupportedOperationException(""Local output sorting does not support type ""+inputType+"" yet."");    }     Collections.sort(inputData, new Comparator<IN>() {     @Override     public int compare(IN o1, IN o2) {      return sortComparator.compare(o1, o2);     }    });   }    if(format instanceof InitializeOnMaster) {    ((InitializeOnMaster)format).initializeGlobal(1);   }   format.configure(this.parameters);    if(format instanceof RichOutputFormat){    ((RichOutputFormat<?>) format).setRuntimeContext(ctx);   }   format.open(0, 1);   for (IN element : inputData) {    format.writeRecord(element);   }      format.close();      if(format instanceof FinalizeOnMaster) {    ((FinalizeOnMaster)format).finalizeGlobal(1);   }  }
@Override   public EEnum getIfcCoilTypeEnum() {    if (ifcCoilTypeEnumEEnum == null) {     ifcCoilTypeEnumEEnum = (EEnum) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI).getEClassifiers()       .get(935);    }    return ifcCoilTypeEnumEEnum;   }
public static HtmlTree META(String name, String content) {         HtmlTree htmltree = new HtmlTree(HtmlTag.META);         htmltree.addAttr(HtmlAttr.NAME, nullCheck(name));         htmltree.addAttr(HtmlAttr.CONTENT, nullCheck(content));         return htmltree;     }
private boolean hasScopeAnnotation(final Class<?> type, final boolean hkManaged) {         boolean found = false;         for (Annotation ann : type.getAnnotations()) {             final Class<? extends Annotation> annType = ann.annotationType();             if (annType.isAnnotationPresent(Scope.class)) {                 found = true;                 break;             }             // guice has special marker annotation             if (!hkManaged && annType.isAnnotationPresent(ScopeAnnotation.class)) {                 found = true;                 break;             }         }         return found;     }
public ServerBuilder accessLogger(String loggerName) {         requireNonNull(loggerName, ""loggerName"");         return accessLogger(LoggerFactory.getLogger(loggerName));     }
static TarArchiveEntry defaultFileEntryWithName( final String fileName ) {         TarArchiveEntry entry = new TarArchiveEntry(fileName, true);         entry.setUserId(ROOT_UID);         entry.setUserName(ROOT_NAME);         entry.setGroupId(ROOT_UID);         entry.setGroupName(ROOT_NAME);         entry.setMode(TarArchiveEntry.DEFAULT_FILE_MODE);         return entry;     }
@Override     protected void populateColumnSchema(ArrayList<VoltTable.ColumnInfo> columns) {         super.populateColumnSchema(columns);         columns.add(new ColumnInfo(VoltSystemProcedure.CNAME_SITE_ID, VoltSystemProcedure.CTYPE_ID));         columns.add(new ColumnInfo(""PARTITION_ID"",  VoltType.INTEGER));         columns.add(new ColumnInfo(""CACHE1_LEVEL"",  VoltType.INTEGER));         columns.add(new ColumnInfo(""CACHE2_LEVEL"",  VoltType.INTEGER));         columns.add(new ColumnInfo(""CACHE1_HITS"",   VoltType.BIGINT));         columns.add(new ColumnInfo(""CACHE2_HITS"",   VoltType.BIGINT));         columns.add(new ColumnInfo(""CACHE_MISSES"",  VoltType.BIGINT));         columns.add(new ColumnInfo(""PLAN_TIME_MIN"", VoltType.BIGINT));         columns.add(new ColumnInfo(""PLAN_TIME_MAX"", VoltType.BIGINT));         columns.add(new ColumnInfo(""PLAN_TIME_AVG"", VoltType.BIGINT));         columns.add(new ColumnInfo(""FAILURES"",      VoltType.BIGINT));     }
public EnableEnhancedMonitoringResult withDesiredShardLevelMetrics(String... desiredShardLevelMetrics) {         if (this.desiredShardLevelMetrics == null) {             setDesiredShardLevelMetrics(new com.amazonaws.internal.SdkInternalList<String>(desiredShardLevelMetrics.length));         }         for (String ele : desiredShardLevelMetrics) {             this.desiredShardLevelMetrics.add(ele);         }         return this;     }
public void normalize(Model model) {      if(model.getLevel() != BioPAXLevel.L3)    throw new IllegalArgumentException(""Not Level3 model. "" +     ""Consider converting it first (e.g., with the PaxTools)."");      //if set, update the xml:base   if(xmlBase != null && !xmlBase.isEmpty())    model.setXmlBase(xmlBase);    // Normalize/merge xrefs, first, and then CVs   // (also because some of original xrefs might have ""normalized"" URIs    // that, in fact, must be used for other biopax types, such as CV or ProteinReference)   log.info(""Normalizing xrefs..."" + description);   normalizeXrefs(model);      // fix displayName where possible   if(fixDisplayName) {    log.info(""Normalizing display names..."" + description);    fixDisplayName(model);   }       log.info(""Normalizing CVs..."" + description);   normalizeCVs(model);      //normalize BioSource objects (better, as it is here, go after Xrefs and CVs)   log.info(""Normalizing organisms..."" + description);   normalizeBioSources(model);    // auto-generate missing entity references:   for(SimplePhysicalEntity spe : new HashSet<SimplePhysicalEntity>(model.getObjects(SimplePhysicalEntity.class))) {    //it skips if spe has entityReference or memberPE already    ModelUtils.addMissingEntityReference(model, spe);   }    log.info(""Normalizing entity references..."" + description);   normalizeERs(model);      // find/add lost (in replace) children   log.info(""Repairing..."" + description);   model.repair(); // it does not remove dangling utility class objects (can be done separately, later, if needed)      log.info(""Optional tasks (reasoning)..."" + description);  }
public Observable<Page<VaultInner>> listByResourceGroupNextAsync(final String nextPageLink) {         return listByResourceGroupNextWithServiceResponseAsync(nextPageLink)             .map(new Func1<ServiceResponse<Page<VaultInner>>, Page<VaultInner>>() {                 @Override                 public Page<VaultInner> call(ServiceResponse<Page<VaultInner>> response) {                     return response.body();                 }             });     }
public static Builder newBuilder(BucketInfo bucketInfo, String name) {     return newBuilder(bucketInfo.getName(), name);   }
public Aggregate DISTINCT() {    ReturnExpression rx = (ReturnExpression)this.astNode;    ReturnAggregate ra = (ReturnAggregate) rx.getReturnValue();    ra.setDistinct();    Aggregate ret = new Aggregate(rx);    return ret;   }
private boolean loadPagesIfNecessary(PagesSupplier pagesSupplier, DataSize maxSize)     {         checkState(!Thread.holdsLock(this), ""Can not load pages while holding a lock on this"");          boolean dataAddedOrNoMorePages;         List<SerializedPageReference> pageReferences;         synchronized (this) {             if (noMorePages) {                 return false;             }              if (!pages.isEmpty()) {                 return false;             }              // The page supplier has incremented the page reference count, and addPages below also increments             // the reference count, so we need to drop the page supplier reference. The call dereferencePage             // is performed outside of synchronized to avoid making a callback while holding a lock.             pageReferences = pagesSupplier.getPages(maxSize);              // add the pages to this buffer, which will increase the reference count             addPages(pageReferences);              // check for no more pages             if (!pagesSupplier.mayHaveMorePages()) {                 noMorePages = true;             }             dataAddedOrNoMorePages = !pageReferences.isEmpty() || noMorePages;         }          // sent pages will have an initial reference count, so drop it         pageReferences.forEach(SerializedPageReference::dereferencePage);          return dataAddedOrNoMorePages;     }
public String readLineSkippingComments(boolean trim) throws IOException {         for (;;) {             String line = readLine();             if (line == null) {                 return line;             }             // Skip over white space             int pos = PatternProps.skipWhiteSpace(line, 0);             // Ignore blank lines and comment lines             if (pos == line.length() || line.charAt(pos) == '#') {                 continue;             }             // Process line             if (trim) line = line.substring(pos);             return line;         }     }
public ApiResponse<ApiSuccessResponse> mediaStopMonitoringWithHttpInfo(String mediatype, MediaStopMonitoringData mediaStopMonitoringData) throws ApiException {         com.squareup.okhttp.Call call = mediaStopMonitoringValidateBeforeCall(mediatype, mediaStopMonitoringData, null, null);         Type localVarReturnType = new TypeToken<ApiSuccessResponse>(){}.getType();         return apiClient.execute(call, localVarReturnType);     }
@Override     public void registerInstanceMethod(String name, Closure closure) {         expandableDelegate().registerInstanceMethod(name, closure);     }
public void addRouter(final Class<?> routeType, Object controller) {          Method[] methods = routeType.getDeclaredMethods();         if (BladeKit.isEmpty(methods)) {             return;         }          String nameSpace = null, suffix = null;         if (null != routeType.getAnnotation(Path.class)) {             nameSpace = routeType.getAnnotation(Path.class).value();             suffix = routeType.getAnnotation(Path.class).suffix();         }          if (null == nameSpace) {             log.warn(""Route [{}] not path annotation"", routeType.getName());             return;         }          for (Method method : methods) {              com.blade.mvc.annotation.Route mapping     = method.getAnnotation(com.blade.mvc.annotation.Route.class);             GetRoute                       getRoute    = method.getAnnotation(GetRoute.class);             PostRoute                      postRoute   = method.getAnnotation(PostRoute.class);             PutRoute                       putRoute    = method.getAnnotation(PutRoute.class);             DeleteRoute                    deleteRoute = method.getAnnotation(DeleteRoute.class);              this.parseRoute(RouteStruct.builder().mapping(mapping)                     .getRoute(getRoute).postRoute(postRoute)                     .putRoute(putRoute).deleteRoute(deleteRoute)                     .nameSpace(nameSpace)                     .suffix(suffix).routeType(routeType)                     .controller(controller).method(method)                     .build());         }     }
public static CalendarPicker<PersianCalendar> persian(         Locale locale,         Supplier<PersianCalendar> todaySupplier     ) {          return CalendarPicker.create(             PersianCalendar.axis(),             new FXCalendarSystemPersian(),             locale,             todaySupplier         );      }
@Override   public JobDetail getJobDetail(String jobKey) throws SchedulerException {      validateState();      return quartzSchedulerResources.getJobStore().retrieveJob(jobKey);   }
public Collection<V> values() {        Set<Map.Entry<K, V>> s = entrySet();        ArrayList l = new ArrayList(s.size());        for (Map.Entry e : s)             l.add(e.getValue());        return l;     }       /**      * Return a filtered set of keys.      * @see Map.keySet      */     public Set<K> keySet() {        Set<Map.Entry<K, V>> s = entrySet();        HashSet keys = new HashSet(s.size());        for (Map.Entry e : mBackingMap.entrySet())            keys.add(e.getKey());        return keys;     }       /**      * Delegates to backing map.      * @see java.util.Map.clear()      */     public void clear() {          mBackingMap.clear();      }       /**      * Delegates to backing map.      * @see java.util.Map.containsKey      */     public boolean containsKey(Object key) {          return mBackingMap.containsKey(key);      }       /**      * Delegates to backing map.      * @see java.util.Map.containsValue      */     public boolean containsValue(Object value) {        return mBackingMap.containsValue(value);     }           /**      * Delegates to backing map.      * @see Object.equals.      */     public boolean equals(Object o) {        return mBackingMap.equals(o);     }       /**      * Delegates to backing map.      * @see Object.hashCode      */     public int hashCode() {        return mBackingMap.hashCode();     }       /**      * Delegates to backing map.      * @see java.util.Map.get      */     public V get(Object key) {        return mBackingMap.get(key);     }           /**      * Delegates to backing map.      * @see java.util.Map.isEmpty      */     public boolean isEmpty() {        return mBackingMap.isEmpty();     }       /**      * Delegates to backing map.      * @see java.util.Map.put      */     public V put(K key, V value) {         return mBackingMap.put(key, value);     }       /**      * Delegates to backing map.      * @see java.util.Map.putAll      */     public void putAll(Map<? extends K,? extends V> m) {         mBackingMap.putAll(m);     }           /**      * Delegates to backing map.      * @see java.util.Map.remove      */     public V remove(Object key) {         return mBackingMap.remove(key);     }       /**      * Delegates to backing map.      * @see java.util.Map.size      */     public int size() {         return mBackingMap.size();     }       /**      * Filter interface.      */     public interface Filter {         /**          * Returns true if the given entry should be included.          */         public boolean accept(Map.Entry e);     }   }
private void copyFiles(String fromDir, String toDir) throws MojoExecutionException {         getLog().debug(""fromDir="" + fromDir + ""; toDir="" + toDir);         try {             File fromDirFile = new File(fromDir);             if (fromDirFile.exists()) {                 Iterator<File> files = FileUtils.iterateFiles(new File(fromDir), null, false);                 while (files.hasNext()) {                     File file = files.next();                     if (file.exists()) {                         FileUtils.copyFileToDirectory(file, new File(toDir));                     } else {                         getLog().error(""File '"" + file.getAbsolutePath() + ""' does not exist. Skipping copy"");                     }                 }             }         } catch (IOException e) {             throw new MojoExecutionException(""Unable to copy file "" + e.getMessage(), e);         }     }
private static ObjectName getObjectName(Cache<?, ?> cache, MBeanType type) {     String cacheManagerName = sanitize(cache.getCacheManager().getURI().toString());     String cacheName = sanitize(cache.getName());      try {       String name = String.format(""javax.cache:type=Cache%s,CacheManager=%s,Cache=%s"",           type, cacheManagerName, cacheName);       return new ObjectName(name);     } catch (MalformedObjectNameException e) {       String msg = String.format(""Illegal ObjectName for cacheManager=[%s], cache=[%s]"",           cacheManagerName, cacheName);       throw new CacheException(msg, e);     }   }
public static void loadCompressedTexture(final GVRContext gvrContext,             ResourceCache<GVRImage> textureCache,             final CompressedTextureCallback callback,             final GVRAndroidResource resource) {         loadCompressedTexture(gvrContext, textureCache, callback, resource,                               GVRCompressedImage.DEFAULT_QUALITY);     }
public static Appendable render(final String input, Appendable target) throws IOException {          int i = 0;         int j, k;          while (true) {             j = input.indexOf(BEGIN_TOKEN, i);             if (j == -1) {                 if (i == 0) {                     target.append(input);                     return target;                 }                 target.append(input.substring(i, input.length()));                 return target;             }             target.append(input.substring(i, j));             k = input.indexOf(END_TOKEN, j);              if (k == -1) {                 target.append(input);                 return target;             }             j += BEGIN_TOKEN_LEN;             String spec = input.substring(j, k);              String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);             if (items.length == 1) {                 target.append(input);                 return target;             }             String replacement = render(items[1], items[0].split(CODE_LIST_SEPARATOR));              target.append(replacement);              i = k + END_TOKEN_LEN;         }     }
public MatchResponse merge(MatchResponse matchResponse) {         if (matchResponse == null || matchResponse == this) {             return this;         } else {             boolean mergedSSLRequired = mergeSSLRequired(matchResponse.isSSLRequired());             boolean mergedAccessPrecluded = mergeAccessPrecluded(matchResponse.isAccessPrecluded());             List<String> mergedRoles = mergeRoles(matchResponse.getRoles(), mergedAccessPrecluded);             return new MatchResponse(mergedRoles, mergedSSLRequired, mergedAccessPrecluded);         }     }
public static StatisticsPageListResult statisticsPageList(              String accessToken, StatisticsPageList statisticsPageList) {          return statisticsPageList(accessToken,                  JsonUtil.toJSONString(statisticsPageList));      }
public static <T> Level0ArrayOperator<T[],T> onArrayOf(final Type<T> type) {          return new Level0ArrayOperator<T[],T>(type, ExecutionTarget.forFn(Normalisation.ARRAY(type.getRawClass())));      }
@Override     public Map<String, Object> getPayload() {         HashMap<String, Object> payload = new HashMap<>();         payload.put(""fun"", getFunction());         kwargs.ifPresent(payload::putAll);         return payload;     }
@Override  public CPDefinitionGroupedEntry findByUuid_Last(String uuid,   OrderByComparator<CPDefinitionGroupedEntry> orderByComparator)   throws NoSuchCPDefinitionGroupedEntryException {   CPDefinitionGroupedEntry cpDefinitionGroupedEntry = fetchByUuid_Last(uuid,     orderByComparator);    if (cpDefinitionGroupedEntry != null) {    return cpDefinitionGroupedEntry;   }    StringBundler msg = new StringBundler(4);    msg.append(_NO_SUCH_ENTITY_WITH_KEY);    msg.append(""uuid="");   msg.append(uuid);    msg.append(""}"");    throw new NoSuchCPDefinitionGroupedEntryException(msg.toString());  }
private BucketShards computeMerged()             throws SQLException     {         if (resultSet.isAfterLast()) {             return endOfData();         }         if (first) {             first = false;             if (!resultSet.next()) {                 return endOfData();             }         }          int bucketNumber = resultSet.getInt(""bucket_number"");         ImmutableSet.Builder<ShardNodes> shards = ImmutableSet.builder();          do {             UUID shardUuid = uuidFromBytes(resultSet.getBytes(""shard_uuid""));             int bucket = resultSet.getInt(""bucket_number"");             Set<String> nodeIdentifiers = ImmutableSet.of(getBucketNode(bucket));              shards.add(new ShardNodes(shardUuid, nodeIdentifiers));         }         while (resultSet.next() && resultSet.getInt(""bucket_number"") == bucketNumber);          return new BucketShards(OptionalInt.of(bucketNumber), shards.build());     }
@Override     public final String getElementText() throws XMLStreamException {         XMLEvent event = this.previousEvent;         if (event == null) {             throw new XMLStreamException(                     ""Must be on START_ELEMENT to read next text, element was null"");         }         if (!event.isStartElement()) {             throw new XMLStreamException(                     ""Must be on START_ELEMENT to read next text"", event.getLocation());         }          final StringBuilder text = new StringBuilder();         while (!event.isEndDocument()) {             switch (event.getEventType()) {                 case XMLStreamConstants.CHARACTERS:                 case XMLStreamConstants.SPACE:                 case XMLStreamConstants.CDATA:                     {                         final Characters characters = event.asCharacters();                         text.append(characters.getData());                         break;                     }                 case XMLStreamConstants.ENTITY_REFERENCE:                     {                         final EntityReference entityReference = (EntityReference) event;                         final EntityDeclaration declaration = entityReference.getDeclaration();                         text.append(declaration.getReplacementText());                         break;                     }                 case XMLStreamConstants.COMMENT:                 case XMLStreamConstants.PROCESSING_INSTRUCTION:                     {                         // Ignore                         break;                     }                 default:                     {                         throw new XMLStreamException(                                 ""Unexpected event type '""                                         + XMLStreamConstantsUtils.getEventName(event.getEventType())                                         + ""' encountered. Found event: ""                                         + event,                                 event.getLocation());                     }             }              event = this.nextEvent();         }          return text.toString();     }
@SuppressWarnings({""checkstyle:magicnumber"", ""checkstyle:npathcomplexity"", ""static-method""})  protected IStatus submit(Charset charset, String title, String body, String login, String password, IProgressMonitor progress) throws Exception {   final SubMonitor subMonitor = SubMonitor.convert(progress, 10);    subMonitor.setTaskName(Messages.SubmitEclipseLogWizard_15);   final Gson gson = new GsonBuilder().create();   final String json = gson.toJson(new GithubIssueJson(title, body));   subMonitor.setWorkRemaining(9);    subMonitor.setTaskName(Messages.SubmitEclipseLogWizard_2);   final ServiceTracker<IProxyService, IProxyService> proxyTracker = new ServiceTracker<>(     SARLEclipsePlugin.getDefault().getBundle().getBundleContext(),     IProxyService.class,     null);   proxyTracker.open();   if (subMonitor.isCanceled()) {    return Status.CANCEL_STATUS;   }   final URL url;   try {    final URI uri = new URI(GITHUB_URL);     final IProxyData[] proxyDataForHost = proxyTracker.getService().select(uri);    for (final IProxyData data : proxyDataForHost) {     if (data.getHost() != null) {      System.setProperty(""http.proxySet"", ""true""); //$NON-NLS-1$ //$NON-NLS-2$      System.setProperty(""http.proxyHost"", data.getHost()); //$NON-NLS-1$     }     if (data.getHost() != null) {      System.setProperty(""http.proxyPort"", String.valueOf(data //$NON-NLS-1$        .getPort()));     }     if (subMonitor.isCanceled()) {      return Status.CANCEL_STATUS;     }    }     url = uri.toURL();   } finally {    proxyTracker.close();   }   subMonitor.setWorkRemaining(8);   if (subMonitor.isCanceled()) {    return Status.CANCEL_STATUS;   }    subMonitor.setTaskName(Messages.SubmitEclipseLogWizard_3);   final HttpURLConnection con = (HttpURLConnection) url.openConnection();   subMonitor.setWorkRemaining(7);   if (subMonitor.isCanceled()) {    return Status.CANCEL_STATUS;   }    //add request header   subMonitor.setTaskName(Messages.SubmitEclipseLogWizard_4);   con.setRequestMethod(""POST""); //$NON-NLS-1$   con.setRequestProperty(""User-Agent"", ""SARL IDE""); //$NON-NLS-1$ //$NON-NLS-2$   // Auth   final String auth = Base64.getEncoder().encodeToString((login + "":"" + password).getBytes()); //$NON-NLS-1$   con.setRequestProperty(""Authorization"", ""Basic "" + auth); //$NON-NLS-1$ //$NON-NLS-2$    con.setDoOutput(true);   con.setDoInput(true);   subMonitor.setWorkRemaining(6);   if (subMonitor.isCanceled()) {    return Status.CANCEL_STATUS;   }    // Send post request   try (DataOutputStream writer = new DataOutputStream(con.getOutputStream())) {    writer.writeBytes(json);    writer.flush();   }   subMonitor.setWorkRemaining(3);   if (subMonitor.isCanceled()) {    return Status.CANCEL_STATUS;   }    //final int responseCode = con.getResponseCode();   subMonitor.setTaskName(Messages.SubmitEclipseLogWizard_6);   final int responseCode = con.getResponseCode();   final StringBuffer response = new StringBuffer();   try (BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()))) {    String inputLine;    while ((inputLine = reader.readLine()) != null) {     response.append(inputLine);     if (subMonitor.isCanceled()) {      return Status.CANCEL_STATUS;     }    }   }   subMonitor.setWorkRemaining(0);   if (subMonitor.isCanceled()) {    return Status.CANCEL_STATUS;   }    if (responseCode != RESPONSE_CODE) {    return SARLEclipsePlugin.getDefault().createStatus(IStatus.ERROR,      Messages.SubmitEclipseLogWizard_14,      new Exception(response.toString()));   }   //System.out.println(responseCode);   //Display.getDefault().asyncExec(() -> {   // final Shell shell = new Shell((Shell) null, SWT.SHELL_TRIM);   // shell.setLayout(new FillLayout());   // final Browser browser = new Browser(shell, SWT.NONE);   // browser.setText(response.toString());   // shell.layout();   // shell.open();    return Status.OK_STATUS;  }
@Override  public List<CommerceVirtualOrderItem> getCommerceVirtualOrderItemsByUuidAndCompanyId(   String uuid, long companyId) {   return commerceVirtualOrderItemPersistence.findByUuid_C(uuid, companyId);  }
public int getParameters(char[] array, int currentIndex, StringBuffer velocityBlock, char endingChar,         VelocityParserContext context)     {         char beginChar = array[currentIndex];          int i = currentIndex + 1;          int depth = 1;          while (i < array.length) {             if (array[i] == endingChar) {                 --depth;                 if (depth == 0) {                     ++i;                     break;                 }             } else if (array[i] == beginChar) {                 ++depth;             } else if (array[i] == '""' || array[i] == '\'') {                 i = getEscape(array, i, null, context);                 continue;             }              ++i;         }          if (velocityBlock != null) {             velocityBlock.append(array, currentIndex, i - currentIndex);         }          return i;     }
public static <T extends V, V> ScoredValue<V> fromNullable(double score, T value) {          if (value == null) {             return new ScoredValue<V>(score, null);         }          return new ScoredValue<V>(score, value);     }
boolean casNext(Node<K,V> cmp, Node<K,V> val) {             return nextUpdater.compareAndSet(this, cmp, val);         }
public static void updateBeanValue(final WComponent component, final boolean visibleOnly) {   // Do not process if component is invisble and ignore visible is true. Will ignore entire branch from this point.   if (!component.isVisible() && visibleOnly) {    return;   }    if (component instanceof WBeanComponent) {    ((WBeanComponent) component).updateBeanValue();   }    // These components recursively update bean values themselves,   // as they have special requirements due to repeating data.   if (component instanceof WDataTable || component instanceof WTable || component instanceof WRepeater) {    return;   }    if (component instanceof Container) {    for (int i = ((Container) component).getChildCount() - 1; i >= 0; i--) {     updateBeanValue(((Container) component).getChildAt(i), visibleOnly);    }   }  }
public int getFootprint() {  if (footprint >= 0)   return footprint;   int foot = 0;   DNSOutput out = new DNSOutput();  rrToWire(out, null, false);  byte [] rdata = out.toByteArray();   if (alg == DNSSEC.Algorithm.RSAMD5) {   int d1 = rdata[rdata.length - 3] & 0xFF;   int d2 = rdata[rdata.length - 2] & 0xFF;   foot = (d1 << 8) + d2;  }  else {   int i;    for (i = 0; i < rdata.length - 1; i += 2) {    int d1 = rdata[i] & 0xFF;    int d2 = rdata[i + 1] & 0xFF;    foot += ((d1 << 8) + d2);   }   if (i < rdata.length) {    int d1 = rdata[i] & 0xFF;    foot += (d1 << 8);   }   foot += ((foot >> 16) & 0xFFFF);  }  footprint = (foot & 0xFFFF);  return footprint; }
private void assertSortedByDistance(DoubleDBIDList results) {     // TODO: sort results instead?     double dist = -1.0;     boolean sorted = true;     for(DoubleDBIDListIter it = results.iter(); it.valid(); it.advance()) {       double qr = it.doubleValue();       if(qr < dist) {         sorted = false;       }       dist = qr;     }     if(!sorted) {       try {         ModifiableDoubleDBIDList.class.cast(results).sort();       }       catch(ClassCastException | UnsupportedOperationException e) {         LoggingUtil.warning(""WARNING: results not sorted by distance!"", e);       }     }   }
protected final void wakeUpLocalConsumers()     {         try         {          List<AbstractSession> sessionsSnapshot = new ArrayList<>(sessions.size());             synchronized (sessions)             {              sessionsSnapshot.addAll(sessions.values());             }             for(int n=0;n<sessionsSnapshot.size();n++)             {                 AbstractSession session = sessionsSnapshot.get(n);                 session.wakeUpConsumers();             }         }         catch (JMSException e)         {          ErrorTools.log(e, log);         }     }
protected void validate(String operationType) throws Exception   {    super.validate(operationType);      MPSString id_validator = new MPSString();    id_validator.setConstraintIsReq(MPSConstants.DELETE_CONSTRAINT, true);    id_validator.setConstraintIsReq(MPSConstants.MODIFY_CONSTRAINT, true);    id_validator.validate(operationType, id, ""\""id\"""");        MPSString profile_name_validator = new MPSString();    profile_name_validator.setConstraintMaxStrLen(MPSConstants.GENERIC_CONSTRAINT, 128);    profile_name_validator.setConstraintMinStrLen(MPSConstants.GENERIC_CONSTRAINT, 1);    profile_name_validator.setConstraintIsReq(MPSConstants.ADD_CONSTRAINT, true);    profile_name_validator.validate(operationType, profile_name, ""\""profile_name\"""");        MPSInternetHost server_name_validator = new MPSInternetHost();    server_name_validator.setConstraintIsReq(MPSConstants.ADD_CONSTRAINT, true);    server_name_validator.validate(operationType, server_name, ""\""server_name\"""");        MPSString to_list_validator = new MPSString();    to_list_validator.setConstraintMinStrLen(MPSConstants.GENERIC_CONSTRAINT, 6);    to_list_validator.validate(operationType, to_list, ""\""to_list\"""");        MPSString cc_list_validator = new MPSString();    cc_list_validator.validate(operationType, cc_list, ""\""cc_list\"""");        MPSString bcc_list_validator = new MPSString();    bcc_list_validator.validate(operationType, bcc_list, ""\""bcc_list\"""");       }
public static void writeOutContent(final byte[] data, final String filename, final String mime) {          writeOutContent(data, filename, mime, true);      }
public static boolean isNotAutoRefreshParam(final ResourceParams params) {         return !(params instanceof ObjectParameter && CoreParameters.AUTO_REFRESH_NAME.equals(((ObjectParameter<?>) params).name()));     }
public static String getSuffix(String path) {          if (null == path)              return null;          int p0 = path.lastIndexOf('.');          int p1 = path.lastIndexOf('/');          if (-1 == p0 || p0 < p1)              return """";          return path.substring(p0);      }
protected List<EmvTransactionRecord> extractLogEntry(final byte[] pLogEntry) throws CommunicationException {   List<EmvTransactionRecord> listRecord = new ArrayList<EmvTransactionRecord>();   // If log entry is defined   if (template.get().getConfig().readTransactions && pLogEntry != null) {    List<TagAndLength> tals = getLogFormat();    if (tals != null && !tals.isEmpty()) {     // read all records     for (int rec = 1; rec <= pLogEntry[1]; rec++) {      byte[] response = template.get().getProvider()        .transceive(new CommandApdu(CommandEnum.READ_RECORD, rec, pLogEntry[0] << 3 | 4, 0).toBytes());      // Extract data      if (ResponseUtils.isSucceed(response)) {       try {        EmvTransactionRecord record = new EmvTransactionRecord();        record.parse(response, tals);         if (record.getAmount() != null) {         // Fix artifact in EMV VISA card         if (record.getAmount() >= 1500000000) {          record.setAmount(record.getAmount() - 1500000000);         }          // Skip transaction with null amount         if (record.getAmount() == null || record.getAmount() <= 1) {          continue;         }        }         if (record != null) {         // Unknown currency         if (record.getCurrency() == null) {          record.setCurrency(CurrencyEnum.XXX);         }         listRecord.add(record);        }       } catch (Exception e) {        LOGGER.error(""Error in transaction format: "" + e.getMessage(), e);       }      } else {       // No more transaction log or transaction disabled       break;      }     }    }   }   return listRecord;  }
int computeFieldInfoSize() {     // The access_flags, name_index, descriptor_index and attributes_count fields use 8 bytes.     int size = 8;     // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.     if (constantValueIndex != 0) {       // ConstantValue attributes always use 8 bytes.       symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE);       size += 8;     }     // Before Java 1.5, synthetic fields are represented with a Synthetic attribute.     if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0         && symbolTable.getMajorVersion() < Opcodes.V1_5) {       // Synthetic attributes always use 6 bytes.       symbolTable.addConstantUtf8(Constants.SYNTHETIC);       size += 6;     }     if (signatureIndex != 0) {       // Signature attributes always use 8 bytes.       symbolTable.addConstantUtf8(Constants.SIGNATURE);       size += 8;     }     // ACC_DEPRECATED is ASM specific, the ClassFile format uses a Deprecated attribute instead.     if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {       // Deprecated attributes always use 6 bytes.       symbolTable.addConstantUtf8(Constants.DEPRECATED);       size += 6;     }     if (firstAttribute != null) {       size += firstAttribute.computeAttributesSize(symbolTable);     }     return size;   }
private int getTagIndex(final String tag) {   if (tag == null) {    return 0;   } else {    int index = knownTags.indexOf(tag);    return index == -1 ? knownTags.size() + 1 : index + 1;   }  }
public static String jsonifyEvent(Object event, String eventType, String serverName, String wlpUserDir, String serverHostName, String[] tags,                                       int maxFieldLength) {          if (eventType.equals(CollectorConstants.GC_EVENT_TYPE)) {              if (event instanceof GCData) {                  return jsonifyGCEvent(wlpUserDir, serverName, serverHostName, event, tags);              } else {                  return jsonifyGCEvent(-1, wlpUserDir, serverName, serverHostName, CollectorConstants.GC_EVENT_TYPE, event, tags);              }          } else if (eventType.equals(CollectorConstants.MESSAGES_LOG_EVENT_TYPE)) {              return jsonifyTraceAndMessage(maxFieldLength, wlpUserDir, serverName, serverHostName, CollectorConstants.MESSAGES_LOG_EVENT_TYPE, event, tags);          } else if (eventType.equals(CollectorConstants.TRACE_LOG_EVENT_TYPE)) {              return jsonifyTraceAndMessage(maxFieldLength, wlpUserDir, serverName, serverHostName, CollectorConstants.TRACE_LOG_EVENT_TYPE, event, tags);          } else if (eventType.equals(CollectorConstants.FFDC_EVENT_TYPE)) {              return jsonifyFFDC(maxFieldLength, wlpUserDir, serverName, serverHostName, event, tags);          } else if (eventType.equals(CollectorConstants.ACCESS_LOG_EVENT_TYPE)) {              return jsonifyAccess(wlpUserDir, serverName, serverHostName, event, tags);          } else if (eventType.equals(CollectorConstants.AUDIT_LOG_EVENT_TYPE)) {              return jsonifyAudit(wlpUserDir, serverName, serverHostName, event, tags);          }         return """";      }
@Override     public void pause(String targets) throws PauseableComponentControllerRequestFailedException {          Tr.info(tc, ""info.server.pause.request.received"", targets);          Set<String> foundTargets = new HashSet<String>();          Set<String> targetList = createTargetList(targets);          if (targetList.isEmpty()) {             Tr.warning(tc, ""warning.server.pause.invalid.targets"");             throw new PauseableComponentControllerRequestFailedException(Tr.formatMessage(tc, ""warning.server.pause.invalid.targets""));         }          Set<String> failed = new HashSet<String>();          //Add each pauseable component to this list. If the tracked values get modified         //while we are iterating and we start over, skip anyone already in this list         Set<PauseableComponent> processedList = new HashSet<PauseableComponent>();          // Sync with other methods changing/querying states for PauseableComponents         synchronized (this) {             while (true) {                 try {                     for (PauseableComponent pauseableComponent : tracker.getTracked().values()) {                          if (processedList.add(pauseableComponent)) {                              if (targetList.contains(pauseableComponent.getName())) {                                 foundTargets.add(pauseableComponent.getName());                                  try {                                     pauseableComponent.pause();                                  } catch (Throwable t) {                                     // Catch anything and mark a failed Add it to the failed list.                                     failed.add(pauseableComponent.getName());                                 }                             }                         }                     }                      break;                 } catch (Throwable t) {                     // Someone modified our list of services. Retry.                 }             }         }          //Check which (if any) targets were not found         boolean targetsNotFound = false;         targetList.removeAll(foundTargets);         if (!targetList.isEmpty()) {             targetsNotFound = true;             Tr.warning(tc, ""warning.server.pause.missing.targets"", Arrays.toString(targetList.toArray()));         }          //Check if we had any failures and throw an exception back with a list of failed pauseable components.         if (!failed.isEmpty()) {              Tr.error(tc, ""error.server.pause.failed"", Arrays.toString(failed.toArray()));              throw new PauseableComponentControllerRequestFailedException(Tr.formatMessage(tc, ""error.server.pause.failed"", Arrays.toString(failed.toArray())));          } else {             Tr.info(tc, ""info.server.pause.request.completed"");              if (targetsNotFound) {                 throw new PauseableComponentControllerRequestFailedException(Tr.formatMessage(tc, ""warning.server.pause.missing.targets"", Arrays.toString(targetList.toArray())));             }         }      }
public VisualizerBuilder setColor(ColorableItem key, Color color) {   settings.colorMap.put(key, color);   return this;  }
public static double getFloatingPointDateFromDate(LocalDateTime referenceDate, LocalDateTime date) {   Duration duration = Duration.between(referenceDate, date);   return ((double)duration.getSeconds()) / SECONDS_PER_DAY;  }
public void containsKey(Object key) {     checkNotNull(key, ""AtomicLongMap does not support null keys"");     check(""asMap().keySet()"").that(actual().asMap().keySet()).contains(key);   }
public static <T> T getInstance(Class<T> clazz, boolean accessible,    Class<?>[] parameterTypes, Object[] paramValue) {   if (clazz == null)    return null;    T t = null;    try {    if (parameterTypes != null && paramValue != null) {     Constructor<T> constructor = clazz       .getDeclaredConstructor(parameterTypes);     Object[] obj = new Object[parameterTypes.length];      System.arraycopy(paramValue, 0, obj, 0, parameterTypes.length);     constructor.setAccessible(accessible);     t = constructor.newInstance(obj);    }    } catch (SecurityException e) {    log.error(""{}"",e.getMessage(),e);   } catch (NoSuchMethodException e) {    log.error(""{}"",e.getMessage(),e);   } catch (IllegalArgumentException e) {    log.error(""{}"",e.getMessage(),e);   } catch (InstantiationException e) {    log.error(""{}"",e.getMessage(),e);   } catch (IllegalAccessException e) {    log.error(""{}"",e.getMessage(),e);   } catch (InvocationTargetException e) {    log.error(""{}"",e.getMessage(),e);   }    return t;  }
private ProducerSession internalCreateProducerSession(                                                           SIDestinationAddress destAddress,                                                           DestinationType destinationType,                                                           boolean system,                                                           SecurityContext secContext,                                                           boolean keepSecurityUserid,                                                           boolean fixedMessagePoint,                                                           boolean preferLocal,                                                           boolean clearPubSubFingerprints,                                                           String discriminator)                     throws SIConnectionUnavailableException, SIConnectionDroppedException,                     SIErrorException,                     SITemporaryDestinationNotFoundException, SIIncorrectCallException, SIResourceException, SINotPossibleInCurrentConfigurationException     {         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())             SibTr.entry(                         tc,                         ""internalCreateProducerSession"",                         new Object[] { destAddress,                                       destinationType,                                       system,                                       secContext,                                       keepSecurityUserid,                                       fixedMessagePoint,                                       preferLocal,                                       clearPubSubFingerprints });          String destinationName = destAddress.getDestinationName();         String busName = destAddress.getBusName();         DestinationHandler destination =                         _destinationManager.getDestination(destinationName, busName, false, true);          // Check the destination type         checkDestinationType(destinationType, destAddress, destination, system);          // Check authority to produce to destination         // If security is disabled then we'll bypass the check         // Security changes for Liberty Messaging: Sharath Start         // Remove the If condition, since the proxy class handles it         checkDestinationAuthority(destination, MessagingSecurityConstants.OPERATION_TYPE_SEND, discriminator);         // Security changes for Liberty Messaging: Sharath End          ProducerSession producer = null;          // Synchronize on the close object, we don't want the connection closing         // while we try to add the producer.         synchronized (this)         {             // See if this connection has been closed             checkNotClosed();              producer =                             new ProducerSessionImpl(destAddress,                                             destination,                                             this,                                             secContext,                                             keepSecurityUserid,                                             fixedMessagePoint,                                             preferLocal,                                             clearPubSubFingerprints);              synchronized (_producers)             {                 //store a reference to that producer session so that we can close                 //it again later if needed                 _producers.add(producer);             }         }          if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())             SibTr.exit(tc, ""internalCreateProducerSession"", producer);         return producer; //169892     }
public byte[] convertToXmlByteArray(BucketAccelerateConfiguration accelerateConfiguration) {         XmlWriter xml = new XmlWriter();         xml.start(""AccelerateConfiguration"", ""xmlns"", Constants.XML_NAMESPACE);         xml.start(""Status"").value(accelerateConfiguration.getStatus()).end();         xml.end();         return xml.getBytes();     }
Statement detachForCall(final Expression callRender) {     checkArgument(callRender.resultType().equals(RENDER_RESULT_TYPE));     final Label reattachRender = new Label();     final SaveRestoreState saveRestoreState = variables.saveRestoreState();     // We pass NULL statement for the restore logic since we handle that ourselves below     int state = addState(reattachRender, Statement.NULL_STATEMENT);     final Statement saveState =         stateField.putInstanceField(thisExpr, BytecodeUtils.constant(state));     return new Statement() {       @Override       protected void doGen(CodeBuilder adapter) {         // Legend: RR = RenderResult, Z = boolean         callRender.gen(adapter); // Stack: RR         adapter.dup(); // Stack: RR, RR         MethodRef.RENDER_RESULT_IS_DONE.invokeUnchecked(adapter); // Stack: RR, Z         // if isDone goto Done         Label end = new Label();         adapter.ifZCmp(Opcodes.IFNE, end); // Stack: RR          saveRestoreState.save().gen(adapter);         saveState.gen(adapter);         adapter.returnValue();          adapter.mark(reattachRender);         callRender.gen(adapter); // Stack: RR         adapter.dup(); // Stack: RR, RR         MethodRef.RENDER_RESULT_IS_DONE.invokeUnchecked(adapter); // Stack: RR, Z         // if isDone goto restore         Label restore = new Label();         adapter.ifZCmp(Opcodes.IFNE, restore); // Stack: RR         // no need to save or restore anything         adapter.returnValue();         adapter.mark(restore); // Stack: RR         saveRestoreState.restore().gen(adapter);         adapter.mark(end); // Stack: RR         adapter.pop(); // Stack:       }     };   }
public String getFileContentsAsString(final File file, final String encoding)    throws IOException {   LOG.info(""Getting files contents as string: "" + file);   BufferedReader br = null;   try {    br = new BufferedReader(new InputStreamReader(new FileInputStream(      file), encoding));     StringBuilder builder = new StringBuilder();     String line = null;    while ((line = br.readLine()) != null) {     builder.append(line);    }     LOG.debug(""File contents: "" + builder);    return builder.toString();   } finally {    if (br != null) {     br.close();    }   }  }
static int parseInt(String key, @Nullable String value) {     requireArgument((value != null) && !value.isEmpty(), ""value of key %s was omitted"", key);     try {       return Integer.parseInt(value);     } catch (NumberFormatException e) {       throw new IllegalArgumentException(String.format(           ""key %s value was set to %s, must be an integer"", key, value), e);     }   }
private Function1D getDerivativeFunc(final RegressionDataSet backingResidsList, final Regressor h)     {         final Function1D fhPrime = (double x) ->         {             double c1 = x;//c2=c1-eps             double eps = 1e-5;             double c1Pc2 = c1 * 2 - eps;//c1+c2 = c1+c1-eps             double result = 0;             /*             * Computing the estimate of the derivative directly, f'(x) approx = f(x)-f(x-eps)             *             * hEst is the output of the new regressor, target is the true residual target value             *             * So we have several             * (hEst_i   c1 - target)^2 - (hEst_i   c2 -target)^2   //4 muls, 3 subs             * Where c2 = c1-eps             * Which simplifies to             * (c1 - c2) hEst ((c1 + c2) hEst - 2 target)             * =             * eps hEst (c1Pc2 hEst - 2 target)//3 muls, 1 sub, 1 shift (mul by 2)             *             * because eps is on the outside and independent of each             * individual summation, we can move it out and do the eps             * multiplicatio ont he final result.  Reducing us to             *             * 2 muls, 1 sub, 1 shift (mul by 2)             *             * per loop             *             * Which reduce computation, and allows us to get the result             * in one pass of the data             */                          for(int i = 0; i < backingResidsList.size(); i++)             {                 double hEst = h.regress(backingResidsList.getDataPoint(i));                 double target = backingResidsList.getTargetValue(i);                                  result += hEst * (c1Pc2 * hEst - 2 * target);             }                          return result * eps;         };          return fhPrime;     }
public static void runExample(AdWordsServicesInterface adWordsServices, AdWordsSession session,       Long campaignId) throws RemoteException {     // Get the CampaignSharedSetService.     CampaignSharedSetServiceInterface campaignSharedSetService =         adWordsServices.get(session, CampaignSharedSetServiceInterface.class);      // First, retrieve all shared sets associated with the campaign.     int offset = 0;     SelectorBuilder selectorBuilder = new SelectorBuilder()       .fields(           CampaignSharedSetField.SharedSetId,           CampaignSharedSetField.CampaignId,           CampaignSharedSetField.SharedSetName,           CampaignSharedSetField.SharedSetType)       .equals(CampaignSharedSetField.CampaignId, campaignId.toString())       .in(           CampaignSharedSetField.SharedSetType,           SharedSetType.NEGATIVE_KEYWORDS.getValue(),           SharedSetType.NEGATIVE_PLACEMENTS.getValue())       .limit(PAGE_SIZE);          List<Long> sharedSetIds = new ArrayList<>();     CampaignSharedSetPage campaignSharedSetPage;     do {       selectorBuilder.offset(offset);       campaignSharedSetPage = campaignSharedSetService.get(selectorBuilder.build());       for (CampaignSharedSet campaignSharedSet : campaignSharedSetPage.getEntries()) {         sharedSetIds.add(campaignSharedSet.getSharedSetId());         System.out.printf(""Campaign shared set ID %d and name '%s' found for campaign ID %d.%n"",             campaignSharedSet.getSharedSetId(), campaignSharedSet.getSharedSetName(),             campaignSharedSet.getCampaignId());       }       offset += PAGE_SIZE;     } while (offset < campaignSharedSetPage.getTotalNumEntries());      if (sharedSetIds.isEmpty()) {       System.out.printf(""No shared sets found for campaign ID %d.%n"", campaignId);       return;     }      // Next, retrieve criterion IDs for all found shared sets.     SharedCriterionServiceInterface sharedCriterionService =         adWordsServices.get(session, SharedCriterionServiceInterface.class);      // Transform shared set IDs to strings.     String[] sharedSetIdStrings = Collections2.transform(sharedSetIds, Functions.toStringFunction())         .toArray(new String[sharedSetIds.size()]);          offset = 0;     selectorBuilder = new SelectorBuilder()       .fields(""SharedSetId"", ""Id"", ""KeywordText"", ""KeywordMatchType"", ""PlacementUrl"")       .in(""SharedSetId"", sharedSetIdStrings)       .limit(PAGE_SIZE);          List<SharedCriterionOperation> removeCriterionOperations = new ArrayList<>();     SharedCriterionPage sharedCriterionPage;     do {       selectorBuilder.offset(offset);       sharedCriterionPage = sharedCriterionService.get(selectorBuilder.build());       for (SharedCriterion sharedCriterion : sharedCriterionPage.getEntries()) {         if (CriterionType.KEYWORD.equals(sharedCriterion.getCriterion().getType())) {           Keyword keyword = (Keyword) sharedCriterion.getCriterion();           System.out.printf(""Shared negative keyword with ID %d and text '%s' was found.%n"",               keyword.getId(), keyword.getText());         } else if (CriterionType.PLACEMENT.equals(sharedCriterion.getCriterion().getType())) {           Placement placement = (Placement) sharedCriterion.getCriterion();           System.out.printf(""Shared negative placement with ID %d and URL '%s' was found.%n"",               placement.getId(), placement.getUrl());         } else {           System.out.printf(""Shared criterion with ID %d was found.%n"",               sharedCriterion.getCriterion().getId());         }          // Create an operation to remove this criterion.         SharedCriterionOperation removeCriterionOperation = new SharedCriterionOperation();         removeCriterionOperation.setOperator(Operator.REMOVE);                  SharedCriterion sharedCriterionToRemove = new SharedCriterion();                  Criterion criterionToRemove = new Criterion();         criterionToRemove.setId(sharedCriterion.getCriterion().getId());                  sharedCriterionToRemove.setCriterion(criterionToRemove);         sharedCriterionToRemove.setSharedSetId(sharedCriterion.getSharedSetId());                  removeCriterionOperation.setOperand(sharedCriterionToRemove);          removeCriterionOperations.add(removeCriterionOperation);       }       offset += PAGE_SIZE;     } while (offset < sharedCriterionPage.getTotalNumEntries());      // Finally, remove the criteria.     if (removeCriterionOperations.isEmpty()) {       System.out.printf(""No shared criteria to remove.%n"");     } else {       SharedCriterionReturnValue sharedCriterionReturnValue =           sharedCriterionService.mutate(removeCriterionOperations.toArray(               new SharedCriterionOperation[removeCriterionOperations.size()]));       for (SharedCriterion removedCriterion : sharedCriterionReturnValue.getValue()) {         System.out.printf(             ""Shared criterion ID %d was successfully removed from shared set ID %d.%n"",             removedCriterion.getCriterion().getId(), removedCriterion.getSharedSetId());       }     }   }
@Override     public R visitSerialField(SerialFieldTree node, P p) {         return defaultAction(node, p);     }
public final void setHeaderColorStyle(HeaderColorStyle headerColorStyle) {         this.headerColorStyle = headerColorStyle;          if (!headerColorStyle.getColorStyle().isEmpty()) {             this.getHeaderLabel().setStyle(headerColorStyle.getColorStyle());              // It's either DEFAULT or CUSTOM value (all empty values)             // If it is DEFAULT, it sets the default style color             // Otherwise if it is CUSTOM, by default no style is applied              // (default css ""generic"" color is in play), user has             // to manually set it via setCustomHeaderColorStyle(String colorStyle)         } else {             if (headerColorStyle == HeaderColorStyle.DEFAULT) {                 switch (this.dialogType) {                     case INFORMATION:                         this.updateHeaderColorStyle(HeaderColorStyle.GLOSS_INFO);                         break;                     case ERROR:                         this.updateHeaderColorStyle(HeaderColorStyle.GLOSS_ERROR);                         break;                     case WARNING:                         this.updateHeaderColorStyle(HeaderColorStyle.GLOSS_WARNING);                         break;                     case CONFIRMATION:                         this.updateHeaderColorStyle(HeaderColorStyle.GLOSS_CONFIRM);                         break;                     case CONFIRMATION_ALT1:                         this.updateHeaderColorStyle(HeaderColorStyle.GLOSS_CONFIRM);                         break;                     case CONFIRMATION_ALT2:                         this.updateHeaderColorStyle(HeaderColorStyle.GLOSS_CONFIRM);                         break;                     case EXCEPTION:                         this.updateHeaderColorStyle(HeaderColorStyle.GLOSS_EXCEPTION);                         break;                     case INPUT_TEXT:                         this.updateHeaderColorStyle(HeaderColorStyle.GLOSS_INPUT);                         break;                     default:                         this.updateHeaderColorStyle(HeaderColorStyle.GENERIC);                         break;                 }             }         }      }
@Deprecated     public Iterable<BoxItem.Info> search(final String query) {         return new Iterable<BoxItem.Info>() {             @Override             public Iterator<BoxItem.Info> iterator() {                 QueryStringBuilder builder = new QueryStringBuilder();                 builder.appendParam(""query"", query);                 builder.appendParam(""ancestor_folder_ids"", getID());                  URL url = SEARCH_URL_TEMPLATE.buildWithQuery(getAPI().getBaseURL(), builder.toString());                 return new BoxItemIterator(getAPI(), url);             }         };     }
public void start() throws Exception     {         Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED));          //Try to restore data from backup before zookeeper will be started         backupManager.restoreAll();          activityQueue.start();         configManager.start();         monitorRunningInstance.start();         cleanupManager.start();         backupManager.start();         autoInstanceManagement.start();         if ( servoMonitoring != null )         {             servoMonitoring.start();         }          configManager.addConfigListener         (             new ConfigListener()             {                 @Override                 public void configUpdated()                 {                     try                     {                         resetLocalConnection();                     }                     catch ( IOException e )                     {                         log.add(ActivityLog.Type.ERROR, ""Resetting connection"", e);                     }                 }             }         );     }
public void purge() {         SortedQueue queue = getQueue();         _eventStore.purge(_writeChannel);         queue.clear();         _eventStore.purge(_readChannel);     }
public void addPointToTail( int x , int y ) {   int index = tail.start + tail.length*2;    int block[];   int blockIndex = tail.block + index/blockLength;   if( blockIndex == blocks.size ) {    tailBlockSize = 0;    block = blocks.grow();   } else {    block = blocks.get( blockIndex );   }   tailBlockSize += 2;   index %= blockLength;    block[index ] = x;   block[index+1 ] = y;   tail.length += 1;  }
@Override   public Set<Entry<Pair<T, I>, V>> entrySet() {    return new AbstractSet<Entry<Pair<T, I>, V>>() {     @Override     public boolean add(Entry<Pair<T, I>, V> e) {      V res = PairMap.this.put(e.getKey(), e.getValue());      return res != e.getValue();     }       @Override     public void clear() {      PairMap.this.clear();     }       @Override     public boolean contains(Object o) {      return o != null        && o instanceof Entry<?, ?>        && PairMap.this.containsKey(((Entry<?, ?>) o).getKey())        && PairMap.this.containsValue(((Entry<?, ?>) o).getValue());     }       @Override     public boolean isEmpty() {      return keys.isEmpty();     }       @Override     public Iterator<Entry<Pair<T, I>, V>> iterator() {      return new Iterator<Entry<Pair<T, I>, V>>() {       final Iterator<Pair<T, I>> keyItr = keys.iterator();       int valueIndex = -1;         @Override       public boolean hasNext() {        return keyItr.hasNext();       }         @Override       public Entry<Pair<T, I>, V> next() {        final Pair<T, I> key = keyItr.next();        valueIndex++;          return new Entry<Pair<T, I>, V>() {         @Override         public Pair<T, I> getKey() {          return key;         }           @Override         public V getValue() {          return values.get(valueIndex);         }           @Override         public V setValue(V value) {          return values.set(valueIndex, value);         }                  @Override         public String toString() {          return ""{"" + getKey() + ""="" + getValue() + ""}"";         }        };       }         @Override       public void remove() {        throw new UnsupportedOperationException();       }      };     }       @Override     public boolean remove(Object o) {      throw new UnsupportedOperationException();     }       @Override     public int size() {      return keys.size();     }    };   }
static private Type resolveTypeVariable (Class fromClass, Class current, Type type, boolean first) {   Type genericSuper = current.getGenericSuperclass();   if (!(genericSuper instanceof ParameterizedType)) return type; // No type arguments passed to super class.    // Search fromClass to current inclusive, using the call stack to traverse the class hierarchy in super class first order.   Class superClass = current.getSuperclass();   if (superClass != fromClass) {    Type resolved = resolveTypeVariable(fromClass, superClass, type, false);    if (resolved instanceof Class) return (Class)resolved; // Resolved in a super class.    type = resolved;   }    // Match the type variable name to the super class parameter.   String name = type.toString(); // Java 8: getTypeName   TypeVariable[] params = superClass.getTypeParameters();   for (int i = 0, n = params.length; i < n; i++) {    TypeVariable param = params[i];    if (param.getName().equals(name)) {     // Use the super class' type variable index to find the actual class in the sub class declaration.     Type arg = ((ParameterizedType)genericSuper).getActualTypeArguments()[i];      // Success, the type variable was explicitly declared.     if (arg instanceof Class) return (Class)arg;     if (arg instanceof ParameterizedType) return resolveType(fromClass, current, arg);      if (arg instanceof TypeVariable) {      if (first) return type; // Failure, no more sub classes.      return arg; // Look for the new type variable in the next sub class.     }    }   }    // If this happens, there is a case we need to handle.   throw new KryoException(""Unable to resolve type variable: "" + type);  }
public boolean lint(String s) {         // return true if either the specific option is enabled, or         // they are all enabled without the specific one being         // disabled         return             isSet(XLINT_CUSTOM, s) ||             (isSet(XLINT) || isSet(XLINT_CUSTOM, ""all"")) &&                 isUnset(XLINT_CUSTOM, ""-"" + s);     }
private boolean verifySignature(Signature signature, String providedSignature) {         // We can only make one call to Signature#verify here.         // Since we need to potentially check two values (one decoded from hex, the other decoded from base64),         // try hex first: It's almost certainly going to fail decoding if a base64 string was passed.         // It is extremely unlikely for base64 strings to be a valid hex string.         // This way, if it's base64, the #verify call will be skipped, and we continue with the #verify for decoded base64.         // This approach might look unnecessarily clever, but short of having redundant Signature instances,         // there doesn't seem to be a better approach for this.         try {             if (signature.verify(Hex.decodeHex(providedSignature.toCharArray()))) {                 return true;             }         } catch (SignatureException|DecoderException ignore) {             // ignore         }          try {             if (signature.verify(Base64.getDecoder().decode(providedSignature))) {                 return true;             }         } catch (SignatureException|IllegalArgumentException ignore) {             // ignore         }         return false;     }
public static String getStringForSign(PayReq request) {            Map<String, Object>  params = new HashMap<String, Object>();            // 必选参数          params.put(HwPayConstant.KEY_MERCHANTID, request.getMerchantId());          params.put(HwPayConstant.KEY_APPLICATIONID, request.getApplicationID());          params.put(HwPayConstant.KEY_PRODUCTNAME, request.getProductName());          params.put(HwPayConstant.KEY_PRODUCTDESC, request.getProductDesc());          params.put(HwPayConstant.KEY_REQUESTID, request.getRequestId());          params.put(HwPayConstant.KEY_AMOUNT, request.getAmount());            // 可选参数          params.put(HwPayConstant.KEY_PARTNER_IDS, request.getPartnerIDs());          params.put(HwPayConstant.KEY_CURRENCY, request.getCurrency());          params.put(HwPayConstant.KEY_COUNTRY, request.getCountry());          params.put(HwPayConstant.KEY_URL, request.getUrl());          params.put(HwPayConstant.KEY_URLVER, request.getUrlVer());          params.put(HwPayConstant.KEY_EXPIRETIME, request.getExpireTime());          params.put(HwPayConstant.KEY_SDKCHANNEL, request.getSdkChannel());            return getNoSign(params, false);      }
protected <T extends TokenBase> List<T> createTokenList(String text) {          if (!split) {             return createTokenList(0, text);         }          List<Integer> splitPositions = getSplitPositions(text);          if (splitPositions.isEmpty()) {             return createTokenList(0, text);         }          ArrayList<T> result = new ArrayList<>();          int offset = 0;          for (int position : splitPositions) {             result.addAll(this.<T>createTokenList(offset, text.substring(offset, position + 1)));             offset = position + 1;         }          if (offset < text.length()) {             result.addAll(this.<T>createTokenList(offset, text.substring(offset)));         }          return result;     }
private int readInt() throws IOException {     latestRead = (int)SerializationUtils.readIntegerType(input, WriterImpl.INT_BYTE_SIZE,                                                          true, input.useVInts());     return latestRead;   }
protected static String formatMessage(String message, byte[] hostData,             int start, int curPos, int bytesLen) {          StringBuilder sb = new StringBuilder();         sb.append(message);         if (hostData != null && hostData.length > 0 && curPos < hostData.length                 && curPos >= start && bytesLen > 0                 && start + bytesLen <= hostData.length) {             sb.append("". Error at offset "");             sb.append(curPos);             sb.append("" : [0x"");             int spyStart = Math.max(start - SPYBUF_MAX_LEN, 0);             appendData(sb, hostData, spyStart, start - spyStart);             sb.append(start > spyStart ? ""->"" : """");             if (curPos > start) {                 appendData(sb, hostData, start, curPos - start);                 sb.append(""^"");                 appendData(sb, hostData, curPos, bytesLen + start - curPos);             } else {                 appendData(sb, hostData, start, bytesLen);             }             int spyStop = Math.min(start + bytesLen + SPYBUF_MAX_LEN,                     hostData.length);             sb.append(spyStop > start + bytesLen ? ""<-"" : """");             appendData(sb, hostData, start + bytesLen, spyStop - start                     - bytesLen);             sb.append(""]"");         } else {             sb.append("". Position is "");             sb.append(curPos);         }         return sb.toString();      }
public ToolScreen addToolbars()     {         super.addToolbars();                  ToolScreen toolbar = new EmptyToolbar(null, this, null, ScreenConstants.DONT_DISPLAY_FIELD_DESC, null);                  Record mainFile = this.getMainRecord();                  BaseField field = this.getScreenRecord().getField(ClassVars.CLASS_KEY);         new SCannedBox(toolbar.getNextLocation(ScreenConstants.FLUSH_LEFT, ScreenConstants.SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Description"", MenuConstants.FORM, ""5"", null);         new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Logic"", MenuConstants.GROUP, ""0"", null);         new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Fields"", MenuConstants.DISTRIBUTION, ""1"", null);         new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Keys"", MenuConstants.GROUP, ""2"", null);         new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Members"", MenuConstants.DISTRIBUTION, ""3"", null);         new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Screen"", MenuConstants.GROUP, ""4"", null);         new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""File header"", MenuConstants.FORMLINK, ""9"", null);         new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Resources"", MenuConstants.DISTRIBUTION, ""7"", null);         new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Help Desc"", MenuConstants.HELP, ""6"", null);         //new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Issues"", MenuConstants.CLONE, ""8"", null);                  JavaButton pJavaButton = new JavaButton(toolbar.getNextLocation(ScreenConstants.FLUSH_LEFT, ScreenConstants.SET_ANCHOR), toolbar, null, ScreenConstants.DISPLAY_FIELD_DESC);         pJavaButton.setClassInfo((ClassInfo)mainFile);         //new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, null, ScreenConstants.DEFAULT_DISPLAY, null, ""File header"", MenuConstants.FORM, ""?screen="" + FileHdrScreen.class.getName(), null);         new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, null, ScreenConstants.DEFAULT_DISPLAY, null, ""Database info"", MenuConstants.FORM, ""?screen="" + DatabaseInfoScreen.class.getName(), null);         //new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, null, ScreenConstants.DEFAULT_DISPLAY, null, ""Layout"", MenuConstants.FORM, ""?screen="" + LayoutScreen.class.getName(), null);                  new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Import/Export"", ""Export"", ""10"", null);                  new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, null, ScreenConstants.DEFAULT_DISPLAY, null, ""Maintenance"", MenuConstants.FORM, ""?screen="" + org.jbundle.app.program.access.AccessGridScreen.class.getName(), null);         String strJob = null;         strJob = Utility.addURLParam(strJob, DBParams.TASK, DBConstants.SAPPLET); // Screen class         strJob = Utility.addURLParam(strJob, DBParams.SCREEN, "".app.program.manual.util.process.CopyHelpInfo"");    // Screen class         new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, null, ScreenConstants.DEFAULT_DISPLAY, null, ""Scan Help"", MenuConstants.RUN, strJob, null);                  return toolbar;     }
private boolean setProperty(String propertyName, int propertyValueNew) {    if(propertyName == null) return false;    Object propertyValueOld = getProperty(propertyName);    if(propertyValueOld instanceof Integer) {     int valueOld = ((Integer)propertyValueOld).intValue();     if (valueOld==propertyValueNew) return true;    }     beforeChange(propertyName);    properties.put(propertyName, Integer.valueOf(propertyValueNew));    afterChange(propertyName);    setModified(propertyName, true);    return true;   }
public void setSorting(boolean value) {         model.setSortingCategories(value);         model.setSortingProperties(value);         sortButton.setSelected(value);     }
public JNDIContentRepositoryBuilder withContextProperty(final String name, final Object value) {          contextProperties.put(name, value);         return this;     }
public EClass getGCBEZRG() {   if (gcbezrgEClass == null) {    gcbezrgEClass = (EClass)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(492);   }   return gcbezrgEClass;  }
@Override   public JsonElement serialize(Period src, Type typeOfSrc, JsonSerializationContext context)   {     final PeriodFormatter fmt = ISOPeriodFormat.standard();     return new JsonPrimitive(fmt.print(src));   }
public EClass getSCFL() {   if (scflEClass == null) {    scflEClass = (EClass)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(335);   }   return scflEClass;  }
public <T> T performGetRequest(String url, Class<T> returnType, Map<String, String> uriVariables) {          int tryNumber = 1;         while(tryNumber <= API_RETRY) {             try {                 return restTemplate.getForObject(url, returnType, uriVariables);             } catch (HttpStatusCodeException error) {                 boolean isTooManyRequestsError = handleHttpStatusCodeError(uriVariables, tryNumber, error);                 if (isTooManyRequestsError) {                     try {                         Thread.sleep(1000);                     } catch (InterruptedException e) {                         log.error(""Error in performGetRequest"", e);                     }                 } else {                     tryNumber++;                 }             } catch (Exception e) {                 handleApiError(tryNumber, e);                 tryNumber++;             }         }          throw new RestApiException(""Error getting "" + returnType.getSimpleName() + "" url variables "" + uriVariables.toString());      }
public void setActions(com.google.api.ads.admanager.axis.v201902.ProgressAction[] actions) {         this.actions = actions;     }
public WebSocketContext messageReceived(String receivedMessage) {         this.stringMessage = S.string(receivedMessage).trim();         isJson = stringMessage.startsWith(""{"") || stringMessage.startsWith(""]"");         tryParseQueryParams();         return this;     }
@Override     public java.util.concurrent.Future<ListVerifiedEmailAddressesResult> listVerifiedEmailAddressesAsync(             com.amazonaws.handlers.AsyncHandler<ListVerifiedEmailAddressesRequest, ListVerifiedEmailAddressesResult> asyncHandler) {          return listVerifiedEmailAddressesAsync(new ListVerifiedEmailAddressesRequest(), asyncHandler);     }
private Node<T> min(Node<T> x) {       do {        if (x.left == null) return x;        x = x.left;       } while (true);      }
public Matrix3d set(Matrix4fc mat) {         m00 = mat.m00();         m01 = mat.m01();         m02 = mat.m02();         m10 = mat.m10();         m11 = mat.m11();         m12 = mat.m12();         m20 = mat.m20();         m21 = mat.m21();         m22 = mat.m22();         return this;     }
@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)  public int getTotalPaddingStart (){   if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1)    return getPaddingStart() + mInputView.getTotalPaddingStart();    return getTotalPaddingLeft();  }
@Nonnull   public PSTitle readTitleFromXML (@Nonnull final IMicroElement eTitle)   {     final PSTitle ret = new PSTitle ();      eTitle.forAllAttributes ( (sNS, sAttrName, sVal) -> {       final String sAttrValue = _getAttributeValue (sVal);       _warn (ret, ""Unsupported attribute '"" + sAttrName + ""'='"" + sAttrValue + ""'"");     });      eTitle.forAllChildren (aTitleChild -> {       switch (aTitleChild.getType ())       {         case TEXT:           ret.addText (((IMicroText) aTitleChild).getNodeValue ());           break;         case ELEMENT:           final IMicroElement eElement = (IMicroElement) aTitleChild;           if (CSchematron.NAMESPACE_SCHEMATRON.equals (eElement.getNamespaceURI ()))           {             final String sLocalName = eElement.getLocalName ();             if (sLocalName.equals (CSchematronXML.ELEMENT_DIR))               ret.addDir (readDirFromXML (eElement));             else               _warn (ret, ""Unsupported Schematron element '"" + sLocalName + ""'"");           }           else             _warn (ret, ""Unsupported namespace URI '"" + eElement.getNamespaceURI () + ""'"");            break;         case COMMENT:           // Ignore comments           break;         default:           _warn (ret, ""Unsupported child node: "" + aTitleChild);       }     });     return ret;   }
@Override  public String getText() {    // sets text from input if not text directly available   text = super.getText();    int t;   try {    t = typeMapper.inverse().get(type);   } catch (NullPointerException e) {    return text;   }   switch (t) {    case FUNCTION:     return text.substring(0, text.length()-1);    case URI:     return extractURI(text);             case UNCLOSED_URI:                 return extractUNCLOSEDURI(text);    case STRING:     return extractSTRING(text);    case UNCLOSED_STRING:     return extractUNCLOSEDSTRING(text);    case CLASSKEYWORD:     return extractCLASSKEYWORD(text);    case HASH:     return extractHASH(text);    default:     return text;   }   }
public void showFeedback(String feedbackText) {         feedbackSpan.setText(feedbackText);         new MaterialAnimation().transition(Transition.FADEINUP).duration(400).animate(feedbackSpan);         MaterialLoader.loading(true, getCurrentStep().getDivBody());         add(divFeedback);     }
private String expandMessage(final BuildEvent event, final String message) {         final HashMap<String,String> data=new HashMap<String, String>();          final String user = retrieveUserName(event);         if(null!=user){             data.put(""user"", user);         }         final String node = retrieveNodeName(event);         if(null!=node){             data.put(""node"", node);         }         data.put(""level"", logLevelToString(event.getPriority()));         if(null!=formatter){              return formatter.reformat(data, message);         }else {             return message;         }     }
private SearchControls getCallerSearchControls() {         String[] attrIds = { idStoreDefinition.getCallerNameAttribute() };         long limit = Long.valueOf(idStoreDefinition.getMaxResults());         int timeOut = idStoreDefinition.getReadTimeout();         int scope = getSearchScope(idStoreDefinition.getCallerSearchScope());         return new SearchControls(scope, limit, timeOut, attrIds, false, false);     }
public void execute( EnforcerRuleHelper theHelper )         throws EnforcerRuleException     {         List<String> missingProfiles = new ArrayList<String>();         try         {             MavenProject project = (MavenProject) theHelper.evaluate( ""${project}"" );             if ( StringUtils.isNotEmpty( profiles ) )             {                 String[] profs = profiles.split( "","" );                 for ( String profile : profs )                 {                     if ( !isProfileActive( project, profile ) )                     {                         missingProfiles.add( profile );                     }                 }                  boolean fail = false;                 if ( !missingProfiles.isEmpty() )                 {                     fail = true;                     // if (all && missingProfiles.size() != profs.length)                     // {                     // fail = true;                     // }                     // else                     // {                     // if (!all && missingProfiles.size() >= (profs.length -1))                     // {                     // fail = true;                     // }                     // }                 }                  if ( fail )                 {                     String message = getMessage();                     StringBuilder buf = new StringBuilder();                     if ( message != null )                     {                         buf.append( message + ""\n"" );                     }                      for ( String profile : missingProfiles )                     {                         buf.append( ""Profile \"""" + profile + ""\"" is not activated.\n"" );                     }                      throw new EnforcerRuleException( buf.toString() );                 }              }          }         catch ( ExpressionEvaluationException e )         {             throw new EnforcerRuleException( ""Unable to retrieve the project."", e );         }      }
public static int listFindIgnoreEmpty(String list, String value, char delimiter) {  if (list == null) return -1;  int len = list.length();  if (len == 0) return -1;  int last = 0;  int count = 0;   for (int i = 0; i < len; i++) {      if (list.charAt(i) == delimiter) {   if (last < i) {       if (list.substring(last, i).equals(value)) return count;       count++;   }   last = i + 1;      }  }  if (last < len) {      if (list.substring(last).equals(value)) return count;  }  return -1;     }
@Pure  public RoadSegment getConnectableSegmentToLastPoint(RoadPath path) {   assert path != null;   if (path.isEmpty()) {    return null;   }   RoadConnection last1 = getLastPoint();   RoadConnection first2 = path.getFirstPoint();   RoadConnection last2 = path.getLastPoint();   last1 = last1.getWrappedRoadConnection();   first2 = first2.getWrappedRoadConnection();   last2 = last2.getWrappedRoadConnection();   if (last1.equals(first2)) {    return path.getFirstSegment();   }   if (last1.equals(last2)) {    return path.getLastSegment();   }   return null;  }
private static void setSystemClassLoaderClassPath() throws Exception {         Log.d(""Setting classpath"");         // We use agent class as we do not extract this class in newly created         // jar (otherwise we may end up creating one -magic jar from another);         // also it will exist even without JUnit classes).         URL url = EkstaziAgent.class.getResource(EkstaziAgent.class.getSimpleName() + "".class"");         String origPath = url.getFile().replace(""file:"", """").replaceAll("".jar!.*"", "".jar"");         File junitJar = new File(origPath);         File xtsJar = new File(origPath.replaceAll("".jar"", ""-magic.jar""));          boolean isCreated = false;         // If extracted (Tool) jar is newer than junit*.jar, there is no reason         // to extract files again, so just return in that case.         if (FileUtil.isSecondNewerThanFirst(junitJar, xtsJar)) {             // We cannot return here, as we have to include jar on the path.             isCreated = true;         } else {             // Extract new jar as junit.jar is newer.             String[] includePrefixes = { Names.EKSTAZI_PACKAGE_BIN };             String[] excludePrefixes = { EkstaziAgent.class.getName() };             isCreated = JarXtractor.extract(junitJar, xtsJar, includePrefixes, excludePrefixes);         }          // Add jar to classpath if it was successfully created, otherwise throw         // an exception.         if (isCreated) {             addURL(xtsJar.toURI().toURL());         } else {             throw new RuntimeException(""Could not extract Tool classes in separate jar."");         }     }
private QueryBuilderKraken parseCreate()   {     Token token;      // TableBuilderKraken factory = null;// = _database.createTableFactory();      if ((token = scanToken()) != Token.TABLE)       throw error(""expected TABLE at '{0}'"", token);      if ((token = scanToken()) != Token.IDENTIFIER)       throw error(""expected identifier at '{0}'"", token);          String name = _lexeme;     String pod = null;          while (peekToken() == Token.DOT) {       scanToken();              if ((token = scanToken()) != Token.IDENTIFIER) {         throw error(""expected identifier at '{0}'"", token);       }            if (pod == null) {         pod = name;       }       else {         pod = pod + '.' + name;       }              name = _lexeme;     }          if (pod == null) {       pod = getPodName();     }      TableBuilderKraken factory = new TableBuilderKraken(pod, name, _sql);     // factory.startTable(_lexeme);      if ((token = scanToken()) != Token.LPAREN) {       throw error(""expected '(' at '{0}'"", token);     }      do {       token = scanToken();        switch (token) {       case IDENTIFIER:         parseCreateColumn(factory, _lexeme);         break;          /*       case UNIQUE:         token = scanToken();                  if (token != KEY) {           _token = token;         }                  factory.addUnique(parseColumnNames());         break;         */        case PRIMARY:         token = scanToken();         if (token != Token.KEY)           throw error(""expected 'key' at {0}"", token);          factory.addPrimaryKey(parseColumnNames());         break;        case KEY:         //String key = parseIdentifier();          factory.addPrimaryKey(parseColumnNames()); // factory.addPrimaryKey(parseColumnNames());         break;          /*       case CHECK:         if ((token = scanToken()) != '(')           throw error(L.l(""Expected '(' at '{0}'"", tokenName(token)));          parseExpr();          if ((token = scanToken()) != ')')           throw error(L.l(""Expected ')' at '{0}'"", tokenName(token)));         break;         */        default:         throw error(""unexpected token '{0}'"", token);       }        token = scanToken();     } while (token == Token.COMMA);      if (token != Token.RPAREN) {       throw error(""expected ')' at '{0}'"", token);     }          token = scanToken();          HashMap<String,String> propMap = new HashMap<>();          if (token == Token.WITH) {       do {         String key = parseIdentifier();         ExprKraken expr = parseExpr();          if (! (expr instanceof LiteralExpr)) {           throw error(""WITH expression must be a literal at '{0}'"", expr);         }                  String value = expr.evalString(null);                  propMap.put(key, value);       } while ((token = scanToken()) == Token.COMMA);     }          if (token != Token.EOF) {       throw error(""Expected end of file at '{0}'"", token);     }      return new CreateQueryBuilder(_tableManager, factory, _sql, propMap);   }
public void debug(Object message, Throwable exception) {     log(Level.DEBUG, message, exception);   }
@Override     public DetachVolumeResult detachVolume(DetachVolumeRequest request) {         request = beforeClientExecution(request);         return executeDetachVolume(request);     }
public void setTransformDef( File transformDef)     {     options_.setTransformDef( transformDef);     if( transformDef != null)       {       options_.setTransformType( Options.TransformType.CUSTOM);       }     }
void setAttribute(File file, String attribute, Object value) {     state.checkOpen();     // TODO(cgdecker): Change attribute stuff to avoid the sad boolean parameter     attributes.setAttribute(file, attribute, value, false);   }
private BT advanceAndRead(BT reuse) throws IOException {   if (!partitions.hasNext()) {    return null;   }   currentPartition = partitions.next();   currentPartition.setReadPosition(0);    try {    reuse = serializer.deserialize(reuse, currentPartition);   } catch (EOFException e) {    reuse = advanceAndRead(reuse);   }   return reuse;  }
private Record parseResponse(InputStream response) throws StageException {     Record record = null;     if (conf.httpMethod == HttpMethod.HEAD) {       // Head will have no body so can't be parsed.   Return an empty record.       record = getContext().createRecord("""");       record.set(Field.create(new HashMap()));      } else if (response != null) {       try (DataParser parser = parserFactory.getParser("""", response, ""0"")) {         // A response may only contain a single record, so we only parse it once.         record = parser.parse();         if (conf.dataFormat == DataFormat.TEXT) {           // Output is placed in a field ""/text"" so we remove it here.           record.set(record.get(""/text""));         }       } catch (IOException | DataParserException e) {         errorRecordHandler.onError(Errors.HTTP_00, e.toString(), e);       }     }     return record;   }
public static <T> String toXml(T obj, XAlias[] xAlias,                                    XAliasField[] xAliasFields, XAliasAttribute[] xAliasAttributes,                                    XOmitField[] xOmitFields) {          return toXml(obj, xAlias, xAliasFields, xAliasAttributes, xOmitFields,                 null, null, null);     }
private final void replaceAll(final Element root,             final Map<String, String> replacements) {         String selector;    // Iterated selector         String replacement; // Iterated HTML replacement         Element replacementElem; // Iterated replacement         Collection<Element> elements; // Selected elements         Element replacementBody; // Body of the replacement          for (final Entry<String, String> replacementEntry : replacements                 .entrySet()) {             selector = replacementEntry.getKey();             replacement = replacementEntry.getValue();              elements = root.select(selector);             if (!elements.isEmpty()) {                 // There are elements to replace                  // Processes the replacement                 replacementBody = Jsoup.parse(replacement).body();                 if (!replacementBody.children().isEmpty()) {                     replacementElem = replacementBody.child(0);                      // Replaces the elements                     for (final Element element : elements) {                         element.replaceWith(replacementElem.clone());                     }                 }             }         }     }
public <T> List<T> querySingleRowTypedResults(String sql, String[] args) {   return db.querySingleRowTypedResults(sql, args);  }
private synchronized static Pattern getPattern(String tagName,    String attrName) {    String key = tagName + ""    "" + attrName;   Pattern pc = pcPatterns.get(key);   if (pc == null) {     String tagPatString = ""<\\s*"" + tagName + ""\\s+[^>]*\\b"" + attrName      + ""\\s*=\\s*("" + ANY_ATTR_VALUE + "")(?:\\s|>)?"";     pc = Pattern.compile(tagPatString, Pattern.CASE_INSENSITIVE);    pcPatterns.put(key, pc);   }   return pc;  }
public void marshall(JobWatermark jobWatermark, ProtocolMarshaller protocolMarshaller) {          if (jobWatermark == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(jobWatermark.getPresetWatermarkId(), PRESETWATERMARKID_BINDING);             protocolMarshaller.marshall(jobWatermark.getInputKey(), INPUTKEY_BINDING);             protocolMarshaller.marshall(jobWatermark.getEncryption(), ENCRYPTION_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public byte[] toBytes()     {         if (tc.isEntryEnabled()) Tr.entry(tc, ""toBytes"");          final byte[] result = new byte[16];          final int t1 = (int)(_timestamp >> 32 & 0xFFFFFFFFL);         final int t2 = (int)(_timestamp & 0xFFFFFFFFL);         Util.setBytesFromInt(result, 0, 4, t1);         Util.setBytesFromInt(result, 4, 4, t2);         Util.setBytesFromInt(result, 8, 4, _epochNumber);         Util.setBytesFromInt(result,12, 4, _sequenceNumber);          if (tc.isEntryEnabled()) Tr.exit(tc, ""toBytes"", Util.toHexString(result));         return result;     }
public static MemoryCache createMemoryCache(Context context, int memoryCacheSize) {   if (memoryCacheSize == 0) {    ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);    int memoryClass = am.getMemoryClass();    if (hasHoneycomb() && isLargeHeap(context)) {     memoryClass = getLargeMemoryClass(am);    }    memoryCacheSize = 1024 * 1024 * memoryClass / 8;   }   return new LruMemoryCache(memoryCacheSize);  }
public OperationFuture<Database, CreateDatabaseMetadata> createDatabase(       String databaseId, Iterable<String> statements) throws SpannerException {     return dbClient.createDatabase(instanceId(), databaseId, statements);   }
public static String parseDate( String text )  {   // loads the script if not loaded yet   if( !loaded )   {    loaded = true;     String scriptContent = null;    if( LocaleInfo.getCurrentLocale().getLocaleName().startsWith( ""fr"" ) )    {     DateFrJSBundle bundle = GWT.create( DateFrJSBundle.class );     scriptContent = bundle.DateJsFr().getText();    }    else    {     DateJSBundle bundle = GWT.create( DateJSBundle.class );     scriptContent = bundle.DateJs().getText();    }     Document doc = Document.get();    ScriptElement sqljs = doc.createScriptElement();    sqljs.setAttribute( ""type"", ""text/javascript"" );    sqljs.setInnerText( scriptContent );    doc.getDocumentElement().getFirstChildElement().appendChild( sqljs );   }    JavaScriptObject date = create( text );   if( date == null )    return null;    String res = toConformity( date );    return res;  }
@RequirePOST     public HttpResponse doApproveAll() throws IOException {         StringBuilder buf = new StringBuilder();         for (Class c : rejected.get()) {             buf.append(c.getName()).append('\n');         }         whitelisted.append(buf.toString());          return HttpResponses.ok();     }
public void writeTo(OutputStream out) throws IOException  {   if (mLength > mBufferSizeLimit)   {    throw new IllegalStateException(""Can't write after a buffer overflow."");   }    if (mLength == 0)   {    // nothing to do    return;   }    // write all previous chunks   int count = mCurrentChunkIndex;   for (int i = 0; i < count; ++i)   {    out.write(mChunkList.get(i));   }    // write the current partial chunk   out.write(mCurrentChunk, 0, mPosInChunk);  }
public void shutdown() {         for (Connection connection : _connectionMap.values()) {             connection.shutdown();         }          for (Connection connection : _privilegedConnectionMap.values()) {             connection.shutdown();         }          _factory.releaseExternalResources();     }
public WebSocketContext sendToUser(String message, String username) {         return sendToConnections(message, username, manager.usernameRegistry(), true);     }
@Override     public PutApprovalResultResult putApprovalResult(PutApprovalResultRequest request) {         request = beforeClientExecution(request);         return executePutApprovalResult(request);     }
public static <C extends Collection<String>> C splitString(String line, char delim, C words) {   return splitString(line, 0, line.length(), delim, words);  }
public void addOrUpdateReceiver(ActivityInfo receiverInfo) {     addComponent(         receiverFilters,         p -> p.receivers,         (p, a) -> p.receivers = a,         new ActivityInfo(receiverInfo),         true);   }
public static Map<String, List<String>> toHashMap(final String aFilePath, final String aPattern,             final String... aIgnoreList) throws FileNotFoundException {         final String filePattern = aPattern != null ? aPattern : WILDCARD;         final RegexFileFilter filter = new RegexFileFilter(filePattern);         final Map<String, List<String>> fileMap = new HashMap<>();         final File source = new File(aFilePath);          for (final File file : listFiles(source, filter, true, aIgnoreList)) {             final String fileName = file.getName();             final String filePath = file.getAbsolutePath();              if (fileMap.containsKey(fileName)) {                 final List<String> paths = fileMap.get(fileName);                  if (!paths.contains(filePath)) {                     paths.add(filePath);                 } else {                     throw new I18nRuntimeException(BUNDLE_NAME, MessageCodes.UTIL_034);                 }             } else {                 final ArrayList<String> pathList = new ArrayList<>();                 pathList.add(filePath);                 fileMap.put(fileName, pathList);             }         }          return Collections.unmodifiableMap(fileMap);     }
static public void skip(InputStream is, int size) throws IOException {      long n;   while (size > 0) {          n = is.skip(size);          if (n <= 0)              break;    size -= n;   }  }
private int parseContentLength(int maxPostDataSize, String length) {         if(length!=null) {             try {                 int size = Integer.parseInt(length);                 if(size>maxPostDataSize) return -1;                 else return size;             } catch(NumberFormatException e) {                 // should never occur.  invalid content length i.e. abc, is usually                 // caught by the container.  However, a user could specify a Content-Length with                 // a value larger than an int max size                 return -1;             }         } else {             return -2;         }     }
public static PhantomJSDriverService createDefaultService(Capabilities desiredCapabilities) {         // Look for Proxy configuration within the Capabilities         Proxy proxy = null;         if (desiredCapabilities != null) {             proxy = Proxy.extractFrom(desiredCapabilities);         }          // Find PhantomJS executable         File phantomjsfile = findPhantomJS(desiredCapabilities, PHANTOMJS_DOC_LINK, PHANTOMJS_DOWNLOAD_LINK);          // Find GhostDriver main JavaScript file         File ghostDriverfile = findGhostDriver(desiredCapabilities, GHOSTDRIVER_DOC_LINK, GHOSTDRIVER_DOWNLOAD_LINK);          // Build & return service         return new Builder().usingPhantomJSExecutable(phantomjsfile)                 .usingGhostDriver(ghostDriverfile)                 .usingAnyFreePort()                 .withProxy(proxy)                 .withLogFile(findLogFile())                 .withAcceptSslCerts(findAcceptSslCerts(desiredCapabilities))                 .usingCommandLineArguments(                         findCLIArgumentsFromCaps(desiredCapabilities, PHANTOMJS_CLI_ARGS))                 .usingGhostDriverCommandLineArguments(                         findCLIArgumentsFromCaps(desiredCapabilities, PHANTOMJS_GHOSTDRIVER_CLI_ARGS))                 .build();     }
private static int parseNanos(String value) throws ParseException {     int result = 0;     for (int i = 0; i < 9; ++i) {       result = result * 10;       if (i < value.length()) {         if (value.charAt(i) < '0' || value.charAt(i) > '9') {           throw new ParseException(""Invalid nanoseconds."", 0);         }         result += value.charAt(i) - '0';       }     }     return result;   }
public static Iterator<Object> getValues(Object[] array)     {         if (array == null)         {             return null;         }         ArrayList<Object> valueList = new ArrayList<Object>();         int i = array.length - 1;         while (i >= 0)         {             valueList.add(array[i]);             i = i - 2;         }         return valueList.iterator();     }
protected void layoutCharts() {         //Pre-sort charts by group column         MultiValuedMap<DJGroup, DJChart> mmap = new ArrayListValuedHashMap<DJGroup, DJChart>();         for (DJChart djChart : getReport().getCharts()) {             mmap.put(djChart.getColumnsGroup(), djChart);         }          for (DJGroup key : mmap.keySet()) {             Collection<DJChart> charts = mmap.get(key);             List<DJChart> l = new ArrayList<DJChart>(charts);             //Reverse iteration of the charts to meet insertion order             for (int i = l.size(); i > 0; i--) {                 DJChart djChart = l.get(i - 1);                 JRDesignChart chart = createChart(djChart);                  //Charts has their own band, so they are added in the band at Y=0                 JRDesignBand band = createGroupForChartAndGetBand(djChart);                 band.addElement(chart);             }         }          //Pre-sort charts by group column         MultiValuedMap<PropertyColumn, ar.com.fdvs.dj.domain.chart.DJChart> mmap2 = new ArrayListValuedHashMap<PropertyColumn, ar.com.fdvs.dj.domain.chart.DJChart>();         for (ar.com.fdvs.dj.domain.chart.DJChart djChart : getReport().getNewCharts()) {             mmap2.put(djChart.getDataset().getColumnsGroup(), djChart);         }          for (PropertyColumn key : mmap2.keySet()) {             Collection<ar.com.fdvs.dj.domain.chart.DJChart> charts = mmap2.get(key);             ArrayList<ar.com.fdvs.dj.domain.chart.DJChart> l = new ArrayList<ar.com.fdvs.dj.domain.chart.DJChart>(charts);             //Reverse iteration of the charts to meet insertion order             for (int i = l.size(); i > 0; i--) {                 ar.com.fdvs.dj.domain.chart.DJChart djChart = l.get(i - 1);                 String name = ""chart_"" + (i - 1) + new Date().getTime();                 JRDesignChart chart = createChart(djChart, name);                  if (djChart.getLink() != null)                     HyperLinkUtil.applyHyperLinkToElement((DynamicJasperDesign) getDesign(), djChart.getLink(), chart, name + ""_hyperlink"");                  //Charts has their own band, so they are added in the band at Y=0                 JRDesignBand band = createGroupForChartAndGetBand(djChart);                 band.addElement(chart);             }         }     }
private byte buildFlagsByte() {    byte flag = 0;    // Add the binary type to bit 5, 0 for standard and 1 for extended   int binaryType = extended ? 1 : 0;   flag += (binaryType << 5);    // Add the empty geometry flag to bit 4, 0 for non-empty and 1 for   // empty   int emptyValue = empty ? 1 : 0;   flag += (emptyValue << 4);    // Add the envelope contents indicator code (3-bit unsigned integer to   // bits 3, 2, and 1)   int envelopeIndicator = envelope == null ? 0 : getIndicator(envelope);   flag += (envelopeIndicator << 1);    // Add the byte order to bit 0, 0 for Big Endian and 1 for Little   // Endian   int byteOrderValue = (byteOrder == ByteOrder.BIG_ENDIAN) ? 0 : 1;   flag += byteOrderValue;    return flag;  }
@Override     public void removeAppender(String name) {         if (name == null || aai == null) {             return;         }         Appender appender = aai.getAppender(name);         aai.removeAppender(name);         if (appender != null) {             fireRemoveAppenderEvent(appender);         }     }
public List<Object> find(Object locator, boolean required) throws ReferenceException {   return find(Object.class, locator, required);  }
private <T> GroupBuilder<T> convertFields(GroupBuilder<T> groupBuilder, List<FieldDescriptor> fieldDescriptors) {     for (FieldDescriptor fieldDescriptor : fieldDescriptors) {       groupBuilder =           addField(fieldDescriptor, groupBuilder)           .id(fieldDescriptor.getNumber())           .named(fieldDescriptor.getName());     }     return groupBuilder;   }
public int getState()    {       boolean hasSuspendedComponents = false;       boolean hasResumedComponents = false;       List<Suspendable> suspendableComponents = getComponentInstancesOfType(Suspendable.class);       for (Suspendable component : suspendableComponents)       {          if (component.isSuspended())          {             hasSuspendedComponents = true;          }          else          {             hasResumedComponents = true;          }       }        if (hasSuspendedComponents && !hasResumedComponents)       {          return ManageableRepository.SUSPENDED;       }       else if (!hasSuspendedComponents)       {          return ManageableRepository.ONLINE;       }       else       {          return ManageableRepository.UNDEFINED;       }    }
public static String getDefaultPort(SystemInfo.BoardType board) throws UnsupportedBoardType {         switch (board){             // ------------------------             // ALL RASPBERRY PI MODELS             // (except Model 3B)             // ------------------------             case RaspberryPi_A:             case RaspberryPi_B_Rev1:             case RaspberryPi_B_Rev2:             case RaspberryPi_A_Plus:             case RaspberryPi_B_Plus:             case RaspberryPi_ComputeModule:             case RaspberryPi_2B:             case RaspberryPi_Zero:             case RaspberryPi_ComputeModule3:             case RaspberryPi_ZeroW:             case RaspberryPi_Alpha:             case RaspberryPi_Unknown: {                 return RaspberryPiSerial.DEFAULT_COM_PORT;             }              // ---------------------------             // RASPBERRY PI MODEL 3B, 3B+             // ---------------------------             case RaspberryPi_3B:             case RaspberryPi_3B_Plus: {                 // if the /dev/ttyS0 port exists, then use it as the default serial port                 File s0ComPort = new File(RaspberryPiSerial.S0_COM_PORT);                 if((s0ComPort.exists())){                     return RaspberryPiSerial.S0_COM_PORT;                 }                 return RaspberryPiSerial.DEFAULT_COM_PORT;             }              // ------------------------             // BANANAPI and BANANAPRO             // ------------------------             case BananaPi: {                 return BananaPiSerial.DEFAULT_COM_PORT;             }             case BananaPro: {                 return BananaProSerial.DEFAULT_COM_PORT;             }              // ------------------------             // BPI             // ------------------------             // TODO : Implement serial for BPI boards    case Bpi_M1:     break;    case Bpi_M1P:     break;    case Bpi_M2:     break;    case Bpi_M2M:     break;    case Bpi_M2P:     break;    case Bpi_M2P_H2_Plus:     break;    case Bpi_M2P_H5:     break;    case Bpi_M2U:     break;    case Bpi_M2U_V40:     break;    case Bpi_M3:     break;    case Bpi_M64:     break;    case Bpi_R1:     break;              // ------------------------             // NANOPI             // ------------------------             // TODO : Implement serial for NanoPi boards    case NanoPi_A64:     break;    case NanoPi_K2:     break;    case NanoPi_M1:     break;    case NanoPi_M1_Plus:     break;    case NanoPi_M3:     break;    case NanoPi_NEO:     break;    case NanoPi_NEO2:     break;    case NanoPi_NEO2_Plus:     break;    case NanoPi_NEO_Air:     break;    case NanoPi_S2:     break;              // ------------------------             // ODROID             // ------------------------             // TODO : Implement serial for Odroid boards     case Odroid:     break;              // ------------------------             // ORANGEPI             // ------------------------             // TODO : Implement serial for OrangePi boards    case OrangePi:     break;              // ------------------------             // UNKNOWN             // ------------------------    case UNKNOWN:     break;    default:     break;         }          // unknown board type, return null         throw new UnsupportedBoardType();  }
public static void downloadFile(final String url, final File file) throws IOException {   try (    InputStream inputStream = new URL(url).openStream();    ReadableByteChannel rbc = Channels.newChannel(inputStream);    FileChannel fileChannel = FileChannel.open(     file.toPath(),     StandardOpenOption.CREATE,     StandardOpenOption.TRUNCATE_EXISTING,     StandardOpenOption.WRITE)   ) {    fileChannel.transferFrom(rbc, 0, Long.MAX_VALUE);   }  }
public void marshall(JobLogs jobLogs, ProtocolMarshaller protocolMarshaller) {          if (jobLogs == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(jobLogs.getJobCompletionReportURI(), JOBCOMPLETIONREPORTURI_BINDING);             protocolMarshaller.marshall(jobLogs.getJobSuccessLogURI(), JOBSUCCESSLOGURI_BINDING);             protocolMarshaller.marshall(jobLogs.getJobFailureLogURI(), JOBFAILURELOGURI_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public JSONArray optJSONArray(int index) {   Object object = opt(index);   return object instanceof JSONArray ? (JSONArray) object : null;  }
public SourceUnit addSource(File file) {         return addSource(new SourceUnit(file, configuration, classLoader, getErrorCollector()));     }
protected String findString(String expr, String field, String errorMsg) {     if (expr == null) {       throw fieldError(field, errorMsg, null);     } else {       return findString(expr);     }   }
protected void validate(String operationType) throws Exception   {    super.validate(operationType);      MPSInternetHost dest_server_validator = new MPSInternetHost();    dest_server_validator.setConstraintIsReq(MPSConstants.DELETE_CONSTRAINT, true);    dest_server_validator.setConstraintIsReq(MPSConstants.ADD_CONSTRAINT, true);    dest_server_validator.setConstraintIsReq(MPSConstants.MODIFY_CONSTRAINT, true);    dest_server_validator.validate(operationType, dest_server, ""\""dest_server\"""");        MPSInt dest_port_validator = new MPSInt();    dest_port_validator.setConstraintMaxValue(MPSConstants.GENERIC_CONSTRAINT, 65535);    dest_port_validator.validate(operationType, dest_port, ""\""dest_port\"""");        MPSString community_validator = new MPSString();    community_validator.setConstraintCharSetRegEx(MPSConstants.GENERIC_CONSTRAINT,""[ a-zA-Z0-9_#.:@=-]+"");    community_validator.setConstraintMaxStrLen(MPSConstants.GENERIC_CONSTRAINT, 128);    community_validator.validate(operationType, community, ""\""community\"""");       }
public static <T> boolean all(Iterable<T> iterable, Predicate<? super T> predicate) {     return Iterators.all(iterable.iterator(), predicate);   }
public float getPixel(int x, int y) {   float pixel = -1;   if (rasters == null) {    readPixels();   }   if (rasters != null) {    pixel = rasters.getFirstPixelSample(x, y).floatValue();   } else {    throw new GeoPackageException(""Could not retrieve pixel value"");   }   return pixel;  }
static AttrAccept createFromString(final String str)     throws BOSHException {         if (str == null) {             return null;         } else {             return new AttrAccept(str);         }     }
@Override  public String getName(String languageId, boolean useDefault) {   return _commerceCurrency.getName(languageId, useDefault);  }
public static ColumnText duplicate(ColumnText org) {         ColumnText ct = new ColumnText(null);         ct.setACopy(org);         return ct;     }
public boolean isDone() {     if (status() == Status.DONE) {       return true;     }     ChangeRequest updated = reload(Dns.ChangeRequestOption.fields(Dns.ChangeRequestField.STATUS));     return updated == null || updated.status() == Status.DONE;   }
public GeometryIndexType getType(GeometryIndex index) {   if (index.hasChild()) {    return getType(index.getChild());   }   return index.getType();  }
@Override   public final String escape(String s) {     checkNotNull(s); // GWT specific check (do not optimize).     for (int i = 0; i < s.length(); i++) {       char c = s.charAt(i);       if ((c < replacementsLength && replacements[c] != null) || c > safeMax || c < safeMin) {         return escapeSlow(s, i);       }     }     return s;   }
public static OpenImmoDocument createDocument(InputStream input) throws SAXException, IOException, ParserConfigurationException {         return createDocument(XmlUtils.newDocument(input, true));     }
public void write(Collection<?> objects, boolean allOrNothing, OutputStream out) {   try {    JsonGenerator jg = objectMapper.getFactory().createGenerator(out, JsonEncoding.UTF8);    jg.writeStartObject();    if (allOrNothing) {     jg.writeBooleanField(""all_or_nothing"", true);    }    jg.writeArrayFieldStart(""docs"");    for (Object o : objects) {     jg.writeObject(o);    }    jg.writeEndArray();    jg.writeEndObject();    jg.flush();    jg.close();   } catch (Exception e) {    throw Exceptions.propagate(e);   } finally {    IOUtils.closeQuietly(out);   }  }
public static int getSurplusQueuedTaskCount() {         /*          * The aim of this method is to return a cheap heuristic guide          * for task partitioning when programmers, frameworks, tools,          * or languages have little or no idea about task granularity.          * In essence by offering this method, we ask users only about          * tradeoffs in overhead vs expected throughput and its          * variance, rather than how finely to partition tasks.          *          * In a steady state strict (tree-structured) computation,          * each thread makes available for stealing enough tasks for          * other threads to remain active. Inductively, if all threads          * play by the same rules, each thread should make available          * only a constant number of tasks.          *          * The minimum useful constant is just 1. But using a value of          * 1 would require immediate replenishment upon each steal to          * maintain enough tasks, which is infeasible.  Further,          * partitionings/granularities of offered tasks should          * minimize steal rates, which in general means that threads          * nearer the top of computation tree should generate more          * than those nearer the bottom. In perfect steady state, each          * thread is at approximately the same level of computation          * tree. However, producing extra tasks amortizes the          * uncertainty of progress and diffusion assumptions.          *          * So, users will want to use values larger, but not much          * larger than 1 to both smooth over transient shortages and          * hedge against uneven progress; as traded off against the          * cost of extra task overhead. We leave the user to pick a          * threshold value to compare with the results of this call to          * guide decisions, but recommend values such as 3.          *          * When all threads are active, it is on average OK to          * estimate surplus strictly locally. In steady-state, if one          * thread is maintaining say 2 surplus tasks, then so are          * others. So we can just use estimated queue length.          * However, this strategy alone leads to serious mis-estimates          * in some non-steady-state conditions (ramp-up, ramp-down,          * other stalls). We can detect many of these by further          * considering the number of ""idle"" threads, that are known to          * have zero queued tasks, so compensate by a factor of          * (#idle/#active) threads.          */         ForkJoinWorkerThread wt =             (ForkJoinWorkerThread)Thread.currentThread();         return wt.workQueue.queueSize() - wt.pool.idlePerActive();     }
public java.util.List<Service> getServices() {         if (services == null) {             services = new com.amazonaws.internal.SdkInternalList<Service>();         }         return services;     }
public String getText(String key) throws MissingResourceException {         initBundles();          if (docletBundle.containsKey(key))             return docletBundle.getString(key);          return commonBundle.getString(key);     }
public final void dump(final LDAPInterface connection,                            final String base,                            final String filter,                            final OutputStream outputStream,                            final FormatLogger logger) {         final FormatWriter ldapWriter = createWriter(outputStream, logger);         if (ldapWriter == null) {             logger.logError(""Error creating writer for output stream"");         } else {             try {                 try {                     final SearchRequest request = new SearchRequest(base, SearchScope.SUB, Filter.create(filter));                     final SearchResult result = connection.search(request);                     if (result.getResultCode() == ResultCode.SUCCESS) {                         final List<SearchResultEntry> entries = result.getSearchEntries();                         if (entries != null) {                             for (final SearchResultEntry entry : entries) {                                 ldapWriter.printEntry(entry);                             }                         } else {                             logger.logInfo(""Search did not return any directory entries"");                         }                     } else {                         logger.logError(""Search operation failed"");                     }                 } catch (final LDAPException e) {                     logger.logError(""Error searching the LDAP directory"", e);                 } finally {                     ldapWriter.close();                 }             } catch (final IOException e) {                 logger.logError(""Error writing directory entry to the output stream"", e);             }         }     }
public boolean clashesWith(MapElementContainer other) {         // if either of the elements is always drawn, the elements do not clash         if (Display.ALWAYS == this.display || Display.ALWAYS == other.display) {             return false;         }         return this.getBoundaryAbsolute().intersects(other.getBoundaryAbsolute());     }
private void evaluateConstraints(DoubleSolution solution)  {     double[] constraint = new double[this.getNumberOfConstraints()];      double x1,x2,x3,x4,x5,x6;     x1 = solution.getVariableValue(0);     x2 = solution.getVariableValue(1);     x3 = solution.getVariableValue(2);     x4 = solution.getVariableValue(3);     x5 = solution.getVariableValue(4);     x6 = solution.getVariableValue(5);      constraint[0] = (x1 + x2)/2.0 - 1.0;     constraint[1] = (6.0 - x1 - x2)/6.0;     constraint[2] = (2.0 - x2 + x1)/2.0;     constraint[3] = (2.0 - x1 + 3.0*x2)/2.0;     constraint[4] = (4.0 - (x3-3.0)*(x3-3.0) - x4)/4.0;     constraint[5] = ((x5-3.0)*(x5-3.0) +x6 - 4.0)/4.0;      double overallConstraintViolation = 0.0;     int violatedConstraints = 0;     for (int i = 0; i < getNumberOfConstraints(); i++) {       if (constraint[i]<0.0){         overallConstraintViolation+=constraint[i];         violatedConstraints++;       }     }      overallConstraintViolationDegree.setAttribute(solution, overallConstraintViolation);     numberOfViolatedConstraints.setAttribute(solution, violatedConstraints);   }
private static void choosePreviewSize(Camera.Parameters parms, int width, int height) {         // We should make sure that the requested MPEG size is less than the preferred         // size, and has the same aspect ratio.         Camera.Size ppsfv = parms.getPreferredPreviewSizeForVideo();         if (ppsfv != null && VERBOSE) {             Log.d(TAG, ""Camera preferred preview size for video is "" +                     ppsfv.width + ""x"" + ppsfv.height);         }          for (Camera.Size size : parms.getSupportedPreviewSizes()) {             if (size.width == width && size.height == height) {                 parms.setPreviewSize(width, height);                 return;             }         }          Log.w(TAG, ""Unable to set preview size to "" + width + ""x"" + height);         if (ppsfv != null) {             parms.setPreviewSize(ppsfv.width, ppsfv.height);         }         // else use whatever the default size is     }
private synchronized void addResolved( String path )     {         for ( int index = path.lastIndexOf( '/' ); index > 0; index = path.lastIndexOf( '/' ) )         {             String name = path.substring( index + 1 );             path = path.substring( 0, index );             Map<String, Artifact> artifactMapper = this.children.get( path );             if ( artifactMapper == null )             {                 artifactMapper = new HashMap<String, Artifact>();                 this.children.put( path, artifactMapper );             }             artifactMapper.put( name, null );         }         if ( !StringUtils.isEmpty( path ) )         {             Map<String, Artifact> artifactMapper = this.children.get( """" );             if ( artifactMapper == null )             {                 artifactMapper = new HashMap<String, Artifact>();                 this.children.put( """", artifactMapper );             }             artifactMapper.put( path, null );         }     }
public ServletHolder newServletHolder(String name,                                           String servletClass)     {         return newServletHolder(name,servletClass,null);     }
private String getSourceName(final String property) {         if (propertyNameMap.containsKey(property)) {             return propertyNameMap.get(property);         } else {             return property;         }     }
public Subject createSubject() {         // If a authenticationContext was defined on the subsystem use that context, otherwise use capture the current         // configuration.         final Subject subject = this.createSubject(getAuthenticationContext());         if (ROOT_LOGGER.isTraceEnabled()) {             ROOT_LOGGER.subject(subject, Integer.toHexString(System.identityHashCode(subject)));         }         return subject;     }
public ResultList<Artwork> getEpisodeImages(int tvID, int seasonNumber, int episodeNumber) throws MovieDbException {         return tmdbEpisodes.getEpisodeImages(tvID, seasonNumber, episodeNumber);     }
protected UserApiKey createApiKeyInternal(final String name) {     final StitchAuthDocRequest.Builder reqBuilder = new StitchAuthDocRequest.Builder();     reqBuilder             .withMethod(Method.POST)             .withPath(this.getBaseRoute())             .withDocument(new Document(ApiKeyFields.NAME, name))             .withRefreshToken();     return getRequestClient().doAuthenticatedRequest(             reqBuilder.build(),             new UserApiKeyDecoder()     );   }
@Override  @Nullable  public String getMapping(Class<?> type, Method method) {    Assert.notNull(type, ""Type must not be null!"");   Assert.notNull(method, ""Method must not be null!"");    String[] mapping = getMappingFrom(findMergedAnnotation(method, annotationType));   String typeMapping = getMapping(type);    if (mapping.length == 0) {    return typeMapping;   }    return typeMapping == null || ""/"".equals(typeMapping) ? mapping[0] : join(typeMapping, mapping[0]);  }
private boolean isMinuteTerm(final int currentTermIdx, final List<Term<Calendar>> terms) {                    final int termSize = terms.size();                    // 直前の項のチェック          if(currentTermIdx -1 > 0) {              DateTerm beforeTerm = null;              for(int i=currentTermIdx-1; i >= 0; i--) {                  final Term<Calendar> term = terms.get(i);                  if(term instanceof DateTerm) {                      beforeTerm = (DateTerm) term;                      break;                  }                                }                            if(beforeTerm != null) {                  if(beforeTerm instanceof DateTerm.HourTerm || beforeTerm instanceof DateTerm.ElapsedHourTerm) {                      return true;                  }              }                        }                    // 直後の項のチェック          if(currentTermIdx +1 < termSize) {              DateTerm afterTerm = null;              for(int i=currentTermIdx+1; i < termSize; i++) {                  final Term<Calendar> term = terms.get(i);                  if(term instanceof DateTerm) {                      afterTerm = (DateTerm) term;                      break;                  }              }                            if(afterTerm != null) {                  if(afterTerm instanceof DateTerm.SecondTerm || afterTerm instanceof DateTerm.ElapsedSecondTerm) {                      return true;                  }              }          }                    return false;      }
public ListMultimap<Class<?>, Object> getParamsForType() {   ArrayListMultimap<Class<?>, Object> retVal = ArrayListMultimap.create();   myParams.entries().forEach(entry -> retVal.put(entry.getKey(), unwrapValue(entry.getValue())));   return Multimaps.unmodifiableListMultimap(retVal);  }
private int calculateTileLevel() {   double baseX = layerBounds.getWidth();   double baseY = layerBounds.getHeight();   // choose the tile level so the area is between minimumTileSize and the next level (minimumTileSize * 4)   double baseArea = baseX * baseY;   double scale = layer.getMapModel().getMapView().getCurrentScale();   double osmArea = preferredTileSize / (scale * scale);   int tileLevel = (int) Math.round(Math.log(baseArea / osmArea) / Math.log(4.0));   if (tileLevel < 0) {    tileLevel = 0;   }   return tileLevel;  }
public static void addSpoiler(Message message, String hint) {         message.addExtension(new SpoilerElement(null, hint));     }
public static INDArray amin(INDArray x, INDArray y, INDArray z, int... dimensions) {         if(dimensions == null || dimensions.length == 0) {             validateShapesNoDimCase(x,y,z);             return Nd4j.getExecutioner().exec(new AMin(x,y,z));         }          return Nd4j.getExecutioner().exec(new BroadcastAMin(x,y,z,dimensions));     }
public void marshall(DescribeStreamRequest describeStreamRequest, ProtocolMarshaller protocolMarshaller) {          if (describeStreamRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(describeStreamRequest.getStreamId(), STREAMID_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public static void prune(List<Point3D_F64> cloud , int minNeighbors , double radius ) {   if( minNeighbors < 0 )    throw new IllegalArgumentException(""minNeighbors must be >= 0"");   NearestNeighbor<Point3D_F64> nn = FactoryNearestNeighbor.kdtree(new KdTreePoint3D_F64() );   NearestNeighbor.Search<Point3D_F64> search = nn.createSearch();    nn.setPoints(cloud,false);   FastQueue<NnData<Point3D_F64>> results = new FastQueue(NnData.class,true);    // It will always find itself   minNeighbors += 1;    // distance is Euclidean squared   radius *= radius;    for( int i = cloud.size()-1; i >= 0; i-- ) {    search.findNearest(cloud.get(i),radius,minNeighbors,results);     if( results.size < minNeighbors ) {     cloud.remove(i);    }   }  }
public static Caffeine<Object, Object> from(Config config) {     CaffeineParser parser = new CaffeineParser(config);     config.entrySet().stream().map(Map.Entry::getKey).forEach(parser::parse);     return parser.cacheBuilder;   }
public EngineResult engineResult(HttpRequestBase request) {         EngineResult engineResult = new EngineResult();         try {             HttpResponse response = httpClient.execute(request);             if (response != null) {                 engineResult.responseCode = response.getStatusLine().getStatusCode();                 HttpEntity responseEntity = response.getEntity();                 long contentLength = responseEntity.getContentLength();                 if (contentLength < 0) {                     contentLength = 0;                 }                 ByteArrayOutputStream bOut = new ByteArrayOutputStream((int) contentLength);                 InputStream in = responseEntity.getContent();                 int read;                 byte[] tmpBuf = new byte[8192];                 while ((read = in.read(tmpBuf)) != -1) {                     bOut.write(tmpBuf, 0, read);                 }                 in.close();                 bOut.close();                 engineResult.response = bOut.toByteArray();                 switch (engineResult.responseCode) {                 case 200:                     engineResult.parse(xmlValidator);                     in = new ByteArrayInputStream(engineResult.response);                     engineResult.engine = Engine.unmarshall(in);                     in.close();                     engineResult.status = ResultStatus.OK;                     break;                 case 404:                     engineResult.status = ResultStatus.NOT_FOUND;                     break;                 case 500:                     engineResult.status = ResultStatus.INTERNAL_ERROR;                     break;                 default:                     engineResult.status = ResultStatus.NO_RESPONSE;                     break;                 }             } else {                 engineResult.status = ResultStatus.NO_RESPONSE;             }         } catch (NoHttpResponseException e) {             engineResult.status = ResultStatus.OFFLINE;             engineResult.t = e;         } catch (ClientProtocolException e) {             engineResult.status = ResultStatus.RESPONSE_EXCEPTION;             engineResult.t = e;         } catch (IOException e) {             engineResult.status = ResultStatus.RESPONSE_EXCEPTION;             engineResult.t = e;         } catch (JAXBException e) {             engineResult.status = ResultStatus.JAXB_EXCEPTION;             engineResult.t = e;         } catch (XMLStreamException e) {             engineResult.status = ResultStatus.XML_EXCEPTION;             engineResult.t = e;         }         return engineResult;     }
public void stop(String logicalQueueName) {   stopQueue(logicalQueueName);    try {    if (isRunning(logicalQueueName)) {     Future<?> future = this.scheduledFutureByQueue.remove(logicalQueueName);     if (future != null) {      future.get(this.queueStopTimeout, TimeUnit.MILLISECONDS);     }    }   }   catch (InterruptedException e) {    Thread.currentThread().interrupt();   }   catch (ExecutionException | TimeoutException e) {    getLogger().warn(""Error stopping queue with name: '"" + logicalQueueName + ""'"",      e);   }  }
@Override     public void onMessageReceived(MessageReceivedEvent event)     {         //These are provided with every event in JDA         JDA jda = event.getJDA();                       //JDA, the core of the api.         long responseNumber = event.getResponseNumber();//The amount of discord events that JDA has received since the last reconnect.          //Event specific information         User author = event.getAuthor();                //The user that sent the message         Message message = event.getMessage();           //The message that was received.         MessageChannel channel = event.getChannel();    //This is the MessageChannel that the message was sent to.                                                         //  This could be a TextChannel, PrivateChannel, or Group!          String msg = message.getContentDisplay();              //This returns a human readable version of the Message. Similar to                                                         // what you would see in the client.          boolean bot = author.isBot();                    //This boolean is useful to determine if the User that                                                         // sent the Message is a BOT or not!          if (event.isFromType(ChannelType.TEXT))         //If this message was sent to a Guild TextChannel         {             //Because we now know that this message was sent in a Guild, we can do guild specific things             // Note, if you don't check the ChannelType before using these methods, they might return null due             // the message possibly not being from a Guild!              Guild guild = event.getGuild();             //The Guild that this message was sent in. (note, in the API, Guilds are Servers)             TextChannel textChannel = event.getTextChannel(); //The TextChannel that this message was sent to.             Member member = event.getMember();          //This Member that sent the message. Contains Guild specific information about the User!              String name;             if (message.isWebhookMessage())             {                 name = author.getName();                //If this is a Webhook message, then there is no Member associated             }                                           // with the User, thus we default to the author for name.             else             {                 name = member.getEffectiveName();       //This will either use the Member's nickname if they have one,             }                                           // otherwise it will default to their username. (User#getName())              System.out.printf(""(%s)[%s]<%s>: %s\n"", guild.getName(), textChannel.getName(), name, msg);         }         else if (event.isFromType(ChannelType.PRIVATE)) //If this message was sent to a PrivateChannel         {             //The message was sent in a PrivateChannel.             //In this example we don't directly use the privateChannel, however, be sure, there are uses for it!             PrivateChannel privateChannel = event.getPrivateChannel();              System.out.printf(""[PRIV]<%s>: %s\n"", author.getName(), msg);         }         else if (event.isFromType(ChannelType.GROUP))   //If this message was sent to a Group. This is CLIENT only!         {             //The message was sent in a Group. It should be noted that Groups are CLIENT only.             Group group = event.getGroup();             String groupName = group.getName() != null ? group.getName() : """";  //A group name can be null due to it being unnamed.              System.out.printf(""[GRP: %s]<%s>: %s\n"", groupName, author.getName(), msg);         }           //Now that you have a grasp on the things that you might see in an event, specifically MessageReceivedEvent,         // we will look at sending / responding to messages!         //This will be an extremely simplified example of command processing.          //Remember, in all of these .equals checks it is actually comparing         // message.getContentDisplay().equals, which is comparing a string to a string.         // If you did message.equals() it will fail because you would be comparing a Message to a String!         if (msg.equals(""!ping""))         {             //This will send a message, ""pong!"", by constructing a RestAction and ""queueing"" the action with the Requester.             // By calling queue(), we send the Request to the Requester which will send it to discord. Using queue() or any             // of its different forms will handle ratelimiting for you automatically!              channel.sendMessage(""pong!"").queue();         }         else if (msg.equals(""!roll""))         {             //In this case, we have an example showing how to use the Success consumer for a RestAction. The Success consumer             // will provide you with the object that results after you execute your RestAction. As a note, not all RestActions             // have object returns and will instead have Void returns. You can still use the success consumer to determine when             // the action has been completed!              Random rand = new Random();             int roll = rand.nextInt(6) + 1; //This results in 1 - 6 (instead of 0 - 5)             channel.sendMessage(""Your roll: "" + roll).queue(sentMessage ->  //This is called a lambda statement. If you don't know             {                                                               // what they are or how they work, try google!                 if (roll < 3)                 {                     channel.sendMessage(""The roll for messageId: "" + sentMessage.getId() + "" wasn't very good... Must be bad luck!\n"").queue();                 }             });         }         else if (msg.startsWith(""!kick""))   //Note, I used ""startsWith, not equals.         {             //This is an admin command. That means that it requires specific permissions to use it, in this case             // it needs Permission.KICK_MEMBERS. We will have a check before we attempt to kick members to see             // if the logged in account actually has the permission, but considering something could change after our             // check we should also take into account the possibility that we don't have permission anymore, thus Discord             // response with a permission failure!             //We will use the error consumer, the second parameter in queue!              //We only want to deal with message sent in a Guild.             if (message.isFromType(ChannelType.TEXT))             {                 //If no users are provided, we can't kick anyone!                 if (message.getMentionedUsers().isEmpty())                 {                     channel.sendMessage(""You must mention 1 or more Users to be kicked!"").queue();                 }                 else                 {                     Guild guild = event.getGuild();                     Member selfMember = guild.getSelfMember();  //This is the currently logged in account's Member object.                                                                 // Very similar to JDA#getSelfUser()!                      //Now, we the the logged in account doesn't have permission to kick members.. well.. we can't kick!                     if (!selfMember.hasPermission(Permission.KICK_MEMBERS))                     {                         channel.sendMessage(""Sorry! I don't have permission to kick members in this Guild!"").queue();                         return; //We jump out of the method instead of using cascading if/else                     }                      //Loop over all mentioned users, kicking them one at a time. Mwauahahah!                     List<User> mentionedUsers = message.getMentionedUsers();                     for (User user : mentionedUsers)                     {                         Member member = guild.getMember(user);  //We get the member object for each mentioned user to kick them!                          //We need to make sure that we can interact with them. Interacting with a Member means you are higher                         // in the Role hierarchy than they are. Remember, NO ONE is above the Guild's Owner. (Guild#getOwner())                         if (!selfMember.canInteract(member))                         {                             // use the MessageAction to construct the content in StringBuilder syntax using append calls                             channel.sendMessage(""Cannot kick member: "")                                    .append(member.getEffectiveName())                                    .append("", they are higher in the hierarchy than I am!"")                                    .queue();                             continue;   //Continue to the next mentioned user to be kicked.                         }                          //Remember, due to the fact that we're using queue we will never have to deal with RateLimits.                         // JDA will do it all for you so long as you are using queue!                         guild.getController().kick(member).queue(                             success -> channel.sendMessage(""Kicked "").append(member.getEffectiveName()).append(""! Cya!"").queue(),                             error ->                             {                                 //The failure consumer provides a throwable. In this case we want to check for a PermissionException.                                 if (error instanceof PermissionException)                                 {                                     PermissionException pe = (PermissionException) error;                                     Permission missingPermission = pe.getPermission();  //If you want to know exactly what permission is missing, this is how.                                                                                         //Note: some PermissionExceptions have no permission provided, only an error message!                                      channel.sendMessage(""PermissionError kicking ["")                                            .append(member.getEffectiveName()).append(""]: "")                                            .append(error.getMessage()).queue();                                 }                                 else                                 {                                     channel.sendMessage(""Unknown error while kicking ["")                                            .append(member.getEffectiveName())                                            .append(""]: <"").append(error.getClass().getSimpleName()).append("">: "")                                            .append(error.getMessage()).queue();                                 }                             });                     }                 }             }             else             {                 channel.sendMessage(""This is a Guild-Only command!"").queue();             }         }         else if (msg.equals(""!block""))         {             //This is an example of how to use the complete() method on RestAction. The complete method acts similarly to how             // JDABuilder's awaitReady() works, it waits until the request has been sent before continuing execution.             //Most developers probably wont need this and can just use queue. If you use complete, JDA will still handle ratelimit             // control, however if shouldQueue is false it won't queue the Request to be sent after the ratelimit retry after time is past. It             // will instead fire a RateLimitException!             //One of the major advantages of complete() is that it returns the object that queue's success consumer would have,             // but it does it in the same execution context as when the request was made. This may be important for most developers,             // but, honestly, queue is most likely what developers will want to use as it is faster.              try             {                 //Note the fact that complete returns the Message object!                 //The complete() overload queues the Message for execution and will return when the message was sent                 //It does handle rate limits automatically                 Message sentMessage = channel.sendMessage(""I blocked and will return the message!"").complete();                 //This should only be used if you are expecting to handle rate limits yourself                 //The completion will not succeed if a rate limit is breached and throw a RateLimitException                 Message sentRatelimitMessage = channel.sendMessage(""I expect rate limitation and know how to handle it!"").complete(false);                  System.out.println(""Sent a message using blocking! Luckly I didn't get Ratelimited... MessageId: "" + sentMessage.getId());             }             catch (RateLimitedException e)             {                 System.out.println(""Whoops! Got ratelimited when attempting to use a .complete() on a RestAction! RetryAfter: "" + e.getRetryAfter());             }             //Note that RateLimitException is the only checked-exception thrown by .complete()             catch (RuntimeException e)             {                 System.out.println(""Unfortunately something went wrong when we tried to send the Message and .complete() threw an Exception."");                 e.printStackTrace();             }         }     }
public boolean isScaleAndShift(double tol) {   return xy * xy + yx * yx < (xx * xx + yy * yy) * tol;  }
public static void xmlGlobalInexistent(Class<?> aClass) {    throw new XmlMappingGlobalDoesNotExistException(MSG.INSTANCE.message(xmlMappingGlobalDoesNotExistException, aClass.getSimpleName()));   }
public void marshall(CancelSchemaExtensionRequest cancelSchemaExtensionRequest, ProtocolMarshaller protocolMarshaller) {          if (cancelSchemaExtensionRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(cancelSchemaExtensionRequest.getDirectoryId(), DIRECTORYID_BINDING);             protocolMarshaller.marshall(cancelSchemaExtensionRequest.getSchemaExtensionId(), SCHEMAEXTENSIONID_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
private List<AdvancedModelWrapper> convertOpenEngSBModelList(List<OpenEngSBModel> models) {         List<AdvancedModelWrapper> wrappers = new ArrayList<AdvancedModelWrapper>();         for (OpenEngSBModel model : models) {             wrappers.add(AdvancedModelWrapper.wrap(model));         }         return wrappers;     }
public void acceptCertificate() {         String action = ""Clicking override link to accept ssl certificate"";         String result = ""Override link clicked"";         //for IE and Edge         if (browser.getName() == BrowserName.INTERNETEXPLORER || browser.getName() == BrowserName.EDGE) {             Element overrideLink = newElement(Locator.ID, ""overridelink"");             if (overrideLink.is().present()) {                 try {                     if (browser.getName() == BrowserName.EDGE) {                         newElement(Locator.ID, ""moreInformationDropdownSpan"").getWebElement().click();                     }                     overrideLink.getWebElement().click();                     reporter.pass(action, result, result);                 } catch (Exception e) {                     reporter.fail(action, result, ""Unable to click override link. ""                             + e.getMessage());                     log.warn(e);                 }             }         }     }
@Nonnull   public static Error fail(@Nullable final String message) {     final AssertionError error = new AssertionError(GetUtils.ensureNonNull(message, ""failed""));     MetaErrorListeners.fireError(""Asserion error"", error);     if (true) {       throw error;     }     return error;   }
static public TypedDataset open( FeatureType datatype, String location, ucar.nc2.util.CancelTask task, StringBuilder errlog) throws IOException {     DatasetUrl durl = DatasetUrl.findDatasetUrl(location);     NetcdfDataset ncd = NetcdfDataset.acquireDataset(durl, true, task);     return open( datatype, ncd, task, errlog);   }
public ServiceFuture<Void> updatePropertiesAsync(String poolId, PoolUpdatePropertiesParameter poolUpdatePropertiesParameter, final ServiceCallback<Void> serviceCallback) {         return ServiceFuture.fromHeaderResponse(updatePropertiesWithServiceResponseAsync(poolId, poolUpdatePropertiesParameter), serviceCallback);     }
protected String parseUserId(String securityName) {         int idx = securityName.indexOf(TOKEN_DELIMETER); // Don't use String.split() - way too expensive.         if (idx > 0) {             return securityName.substring(0, idx);         } else {             return securityName;         }     }
public List<Message> requestArtistMenuFrom(final SlotReference slotReference, final int sortOrder)             throws Exception {          ConnectionManager.ClientTask<List<Message>> task = new ConnectionManager.ClientTask<List<Message>>() {             @Override             public List<Message> useClient(Client client) throws Exception {                 if (client.tryLockingForMenuOperations(MetadataFinder.MENU_TIMEOUT, TimeUnit.SECONDS)) {                     try {                         logger.debug(""Requesting Artist menu."");                         Message response = client.menuRequest(Message.KnownType.ARTIST_MENU_REQ, Message.MenuIdentifier.MAIN_MENU, slotReference.slot,                                 new NumberField(sortOrder));                         return client.renderMenuItems(Message.MenuIdentifier.MAIN_MENU, slotReference.slot, CdjStatus.TrackType.REKORDBOX, response);                     } finally {                         client.unlockForMenuOperations();                     }                 } else {                     throw new TimeoutException(""Unable to lock player for menu operations."");                 }             }         };          return ConnectionManager.getInstance().invokeWithClientSession(slotReference.player, task, ""requesting artist menu"");     }
void applyGaussian(GrayF32 input, GrayF32 output, Kernel1D kernel) {   tempBlur.reshape(input.width, input.height);   GConvolveImageOps.horizontalNormalized(kernel, input, tempBlur);   GConvolveImageOps.verticalNormalized(kernel, tempBlur,output);  }
public Coordinate getIntersection(LineSegment lineSegment) { // may not be on either one of the line segments.   // http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/   double x1 = this.x1();   double y1 = this.y1();   double x2 = this.x2();   double y2 = this.y2();   double x3 = lineSegment.x1();   double y3 = lineSegment.y1();   double x4 = lineSegment.x2();   double y4 = lineSegment.y2();    double denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);   double u1 = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;    double x = x1 + u1 * (x2 - x1);   double y = y1 + u1 * (y2 - y1);   return new Coordinate(x, y);  }
protected Criteria createDistinctRootEntityCriteria(Criterion... criterion) {         Criteria criteria = getSession().createCriteria(entityClass);         addCriterionsToCriteria(criteria, criterion);         criteria.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);         criteria.setCacheable(this.useQueryCache);         return criteria;     }
public void delete(String resourceGroupName, String virtualWANName) {         deleteWithServiceResponseAsync(resourceGroupName, virtualWANName).toBlocking().last().body();     }
protected CatalogBuilder makeCatalogFiles(URI catURI, State localState, List<String> filenames, boolean addLatest) throws IOException {     Catalog parentCatalog = parent.getParentCatalog();      CatalogBuilder result = new CatalogBuilder();     result.setName(makeFullName(parent));     result.setVersion(parentCatalog.getVersion());     result.setBaseURI(catURI);     result.addService(orgService);      DatasetBuilder top = new DatasetBuilder(null);     top.transferInheritedMetadata(parent); // make all inherited metadata local     top.setName(FILES);      // add Variables, GeospatialCoverage, TimeCoverage     ThreddsMetadata tmi = top.getInheritableMetadata();     tmi.set(Dataset.TimeCoverage, null);      // LOOK     if (localState.coverage != null) {       tmi.set(Dataset.GeospatialCoverage, localState.coverage);     }     tmi.set(Dataset.ServiceName, orgService.getName());     result.addDataset(top);      if (addLatest) {       DatasetBuilder latest = new DatasetBuilder(top);       latest.setName(getLatestFileName());       latest.put(Dataset.UrlPath, LATEST_DATASET_CATALOG);       latest.put(Dataset.Id, LATEST_DATASET_CATALOG);       latest.put(Dataset.ServiceName, latestService.getName());       latest.addServiceToCatalog(latestService);       top.addDataset(latest);     }      // sort copy of files     List<String> sortedFilenames = new ArrayList<>(filenames);     Collections.sort(sortedFilenames, String.CASE_INSENSITIVE_ORDER);      // if not increasing (i.e. we WANT newest file listed first), reverse sort     if (!this.config.getSortFilesAscending()) {       Collections.reverse(sortedFilenames);     }      for (String f : sortedFilenames) {       if (!f.startsWith(topDirectory))         logger.warn(""File {} doesnt start with topDir {}"", f, topDirectory);        DatasetBuilder ds = new DatasetBuilder(top);        String fname = f.substring(topDirectory.length() + 1);       ds.setName(fname);        String lpath = this.configPath + ""/"" + FILES + ""/"" + fname;       // String lpath = getPath() + ""/"" + FILES + ""/"" + fname;       ds.put(Dataset.UrlPath, lpath);       ds.put(Dataset.Id, lpath);       ds.put(Dataset.VariableMapLinkURI, new ThreddsMetadata.UriResolved(makeMetadataLink(lpath, VARIABLES), catURI));        File file = new File(f);       ds.put(Dataset.DataSize, file.length());       top.addDataset(ds);     }      return result;   }
public void stopThreads() {   // 停止连接测试线程   TaskEngine.getInstance().cancelScheduledTask(thriftConnectionTesterThread);    // 停止连接最大时间检测线程   TaskEngine.getInstance().cancelScheduledTask(thriftConnectionMaxAgeThread);    // 停止分区检测线程   poolWatchThread.stop();   this.poolWatchThreadSignalQueue.offer(new Object());  }
public boolean ok() {         Object okValue = get(""ok"");         if (okValue instanceof Boolean) {             return (Boolean) okValue;         } else if (okValue instanceof Number) {             return ((Number) okValue).intValue() == 1;         } else {             return false;         }     }
public ConversionHandler to(MappedField destinationMappedField){    this.destinationField = destinationMappedField.getValue();     placeholders.put(destinationTypePattern, destinationField.getType().getName());    placeholders.put(destinationNamePattern, destinationField.getName());    placeholders.put(destinationGetPattern, destinationMappedField.getMethod());    placeholders.put(destinationSetPattern, destinationMappedField.setMethod());    return this;   }
@SuppressWarnings(""unchecked"")    public static void addAnnotation(Field field, Annotation annotation) {      field.getAnnotation(Annotation.class);// prevent declaredAnnotations haven't initialized      Map<Class<? extends Annotation>, Annotation> annos;      try {        annos = (Map<Class<? extends Annotation>, Annotation>) Field_Field_DeclaredAnnotations.get(field);      } catch (IllegalAccessException e) {        throw new IllegalStateException(e);      }      if (annos.getClass() == Collections.EMPTY_MAP.getClass()) {        annos = new HashMap<>();        try {          Field_Field_DeclaredAnnotations.set(field, annos);        } catch (IllegalAccessException e) {          throw new IllegalStateException(e);        }      }      annos.put(annotation.annotationType(), annotation);    }
public HeaderDefinition getHeaderDefinition() {     JSONArray jsonArray = null;     try {       jsonArray = _jsonObject.getJSONArray(COLUMN_NAMES_FIELD);       List<String> columnNames = new ArrayList<String>(jsonArray.length());       for (int i = 0; i < jsonArray.length(); i++) {         columnNames.add(jsonArray.getString(i));       }       return HeaderDefinition.of(columnNames);     } catch (JSONException ex) {       s_logger.error(""Metadata had unexpected structure - could not extract column_names field. Was:\n{}"", _jsonObject.toString());       throw new QuandlRuntimeException(""Metadata had unexpected structure"", ex);     }   }
private List<ObjectType> buildParametersSection(MarkupDocBuilder markupDocBuilder, PathOperation operation) {          List<ObjectType> inlineDefinitions = new ArrayList<>();          parameterTableComponent.apply(markupDocBuilder, ParameterTableComponent.parameters(                 operation,                 inlineDefinitions,                 getSectionTitleLevel()         ));          return inlineDefinitions;     }
@SuppressWarnings(""NonConstantStringShouldBeStringBuffer"")  protected void acceptActionClass(final Class<?> actionClass) {    if (actionClass == null) {    return;   }    if (!checkClass(actionClass)) {    return;    }    if (actionClass.getAnnotation(MadvocAction.class) == null) {    return;   }    ClassDescriptor cd = ClassIntrospector.get().lookup(actionClass);    MethodDescriptor[] allMethodDescriptors = cd.getAllMethodDescriptors();   for (MethodDescriptor methodDescriptor : allMethodDescriptors) {    if (!methodDescriptor.isPublic()) {     continue;    }    // just public methods    final Method method = methodDescriptor.getMethod();     final boolean hasAnnotation = actionConfigManager.hasActionAnnotationOn(method);     if (!hasAnnotation) {     continue;    }     webappConfigurations.add(() -> actionsManager.registerAction(actionClass, method, null));   }  }
public static ChunksManifest createManifestFrom(InputStream xml) {         try {             ChunksManifestDocument doc = ChunksManifestDocument.Factory.parse(                 xml);             return ManifestElementReader.createManifestFrom(doc);         } catch (XmlException e) {             throw new DuraCloudRuntimeException(e);         } catch (IOException e) {             throw new DuraCloudRuntimeException(e);         }     }
public void setSrcPath(String in) throws IOException {     srcPath= new Path(in);     if (!srcPath.isAbsolute() || !srcPath.toUri().isAbsolute()) {       throw new IOException(""Path "" + in +  "" is not absolute."");     }   }
public static ExternalSessionKey fromResponseBody(String responseBody) throws NewSessionException {     if (responseBody != null && responseBody.startsWith(""OK,"")) {       return new ExternalSessionKey(responseBody.replace(""OK,"", """"));     }     throw new NewSessionException(""The server returned an error : ""+responseBody);   }
private JScrollPane getDefaultPane() {    if (defaultPane == null) {     defaultPane = new JScrollPane();     defaultPane.setViewportView(getDefaultOutput());     defaultPane.setName(""defaultPane"");     defaultPane.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);    }    return defaultPane;   }
public Matrix3 setToTransform (IVector translation, double rotation, double scale) {         return setToRotation(rotation).set(m00 * scale, m10 * scale, translation.x(),                                            m01 * scale, m11 * scale, translation.y(),                                            0f, 0f, 1f);     }
@Override    public Object[] toArray() {       // Estimate size of array; be prepared to see more or fewer elements       Object[] r = new Object[size()];       try (CloseableIterator<O> it = iterator()) {          for (int i = 0; i < r.length; i++) {             if (! it.hasNext()) // fewer elements than expected                return Arrays.copyOf(r, i);             r[i] = it.next();          }          return it.hasNext() ? finishToArray(r, it) : r;       }    }
private String buildCreateDDLQuery(TableInfo tableInfo)     {         String statement;         boolean flag = false;         StringBuilder compoundKeys = null;         StringBuilder builder = new StringBuilder();         builder.append(""CREATE TABLE "");         builder.append(tableInfo.getTableName());         builder.append(Constants.OPEN_ROUND_BRACKET);          if (!tableInfo.getTableIdType().isAnnotationPresent(Embeddable.class))         {             builder.append(tableInfo.getIdColumnName());             builder.append(Constants.SPACE);             String idType = tableInfo.getTableIdType().getSimpleName().toLowerCase();             builder.append(OracleNoSQLValidationClassMapper.getValidIdType(idType));             builder.append(Constants.COMMA);         }          for (ColumnInfo columnInfo : tableInfo.getColumnMetadatas())         {             builder.append(columnInfo.getColumnName());             builder.append(Constants.SPACE);             String coulmnType = columnInfo.getType().getSimpleName().toLowerCase();             builder.append(OracleNoSQLValidationClassMapper.getValidType(coulmnType));             builder.append(Constants.COMMA);         }         for (EmbeddedColumnInfo embeddedColumnInfo : tableInfo.getEmbeddedColumnMetadatas())         {             if (tableInfo.getIdColumnName().equals(embeddedColumnInfo.getEmbeddedColumnName()))             {                 compoundKeys = new StringBuilder();                 flag = true;             }             for (ColumnInfo columnInfo : embeddedColumnInfo.getColumns())             {                 builder.append(columnInfo.getColumnName());                 builder.append(Constants.SPACE);                 String coulmnType = columnInfo.getType().getSimpleName().toLowerCase();                 builder.append(OracleNoSQLValidationClassMapper.getValidType(coulmnType));                 builder.append(Constants.COMMA);                 if (flag)                 {                     compoundKeys.append(columnInfo.getColumnName());                     compoundKeys.append(Constants.COMMA);                 }             }             flag = false;         }          builder.append(""PRIMARY KEY"");         builder.append(Constants.OPEN_ROUND_BRACKET);          if (!tableInfo.getTableIdType().isAnnotationPresent(Embeddable.class))         {             builder.append(tableInfo.getIdColumnName());         }         else         {             compoundKeys.deleteCharAt(compoundKeys.length() - 1);             builder.append(compoundKeys.toString());         }          builder.append(Constants.CLOSE_ROUND_BRACKET);         builder.append(Constants.CLOSE_ROUND_BRACKET);          statement = builder.toString();         return statement;     }
public LDAPQuery setAttributes(List<String> attributes) {   if(attributes != null && attributes.size() > 0) {    this.attributes = new String[attributes.size()];    int i = 0;    for(String attribute : attributes) {     this.attributes[i++] = attribute;    }   } else {    this.attributes = ALL_ATTRIBUTES;   }   return this;  }
public static PackageIndex<Integer> createPackageIndex(String resourceName) {         PackageIndex<Integer> packageIndex = new PackageIndex<Integer>();          BufferedReader br = null;         try {             br = getLibertyTraceListReader(resourceName);             addFiltersAndValuesToIndex(br, packageIndex);         } catch (IOException e) {             System.err.println(""Unable to load "" + resourceName);         } finally {             tryToCloseReader(br);         }          packageIndex.compact();         return packageIndex;     }
public static TimeOfDay fromDateFields(Date date) {         if (date == null) {             throw new IllegalArgumentException(""The date must not be null"");         }         return new TimeOfDay(             date.getHours(),             date.getMinutes(),             date.getSeconds(),             (((int) (date.getTime() % 1000)) + 1000) % 1000         );     }
@Override  public boolean eIsSet(int featureID) {   switch (featureID) {    case AfplibPackage.EXTENSION_FONT__GCSGID:     return GCSGID_EDEFAULT == null ? gcsgid != null : !GCSGID_EDEFAULT.equals(gcsgid);   }   return super.eIsSet(featureID);  }
private void parseBody(Node parent, String tag, String bodyType)          throws JasperException      {         if( bodyType.equalsIgnoreCase( TagInfo.BODY_CONTENT_TAG_DEPENDENT ) ) {             parseTagDependentBody( parent, tag );         }         else if( bodyType.equalsIgnoreCase( TagInfo.BODY_CONTENT_EMPTY ) ) {             if( !reader.matchesETag( tag ) ) {   err.jspError(start, ""jasper.error.emptybodycontent.nonempty"",         tag);             }         }         else if( bodyType == JAVAX_BODY_CONTENT_PLUGIN ) {             // (note the == since we won't recognize JAVAX_*              // from outside this module).             parsePluginTags(parent);             if( !reader.matchesETag( tag ) ) {                 err.jspError( reader.mark(), ""jsp.error.unterminated"",                     ""&lt;"" + tag  );             }         }         else if( bodyType.equalsIgnoreCase( TagInfo.BODY_CONTENT_JSP ) ||             bodyType.equalsIgnoreCase( TagInfo.BODY_CONTENT_SCRIPTLESS ) ||             (bodyType == JAVAX_BODY_CONTENT_PARAM) ||             (bodyType == JAVAX_BODY_CONTENT_TEMPLATE_TEXT) )         {             while (reader.hasMoreInput()) {                 if (reader.matchesETag(tag)) {                     return;                 }                                  // Check for nested jsp:body or jsp:attribute                 if (tag.equals(""jsp:body"") || tag.equals(""jsp:attribute"")) {                     if (reader.matches(""<jsp:attribute"")) {                         err.jspError(reader.mark(), ""jsp.error.nested.jspattribute"");                     }                     else if (reader.matches(""<jsp:body"")) {                         err.jspError(reader.mark(), ""jsp.error.nested.jspbody"");                     }                 }                  if( bodyType.equalsIgnoreCase( TagInfo.BODY_CONTENT_JSP ) ) {                     parseElements( parent );                 }                 else if( bodyType.equalsIgnoreCase(                      TagInfo.BODY_CONTENT_SCRIPTLESS ) )                  {                     parseElementsScriptless( parent );                 }                 else if( bodyType == JAVAX_BODY_CONTENT_PARAM ) {                     // (note the == since we won't recognize JAVAX_*                      // from outside this module).                     reader.skipSpaces();                     parseParam( parent );                 }   else if (bodyType == JAVAX_BODY_CONTENT_TEMPLATE_TEXT) {       parseElementsTemplateText(parent);   }             }             err.jspError(start, ""jsp.error.unterminated"", ""&lt;""+tag );         }         else {             err.jspError(start, ""jsp.error.tld.badbodycontent"", bodyType,                          tag);         }     }
public void setCosts(Costs nodeCosts) {   // add the costs from the step function   nodeCosts.addCosts(this.solutionSetDeltaPlanNode.getCumulativeCostsShare());   nodeCosts.addCosts(this.nextWorkSetPlanNode.getCumulativeCostsShare());    super.setCosts(nodeCosts);  }
public Connection getConnection(String name) throws ExecutionException {         Connection connection = null;         synchronized (connections) {             if (connections.containsKey(name)) {                 connection = connections.get(name);             } else {                  String msg = ""The connection ["" + name + ""] does not exist"";                 logger.error(msg);                 throw new ExecutionException(msg);             }         }         return connection;     }
public Observable<ServiceResponse<Map<String, String>>> listEndpointsWithServiceResponseAsync(UUID appId) {         if (this.client.endpoint() == null) {             throw new IllegalArgumentException(""Parameter this.client.endpoint() is required and cannot be null."");         }         if (appId == null) {             throw new IllegalArgumentException(""Parameter appId is required and cannot be null."");         }         String parameterizedHost = Joiner.on("", "").join(""{Endpoint}"", this.client.endpoint());         return service.listEndpoints(appId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())             .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, String>>>>() {                 @Override                 public Observable<ServiceResponse<Map<String, String>>> call(Response<ResponseBody> response) {                     try {                         ServiceResponse<Map<String, String>> clientResponse = listEndpointsDelegate(response);                         return Observable.just(clientResponse);                     } catch (Throwable t) {                         return Observable.error(t);                     }                 }             });     }
@Override   public EClass getIfcLaborResourceType() {    if (ifcLaborResourceTypeEClass == null) {     ifcLaborResourceTypeEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)       .getEClassifiers().get(334);    }    return ifcLaborResourceTypeEClass;   }
@Override  public List<CommerceAddress> findByG_C_C_DB(long groupId, long classNameId,   long classPK, boolean defaultBilling, int start, int end) {   return findByG_C_C_DB(groupId, classNameId, classPK, defaultBilling,    start, end, null);  }
@Generated(value = ""com.sun.tools.xjc.Driver"", date = ""2018-10-12T02:54:50+02:00"", comments = ""JAXB RI v2.2.11"")     public List<Wohnung> getWohnung() {         if (wohnung == null) {             wohnung = new ArrayList<Wohnung>();         }         return this.wohnung;     }
public void delete(HTableInterface hTable, Object rowKey, String columnFamily)     {         try         {             byte[] rowBytes = HBaseUtils.getBytes(rowKey);             Delete delete = new Delete(rowBytes);             byte[] family = HBaseUtils.getBytes(columnFamily);             delete.deleteFamily(family);             hTable.delete(delete);         }         catch (IOException e)         {             log.error(""Error while delete on hbase for : "" + rowKey);             throw new PersistenceException(e);         }     }
public void setMessageException(Throwable ex)     {         String strErrorMessage = ex.getMessage();         BaseMessage message = this.getMessage();         if ((message != null) && (message.getMessageHeader() instanceof TrxMessageHeader))             ((TrxMessageHeader)message.getMessageHeader()).put(TrxMessageHeader.MESSAGE_ERROR, strErrorMessage);         else             ex.printStackTrace();     }
public static List<Filter<File>> createExcludeFilterList(final Log log,             final String... patterns) {         return createFilterList(log, false, patterns);     }
public EnvironmentResourceDescription withLaunchConfigurations(LaunchConfiguration... launchConfigurations) {         if (this.launchConfigurations == null) {             setLaunchConfigurations(new com.amazonaws.internal.SdkInternalList<LaunchConfiguration>(launchConfigurations.length));         }         for (LaunchConfiguration ele : launchConfigurations) {             this.launchConfigurations.add(ele);         }         return this;     }
private void writeObject(final java.io.ObjectOutputStream out)      throws IOException {      out.writeObject(inequalitySymbol);      out.writeLong(timeStamp);    }
public int size() {         if (pad_bits == 0) {             return bin.length;         }         if (bin.length == 0) {             throw new java.lang.IllegalStateException(""Impossible length"");         }         return bin.length - 1;     }
public Reader asReader() {          Reader r = getReader();          if (r != null) return r;          String s = getString();          if (s != null) return new StringReader(s);          InputStream is = fromStreamOrBufferOrUrl();          if (is != null) return readerFrom(is);          throw resourceUnaccessible();      }
public int getNameIndex(CharSequence name)     {         for (ConstantInfo ci : listConstantInfo(Utf8.class))         {             Utf8 utf8 = (Utf8) ci;             String str = utf8.getString();             if (str.contentEquals(name))             {                 return constantPoolIndexMap.get(ci);             }         }         return -1;     }
private String getFulltextStatement(QueryRootNode aqt) throws RepositoryException    {       final String[] stmt = new String[1];       aqt.accept(new TraversingQueryNodeVisitor()       {          @Override          public Object visit(RelationQueryNode node, Object o) throws RepositoryException          {             if (stmt[0] == null && node.getOperation() == RelationQueryNode.OPERATION_SPELLCHECK)             {                stmt[0] = node.getStringValue();             }             return super.visit(node, o);          }       }, null);       return stmt[0];    }
public boolean removeValue(Object value) {   try {    boolean result = false;    if (isCluster(groupName)) {     result = getBinaryJedisClusterCommands(groupName).lrem(keyBytes, 0, valueSerialize(value)) >= 1;    } else {     result = getBinaryJedisCommands(groupName).lrem(keyBytes, 0, valueSerialize(value)) >= 1;    }    return result;   } finally {    getJedisProvider(groupName).release();   }  }
@Override  public final void lock(int handle) throws DataStoreException      {         if (SAFE_MODE) checkHandle(handle);         if (!locks.flip(handle))         {             locks.flip(handle); // Restore state             throw new DataStoreException(""Handle already locked : ""+handle);         }     }
static public Value floatValue (String name, final float currentValue, final float min, final float max,    final String description) {    return new DefaultValue(name, String.valueOf(currentValue)) {     public void showDialog () {      JSpinner spinner = new JSpinner(new SpinnerNumberModel(currentValue, min, max, 0.1f));      if (showValueDialog(spinner, description)) value = String.valueOf(((Double)spinner.getValue()).floatValue());     }       public Object getObject () {      return Float.valueOf(value);     }    };   }
public static Date parseW3CDateTime(String sDate, final Locale locale) {         // if sDate has time on it, it injects 'GTM' before de TZ displacement to allow the         // SimpleDateFormat parser to parse it properly         final int tIndex = sDate.indexOf(""T"");         if (tIndex > -1) {             if (sDate.endsWith(""Z"")) {                 sDate = sDate.substring(0, sDate.length() - 1) + ""+00:00"";             }             int tzdIndex = sDate.indexOf(""+"", tIndex);             if (tzdIndex == -1) {                 tzdIndex = sDate.indexOf(""-"", tIndex);             }             if (tzdIndex > -1) {                 String pre = sDate.substring(0, tzdIndex);                 final int secFraction = pre.indexOf("","");                 if (secFraction > -1) {                     pre = pre.substring(0, secFraction);                 }                 final String post = sDate.substring(tzdIndex);                 sDate = pre + ""GMT"" + post;             }         } else {             sDate += ""T00:00GMT"";         }         return parseUsingMask(W3CDATETIME_MASKS, sDate, locale);     }
@SuppressWarnings(""unchecked"")     private E[] leafNodeArrayFor(int i) {         // i is the index into this vector.  Each 5 bits represent an index into an array.  The         // highest 5 bits (that are less than the shift value) are the index into the top-level         // array. The lowest 5 bits index the the leaf.  The guts of this method indexes into the         // array at each level, finally indexing into the leaf node.          if (i >= 0 && i < size) {             if (i >= tailoff()) {                 return tail;             }             Node node = root;             for (int level = shift; level > 0; level -= NODE_LENGTH_POW_2) {                 node = (Node) node.array[(i >>> level) & LOW_BITS];             }             return (E[]) node.array;         }         throw new IndexOutOfBoundsException();     }
public void consumeExpectedSymbol(String symbol) {         if (current().matches(Token.TokenType.SYMBOL, symbol)) {             consume();         } else {             addError(current(), ""Unexpected token: '%s'. Expected: '%s'"", current().getSource(), symbol);         }     }
public void set(String name, Object obj) throws IOException {         if (!(obj instanceof Boolean)) {             throw new IOException(""Attribute must be of type Boolean."");         }         boolean val = ((Boolean)obj).booleanValue();         if (name.equalsIgnoreCase(DIGITAL_SIGNATURE)) {             set(0,val);         } else if (name.equalsIgnoreCase(NON_REPUDIATION)) {             set(1,val);         } else if (name.equalsIgnoreCase(KEY_ENCIPHERMENT)) {             set(2,val);         } else if (name.equalsIgnoreCase(DATA_ENCIPHERMENT)) {             set(3,val);         } else if (name.equalsIgnoreCase(KEY_AGREEMENT)) {             set(4,val);         } else if (name.equalsIgnoreCase(KEY_CERTSIGN)) {             set(5,val);         } else if (name.equalsIgnoreCase(CRL_SIGN)) {             set(6,val);         } else if (name.equalsIgnoreCase(ENCIPHER_ONLY)) {             set(7,val);         } else if (name.equalsIgnoreCase(DECIPHER_ONLY)) {             set(8,val);         } else {           throw new IOException(""Attribute name not recognized by""                                 + "" CertAttrSet:KeyUsage."");         }         encodeThis();     }
void rainbow(Nfa nfa, int type, short but, State from, State to) {         ColorDesc cd;         short co;          for (co = 0; co < colorDescs.size(); co++) {             cd = colorDescs.get(co);             if (cd != null                     && cd.sub != co                     && co != but                     && !cd.pseudo()) {                 nfa.newarc(type, co, from, to);             }         }     }
@Override   public boolean isFlowRunning(final int projectId, final String flowId) {     boolean isRunning = false;     try {       isRunning = isFlowRunningHelper(projectId, flowId,           this.executorLoader.fetchUnfinishedFlows().values());      } catch (final ExecutorManagerException e) {       logger.error(           ""Failed to check if the flow is running for project "" + projectId + "", flow "" + flowId,           e);     }     return isRunning;   }
public int getCount (K key)     {         CountEntry<K> entry = _backing.get(key);         return (entry == null) ? 0 : entry.count;     }
private static SerializerFactory getInstance() {     if (instance == null) {       String className = JacksonSerializerFactory.class.getName();       try {         className = System.getProperty(SERIALIZER_FACTORY_CLASS_NAME);       } catch (Exception e) {       }        if (className != null) {         ClassLoader loader = Thread.currentThread().getContextClassLoader();         try {           Class<?> clazz = loader.loadClass(className);           instance = (SerializerFactory) clazz.newInstance();         } catch (Exception e) {           throw new IllegalArgumentException(""Error instantiating serializer factory."");         }       } else {         instance = new JacksonSerializerFactory();       }     }     return instance;   }
protected SofaResponse doInvokeSync(SofaRequest request, int timeout) throws InterruptedException,         ExecutionException, TimeoutException {         HttpResponseFuture future = new HttpResponseFuture(request, timeout);         AbstractHttpClientHandler callback = new SyncInvokeClientHandler(transportConfig.getConsumerConfig(),             transportConfig.getProviderInfo(), future, request, RpcInternalContext.getContext(),             ClassLoaderUtils.getCurrentClassLoader());         future.setSentTime();         doSend(request, callback, timeout);         future.setSentTime();         return future.getSofaResponse(timeout, TimeUnit.MILLISECONDS);     }
public final double getScore(int s, int t, int d, int ic) {         return scores[getIndex(s, t, d, ic)];     }
protected String getDefaultString() {         final StringBuilder outBuilder = new StringBuilder();         if (!namespace.isEmpty()) {             outBuilder.append(namespace).append(""\n"");         }         if (!qvarMapVariable.isEmpty() && addQvarMap) {             outBuilder.append(qvarMapVariable).append(""\n"");         }         outBuilder.append(""for $m in "").append(pathToRoot).append("" return\n"")                 .append(""for $x in $m//*:"").append(NonWhitespaceNodeList.getFirstChild(mainElement).getLocalName())                 .append(""\n"").append(exactMatchXQuery);         if (!lengthConstraint.isEmpty() || !qvarConstraint.isEmpty()) {             outBuilder.append(""\n"").append(""where"").append(""\n"");             if (lengthConstraint.isEmpty()) {                 outBuilder.append(qvarConstraint);             } else {                 outBuilder.append(lengthConstraint)                         .append(qvarConstraint.isEmpty() ? """" : ""\n and "").append(qvarConstraint);             }         }         outBuilder.append(""\n\n"").append(""return"").append(""\n"").append(returnFormat);         return outBuilder.toString();     }
@Nonnull   public static String getAsCompleteDisplayName (@Nonnull final IPersonName aName)   {     if (isFirstNameFirst ())       return getAsCompleteDisplayNameFirstNameFirst (aName);     return getAsCompleteDisplayNameLastNameFirst (aName);   }
static void log(Task action, String msg) {         log(action.event.getKey(), action.method, msg);     }
public void end() {     final OClass vClass = db.getMetadata().getSchema().getClass(vertexClass);      try {        runningThreads = new AtomicInteger(parallel);       for (int i = 0; i < parallel - 1; i++) {         Thread t = new BatchImporterJob(i, vClass);         t.start();       }       Thread t = new BatchImporterJob(parallel - 1, vClass);       t.run();        if (runningThreads.get() > 0) {         synchronized (runningThreads) {           while (runningThreads.get() > 0) {             try {               runningThreads.wait();             } catch (InterruptedException e) {             }           }         }       }      } finally {       db.activateOnCurrentThread();       db.declareIntent(null);       db.close();       if (walActive)         OGlobalConfiguration.USE_WAL.setValue(true);     }   }
public static HttpClientContext newClientContext(HttpClientSettings settings,                                                      Map<String, ? extends Object>                                                              attributes) {         final HttpClientContext clientContext = new HttpClientContext();          if (attributes != null && !attributes.isEmpty()) {             for (Map.Entry<String, ?> entry : attributes.entrySet()) {                 clientContext.setAttribute(entry.getKey(), entry.getValue());             }         }          addPreemptiveAuthenticationProxy(clientContext, settings);          clientContext.setAttribute(HttpContextUtils.DISABLE_SOCKET_PROXY_PROPERTY, settings.disableSocketProxy());         return clientContext;      }
private PropertySource<?> loadSettingsByApplicationProfiles(final Environment environment, final File config) {         val profiles = ConfigurationPropertiesLoaderFactory.getApplicationProfiles(environment);         val resources = scanForConfigurationResources(config, profiles);         val composite = new CompositePropertySource(""applicationProfilesCompositeProperties"");         LOGGER.info(""Configuration files found at [{}] are [{}] under profile(s) [{}]"", config, resources, profiles);         resources.forEach(Unchecked.consumer(f -> {             LOGGER.debug(""Loading configuration file [{}]"", f);             val loader = configurationPropertiesLoaderFactory.getLoader(f, ""applicationProfilesProperties-"" + f.getFilename());             composite.addFirstPropertySource(loader.load());         }));          return composite;     }
final public void exclusiveOrExpression() throws ParseException {     andExpression();     label_5:     while (true) {       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {       case 11:       case 12:         ;         break;       default:         jj_la1[9] = jj_gen;         break label_5;       }       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {       case 11:         jj_consume_token(11);         break;       case 12:         jj_consume_token(12);         break;       default:         jj_la1[10] = jj_gen;         jj_consume_token(-1);         throw new ParseException();       }                                      ASTXor jjtn001 = new ASTXor(JJTXOR);                                      boolean jjtc001 = true;                                      jjtree.openNodeScope(jjtn001);       try {         andExpression();       } catch (Throwable jjte001) {                                      if (jjtc001) {                                        jjtree.clearNodeScope(jjtn001);                                        jjtc001 = false;                                      } else {                                        jjtree.popNode();                                      }                                      if (jjte001 instanceof RuntimeException) {                                        {if (true) throw (RuntimeException)jjte001;}                                      }                                      if (jjte001 instanceof ParseException) {                                        {if (true) throw (ParseException)jjte001;}                                      }                                      {if (true) throw (Error)jjte001;}       } finally {                                      if (jjtc001) {                                        jjtree.closeNodeScope(jjtn001,  2);                                      }       }     }   }
public String getToolTip() {         StringBuilder message = new StringBuilder();         message.append(""<p>"");         message.append(Messages.DRY_Duplications_Header());         message.append(""<ul>"");         for (DuplicateCode duplication : links) {             message.append(""<li>"");             message.append(String.format(""<a href=\""link.%s.%s/#%s\"">%s (%s)</a>"",                     getKey(), duplication.getKey(), duplication.getPrimaryLineNumber(),                     duplication.getLinkName(), duplication.getPrimaryLineNumber()));             message.append(""</li>"");         }         message.append(""</ul>"");         message.append(""</p>"");         return message.toString();     }
@SuppressWarnings({""PMD.UseObjectForClearerAPI""})     // CHECKSTYLE:ON     private static void logDefault(final String key,                                    final String invalidValue,                                    final String validationError,                                    final String defaultValue) {          if (LOG.isWarnEnabled()) {             final StringBuilder msg = new StringBuilder(""Invalid value ('"")                     .append(invalidValue)                     .append(""', "")                     .append(validationError)                     .append("") for key '"")                     .append(key)                     .append(""', using default instead ('"");             if (defaultValue == null) {                 msg.append(""null')"");             } else {                 msg.append(defaultValue).append(""')"");             }             LOG.warn(msg.toString());         }     }
public static MediaPlayer createMediaPlayer(String filenameOrURL) {         // create mediaplayer instance         MediaPlayer mediaPlayer = new MediaPlayer();         try {             mediaPlayer.setDataSource(filenameOrURL);             mediaPlayer.prepare();         } catch (IOException e) {             e.printStackTrace();             return null;         }          return mediaPlayer;     }
@Override     public Request<ReplaceTransitGatewayRouteRequest> getDryRunRequest() {         Request<ReplaceTransitGatewayRouteRequest> request = new ReplaceTransitGatewayRouteRequestMarshaller().marshall(this);         request.addParameter(""DryRun"", Boolean.toString(true));         return request;     }
private ExecutionMessage createTerminatedExecutionMessage(Execution nextStepExecution) {         Payload payload = converter.createPayload(nextStepExecution); //we need the payload         ExecutionMessage finalMessage = (ExecutionMessage) executionMessage.clone();         finalMessage.setStatus(ExecStatus.TERMINATED); //in queue it is checked and finish flow is called         finalMessage.incMsgSeqId();         finalMessage.setPayload(payload);         return finalMessage;     }
public List<Integer> getTrackIds() {         ArrayList<Integer> results = new ArrayList<Integer>(trackCount);         Enumeration<? extends ZipEntry> entries = zipFile.entries();         while (entries.hasMoreElements()) {             ZipEntry entry = entries.nextElement();             if (entry.getName().startsWith(CACHE_METADATA_ENTRY_PREFIX)) {                 String idPart = entry.getName().substring(CACHE_METADATA_ENTRY_PREFIX.length());                 if (idPart.length() > 0) {                     results.add(Integer.valueOf(idPart));                 }             }         }          return Collections.unmodifiableList(results);     }
public void skip(long n) throws IOException {   if (capacity == 0) {    // aligned    while (n != 0) {     n -= istream.skip(n);    }   } else {    // not aligned, grrr    for (int i = 0; i < n; n++) {     readBits(8);    }   }  }
AlignmentPattern find() throws NotFoundException {     int startX = this.startX;     int height = this.height;     int maxJ = startX + width;     int middleI = startY + (height / 2);     // We are looking for black/white/black modules in 1:1:1 ratio;     // this tracks the number of black/white/black modules seen so far     int[] stateCount = new int[3];     for (int iGen = 0; iGen < height; iGen++) {       // Search from middle outwards       int i = middleI + ((iGen & 0x01) == 0 ? (iGen + 1) / 2 : -((iGen + 1) / 2));       stateCount[0] = 0;       stateCount[1] = 0;       stateCount[2] = 0;       int j = startX;       // Burn off leading white pixels before anything else; if we start in the middle of       // a white run, it doesn't make sense to count its length, since we don't know if the       // white run continued to the left of the start point       while (j < maxJ && !image.get(j, i)) {         j++;       }       int currentState = 0;       while (j < maxJ) {         if (image.get(j, i)) {           // Black pixel           if (currentState == 1) { // Counting black pixels             stateCount[1]++;           } else { // Counting white pixels             if (currentState == 2) { // A winner?               if (foundPatternCross(stateCount)) { // Yes                 AlignmentPattern confirmed = handlePossibleCenter(stateCount, i, j);                 if (confirmed != null) {                   return confirmed;                 }               }               stateCount[0] = stateCount[2];               stateCount[1] = 1;               stateCount[2] = 0;               currentState = 1;             } else {               stateCount[++currentState]++;             }           }         } else { // White pixel           if (currentState == 1) { // Counting black pixels             currentState++;           }           stateCount[currentState]++;         }         j++;       }       if (foundPatternCross(stateCount)) {         AlignmentPattern confirmed = handlePossibleCenter(stateCount, i, maxJ);         if (confirmed != null) {           return confirmed;         }       }      }      // Hmm, nothing we saw was observed and confirmed twice. If we had     // any guess at all, return it.     if (!possibleCenters.isEmpty()) {       return possibleCenters.get(0);     }      throw NotFoundException.getNotFoundInstance();   }
private ClassLoader getDefaultClassLoader() {         ClassLoader classLoader;         try {             classLoader = Thread.currentThread().getContextClassLoader();         } catch (Throwable ex) {             classLoader = null;         }         if (classLoader == null) {             classLoader = ClassPathResource.class.getClassLoader();         }         return classLoader;     }
public final void ruleOpAdd() throws RecognitionException {            int stackSize = keepStackSize();                   try {             // InternalXbase.g:446:2: ( ( ( rule__OpAdd__Alternatives ) ) )             // InternalXbase.g:447:2: ( ( rule__OpAdd__Alternatives ) )             {             // InternalXbase.g:447:2: ( ( rule__OpAdd__Alternatives ) )             // InternalXbase.g:448:3: ( rule__OpAdd__Alternatives )             {             if ( state.backtracking==0 ) {                before(grammarAccess.getOpAddAccess().getAlternatives());              }             // InternalXbase.g:449:3: ( rule__OpAdd__Alternatives )             // InternalXbase.g:449:4: rule__OpAdd__Alternatives             {             pushFollow(FOLLOW_2);             rule__OpAdd__Alternatives();              state._fsp--;             if (state.failed) return ;              }              if ( state.backtracking==0 ) {                after(grammarAccess.getOpAddAccess().getAlternatives());              }              }               }          }         catch (RecognitionException re) {             reportError(re);             recover(input,re);         }         finally {               restoreStackSize(stackSize);          }         return ;     }
public static com.liferay.commerce.model.CommerceShipmentItem deleteCommerceShipmentItem(   com.liferay.commerce.model.CommerceShipmentItem commerceShipmentItem) {   return getService().deleteCommerceShipmentItem(commerceShipmentItem);  }
protected List<WsByteBuffer> compress(List<WsByteBuffer> list, WsByteBuffer buffer) {         if (null == buffer) {             return null;         }         int dataSize = buffer.remaining();         if (0 == dataSize) {             return list;         }         byte[] input = null;         int initOffset = 0;         if (buffer.hasArray()) {             input = buffer.array();             initOffset = buffer.arrayOffset() + buffer.position();             buffer.position(buffer.limit());         } else {             input = new byte[dataSize];             buffer.get(input);         }         this.deflater.setInput(input, initOffset, dataSize);          // keep compressing data until we use up the input amount         int offset = 0;         while (!this.deflater.needsInput()) {             int len = this.deflater.deflate(this.buf, offset, this.buf.length - offset);             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                 Tr.debug(tc, ""Compressed amount="" + len + "" read="" + this.deflater.getBytesRead() + "" written="" + this.deflater.getBytesWritten());             }             if (0 == len) {                 break; // out of while             }             offset += len;             if (offset == this.buf.length) {                 list.add(makeBuffer(offset));                 offset = 0;             }         }         // if we generated output, put it into a buffer on the list         if (0 < offset) {             list.add(makeBuffer(offset));         }         return list;     }
@Override   public EClass getIfcRevolvedAreaSolidTapered() {    if (ifcRevolvedAreaSolidTaperedEClass == null) {     ifcRevolvedAreaSolidTaperedEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)       .getEClassifiers().get(576);    }    return ifcRevolvedAreaSolidTaperedEClass;   }
private boolean isRequestURLEqualsExitPageHost(HttpServletRequest req, String logoutURLhost) {         boolean acceptURL = false;         try {             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())                 Tr.debug(tc, ""about to attempt matching the logout exit url with the domain of the request."");             StringBuffer requestURLString = req.getRequestURL();             URL requestURL = new URL(new String(requestURLString));             String requestURLhost = requestURL.getHost();             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())                 Tr.debug(tc, "" host of the request url is: "" + requestURLhost + "" and the host of the logout URL is: "" + logoutURLhost);             if (logoutURLhost != null && requestURLhost != null && logoutURLhost.equalsIgnoreCase(requestURLhost)) {                 acceptURL = true;             }         } catch (MalformedURLException e) {             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {                 Tr.debug(tc, ""caught Exception trying to form request URL object: "" + e.getMessage());             }         }         return acceptURL;     }
public static <T> CompletableFuture<List<T>> allOf(List<CompletableFuture<T>> futures) {     return AtomixFuture.wrap(CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()]))         .thenApply(v -> futures.stream()             .map(CompletableFuture::join)             .collect(Collectors.toList())));   }
private ArrayList<ArrayDBIDs> buildOneDimIndexes(Relation<? extends NumberVector> relation) {     final int dim = RelationUtil.dimensionality(relation);     ArrayList<ArrayDBIDs> subspaceIndex = new ArrayList<>(dim + 1);      SortDBIDsBySingleDimension comp = new VectorUtil.SortDBIDsBySingleDimension(relation);     for(int i = 0; i < dim; i++) {       ArrayModifiableDBIDs amDBIDs = DBIDUtil.newArray(relation.getDBIDs());       comp.setDimension(i);       amDBIDs.sort(comp);       subspaceIndex.add(amDBIDs);     }      return subspaceIndex;   }
private SSLSocketFactory getSSLSocketFactory() throws Exception {         SSLSocketFactory sslSF = null;         Object sslConfig = this.sslConfig.getService();         if(sslConfig != null) {             // Reflectively invoke this operation to a helper class because the classes needed to perform             // this operation are dynamically imported, depending on if the ssl-1.0 feature is enabled.             Class<?> SSLHelper = Class.forName(""com.ibm.ws.cloudant.internal.SSLHelper"");             sslSF = (SSLSocketFactory) SSLHelper.getMethod(""getSSLSocketFactory"", Object.class).invoke(null, sslConfig);         }         return sslSF;     }
public void setWorldRotations(float[] rotations)     {         if (rotations.length != mBones.length * 4)         {             throw new IllegalArgumentException(""Source array is the wrong size"");         }         mNeedSync = true;         for (int i = 0; i < mBones.length; ++i)         {             Bone bone = mBones[i];             int t = i * 4;              bone.setWorldRotation(rotations[t], rotations[t + 1], rotations[t + 2], rotations[t + 3]);             bone.Changed |= WORLD_ROT;              calcLocal(bone, mSkeleton.getParentBoneIndex(i));              if (sDebug)             {                 Log.d(""BONE"", ""setWorldRotation: %s %s"", mSkeleton.getBoneName(i), bone.toString());             }         }     }
public Binder varargs(int index, Class<?> type) {         return new Binder(this, new Varargs(type(), index, type));     }
@Override  protected boolean doHandleRequest(final Request request) {   boolean selected = getRequestValue(request);   boolean current = getValue();    boolean changed = current != selected;    if (changed) {    setData(selected);   }    return changed;  }
public int getLearnerToUse(int predMode) {   int predictionMode = predMode;   if (predictionMode == 0) {    double perceptronError= this.perceptron.getCurrentError();    double meanTargetError =this.targetMean.getCurrentError();    if (perceptronError < meanTargetError)     predictionMode = 1; //PERCEPTRON    else     predictionMode = 2; //TARGET MEAN   }   return predictionMode;  }
public final void addAll (final SettingsMap textKeys) {          for (Map.Entry<OperationalTextKey , String> e : textKeys.entrySet()) {             add(e.getKey(), e.getValue());         }          isDirty = true;     }
private File getFileForEvent(File collectionDir, Calendar timestamp) throws IOException {         int counter = 0;         File eventFile = getNextFileForEvent(collectionDir, timestamp, counter);         while (eventFile.exists()) {             eventFile = getNextFileForEvent(collectionDir, timestamp, counter);             counter++;         }         return eventFile;     }
private void createPathQuery(String path, int operation)    {       MergingPathQueryNode pathNode =          new MergingPathQueryNode(operation, factory.createPathQueryNode(null).getValidJcrSystemNodeTypeNames());       pathNode.setAbsolute(true);        if (path.equals(""/""))       {          pathNode.addPathStep(factory.createLocationStepQueryNode(pathNode));          pathConstraints.add(pathNode);          return;       }        String[] names = path.split(""/"");        for (int i = 0; i < names.length; i++)       {          if (names[i].length() == 0)          {             if (i == 0)             {                // root                pathNode.addPathStep(factory.createLocationStepQueryNode(pathNode));             }             else             {                // descendant '//' -> invalid path                // todo throw or ignore?                // we currently do not throw and add location step for an                // empty name (which is basically the root node)                pathNode.addPathStep(factory.createLocationStepQueryNode(pathNode));             }          }          else          {             int idx = names[i].indexOf('[');             String name;             int index = LocationStepQueryNode.NONE;             if (idx > -1)             {                // contains index                name = names[i].substring(0, idx);                String suffix = names[i].substring(idx);                String indexStr = suffix.substring(1, suffix.length() - 1);                if (indexStr.equals(""%""))                {                   // select all same name siblings                   index = LocationStepQueryNode.NONE;                }                else                {                   try                   {                      index = Integer.parseInt(indexStr);                   }                   catch (NumberFormatException e)                   {                      log.warn(""Unable to parse index for path element: "" + names[i]);                   }                }                if (name.equals(""%""))                {                   name = null;                }             }             else             {                // no index specified                // - index defaults to 1 if there is an explicit name test                // - index defaults to NONE if name test is %                name = names[i];                if (name.equals(""%""))                {                   name = null;                }                else                {                   index = 1;                }             }             InternalQName qName = null;             if (name != null)             {                try                {                   qName = resolver.parseJCRName(name).getInternalName();                }                catch (NamespaceException e)                {                   throw new IllegalArgumentException(""Illegal name: "" + name, e);                }                catch (RepositoryException e)                {                   throw new IllegalArgumentException(""Illegal name: "" + name, e);                }              }             // if name test is % this means also search descendants             boolean descendant = name == null;             LocationStepQueryNode step = factory.createLocationStepQueryNode(pathNode);             step.setNameTest(qName);             step.setIncludeDescendants(descendant);             if (index > 0)             {                step.setIndex(index);             }             pathNode.addPathStep(step);          }       }       pathConstraints.add(pathNode);    }
public static base_response add(nitro_service client, cmppolicylabel resource) throws Exception {   cmppolicylabel addresource = new cmppolicylabel();   addresource.labelname = resource.labelname;   addresource.type = resource.type;   return addresource.add_resource(client);  }
public Point3d[] calculate3DCoordinates1(Point3d aPoint, Point3d bPoint, Point3d cPoint, int nwanted,             double length, double angle) {         Point3d points[] = new Point3d[nwanted];         // BA vector         Vector3d ba = new Vector3d(aPoint);         ba.sub(bPoint);         ba.normalize();         // if no cPoint, generate a random reference         if (cPoint == null) {             Vector3d cVector = getNonColinearVector(ba);             cPoint = new Point3d(cVector);         }         // CB vector         Vector3d cb = new Vector3d(bPoint);         cb.sub(cPoint);         cb.normalize();         // if A, B, C colinear, replace C by random point         double cbdotba = cb.dot(ba);         if (cbdotba > 0.999999) {             Vector3d cVector = getNonColinearVector(ba);             cPoint = new Point3d(cVector);             cb = new Vector3d(bPoint);             cb.sub(cPoint);         }         // cbxba = c x b         Vector3d cbxba = new Vector3d();         cbxba.cross(cb, ba);         cbxba.normalize();         // create three perp axes ba, cbxba, and ax         Vector3d ax = new Vector3d();         ax.cross(cbxba, ba);         ax.normalize();         double drot = Math.PI * 2.0 / (double) nwanted;         for (int i = 0; i < nwanted; i++) {             double rot = (double) i * drot;             points[i] = new Point3d(aPoint);             Vector3d vx = new Vector3d(ba);             vx.scale(-Math.cos(angle) * length);             Vector3d vy = new Vector3d(ax);             vy.scale(Math.cos(rot) * length);             Vector3d vz = new Vector3d(cbxba);             vz.scale(Math.sin(rot) * length);             points[i].add(vx);             points[i].add(vy);             points[i].add(vz);         }         /*          * ax = null; cbxba = null; ba = null; cb = null;          */         return points;     }
public static Date parseTimestamp(String date) {   try {    return hasText(date) ? timestampParser.parse(date) : null;   } catch (ParseException e) {    logger.log(Level.WARNING, ""parseTimestamp - ParseException caught."", e);   }    return null;  }
private String getSqlName(final Path path) {   StringBuilder builder = new StringBuilder();    boolean dialectFlag = true;   for (Path part : relativePath(path)) {    String s = part.toString();    if (dialectFlag) {     // loadPathの直下がdialectと一致する場合はその下のフォルダから名前を付ける     dialectFlag = false;     if (dialects.contains(s.toLowerCase())) {      continue;     }    }    builder.append(s).append(""/"");   }    return builder.substring(0, builder.length() - (fileExtension.length() + 1));  }
public List<T> collect() throws Exception {   final String id = new AbstractID().toString();   final TypeSerializer<T> serializer = getType().createSerializer(getExecutionEnvironment().getConfig());    this.output(new Utils.CollectHelper<>(id, serializer)).name(""collect()"");   JobExecutionResult res = getExecutionEnvironment().execute();    ArrayList<byte[]> accResult = res.getAccumulatorResult(id);   if (accResult != null) {    try {     return SerializedListAccumulator.deserializeList(accResult, serializer);    } catch (ClassNotFoundException e) {     throw new RuntimeException(""Cannot find type class of collected data type."", e);    } catch (IOException e) {     throw new RuntimeException(""Serialization error while deserializing collected data"", e);    }   } else {    throw new RuntimeException(""The call to collect() could not retrieve the DataSet."");   }  }
public DeviceDescription withAttributes(java.util.Map<String, String> attributes) {         setAttributes(attributes);         return this;     }
private void addTranslationJacobian( DMatrixRMaj R ,            Point3D_F64 cameraPt )  {   double z = cameraPt.z;   double z2 = z*z;    // partial T.x   output[indexX++] = R.get(0,0)/cameraPt.z - R.get(2,0)/z2*cameraPt.x;   output[indexY++] = R.get(1,0)/cameraPt.z - R.get(2,0)/z2*cameraPt.y;   // partial T.y   output[indexX++] = R.get(0,1)/cameraPt.z - R.get(2,1)/z2*cameraPt.x;   output[indexY++] = R.get(1,1)/cameraPt.z - R.get(2,1)/z2*cameraPt.y;   // partial T.z   output[indexX++] = R.get(0,2)/cameraPt.z - R.get(2,2)/z2*cameraPt.x;   output[indexY++] = R.get(1,2)/cameraPt.z - R.get(2,2)/z2*cameraPt.y;  }
private boolean hasBidirectionalAssociation(Class clazz)      {          ClassDescriptor cdesc;          Collection refs;          boolean hasBidirAssc;            if (_withoutBidirAssc.contains(clazz))          {              return false;          }            if (_withBidirAssc.contains(clazz))          {              return true;          }            // first time we meet this class, let's look at metadata          cdesc = _pb.getClassDescriptor(clazz);          refs = cdesc.getObjectReferenceDescriptors();          hasBidirAssc = false;          REFS_CYCLE:          for (Iterator it = refs.iterator(); it.hasNext(); )          {              ObjectReferenceDescriptor ord;              ClassDescriptor relCDesc;              Collection relRefs;                ord = (ObjectReferenceDescriptor) it.next();              relCDesc = _pb.getClassDescriptor(ord.getItemClass());              relRefs = relCDesc.getObjectReferenceDescriptors();              for (Iterator relIt = relRefs.iterator(); relIt.hasNext(); )              {                  ObjectReferenceDescriptor relOrd;                    relOrd = (ObjectReferenceDescriptor) relIt.next();                  if (relOrd.getItemClass().equals(clazz))                  {                      hasBidirAssc = true;                      break REFS_CYCLE;                  }              }          }          if (hasBidirAssc)          {              _withBidirAssc.add(clazz);          }          else          {              _withoutBidirAssc.add(clazz);          }            return hasBidirAssc;      }
public String words(int count) {   StringBuilder s = new StringBuilder();   while (count-- > 0)    s.append(randomWord()).append("" "");   return s.toString().trim();  }
@Override  public <T> List<T> search(String base, String filter, int searchScope, AttributesMapper<T> mapper) {   return search(base, filter, searchScope, ALL_ATTRIBUTES, mapper);  }
public void init(Configuration configuration) throws Exception {         if (configuration.getBootstrapPropertyResolver().getProperty(CONTEXT_TIMEOUT_NAME) != null) {             log.debug(""Configuring context timeout with value "", configuration.getBootstrapPropertyResolver().getProperty(CONTEXT_TIMEOUT_NAME));             try {                 contextTimeout = Long.parseLong(configuration.getBootstrapPropertyResolver().getProperty(CONTEXT_TIMEOUT_NAME));             } catch (NumberFormatException e) {                 log.warn(""Init parameter "", CONTEXT_TIMEOUT_NAME, "" is not a parsable long, timeout will be "", "" instead"");                 contextTimeout = DEFAULT_CONTEXT_TIMEOUT;             }         }     }
private BioPAXElement getIdentical(BioPAXElement bpe)  {   int key = bpe.hashCode();   List<BioPAXElement> list = equivalenceMap.get(key);   if (list != null)   {    for (BioPAXElement other : list)    {     if (other.equals(bpe))     {      return other;     }    }   }   return null;  }
public boolean isOlderThan(SetElement other) {     if (other == null) {       return true;     }     return this.timestamp.isOlderThan(other.timestamp);   }
@Override     public StartThingRegistrationTaskResult startThingRegistrationTask(StartThingRegistrationTaskRequest request) {         request = beforeClientExecution(request);         return executeStartThingRegistrationTask(request);     }
public ArrayList<STUNService> loadSTUNServers(java.io.InputStream stunConfigStream) {         ArrayList<STUNService> serversList = new ArrayList<>();         String serverName;         int serverPort;          try {             XmlPullParser parser = XmlPullParserFactory.newInstance().newPullParser();             parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, true);             parser.setInput(stunConfigStream, ""UTF-8"");              int eventType = parser.getEventType();             do {                 if (eventType == XmlPullParser.START_TAG) {                      // Parse a STUN server definition                     if (parser.getName().equals(""stunServer"")) {                          serverName = null;                         serverPort = -1;                          // Parse the hostname                         parser.next();                         parser.next();                         serverName = parser.nextText();                          // Parse the port                         parser.next();                         parser.next();                         try {                             serverPort = Integer.parseInt(parser.nextText());                         }                         catch (Exception e) {                         }                          // If we have a valid hostname and port, add                         // it to the list.                         if (serverName != null && serverPort != -1) {                             STUNService service = new STUNService(serverName, serverPort);                              serversList.add(service);                         }                     }                 }                 eventType = parser.next();              }             while (eventType != XmlPullParser.END_DOCUMENT);          }         catch (XmlPullParserException e) {             LOGGER.log(Level.SEVERE, ""Exception"", e);         }         catch (IOException e) {             LOGGER.log(Level.SEVERE, ""Exception"", e);         }          currentServer = bestSTUNServer(serversList);          return serversList;     }
public void clearCommand(Command command) {   List controls = getControlsFor(command);      for (int i=0;i<controls.size();i++) {       unbindCommand((Control) controls.get(i));      }  }
public void validateFile(MultipartFile file, long maxLength, String[] allowExtName) {          if (file.isEmpty()) {             throw new FieldException(""file"", ""您没有上传文件"", null);         }          // 文件大小         if (file.getSize() < 0 || file.getSize() > maxLength) {              throw new FieldException(""file"", ""文件不允许超过"" + String.valueOf(maxLength), null);         }          //         // 处理不选择文件点击上传时，也会有MultipartFile对象，在此进行过滤         //         String filename = file.getOriginalFilename();          if (filename == """") {             throw new FieldException(""file"", ""文件名不能为空"", null);         }          //         // 文件名后缀         //         /*         if (filename.contains(""."")) {              String extName = filename.substring(filename.lastIndexOf(""."")).toLowerCase();             if (allowExtName == null || allowExtName.length == 0 || Arrays.binarySearch(allowExtName, extName) >= 0) {             } else {                 //throw new FieldException(""file"", ""文件后缀不允许"", null);             }         } else {             //throw new FieldException(""file"", ""文件后缀不允许"", null);         }*/     }
public final EObject ruleJvmParameterizedTypeReference() throws RecognitionException {         EObject current = null;          Token otherlv_1=null;         Token otherlv_3=null;         Token otherlv_5=null;         Token otherlv_7=null;         Token otherlv_9=null;         Token otherlv_11=null;         Token otherlv_13=null;         EObject lv_arguments_2_0 = null;          EObject lv_arguments_4_0 = null;          EObject lv_arguments_10_0 = null;          EObject lv_arguments_12_0 = null;             enterRule();          try {             // InternalXtype.g:270:2: ( ( ( ( ruleQualifiedName ) ) ( ( ( '<' )=>otherlv_1= '<' ) ( (lv_arguments_2_0= ruleJvmArgumentTypeReference ) ) (otherlv_3= ',' ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) ) )* otherlv_5= '>' ( ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) ) ( ( ruleValidID ) ) ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )? )* )? ) )             // InternalXtype.g:271:2: ( ( ( ruleQualifiedName ) ) ( ( ( '<' )=>otherlv_1= '<' ) ( (lv_arguments_2_0= ruleJvmArgumentTypeReference ) ) (otherlv_3= ',' ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) ) )* otherlv_5= '>' ( ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) ) ( ( ruleValidID ) ) ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )? )* )? )             {             // InternalXtype.g:271:2: ( ( ( ruleQualifiedName ) ) ( ( ( '<' )=>otherlv_1= '<' ) ( (lv_arguments_2_0= ruleJvmArgumentTypeReference ) ) (otherlv_3= ',' ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) ) )* otherlv_5= '>' ( ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) ) ( ( ruleValidID ) ) ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )? )* )? )             // InternalXtype.g:272:3: ( ( ruleQualifiedName ) ) ( ( ( '<' )=>otherlv_1= '<' ) ( (lv_arguments_2_0= ruleJvmArgumentTypeReference ) ) (otherlv_3= ',' ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) ) )* otherlv_5= '>' ( ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) ) ( ( ruleValidID ) ) ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )? )* )?             {             // InternalXtype.g:272:3: ( ( ruleQualifiedName ) )             // InternalXtype.g:273:4: ( ruleQualifiedName )             {             // InternalXtype.g:273:4: ( ruleQualifiedName )             // InternalXtype.g:274:5: ruleQualifiedName             {             if ( state.backtracking==0 ) {                     if (current==null) {                     current = createModelElement(grammarAccess.getJvmParameterizedTypeReferenceRule());                    }                                }             if ( state.backtracking==0 ) {                     newCompositeNode(grammarAccess.getJvmParameterizedTypeReferenceAccess().getTypeJvmTypeCrossReference_0_0());                                }             pushFollow(FOLLOW_9);             ruleQualifiedName();              state._fsp--;             if (state.failed) return current;             if ( state.backtracking==0 ) {                     afterParserOrEnumRuleCall();                                }              }               }              // InternalXtype.g:288:3: ( ( ( '<' )=>otherlv_1= '<' ) ( (lv_arguments_2_0= ruleJvmArgumentTypeReference ) ) (otherlv_3= ',' ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) ) )* otherlv_5= '>' ( ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) ) ( ( ruleValidID ) ) ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )? )* )?             int alt10=2;             int LA10_0 = input.LA(1);              if ( (LA10_0==16) && (synpred2_InternalXtype())) {                 alt10=1;             }             switch (alt10) {                 case 1 :                     // InternalXtype.g:289:4: ( ( '<' )=>otherlv_1= '<' ) ( (lv_arguments_2_0= ruleJvmArgumentTypeReference ) ) (otherlv_3= ',' ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) ) )* otherlv_5= '>' ( ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) ) ( ( ruleValidID ) ) ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )? )*                     {                     // InternalXtype.g:289:4: ( ( '<' )=>otherlv_1= '<' )                     // InternalXtype.g:290:5: ( '<' )=>otherlv_1= '<'                     {                     otherlv_1=(Token)match(input,16,FOLLOW_10); if (state.failed) return current;                     if ( state.backtracking==0 ) {                             newLeafNode(otherlv_1, grammarAccess.getJvmParameterizedTypeReferenceAccess().getLessThanSignKeyword_1_0());                                                }                      }                      // InternalXtype.g:296:4: ( (lv_arguments_2_0= ruleJvmArgumentTypeReference ) )                     // InternalXtype.g:297:5: (lv_arguments_2_0= ruleJvmArgumentTypeReference )                     {                     // InternalXtype.g:297:5: (lv_arguments_2_0= ruleJvmArgumentTypeReference )                     // InternalXtype.g:298:6: lv_arguments_2_0= ruleJvmArgumentTypeReference                     {                     if ( state.backtracking==0 ) {                              newCompositeNode(grammarAccess.getJvmParameterizedTypeReferenceAccess().getArgumentsJvmArgumentTypeReferenceParserRuleCall_1_1_0());                                                 }                     pushFollow(FOLLOW_11);                     lv_arguments_2_0=ruleJvmArgumentTypeReference();                      state._fsp--;                     if (state.failed) return current;                     if ( state.backtracking==0 ) {                              if (current==null) {                              current = createModelElementForParent(grammarAccess.getJvmParameterizedTypeReferenceRule());                             }                             add(                              current,                              ""arguments"",                              lv_arguments_2_0,                              ""org.eclipse.xtext.xbase.Xtype.JvmArgumentTypeReference"");                             afterParserOrEnumRuleCall();                                                 }                      }                       }                      // InternalXtype.g:315:4: (otherlv_3= ',' ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) ) )*                     loop6:                     do {                         int alt6=2;                         int LA6_0 = input.LA(1);                          if ( (LA6_0==13) ) {                             alt6=1;                         }                           switch (alt6) {                      case 1 :                          // InternalXtype.g:316:5: otherlv_3= ',' ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) )                          {                          otherlv_3=(Token)match(input,13,FOLLOW_10); if (state.failed) return current;                          if ( state.backtracking==0 ) {                                  newLeafNode(otherlv_3, grammarAccess.getJvmParameterizedTypeReferenceAccess().getCommaKeyword_1_2_0());                                                          }                          // InternalXtype.g:320:5: ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) )                          // InternalXtype.g:321:6: (lv_arguments_4_0= ruleJvmArgumentTypeReference )                          {                          // InternalXtype.g:321:6: (lv_arguments_4_0= ruleJvmArgumentTypeReference )                          // InternalXtype.g:322:7: lv_arguments_4_0= ruleJvmArgumentTypeReference                          {                          if ( state.backtracking==0 ) {                                    newCompositeNode(grammarAccess.getJvmParameterizedTypeReferenceAccess().getArgumentsJvmArgumentTypeReferenceParserRuleCall_1_2_1_0());                                                            }                          pushFollow(FOLLOW_11);                          lv_arguments_4_0=ruleJvmArgumentTypeReference();                           state._fsp--;                          if (state.failed) return current;                          if ( state.backtracking==0 ) {                                    if (current==null) {                                    current = createModelElementForParent(grammarAccess.getJvmParameterizedTypeReferenceRule());                                   }                                   add(                                    current,                                    ""arguments"",                                    lv_arguments_4_0,                                    ""org.eclipse.xtext.xbase.Xtype.JvmArgumentTypeReference"");                                   afterParserOrEnumRuleCall();                                                            }                           }                            }                            }                          break;                       default :                          break loop6;                         }                     } while (true);                      otherlv_5=(Token)match(input,17,FOLLOW_12); if (state.failed) return current;                     if ( state.backtracking==0 ) {                            newLeafNode(otherlv_5, grammarAccess.getJvmParameterizedTypeReferenceAccess().getGreaterThanSignKeyword_1_3());                                               }                     // InternalXtype.g:344:4: ( ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) ) ( ( ruleValidID ) ) ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )? )*                     loop9:                     do {                         int alt9=2;                         int LA9_0 = input.LA(1);                          if ( (LA9_0==18) && (synpred3_InternalXtype())) {                             alt9=1;                         }                           switch (alt9) {                      case 1 :                          // InternalXtype.g:345:5: ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) ) ( ( ruleValidID ) ) ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )?                          {                          // InternalXtype.g:345:5: ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) )                          // InternalXtype.g:346:6: ( ( () '.' ) )=> ( () otherlv_7= '.' )                          {                          // InternalXtype.g:352:6: ( () otherlv_7= '.' )                          // InternalXtype.g:353:7: () otherlv_7= '.'                          {                          // InternalXtype.g:353:7: ()                          // InternalXtype.g:354:8:                           {                          if ( state.backtracking==0 ) {                                     current = forceCreateModelElementAndSet(                                     grammarAccess.getJvmParameterizedTypeReferenceAccess().getJvmInnerTypeReferenceOuterAction_1_4_0_0_0(),                                     current);                                                             }                           }                           otherlv_7=(Token)match(input,18,FOLLOW_13); if (state.failed) return current;                          if ( state.backtracking==0 ) {                                    newLeafNode(otherlv_7, grammarAccess.getJvmParameterizedTypeReferenceAccess().getFullStopKeyword_1_4_0_0_1());                                                            }                           }                            }                           // InternalXtype.g:366:5: ( ( ruleValidID ) )                          // InternalXtype.g:367:6: ( ruleValidID )                          {                          // InternalXtype.g:367:6: ( ruleValidID )                          // InternalXtype.g:368:7: ruleValidID                          {                          if ( state.backtracking==0 ) {                                    if (current==null) {                                    current = createModelElement(grammarAccess.getJvmParameterizedTypeReferenceRule());                                   }                                                            }                          if ( state.backtracking==0 ) {                                    newCompositeNode(grammarAccess.getJvmParameterizedTypeReferenceAccess().getTypeJvmTypeCrossReference_1_4_1_0());                                                            }                          pushFollow(FOLLOW_14);                          ruleValidID();                           state._fsp--;                          if (state.failed) return current;                          if ( state.backtracking==0 ) {                                    afterParserOrEnumRuleCall();                                                            }                           }                            }                           // InternalXtype.g:382:5: ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )?                          int alt8=2;                          int LA8_0 = input.LA(1);                           if ( (LA8_0==16) && (synpred4_InternalXtype())) {                              alt8=1;                          }                          switch (alt8) {                              case 1 :                                  // InternalXtype.g:383:6: ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>'                                  {                                  // InternalXtype.g:383:6: ( ( '<' )=>otherlv_9= '<' )                                  // InternalXtype.g:384:7: ( '<' )=>otherlv_9= '<'                                  {                                  otherlv_9=(Token)match(input,16,FOLLOW_10); if (state.failed) return current;                                  if ( state.backtracking==0 ) {                                            newLeafNode(otherlv_9, grammarAccess.getJvmParameterizedTypeReferenceAccess().getLessThanSignKeyword_1_4_2_0());                                                                            }                                   }                                   // InternalXtype.g:390:6: ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) )                                  // InternalXtype.g:391:7: (lv_arguments_10_0= ruleJvmArgumentTypeReference )                                  {                                  // InternalXtype.g:391:7: (lv_arguments_10_0= ruleJvmArgumentTypeReference )                                  // InternalXtype.g:392:8: lv_arguments_10_0= ruleJvmArgumentTypeReference                                  {                                  if ( state.backtracking==0 ) {                                             newCompositeNode(grammarAccess.getJvmParameterizedTypeReferenceAccess().getArgumentsJvmArgumentTypeReferenceParserRuleCall_1_4_2_1_0());                                                                             }                                  pushFollow(FOLLOW_11);                                  lv_arguments_10_0=ruleJvmArgumentTypeReference();                                   state._fsp--;                                  if (state.failed) return current;                                  if ( state.backtracking==0 ) {                                             if (current==null) {                                             current = createModelElementForParent(grammarAccess.getJvmParameterizedTypeReferenceRule());                                            }                                            add(                                             current,                                             ""arguments"",                                             lv_arguments_10_0,                                             ""org.eclipse.xtext.xbase.Xtype.JvmArgumentTypeReference"");                                            afterParserOrEnumRuleCall();                                                                             }                                   }                                    }                                   // InternalXtype.g:409:6: (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )*                                  loop7:                                  do {                                      int alt7=2;                                      int LA7_0 = input.LA(1);                                       if ( (LA7_0==13) ) {                                          alt7=1;                                      }                                        switch (alt7) {                                   case 1 :                                       // InternalXtype.g:410:7: otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) )                                       {                                       otherlv_11=(Token)match(input,13,FOLLOW_10); if (state.failed) return current;                                       if ( state.backtracking==0 ) {                                                 newLeafNode(otherlv_11, grammarAccess.getJvmParameterizedTypeReferenceAccess().getCommaKeyword_1_4_2_2_0());                                                                                      }                                       // InternalXtype.g:414:7: ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) )                                       // InternalXtype.g:415:8: (lv_arguments_12_0= ruleJvmArgumentTypeReference )                                       {                                       // InternalXtype.g:415:8: (lv_arguments_12_0= ruleJvmArgumentTypeReference )                                       // InternalXtype.g:416:9: lv_arguments_12_0= ruleJvmArgumentTypeReference                                       {                                       if ( state.backtracking==0 ) {                                                   newCompositeNode(grammarAccess.getJvmParameterizedTypeReferenceAccess().getArgumentsJvmArgumentTypeReferenceParserRuleCall_1_4_2_2_1_0());                                                                                        }                                       pushFollow(FOLLOW_11);                                       lv_arguments_12_0=ruleJvmArgumentTypeReference();                                        state._fsp--;                                       if (state.failed) return current;                                       if ( state.backtracking==0 ) {                                                   if (current==null) {                                                   current = createModelElementForParent(grammarAccess.getJvmParameterizedTypeReferenceRule());                                                  }                                                  add(                                                   current,                                                   ""arguments"",                                                   lv_arguments_12_0,                                                   ""org.eclipse.xtext.xbase.Xtype.JvmArgumentTypeReference"");                                                  afterParserOrEnumRuleCall();                                                                                        }                                        }                                         }                                         }                                       break;                                    default :                                       break loop7;                                      }                                  } while (true);                                   otherlv_13=(Token)match(input,17,FOLLOW_12); if (state.failed) return current;                                  if ( state.backtracking==0 ) {                                           newLeafNode(otherlv_13, grammarAccess.getJvmParameterizedTypeReferenceAccess().getGreaterThanSignKeyword_1_4_2_3());                                                                           }                                   }                                  break;                           }                            }                          break;                       default :                          break loop9;                         }                     } while (true);                       }                     break;              }               }               }              if ( state.backtracking==0 ) {                 leaveRule();              }         }              catch (RecognitionException re) {                 recover(input,re);                 appendSkippedTokens();             }         finally {         }         return current;     }
@Deprecated     @Override     protected int writeDeltaTo(int jumpTarget) {         int i=charsLength-jumpTarget;         assert(i>=0);         if(i<=CharsTrie.kMaxOneUnitDelta) {             return write(i);         }         int length;         if(i<=CharsTrie.kMaxTwoUnitDelta) {             intUnits[0]=(char)(CharsTrie.kMinTwoUnitDeltaLead+(i>>16));             length=1;         } else {             intUnits[0]=(char)(CharsTrie.kThreeUnitDeltaLead);             intUnits[1]=(char)(i>>16);             length=2;         }         intUnits[length++]=(char)i;         return write(intUnits, length);     }
public Location update(Map<String, Object> params) throws StripeException {     return update(params, (RequestOptions) null);   }
private final void donCompletion( CountedCompleter caller ) {   // Distributed completion     assert _lo == null || _lo.isDone();     assert _hi == null || _hi.isDone();     // Fold up results from left & right subtrees     if( _lo    != null ) reduce2(_lo.get());     if( _hi    != null ) reduce2(_hi.get());     if( _local != null ) reduce2(_local   );     // Note: in theory (valid semantics) we could push these ""over the wire""     // and block for them as we're blocking for the top-level initial split.     // However, that would require sending ""isDone"" flags over the wire also.     // MUCH simpler to just block for them all now, and send over the empty set     // of not-yet-blocked things.     if(_local != null && _local._fs != null )       _local._fs.blockForPending(); // Block on all other pending tasks, also     _keys = null;                   // Do not return _keys over wire     if( _top_level ) postGlobal();   }
synchronized void setDeadLetters(final DeadLetters deadLetters) {     if (deadLetters != null && this.deadLetters != null) {       deadLetters.stop();       throw new IllegalStateException(""Dead letters already exists."");     }      this.deadLetters = deadLetters;   }
@Override     public CreateLoggerDefinitionVersionResult createLoggerDefinitionVersion(CreateLoggerDefinitionVersionRequest request) {         request = beforeClientExecution(request);         return executeCreateLoggerDefinitionVersion(request);     }
public RemoteBaseSession makeRemoteSession(String strSessionClassName) throws RemoteException     {         BaseTransport transport = this.createProxyTransport(MAKE_REMOTE_SESSION);         transport.addParam(NAME, strSessionClassName);         String strClassAndID = (String)transport.sendMessageAndGetReply();         return this.checkForSession(strClassAndID);     }
public static <E> Optional<E> get(final Iterable<E> iterable, final int position) {         checkNotNull(iterable, ""Get requires an iterable"");         if (position < 0) {             return Optional.empty();         }          int iterablePosition = 0;         for (E anIterable : iterable) {             if (iterablePosition == position) {                 return of(anIterable);             }             iterablePosition++;         }          return Optional.empty();     }
public void copyDocFiles(Configuration configuration, PackageDoc pd) {         Location locn = configuration.getLocationForPackage(pd);         copyDocFiles(configuration, locn, DocPath.forPackage(pd).resolve(DocPaths.DOC_FILES));     }
private static void buildTransformers2_1_0(ResourceTransformationDescriptionBuilder builder) {         ResourceTransformationDescriptionBuilder hornetqServer = builder.addChildResource(pathElement(HORNETQ_SERVER));         ResourceTransformationDescriptionBuilder addressSetting = hornetqServer.addChildResource(AddressSettingDefinition.PATH);         rejectDefinedAttributeWithDefaultValue(addressSetting, MAX_REDELIVERY_DELAY, REDELIVERY_MULTIPLIER);          ResourceTransformationDescriptionBuilder bridge = hornetqServer.addChildResource(BridgeDefinition.PATH);         bridge.getAttributeBuilder().setValueConverter(new DoubleToBigDecimalConverter(), RETRY_INTERVAL_MULTIPLIER);           ResourceTransformationDescriptionBuilder clusterConnection = hornetqServer.addChildResource(ClusterConnectionDefinition.PATH);         clusterConnection.getAttributeBuilder().setValueConverter(new DoubleToBigDecimalConverter(), RETRY_INTERVAL_MULTIPLIER);          ResourceTransformationDescriptionBuilder connectionFactory = hornetqServer.addChildResource(ConnectionFactoryDefinition.PATH);         connectionFactory.getAttributeBuilder().setValueConverter(new DoubleToBigDecimalConverter(), RETRY_INTERVAL_MULTIPLIER);          ResourceTransformationDescriptionBuilder pooledConnectionFactory = hornetqServer.addChildResource(PooledConnectionFactoryDefinition.PATH);         pooledConnectionFactory.getAttributeBuilder().setValueConverter(new DoubleToBigDecimalConverter(), RETRY_INTERVAL_MULTIPLIER);     }
public Blade listen(@NonNull String address, int port) {         Assert.greaterThan(port, 0, ""server port not is negative number."");         this.environment.set(ENV_KEY_SERVER_ADDRESS, address);         this.environment.set(ENV_KEY_SERVER_PORT, port);         return this;     }
protected void getAllNamesAux(final List<String> vec) {         vec.addAll(this.variables.keySet());         if ( methods != null )             vec.addAll(this.methods.keySet());         if (this.parent != null)             this.parent.getAllNamesAux(vec);     }
protected RunClassInSeparateJvmMachine buildRunClassInSeparateJvmMachine(             String name,             String classNameWithMainToRun,             List<String> classpath,              List<String> jvmArguments,             File mavenBaseDir) {         return new RunClassInSeparateJvmMachine(             name,             classNameWithMainToRun,             classpath,             buildJvmArguments(),             mavenBaseDir         );     }
public SDVariable multiHeadDotProductAttention(String name, SDVariable queries, SDVariable keys, SDVariable values, SDVariable Wq, SDVariable Wk, SDVariable Wv, SDVariable Wo, SDVariable mask, boolean scaled){         final SDVariable result = f().multiHeadDotProductAttention(queries, keys, values, Wq, Wk, Wv, Wo, mask, scaled);         return updateVariableNameAndReference(result, name);     }
@Override   public synchronized boolean addEntry(Principal caller, Principal principal, Permission permission)   {    return addEntry(caller, new SecurityAccessControl(principal, permission));   }
private void add_block_to_freelist(Block block, int ql_index)     {         block.next = ql_heads[ql_index].first_block;         ql_heads[ql_index].first_block = block;         ql_heads[ql_index].length++;         if (ql_heads[ql_index].length == 1) {             nonempty_lists++;         }     }
public String java(GeneratedPackage generatedPackage, String javaClassName) {         generatedPackageRestriction(generatedPackage);         return java(generatedPackage.getPackageName(), javaClassName);     }
public static Rectangle getBoundaryAbsolute(Tile upperLeft, Tile lowerRight) {         return new Rectangle(upperLeft.getOrigin().x, upperLeft.getOrigin().y, lowerRight.getOrigin().x + upperLeft.tileSize, lowerRight.getOrigin().y + upperLeft.tileSize);     }
public BaseMessageFilter createDefaultFilter(JMessageListener listener)     {         BaseMessageFilter messageFilter = null;         String strQueueName = MessageConstants.RECORD_QUEUE_NAME; // Default queue name=         String strQueueType = MessageConstants.INTRANET_QUEUE;    // Default queue type         if (m_baseMessageQueue != null)         {             strQueueName = m_baseMessageQueue.getQueueName();             strQueueType = m_baseMessageQueue.getQueueType();         }         messageFilter = new BaseMessageFilter(strQueueName, strQueueType, null, null);    // Take all messages         messageFilter.addMessageListener(listener);         //xif (bAddToReceiver)  // Already added at previous line.         //x    this.addMessageFilter(messageFilter);         return messageFilter;     }
private static int calculateBitRate(int mpegVer, int layer, int code) {         int[] arr = null;         if (mpegVer == AudioFrame.MPEG_V1) {             switch (layer) {                 case AudioFrame.LAYER_1:                     arr = BIT_RATE_MPEG1_L1;                     break;                 case AudioFrame.LAYER_2:                     arr = BIT_RATE_MPEG1_L2;                     break;                 case AudioFrame.LAYER_3:                     arr = BIT_RATE_MPEG1_L3;                     break;             }         } else {             if (layer == AudioFrame.LAYER_1) {                 arr = BIT_RATE_MPEG2_L1;             } else {                 arr = BIT_RATE_MPEG2_L2;             }         }         return arr[code];     }
public static <E> Page<E> offsetPage(int offset, int limit) {         return offsetPage(offset, limit, DEFAULT_COUNT);     }
private void validateInterceptorBindings() throws EJBConfigurationException     {         final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();         if (isTraceOn && tc.isEntryEnabled())         {             Tr.entry(tc, ""validateInterceptorBindings"");         }          // d630872 - Build a list of methods that can be the target of an         // interceptor.  This includes all business methods (AroundInvoke) and         // all timer methods (AroundTimeout).         List<Method> interceptableMethods = new ArrayList<Method>(ivEJBMethodInfoMap.keySet());         if (ivBmd.timedMethodInfos != null) // d630872.1         {             for (EJBMethodInfoImpl info : ivBmd.timedMethodInfos)             {                 interceptableMethods.add(info.getMethod());             }         }          // For each InterceptorBinding from WCCM.         for (EJBInterceptorBinding binding : ivInterceptorBinding)         {             String ejbName = binding.getEJBName();             EJBInterceptorBinding.BindingStyle bindingStyle = binding.getBindingStyle();             if (ejbName.equals(""*""))             {                 // Style 1 binding. Is this the first style 1 InterceptorBinding?                 if (ivModuleInterceptorBinding == null)                 {                     // Save reference to module-level binding for future use.                     ivModuleInterceptorBinding = binding;                 }                 else                 {                     // CNTR0245E: The {0} module of the {1) application has more than one style 1 interceptor-binding                     // in the deployment descriptor. Only one style 1 interceptor-binding is allowed.                      J2EEName j2eeName = ivEJBModuleMetaDataImpl.getJ2EEName();                     String message = ""The "" + j2eeName.getModule() + "" module of the "" + j2eeName.getApplication()                                      + "" application has more than one style 1 interceptor-binding in the deployment""                                      + "" deployment descriptor. Only one style 1 interceptor-binding is allowed"";                     Tr.error(tc, ""DUPLICATE_STYLE_1_INTERCEPTOR_BINDING_CNTR0245E""                              , new Object[] { j2eeName.getModule(), j2eeName.getApplication() }); //d472939                     throw new EJBConfigurationException(message); // d463727                 }             }             else             {                 // Binding not for the module, so only process those interceptor bindings that are                 // for the EJB class specified by the caller.                 if (ejbName.equals(ivEjbName))                 {                     if (bindingStyle == EJBInterceptorBinding.BindingStyle.STYLE2)                     {                         // This is a style 2 interceptor-binding that applies to the class.                         // Is this the first style 2 interceptor binding for this EJB?                         if (ivClassInterceptorBinding == null)                         {                             // Yep, save reference style 2 for future use.                             ivClassInterceptorBinding = binding;                         }                         else                         {                             // Nope, then we need to validate and merge second style 2                             // with the first style 2 interceptor binding.                             EJBInterceptorBinding binding1 = ivClassInterceptorBinding; // d457352                             ivClassInterceptorBinding = validateAndMergeStyle2Bindings(binding1, binding); // d457352                         }                     }                     else if (bindingStyle == EJBInterceptorBinding.BindingStyle.STYLE3)                     {                         // This is a style 3 interceptor-binding that applies to all business                         // methods with the method name specified by method-name element.                         // Put style 3 interceptor binding into the map.                         String methodName = binding.getMethodName();                         EJBInterceptorBinding oldBinding = ivStyle3InterceptorBindingMap.put(methodName, binding);                          // Did the put replace an existing map entry?                         if (oldBinding != null)                         {                             // Yep, tthis was NOT the first style 3 binding for this EJB.  We need to validate and                             // merge second style 3 with the first style 3 interceptor binding.                             EJBInterceptorBinding merged;                             merged = validateAndMergeStyle3Or4Bindings(methodName, null, oldBinding, binding); // d457352                              // No exception was thrown, so merger is valid. Replace map entry with the merged binding.                             ivStyle3InterceptorBindingMap.put(methodName, merged); // d457352                         }                         else                         {                             // Nope, this must be the first style 3 binding for this EJB. We must                             // verify there is at least 1 business method exist by this method name.                             boolean notFound = true;                             for (Method m : interceptableMethods) // d630872                             {                                 // Does method name match?                                 if (m.getName().equals(methodName))                                 {                                     // Yep, indicate we found a business method and exit the loop.                                     notFound = false;                                     break;                                 }                             }                              // Log error and throw exception if business method was not found.                             if (notFound)                             {                                 if (isTraceOn && tc.isDebugEnabled())                                 {                                     Tr.debug(tc, ""method not found for interceptor binding"");                                     binding.dump();                                 }                                  // CNTR0244E: The {0} method name is not found in one of the business interfaces                                 // of the {1} enterprise bean. A style {2} interceptor-binding element requires                                 // the method to be a business method of the enterprise bean.                                 String j2eeName = ivJ2EEName.toString();                                 Tr.error(tc, ""BUSINESS_METHOD_NOT_FOUND_FOR_INTERCEPTOR_BINDING_CNTR0244E""                                          , new Object[] { methodName, j2eeName, ""3"" }); //d472939                                  String message = ""The "" + methodName + "" method name is not found ""                                                  + "" in one of the business interfaces of the "" + j2eeName                                                  + "" enterprise bean. A style 3 interceptor-binding element requires""                                                  + "" the method to be a business method of the enterprise bean"";                                 throw new EJBConfigurationException(message); // d463727                             }                         }                     }                     else if (bindingStyle == EJBInterceptorBinding.BindingStyle.STYLE4)                     {                         // This is a style 4 interceptor-binding that applies to a business method                         // with a specific method signature. Verify it does not duplicate a style 3 binding.                         String methodName = binding.getMethodName();                         List<String> methodParms = binding.getMethodParms();                         String signature = methodSignature(methodName, methodParms);                         signature = normalizeSignature(signature.trim());                          // d472972 start                         // Put style 4 interceptor binding into the map.                         EJBInterceptorBinding oldBinding = ivStyle4InterceptorBindingMap.put(signature, binding);                          // Did the put replace an existing map entry?                         if (oldBinding != null)                         {                             // Yep, this was NOT the first style 4 binding for this EJB method.  We need to validate and                             // merge second style 4 with the first style 4 interceptor binding.                             EJBInterceptorBinding merged;                             merged = validateAndMergeStyle3Or4Bindings(methodName, signature, oldBinding, binding); // d457352                              // No exception was thrown, so merger is valid. Replace map entry with the merged binding.                             if (isTraceOn && tc.isDebugEnabled())                             {                                 Tr.debug(tc, ""replaced style 4 for method signature: "" + signature);                             }                             ivStyle4InterceptorBindingMap.put(signature, merged);                         }                         else                         {                             // This is first style 4 binding for this EJB method.                             // Verify there is a business method by this method name and signature.                             if (isTraceOn && tc.isDebugEnabled())                             {                                 Tr.debug(tc, ""added style 4 for method signature: "" + signature);                             }                             boolean notFound = true;                             for (Method m : interceptableMethods) // d630872                             {                                 // Does method name and signature match?                                 if (m.getName().equals(methodName))                                 {                                     String methodSignature = MethodAttribUtils.methodSignature(m);                                     if (signature.equals(methodSignature))                                     {                                         // Yep, indicate we found the business method and exit the loop.                                         notFound = false;                                         break;                                     }                                 }                             }                              // Log error and throw exception if business method was not found.                             if (notFound)                             {                                 if (isTraceOn && tc.isDebugEnabled())                                 {                                     Tr.debug(tc, ""method not found for interceptor binding"");                                     binding.dump();                                 }                                  // CNTR0244E: The {0} method name is not found in one of the business interfaces                                 // of the {1} enterprise bean. A style {2} interceptor-binding element requires                                 // the method to be a business method of the enterprise bean.                                 String j2eeName = ivJ2EEName.toString();                                 Tr.error(tc, ""BUSINESS_METHOD_NOT_FOUND_FOR_INTERCEPTOR_BINDING_CNTR0244E""                                          , new Object[] { methodName, j2eeName, ""4"" }); //d472939                                  String message = ""The "" + methodName + "" method name is not found ""                                                  + "" in one of the business interfaces of the "" + j2eeName                                                  + "" enterprise bean. A style 4 interceptor-binding element requires""                                                  + "" the method to be a business method of the enterprise bean"";                                 throw new EJBConfigurationException(message); // d463727                             }                         } // d472972 end                     }                 }             }         }          if (isTraceOn && tc.isEntryEnabled())         {             Tr.exit(tc, ""validateInterceptorBindings"");         }     }
public void command_inout_asynch(String cmdname, CallBack cb) throws DevFailed {         deviceProxyDAO.command_inout_asynch(this, cmdname, cb);     }
public void updateMask(AclActions groupActions) {     AclActions result = new AclActions(groupActions);      for (Map.Entry<String, AclActions> kv : mNamedUserActions.entrySet()) {       AclActions userAction = kv.getValue();       result.merge(userAction);        for (AclAction action : AclAction.values()) {         if (result.contains(action) || userAction.contains(action)) {           result.add(action);         }       }     }      for (Map.Entry<String, AclActions> kv : mNamedGroupActions.entrySet()) {       AclActions userAction = kv.getValue();       result.merge(userAction);        for (AclAction action : AclAction.values()) {         if (result.contains(action) || userAction.contains(action)) {           result.add(action);         }       }     }      mMaskActions = result;   }
public void setData(byte[] data, int offset, int length) {         if (immutable) {             throw new IllegalStateException(ERR_MSG_IMMUTABLE);         }         this.data = new byte[length];         System.arraycopy(data, offset, this.data, 0, length);     }
public void marshall(GetContentModerationRequest getContentModerationRequest, ProtocolMarshaller protocolMarshaller) {          if (getContentModerationRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(getContentModerationRequest.getJobId(), JOBID_BINDING);             protocolMarshaller.marshall(getContentModerationRequest.getMaxResults(), MAXRESULTS_BINDING);             protocolMarshaller.marshall(getContentModerationRequest.getNextToken(), NEXTTOKEN_BINDING);             protocolMarshaller.marshall(getContentModerationRequest.getSortBy(), SORTBY_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public Criteria within(Circle circle) {    Assert.notNull(circle, ""Circle for 'within' must not be 'null'."");   return within(circle.getCenter(), circle.getRadius());  }
public <T> JavaRDD<T> createJavaRDD(             ExtractorConfig<T> config) {         return new DeepJavaRDD<>((DeepRDD<T, ExtractorConfig<T>>) createRDD(config));     }
public static File getTempDir(){         String p = System.getProperty(ND4JSystemProperties.ND4J_TEMP_DIR_PROPERTY);         if(p == null || p.isEmpty()){             return new File(System.getProperty(""java.io.tmpdir""));         } else {             return new File(p);         }     }
private <T> Single<PollingState<T>> pollPutOrPatchSingleAsync(final PollingState<T> pollingState, final Type resourceType) {         pollingState.withResourceType(resourceType);         pollingState.withSerializerAdapter(restClient().serializerAdapter());         if (pollingState.isStatusTerminal()) {             if (pollingState.isStatusSucceeded() && pollingState.resource() == null) {                 return updateStateFromGetResourceOperationAsync(pollingState, pollingState.putOrPatchResourceUri()).toSingle();             }             return Single.just(pollingState);         }         return putOrPatchPollingDispatcher(pollingState, pollingState.putOrPatchResourceUri())                 .map(new Func1<PollingState<T>, PollingState<T>>() {                     @Override                     public PollingState<T> call(PollingState<T> tPollingState) {                         tPollingState.throwCloudExceptionIfInFailedState();                         return tPollingState;                     }                 })                 .flatMap(new Func1<PollingState<T>, Observable<PollingState<T>>>() {                     @Override                     public Observable<PollingState<T>> call(PollingState<T> tPollingState) {                         if (pollingState.isStatusSucceeded() && pollingState.resource() == null) {                             return updateStateFromGetResourceOperationAsync(pollingState, pollingState.putOrPatchResourceUri());                         }                         return Observable.just(tPollingState);                     }                 })                 .toSingle();     }
public static long getIdlenessStartTime(Record record) {         long lastAccessTime = record.getLastAccessTime();         return lastAccessTime <= 0 ? record.getCreationTime() : lastAccessTime;     }
public double calculateDistance2(DoubleSolution individual, double[] lambda) {      double distance;     double distanceSum = 0.0;      double[] vecInd = new double[problem.getNumberOfObjectives()];     double[] normalizedObj = new double[problem.getNumberOfObjectives()];      for (int i = 0; i < problem.getNumberOfObjectives(); i++) {       distanceSum += individual.getObjective(i);     }     for (int i = 0; i < problem.getNumberOfObjectives(); i++) {       normalizedObj[i] = individual.getObjective(i) / distanceSum;     }     for (int i = 0; i < problem.getNumberOfObjectives(); i++) {       vecInd[i] = normalizedObj[i] - lambda[i];     }      distance = norm_vector(vecInd);      return distance;   }
@Override    public CompletableFuture<Object> invokeAsync() throws Throwable {       // make sure the get command doesn't perform a remote call       // as our caller is already calling the ClusteredGetCommand on all the relevant nodes       // CACHE_MODE_LOCAL is not used as it can be used when we want to ignore the ownership with respect to reads       long flagBitSet = EnumUtil.bitSetOf(Flag.SKIP_REMOTE_LOOKUP);       GetCacheEntryCommand command = commandsFactory.buildGetCacheEntryCommand(key, segment,             EnumUtil.mergeBitSets(flagBitSet, getFlagsBitSet()));       command.setTopologyId(topologyId);       InvocationContext invocationContext = icf.createRemoteInvocationContextForCommand(command, getOrigin());       CompletableFuture<Object> future = invoker.invokeAsync(invocationContext, command);       return future.thenApply(rv -> {          if (trace) log.tracef(""Return value for key=%s is %s"", key, rv);          //this might happen if the value was fetched from a cache loader          if (rv instanceof MVCCEntry) {             MVCCEntry mvccEntry = (MVCCEntry) rv;             return entryFactory.createValue(mvccEntry);          } else if (rv instanceof InternalCacheEntry) {             InternalCacheEntry internalCacheEntry = (InternalCacheEntry) rv;             return internalCacheEntry.toInternalCacheValue();          } else { // null or Response             return rv;          }       });    }
@Nullable     private static ParameterizedType asParameterizedType(Type type, Class<?> expectedType) {         ParameterizedType result = null;         if (isParameterizedType(type)) {             ParameterizedType parameterizedType = (ParameterizedType) type;             if (expectedType.isAssignableFrom((Class<?>) parameterizedType.getRawType())) {                 result = parameterizedType;             }         }         return result;     }
protected DataSource getDataSource( HttpServletRequest request, String key )     {         // Return the requested data source instance         return ( DataSource ) getServletContext().getAttribute( key + getModuleConfig().getPrefix() );     }
public static KeyPair generateKeyPair(String algorithm, int keySize, byte[] seed) {    // SM2算法需要单独定义其曲线生成    if (""SM2"".equalsIgnoreCase(algorithm)) {     final ECGenParameterSpec sm2p256v1 = new ECGenParameterSpec(SM2_DEFAULT_CURVE);     return generateKeyPair(algorithm, keySize, seed, sm2p256v1);    }      return generateKeyPair(algorithm, keySize, seed, (AlgorithmParameterSpec[]) null);   }
public FormInputHandler timeout(final long theTimeoutSeconds) {    checkArgument(theTimeoutSeconds > 0, ""'theTimeoutSeconds' must be greater than zero"");    Fields fields = new Fields(this);    fields.finder = fields.finder.timeout(theTimeoutSeconds);    return new FormInputHandler(fields);   }
public Matrix4f rotationY(float ang) {         float sin, cos;         sin = (float) Math.sin(ang);         cos = (float) Math.cosFromSin(sin, ang);         if ((properties & PROPERTY_IDENTITY) == 0)             MemUtil.INSTANCE.identity(this);         this._m00(cos);         this._m02(-sin);         this._m20(sin);         this._m22(cos);         _properties(PROPERTY_AFFINE | PROPERTY_ORTHONORMAL);         return this;     }
@Override     public CreateEgressOnlyInternetGatewayResult createEgressOnlyInternetGateway(CreateEgressOnlyInternetGatewayRequest request) {         request = beforeClientExecution(request);         return executeCreateEgressOnlyInternetGateway(request);     }
private boolean validOrthologousStatement(final Statement stmt) {         // test statement is well-formed         if (stmt.getRelationshipType() == RelationshipType.ORTHOLOGOUS                 && stmt.getObject() != null                 && stmt.getObject().getTerm() != null) {              // test subject has only one namespace parameter             final Term subject = stmt.getSubject();             List<Parameter> subparams = subject.getParameters();             if (subparams == null || subparams.size() != 1                     || subparams.get(0).getNamespace() == null) {                 return false;             }              // test object has only one namespace parameter             final Term object = stmt.getObject().getTerm();             List<Parameter> objparams = object.getParameters();             if (objparams == null || objparams.size() != 1                     || objparams.get(0).getNamespace() == null) {                 return false;             }              return true;         }          return false;     }
private void init() throws ConfigFileIOException {         this.props = new Properties();         log.info(""Reading config file: {}"", this.configFile);         boolean ok = true;         try {             // El fichero esta en el CLASSPATH             this.props.load(SystemConfig.class.getResourceAsStream(this.configFile));         } catch (Exception e) {             log.warn(""File not found in the Classpath"");             try {                 this.props.load(new FileInputStream(this.configFile));             } catch (IOException ioe) {                 log.error(""Can't open file: {}"", ioe.getLocalizedMessage());                 ok = false;                 ioe.printStackTrace();                 throw new ConfigFileIOException(ioe.getLocalizedMessage());             }         }         if (ok) {             log.info(""Configuration loaded successfully"");             if (log.isDebugEnabled()) {                 log.debug(this.toString());             }         }     }
public void setSpecularIntensity(float r, float g, float b, float a) {        setVec4(""specular_intensity"", r, g, b, a);    }
@Override     public void execute() throws BuildException {         logger = new DITAOTAntLogger(getProject());         final MessageBean msgBean = MessageUtils.getMessage(id, readParamValues());         if (msgBean != null) {             final String type = msgBean.getType();             if (ERROR.equals(type)) {                 logger.error(msgBean.toString());             } else if (WARN.equals(type)) {                 logger.warn(msgBean.toString());             } else if (INFO.equals(type)) {                 logger.info(msgBean.toString());             } else if (DEBUG.equals(type)) {                 logger.debug(msgBean.toString());             }         }     }
public final void mNS_PREFIX() throws RecognitionException {         try {             int _type = NS_PREFIX;             int _channel = DEFAULT_TOKEN_CHANNEL;             // BELScript.g:293:10: ( LETTER ( LETTER | DIGIT )* ':' )             // BELScript.g:294:5: LETTER ( LETTER | DIGIT )* ':'             {             mLETTER();              // BELScript.g:294:12: ( LETTER | DIGIT )*             loop9:             do {                 int alt9=2;                 int LA9_0 = input.LA(1);                  if ( ((LA9_0>='0' && LA9_0<='9')||(LA9_0>='A' && LA9_0<='Z')||(LA9_0>='a' && LA9_0<='z')) ) {                     alt9=1;                 }                   switch (alt9) {              case 1 :                  // BELScript.g:                  {                  if ( (input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='Z')||(input.LA(1)>='a' && input.LA(1)<='z') ) {                      input.consume();                   }                  else {                      MismatchedSetException mse = new MismatchedSetException(null,input);                      recover(mse);                      throw mse;}                    }                  break;               default :                  break loop9;                 }             } while (true);              match(':');               }              state.type = _type;             state.channel = _channel;         }         finally {         }     }
public String getTopMethods(int num) {    stopCollecting();    CountMap<String> selfms = new CountMap<String>(selfMethods);    CountMap<String> stackms = new CountMap<String>(stackMethods);    StringBuilder buff = new StringBuilder();    buff.append(""Top methods over "").append(time).append("" ms ("").append(pauseTime).append("" ms paused), with "")      .append(total).append("" counts:"").append(LINE_SEPARATOR);    buff.append(""Rank\tSelf\tStack\tMethod"").append(LINE_SEPARATOR);    for (int i = 0, n = 0; selfms.size() > 0 && n < num; i++) {     int highest = 0;     List<Map.Entry<String, Integer>> bests = new ArrayList<Map.Entry<String, Integer>>();     for (Map.Entry<String, Integer> el : selfms.entrySet()) {      if (el.getValue() > highest) {       bests.clear();       bests.add(el);       highest = el.getValue();      } else if (el.getValue() == highest) {       bests.add(el);      }     }     for (Map.Entry<String, Integer> e : bests) {      selfms.remove(e.getKey());      int selfPercent = 100 * highest / Math.max(total, 1);      int stackPercent = 100 * stackms.remove(e.getKey()) / Math.max(total, 1);      buff.append(i + 1).append(""\t"").append(selfPercent).append(""%\t"").append(stackPercent).append(""%\t"")        .append(e.getKey()).append(LINE_SEPARATOR);      n++;     }    }    return buff.toString();   }
public static double bachelierOptionImpliedVolatility(    double forward,    double optionMaturity,    double optionStrike,    double payoffUnit,    double optionValue)  {   if(forward == optionStrike) {    return optionValue / Math.sqrt(optionMaturity / Math.PI / 2.0) / payoffUnit;   }    // Limit the maximum number of iterations, to ensure this calculation returns fast, e.g. in cases when there is no such thing as an implied vol   // TODO: An exception should be thrown, when there is no implied volatility for the given value.   int  maxIterations = 100;   double maxAccuracy  = 0.0;    // Calculate an lower and upper bound for the volatility   double volatilityLowerBound = 0.0;   double volatilityUpperBound = Math.sqrt(2 * Math.PI * Math.E) * (optionValue / payoffUnit + Math.abs(forward-optionStrike)) / Math.sqrt(optionMaturity);    // Solve for implied volatility   GoldenSectionSearch solver = new GoldenSectionSearch(volatilityLowerBound, volatilityUpperBound);   while(solver.getAccuracy() > maxAccuracy && !solver.isDone() && solver.getNumberOfIterations() < maxIterations) {    double volatility = solver.getNextPoint();     double valueAnalytic = bachelierOptionValue(forward, volatility, optionMaturity, optionStrike, payoffUnit);     double error = valueAnalytic - optionValue;     solver.setValue(error*error);   }    return solver.getBestPoint();  }
public static synchronized void truncateStorage(final StorageConfiguration pConf) throws TTException {         // check that database must be closed beforehand         if (!STORAGEMAP.containsKey(pConf.mFile)) {             if (existsStorage(pConf.mFile)) {                 final IStorage storage = new Storage(pConf);                 final File[] resources =                     new File(pConf.mFile, StorageConfiguration.Paths.Data.getFile().getName()).listFiles();                 for (final File resource : resources) {                     storage.truncateResource(new SessionConfiguration(resource.getName(), null));                 }                 storage.close();                 // instantiate the database for deletion                 IOUtils.recursiveDelete(pConf.mFile);             }         }     }
public ClassificationModel attachLink(ClassificationModel classificationModel, LinkModel linkModel)     {         for (LinkModel existing : classificationModel.getLinks())         {             if (StringUtils.equals(existing.getLink(), linkModel.getLink()))             {                 return classificationModel;             }         }         classificationModel.addLink(linkModel);         return classificationModel;     }
public static BlockInStream create(FileSystemContext context, BlockInfo info,       WorkerNetAddress dataSource, BlockInStreamSource dataSourceType, InStreamOptions options)       throws IOException {     URIStatus status = options.getStatus();     ReadType readType = ReadType.fromProto(options.getOptions().getReadType());      long blockId = info.getBlockId();     long blockSize = info.getLength();      // Construct the partial read request     ReadRequest.Builder builder =         ReadRequest.newBuilder().setBlockId(blockId).setPromote(readType.isPromote());     // Add UFS fallback options     builder.setOpenUfsBlockOptions(options.getOpenUfsBlockOptions(blockId));     AlluxioConfiguration alluxioConf = context.getClusterConf();     boolean shortCircuit = alluxioConf.getBoolean(PropertyKey.USER_SHORT_CIRCUIT_ENABLED);     boolean sourceSupportsDomainSocket = NettyUtils.isDomainSocketSupported(dataSource,         alluxioConf);     boolean sourceIsLocal = dataSourceType == BlockInStreamSource.LOCAL;      // Short circuit     if (sourceIsLocal && shortCircuit && !sourceSupportsDomainSocket) {       LOG.debug(""Creating short circuit input stream for block {} @ {}"", blockId, dataSource);       try {         return createLocalBlockInStream(context, dataSource, blockId, blockSize, options);       } catch (NotFoundException e) {         // Failed to do short circuit read because the block is not available in Alluxio.         // We will try to read via gRPC. So this exception is ignored.         LOG.warn(""Failed to create short circuit input stream for block {} @ {}. Falling back to ""             + ""network transfer"", blockId, dataSource);       }     }      // gRPC     LOG.debug(""Creating gRPC input stream for block {} @ {} from client {} reading through {}"",         blockId, dataSource, NetworkAddressUtils.getClientHostName(alluxioConf), dataSource);     return createGrpcBlockInStream(context, dataSource, dataSourceType, builder.buildPartial(),         blockSize, options);   }
@Nonnull     public HttpHealthCheck addHealthCheck(String name, String url, int interval, long timeout) {         if (name == null || name.trim().length() == 0) {             throw new IllegalArgumentException(""The name must not be null or empty."");         }          if (url == null || url.trim().length() == 0) {             throw new IllegalArgumentException(""The URL must not be null or empty."");         }          if (!Url.isUrl(url)) {             throw new IllegalArgumentException(url + "" is not a valid URL."");         }          if (interval < 0) {             throw new IllegalArgumentException(""The polling interval must be zero or a positive integer."");         }          if (timeout < 0) {             throw new IllegalArgumentException(""The timeout must be zero or a positive integer."");         }          HttpHealthCheck healthCheck = new HttpHealthCheck(name, url, interval, timeout);         healthChecks.add(healthCheck);          return healthCheck;     }
public static void lock(Lock lock, String callerClass, String callerMethod, Object... args) {    final String sourceMethod = ""lock""; //$NON-NLS-1$    final boolean isTraceLogging = log.isLoggable(Level.FINER);    if (isTraceLogging) {     log.entering(sourceClass, sourceMethod, new Object[]{Thread.currentThread(), lock, callerClass, callerMethod, args});    }    long start = System.currentTimeMillis();    boolean quiesced = false, logged = false;    try {     while (!lock.tryLock(SIGNAL_LOG_INTERVAL_SECONDS, TimeUnit.SECONDS)) {      if (!quiesced) {       quiesced = logWaiting(callerClass, callerMethod, lock, start, args);       logged = true;      }     }    } catch (InterruptedException ex) {     // InterruptedException is not thrown by Lock.lock() so convert to a     // RuntimeException.     throw new RuntimeException(ex);    }    if (logged) {     logResuming(callerClass, callerMethod, lock, start);    }    if (isTraceLogging) {     log.exiting(sourceClass, sourceMethod, Arrays.asList(Thread.currentThread(), lock, callerClass, callerMethod));    }    return;   }
private static I_Loader initLoader(String type) {            if (TYPE_PROPERTIES.equals(type)) {              return new CmsVfsBundleLoaderProperties();          } else if (TYPE_XML.equals(type)) {              return new CmsVfsBundleLoaderXml();          } else {              return new CmsVfsBundleLoaderXml();          }      }
public String getOtherTrackType()  {   final Element element = getElement(""Type"", 0);    if (element != null)   {    return element.getText();   }   else   {    return null;   }  }
@Override    public <C> CompletionStage<Void> addListenerAsync(Object listener, CacheEventFilter<? super K, ? super V> filter,                                CacheEventConverter<? super K, ? super V, C> converter, ClassLoader classLoader) {       return addListenerInternal(listener, DataConversion.IDENTITY_KEY, DataConversion.IDENTITY_VALUE, filter, converter, classLoader, false);    }
public String[] getGeneratorFunctions()     {     String[] functions = new String[ generators_.size()];     generators_.keySet().toArray( functions);     return functions;     }
public <E extends Exception> void forEach(final Try.IndexedConsumer<? super T, E> action) throws E {          N.forEach(coll, action);      }
public long getInstantMillis(Object object, Chronology chrono) {         String str = (String) object;         DateTimeFormatter p = ISODateTimeFormat.dateTimeParser();         return p.withChronology(chrono).parseMillis(str);     }
public void complete(Element e) throws KNXMLException   {    if (e.isEmptyElementTag())     return;    final int index = openElems.lastIndexOf(e.getName());    if (index == -1)     throw new KNXMLException(""element tag not read before"", e.getName(), line);    String end = null;    final StringBuffer content = new StringBuffer(50);    while (canRead()) {     // read text content     final String s = read('<');     final boolean current = openElems.peek().equals(e.getName());     // if character data is for current element, append it     if (current && s.length() > 0)      content.append(References.replace(s, false));     // read a possible end tag     end = read('>');     if (skipComment(end))      ;     else if (current && readCDATASection(end, content))      ;     else if (end.length() > 0 && end.charAt(0) == '/') {      // actually, no white space is allowed between '/' and tag name      // but there might be some between end of name and '>'      final String tag = end.substring(1).trim();      // got end tag?      if (!tag.equals(openElems.peek()))       throw new KNXMLException(""element end tag does not match start tag"",        tag, line);      openElems.pop();      if (tag.equals(e.getName())) {       e.setCharacterData(content.toString());       pos = END_TAG;       return;      }     }     else if (end.length() > 0)      // don't push empty element tags      if (end.charAt(end.length() - 1) != '/') {       final String tag = splitOnSpace(end);       if (tag.length() > 0)        openElems.push(tag);      }    }    throw new KNXMLException(""end of XML input with elements left open"", end, line);   }
public static double mod(double a, double b) {   int n = (int)(a/b);      a -= n*b;   if (a < 0)    return a + b;   return a;  }
public SortedSet<AbstractPanel> getSortedPanels(PanelType panelType) {    validateNotNull(panelType, ""panelType"");      List<AbstractPanel> panels = getPanels(panelType);    SortedSet<AbstractPanel> sortedPanels = new TreeSet<>(new Comparator<AbstractPanel>() {       @Override     public int compare(AbstractPanel abstractPanel, AbstractPanel otherAbstractPanel) {      String name = abstractPanel.getName();      String otherName = otherAbstractPanel.getName();      if (name == null) {       if (otherName == null) {        return 0;       }       return -1;      } else if (otherName == null) {       return 1;      }      return name.compareTo(otherName);     }    });    sortedPanels.addAll(panels);    return sortedPanels;   }
public static void recursivelyDelete(File f) throws IOException {         if (!f.exists()) {             return;         }         if (f.isDirectory()) {             for (File f1 : f.listFiles()) {                 recursivelyDelete(f1);             }             if (!f.delete()) {                 throw new IOException(""Unable to delete directory "" + f);             }         }         else {             if (!f.delete()) {                 throw new IOException(""Unable to delete file "" + f);             }         }     }
public Observable<ServiceResponse<Page<StorageAccountCredentialInner>>> listByDataBoxEdgeDeviceSinglePageAsync(final String deviceName, final String resourceGroupName) {         if (deviceName == null) {             throw new IllegalArgumentException(""Parameter deviceName is required and cannot be null."");         }         if (this.client.subscriptionId() == null) {             throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");         }         if (resourceGroupName == null) {             throw new IllegalArgumentException(""Parameter resourceGroupName is required and cannot be null."");         }         if (this.client.apiVersion() == null) {             throw new IllegalArgumentException(""Parameter this.client.apiVersion() is required and cannot be null."");         }         return service.listByDataBoxEdgeDevice(deviceName, this.client.subscriptionId(), resourceGroupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())             .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<StorageAccountCredentialInner>>>>() {                 @Override                 public Observable<ServiceResponse<Page<StorageAccountCredentialInner>>> call(Response<ResponseBody> response) {                     try {                         ServiceResponse<PageImpl<StorageAccountCredentialInner>> result = listByDataBoxEdgeDeviceDelegate(response);                         return Observable.just(new ServiceResponse<Page<StorageAccountCredentialInner>>(result.body(), result.response()));                     } catch (Throwable t) {                         return Observable.error(t);                     }                 }             });     }
public XMLString xstr(XPathContext xctxt)           throws javax.xml.transform.TransformerException   {     return execute(xctxt).xstr();   }
public static ClassInfo classInfo(final ClassLoader cl, final String className) {         final Index index = index(cl, className);         return index.getClassByName(DotName.createSimple(className));     }
public PropertyBuilder renderingAsPassword() {         if (this.type != Property.Type.String) {             throw new IllegalStateException(""stringRenderingPassword can only be applied to a String property"");         }         return renderingOption(StringRenderingConstants.DISPLAY_TYPE_KEY, StringRenderingConstants.DisplayType                 .PASSWORD);     }
private static int generateCompatViewId() {         for (; ; ) {             final int result = sNextGeneratedId.get();             int newValue = result + 1;             /**              * ID number larger than 0x00FFFFFF is reserved for static views defined in the /res xml files.              * Android doesn't want you to use 0 as a view's id, and it needs to be flipped before 0x01000000 to avoid              * the conflicts with static resource IDs              */             if (newValue > 0x00FFFFFF) {                 newValue = 1; // Roll over to 1, not 0.             }             if (sNextGeneratedId.compareAndSet(result, newValue)) {                 return result;             }         }     }
protected long getLogSpaceReserved() {         if (Tracing.isAnyTracingEnabled() && trace.isEntryEnabled())             trace.entry(this, cclass                         , ""getLogSpaceReserved""                           + "")"");          if (Tracing.isAnyTracingEnabled() && trace.isEntryEnabled())             trace.exit(this, cclass                        , ""getLogSpaceReserved""                        , ""returns logSpaceReserved="" + logSpaceReserved + ""(long)""                             );         return logSpaceReserved;     }
public static boolean hasProperty(ClassNode classNode, String propertyName) {         if (classNode == null || !StringUtils.hasText(propertyName)) {             return false;         }          final MethodNode method = classNode.getMethod(GrailsNameUtils.getGetterName(propertyName), Parameter.EMPTY_ARRAY);         if (method != null) return true;          // check read-only field with setter         if( classNode.getField(propertyName) != null && !classNode.getMethods(GrailsNameUtils.getSetterName(propertyName)).isEmpty()) {             return true;         }          for (PropertyNode pn : classNode.getProperties()) {             if (pn.getName().equals(propertyName) && !pn.isPrivate()) {                 return true;             }         }          return false;     }
private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,       Node toNode) {     cfg.createNode(fromNode);     cfg.createNode(toNode);     cfg.connectIfNotFound(fromNode, branch, toNode);   }
public static <T> Stream<Map.Entry<Integer, T>> enumerate(Stream<T> stream) {         Iterator<Map.Entry<Integer, T>> iterator = new Iterator<Map.Entry<Integer, T>>() {             private int counter = 0;                          private final Iterator<T> internalIterator = stream.iterator();                          /** {@inheritDoc} */             @Override             public boolean hasNext() {                 return internalIterator.hasNext();             }                          /** {@inheritDoc} */             @Override             public Map.Entry<Integer, T> next() {                 return new AbstractMap.SimpleImmutableEntry<>(counter++, internalIterator.next());             }              /** {@inheritDoc} */             @Override             public void remove() {                 throw new UnsupportedOperationException(""This is a read-only iterator, remove operation is not supported."");             }         };         return stream(iterator, stream.isParallel());     }
public static double isBetweenInclusive (final double dValue,                                            final String sName,                                            final double dLowerBoundInclusive,                                            final double dUpperBoundInclusive)   {     if (isEnabled ())       return isBetweenInclusive (dValue, () -> sName, dLowerBoundInclusive, dUpperBoundInclusive);     return dValue;   }
public AssertSoapFaultBuilder faultDetailResource(Resource resource, Charset charset) {         try {             action.getFaultDetails().add(FileUtils.readToString(resource, charset));         } catch (IOException e) {             throw new CitrusRuntimeException(""Failed to read fault detail resource"", e);         }         return this;     }
public <T> CloseableIterator<T> getMany(final Class<T> type, final Map<String, Object> query) {         return getMany(type, query, false);     }
public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException     {         if (e == null)         {             throw new IllegalArgumentException(""The 'e' parameter may not be null."");         }          ReentrantLock lock = this.lock;         lock.lockInterruptibly();          long nanos = unit.toNanos(timeout);          try         {             do             {                 if (insert(e, false))                 {                     return true;                 }                  try                 {                     nanos = notFull.awaitNanos(nanos);                 }                 catch (InterruptedException ie)                 {                     // Wake up another thread waiting on notFull, as the condition may be true, but this thread                     // was interrupted so cannot make use of it.                     notFull.signal();                      throw ie;                 }             }             while (nanos > 0);              return false;         }         finally         {             lock.unlock();         }     }
public PagedList<HybridConnectionInner> listHybridConnectionsNext(final String nextPageLink) {         ServiceResponse<Page<HybridConnectionInner>> response = listHybridConnectionsNextSinglePageAsync(nextPageLink).toBlocking().single();         return new PagedList<HybridConnectionInner>(response.body()) {             @Override             public Page<HybridConnectionInner> nextPage(String nextPageLink) {                 return listHybridConnectionsNextSinglePageAsync(nextPageLink).toBlocking().single().body();             }         };     }
private void bindProcedure(PreparedStatement stmt, ClassDescriptor cld, Object obj, ProcedureDescriptor proc)              throws SQLException      {          int valueSub = 0;            // Figure out if we are using a callable statement.  If we are, then we          // will need to register one or more output parameters.          CallableStatement callable = null;          try          {              callable = (CallableStatement) stmt;          }          catch(Exception e)          {              m_log.error(""Error while bind values for class '"" + (cld != null ? cld.getClassNameOfObject() : null)                      + ""', using stored procedure: ""+ proc, e);              if(e instanceof SQLException)              {                  throw (SQLException) e;              }              else              {                  throw new PersistenceBrokerException(""Unexpected error while bind values for class '""                          + (cld != null ? cld.getClassNameOfObject() : null) + ""', using stored procedure: ""+ proc);              }          }            // If we have a return value, then register it.          if ((proc.hasReturnValue()) && (callable != null))          {              int jdbcType = proc.getReturnValueFieldRef().getJdbcType().getType();              m_platform.setNullForStatement(stmt, valueSub + 1, jdbcType);              callable.registerOutParameter(valueSub + 1, jdbcType);              valueSub++;          }            // Process all of the arguments.          Iterator iterator = proc.getArguments().iterator();          while (iterator.hasNext())          {              ArgumentDescriptor arg = (ArgumentDescriptor) iterator.next();              Object val = arg.getValue(obj);              int jdbcType = arg.getJdbcType();              setObjectForStatement(stmt, valueSub + 1, val, jdbcType);              if ((arg.getIsReturnedByProcedure()) && (callable != null))              {                  callable.registerOutParameter(valueSub + 1, jdbcType);              }              valueSub++;          }      }
public void combine(SpdLong other) {         if (other == null)             return;         if (stat.isEnabled() && other.isEnabled())             stat.combine((CountStatisticImpl) other.getStatistic());     }
@Override     public PutBotResult putBot(PutBotRequest request) {         request = beforeClientExecution(request);         return executePutBot(request);     }
protected void loadLocalDatabases() {     final List<String> dbs = new ArrayList<String>(serverInstance.getAvailableStorageNames().keySet());     Collections.sort(dbs);      for (final String databaseName : dbs) {       if (messageService.getDatabase(databaseName) == null) {         ODistributedServerLog.info(this, nodeName, null, DIRECTION.NONE, ""Opening database '%s'..."", databaseName);          // INIT THE STORAGE         final ODistributedStorage stg = getStorage(databaseName);          executeInDistributedDatabaseLock(databaseName, 60000, null, new OCallable<Object, OModifiableDistributedConfiguration>() {           @Override           public Object call(OModifiableDistributedConfiguration cfg) {             ODistributedServerLog.info(this, nodeName, null, DIRECTION.NONE, ""Current node started as %s for database '%s'"",                 cfg.getServerRole(nodeName), databaseName);              final ODistributedDatabaseImpl ddb = messageService.registerDatabase(databaseName, cfg);             ddb.resume();              // 1ST NODE TO HAVE THE DATABASE             cfg.addNewNodeInServerList(nodeName);              // COLLECT ALL THE CLUSTERS WITH REMOVED NODE AS OWNER             reassignClustersOwnership(nodeName, databaseName, cfg, true);              try {               ddb.getSyncConfiguration().setLastLSN(nodeName, ((OAbstractPaginatedStorage) stg.getUnderlying()).getLSN(), false);             } catch (IOException e) {               ODistributedServerLog                   .error(this, nodeName, null, DIRECTION.NONE, ""Error on saving distributed LSN for database '%s' (err=%s)."",                       databaseName, e.getMessage());             }             ddb.setOnline();              return null;           }         });       }     }   }
public static <C> Module overrideModule(         final Class<C> configInterface,         final Named name,         final OverrideConsumer<C> overrideConsumer)     {         return overrideModule(configInterface, Optional.of(name), overrideConsumer);     }
public void addHeader( String name, String value )     {         headers.add( new BasicHeader( name, value ) );     }
public void setMode(final MenuMode mode) {   // mode server mapped to mode dynamic as per https://github.com/BorderTech/wcomponents/issues/687   getOrCreateComponentModel().mode = MenuMode.SERVER.equals(mode) ? MenuMode.DYNAMIC : mode;  }
@Override     public void notifyReceiveAllowed(boolean isAllowed)     {         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())             SibTr.entry(tc, ""notifyReceiveAllowed"", new Object[] { Boolean.valueOf(isAllowed), this });          this.lock();         try         {             try             {                 checkReceiveAllowed();             } catch (SISessionUnavailableException e)             {                 // FFDC                 FFDCFilter.processException(                                             e,                                             ""com.ibm.ws.sib.processor.impl.JSLocalConsumerPoint.notifyReceiveAllowed"",                                             ""1:4287:1.22.5.1"",                                             this);                  SibTr.exception(tc, e);             } catch (SIResourceException e)             {                 // FFDC                 FFDCFilter.processException(                                             e,                                             ""com.ibm.ws.sib.processor.impl.JSLocalConsumerPoint.notifyReceiveAllowed"",                                             ""1:4298:1.22.5.1"",                                             this);                  SibTr.exception(tc, e);             }         } finally         {             this.unlock();         }          if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())             SibTr.exit(tc, ""notifyReceiveAllowed"");     }
private static int findEndOfHeader(byte[] pBytes, int pEnd) {         byte[] header = HTTP_HEADER_END.getBytes();          // Normal condition, check all bytes         for (int i = 0; i < pEnd - 4; i++) {  // Need 4 bytes to match             if ((pBytes[i] == header[0]) && (pBytes[i + 1] == header[1]) && (pBytes[i + 2] == header[2]) && (pBytes[i + 3] == header[3])) {                  //System.err.println(""FOUND END OF HEADER!"");                 return i + 4;             }         }          // Check last 3 bytes, to check if we have a partial match         if ((pEnd - 1 >= 0) && (pBytes[pEnd - 1] == header[0])) {              //System.err.println(""FOUND LAST BYTE"");             return -2;  // LAST BYTE         }         else if ((pEnd - 2 >= 0) && (pBytes[pEnd - 2] == header[0]) && (pBytes[pEnd - 1] == header[1])) {              //System.err.println(""FOUND LAST TWO BYTES"");             return -3;  // LAST TWO BYTES         }         else if ((pEnd - 3 >= 0) && (pBytes[pEnd - 3] == header[0]) && (pBytes[pEnd - 2] == header[1]) && (pBytes[pEnd - 1] == header[2])) {              //System.err.println(""FOUND LAST THREE BYTES"");             return -4;  // LAST THREE BYTES         }         return -1;  // NO BYTES MATCH     }
@Override     public DeleteNotificationResult deleteNotification(DeleteNotificationRequest request) {         request = beforeClientExecution(request);         return executeDeleteNotification(request);     }
private boolean blockedStorageClose(StorageType storageType) {         DB storage = storageRegistry.get(storageType);         if(isOpenStorage(storage)) {             storage.commit();              //find the underlying engine             Engine e = storage.getEngine();             while (EngineWrapper.class.isAssignableFrom(e.getClass())) {                 e = ((EngineWrapper) e).getWrappedEngine();             }              //close and wait until the close on the underlying engine is also finished             storage.close();             while (!e.isClosed()) {                 logger.trace(""Waiting for the engine to close"");                 try {                     TimeUnit.MILLISECONDS.sleep(100);                 } catch (InterruptedException ex) {                     throw new RuntimeException(ex);                 }             }              return true;         }         else {             return false;         }     }
public static Chainr fromFile( File chainrSpecFile, ChainrInstantiator chainrInstantiator ) {         Object chainrSpec;         try {             FileInputStream fileInputStream = new FileInputStream( chainrSpecFile );             chainrSpec = JsonUtils.jsonToObject( fileInputStream );         } catch ( Exception e ) {             throw new RuntimeException( ""Unable to load chainr spec file "" + chainrSpecFile.getAbsolutePath() );         }         return getChainr( chainrInstantiator, chainrSpec );     }
@SuppressWarnings(""ReferenceEquality"")   private void logImpl(String message, Object... args) {     this.args = args;     // Evaluate any (rare) LazyArg instances early. This may throw exceptions from user code, but     // it seems reasonable to propagate them in this case (they would have been thrown if the     // argument was evaluated at the call site anyway).     for (int n = 0; n < args.length; n++) {       if (args[n] instanceof LazyArg) {         args[n] = ((LazyArg<?>) args[n]).evaluate();       }     }     // Using ""!="" is fast and sufficient here because the only real case this should be skipping     // is when we called log(String) or log(), which should not result in a template being created.     // DO NOT replace this with a string instance which can be interned, or use equals() here,     // since that could mistakenly treat other calls to log(String, Object...) incorrectly.     if (message != LITERAL_VALUE_MESSAGE) {       this.templateContext = new TemplateContext(getMessageParser(), message);     }     getLogger().write(this);   }
public void marshall(ListUserPoolsRequest listUserPoolsRequest, ProtocolMarshaller protocolMarshaller) {          if (listUserPoolsRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(listUserPoolsRequest.getNextToken(), NEXTTOKEN_BINDING);             protocolMarshaller.marshall(listUserPoolsRequest.getMaxResults(), MAXRESULTS_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
protected static int encodeInt(        long x,        byte[] res,        int resOffset    ) {      byte i, l;      long m;      long mask = 0xf0000000;      long init = x & mask;        if (init == 0) {        l = 8;        for (i = 0; i < 8; i++) {          m = mask >> (4 * i);          if ((x & m) != 0) {            l = i;            break;          }        }        res[resOffset] = l;        for (i = l; i < 8; i++) {          res[resOffset + 1 + i - l] = (byte) (0xf & (x >> (4 * (i - l))));        }          return 1 + 8 - l;        } else if (init == mask) {        l = 7;        for (i = 0; i < 8; i++) {          m = mask >> (4 * i);          if ((x & m) != m) {            l = i;            break;          }        }        res[resOffset] = (byte) (l | 8);        for (i = l; i < 8; i++) {          res[resOffset + 1 + i - l] = (byte) (0xf & (x >> (4 * (i - l))));        }          return 1 + 8 - l;        } else {        res[resOffset] = 0;        for (i = 0; i < 8; i++) {          res[resOffset + 1 + i] = (byte) (0xf & (x >> (4 * i)));        }          return 9;        }    }
public void setNotifyConfig(boolean notify) {         addField(ConfigureNodeFields.notify_config, FormField.Type.bool);         setAnswer(ConfigureNodeFields.notify_config.getFieldName(), notify);     }
public Object convertToType(Object obj, Class<?> type) {          boolean originalResolved = isPropertyResolved();         setPropertyResolved(false);         try {             ELResolver resolver = getELResolver();             if (resolver != null) {                 Object result = resolver.convertToType(this, obj, type);                 if (isPropertyResolved()) {                     return result;                 }             }         } finally {             setPropertyResolved(originalResolved);         }          return ELManager.getExpressionFactory().coerceToType(obj, type);     }
private Node parseAndRecordTypeNode(       JsDocToken token,       int lineno,       int startCharno,       boolean matchingLC,       boolean onlyParseSimpleNames) {     Node typeNode;      if (onlyParseSimpleNames) {       typeNode = parseTypeNameAnnotation(token);     } else {       typeNode = parseTypeExpressionAnnotation(token);     }      recordTypeNode(lineno, startCharno, typeNode, matchingLC);     return typeNode;   }
@SuppressWarnings(""unchecked"")     public static <T> T asType(String self, Class<T> c) {         if (c == List.class) {             return (T) toList(self);         } else if (c == BigDecimal.class) {             return (T) toBigDecimal(self);         } else if (c == BigInteger.class) {             return (T) toBigInteger(self);         } else if (c == Long.class || c == Long.TYPE) {             return (T) toLong(self);         } else if (c == Integer.class || c == Integer.TYPE) {             return (T) toInteger(self);         } else if (c == Short.class || c == Short.TYPE) {             return (T) toShort(self);         } else if (c == Byte.class || c == Byte.TYPE) {             return (T) Byte.valueOf(self.trim());         } else if (c == Character.class || c == Character.TYPE) {             return (T) toCharacter(self);         } else if (c == Double.class || c == Double.TYPE) {             return (T) toDouble(self);         } else if (c == Float.class || c == Float.TYPE) {             return (T) toFloat(self);         } else if (c == File.class) {             return (T) new File(self);         } else if (c.isEnum()) {             return (T) InvokerHelper.invokeMethod(c, ""valueOf"", new Object[]{ self });         }         return DefaultGroovyMethods.asType((Object) self, c);     }
@SuppressWarnings(""resource"")   private static String parseGwtRpcMethodName(InputStream stream, String charEncoding) {    //commented out code uses GWT-user library for a more 'proper' approach.    //GWT-user library approach is more future-proof, but requires more dependency management.    //    RPCRequest decodeRequest = RPC.decodeRequest(readLine);    //    gwtmethodname = decodeRequest.getMethod().getName();      try {     final Scanner scanner;     if (charEncoding == null) {      scanner = new Scanner(stream);     } else {      scanner = new Scanner(stream, charEncoding);     }     scanner.useDelimiter(GWT_RPC_SEPARATOR_CHAR_PATTERN); //AbstractSerializationStream.RPC_SEPARATOR_CHAR       //AbstractSerializationStreamReader.prepareToRead(...)     scanner.next(); //stream version number     scanner.next(); //flags       //ServerSerializationStreamReader.deserializeStringTable()     scanner.next(); //type name count       //ServerSerializationStreamReader.preapreToRead(...)     scanner.next(); //module base URL     scanner.next(); //strong name       //RPC.decodeRequest(...)     scanner.next(); //service interface name     return ""."" + scanner.next(); //service method name       //note we don't close the scanner because we don't want to close the underlying stream    } catch (final NoSuchElementException e) {     LOG.debug(""Unable to parse GWT-RPC request"", e);       //code above is best-effort - we were unable to parse GWT payload so     //treat as a normal HTTP request     return null;    }   }
public Font getNotationFontForContext(int notationContext) {    try {     Font baseNotationFont = ((MusicalFont) getTemplate().getAttributeObject(       ScoreAttribute.NOTATION_FONT)).getFont();       switch (notationContext) {     case NOTATION_CONTEXT_GRACENOTE:      return baseNotationFont.deriveFont(getTemplate()        .getAttributeSize(          ScoreAttribute.NOTATION_GRACENOTE_SIZE));     case NOTATION_CONTEXT_TEMPO:      return baseNotationFont.deriveFont(getTemplate()        .getAttributeSize(ScoreAttribute.NOTATION_TEMPO_SIZE));     case NOTATION_CONTEXT_NOTE:     default:      return baseNotationFont.deriveFont(getTemplate()        .getAttributeSize(ScoreAttribute.NOTATION_SIZE));     }    } catch (Exception e) {     e.printStackTrace();     throw new RuntimeException(e);    }   }
public Map<String, String> getPathParametersEncoded(String requestUri) {                  Matcher m = regex.matcher(requestUri);                  return mapParametersFromPath(requestUri, parameters, m);     }
private IConceptSet filterEquivalents(final IConceptSet concepts) {         int[] cArray = concepts.toArray();         boolean[] toExclude = new boolean[cArray.length];          for(int i = 0; i < cArray.length; i++) {             if(toExclude[i]) continue;             final IConceptSet iAncestors = IConceptSet.FACTORY.createConceptSet(getAncestors(no, cArray[i]));             for(int j = i+1; j < cArray.length; j++) {                 if(iAncestors.contains(cArray[j])) {                     final IConceptSet jAncestors = IConceptSet.FACTORY.createConceptSet(getAncestors(no, cArray[j]));                     if(jAncestors.contains(cArray[i])) {                         // These concepts are equivalent to mark the second concept as excluded                         toExclude[j] = true;                     }                 }             }         }          IConceptSet res = IConceptSet.FACTORY.createConceptSet();         for(int i = 0; i < cArray.length; i++) {             if(!toExclude[i]) {                 res.add(cArray[i]);             }         }          return res;     }
@Override   public void exec(Result<Object> result, Object[] args)   {     TableKelp tableKelp = _table.getTableKelp();          RowCursor minCursor = tableKelp.cursor();     RowCursor maxCursor = tableKelp.cursor();          minCursor.clear();     maxCursor.setKeyMax();          _whereKraken.fillMinCursor(minCursor, args);     _whereKraken.fillMaxCursor(minCursor, args);          //QueryKelp whereKelp = _whereExpr.bind(args);     // XXX: binding should be with unique     EnvKelp whereKelp = new EnvKelp(_whereKelp, args);          //tableKelp.findOne(minCursor, maxCursor, whereKelp,     //                  new FindDeleteResult(result));          _table.notifyOwner(minCursor.getKey());          // result.completed(null);          result.ok(null);   }
@Override      public DEBBuilder setPackageName(String name)      {          this.name = name;          control.setPackage(name);          return this;      }
private static String getCorrectedTimeZoneIdFrom(String value) {         if (value != null) {             value = value.contains(""\"""") ? value.replaceAll(""\"""", """") : value;             if (TIMEZONE_REGISTRY.getTimeZone(value) != null) {                 return TIMEZONE_REGISTRY.getTimeZone(value).getID();             }             String nameCandidate = MS_TIMEZONE_NAMES.get(value);             if (nameCandidate != null) {                 return TIMEZONE_REGISTRY.getTimeZone(nameCandidate) != null                         ? TIMEZONE_REGISTRY.getTimeZone(nameCandidate).getID() : nameCandidate;             }             return MS_TIMEZONE_IDS.get(value);         }         return null;     }
public void      doArchive(String logListURI, String archiveDirectory)     throws IOException   {     String destURL = FileSystem.getDefaultUri(fsConfig) + archiveDirectory;     DistCp.copy(new JobConf(fsConfig), logListURI, destURL, null, true, false);   }
public void add(String column, Object value) {         add(System.currentTimeMillis(), column, value);     }
public final Source createSource(OrganizationName parent, Source source) {      CreateSourceRequest request =         CreateSourceRequest.newBuilder()             .setParent(parent == null ? null : parent.toString())             .setSource(source)             .build();     return createSource(request);   }
@Override  public void started(ServiceBroker broker) throws Exception {   super.started(broker);    // Local nodeID   this.nodeID = broker.getNodeID();    // Set components   ServiceBrokerConfig cfg = broker.getConfig();   this.executor = cfg.getExecutor();   this.scheduler = cfg.getScheduler();   this.strategyFactory = cfg.getStrategyFactory();   this.contextFactory = cfg.getContextFactory();   this.transporter = cfg.getTransporter();   this.eventbus = cfg.getEventbus();   this.uid = cfg.getUidGenerator();  }
protected List<CmsPushButton> getButtons() {            CmsPushButton workplaceButton = new CmsPushButton();          workplaceButton.setText(getMessage(Messages.GUI_CONFIRMATION_WORKPLACE_BUTTON_0));          workplaceButton.addClickHandler(new ClickHandler() {                @SuppressWarnings(""synthetic-access"")              public void onClick(ClickEvent e) {                    Window.Location.assign(m_closeLink);              }          });          List<CmsPushButton> result = new ArrayList<CmsPushButton>();          if (m_isWorkplaceUser) {              result.add(workplaceButton);          }          return result;      }
@Override     public void     flush()             throws IOException     {         if(mode == RequestMode.DMR)             return; // leave to close() to do this         if(dmr8 != null) {             sendDXR(dmr8);             dmr8 = null;         }     }
private boolean isCheckedException(TypeMirror t) {         return !(env.types.isAssignable(t, env.java_lang_Error)                 || env.types.isAssignable(t, env.java_lang_RuntimeException));     }
public char[] getMediumCBuffer(int minSize)     {         char[] result = null;         if (mMediumCBuffer != null && mMediumCBuffer.length >= minSize) {             result = mMediumCBuffer;             mMediumCBuffer = null;         } //System.err.println(""DEBUG: Alloc CMed: ""+result);         return result;     }
public static <T> String apiVersion(T item, String apiVersion) {     if (item instanceof HasMetadata && Utils.isNotNullOrEmpty(((HasMetadata) item).getApiVersion())) {       return trimVersion(((HasMetadata) item).getApiVersion());     } else if (apiVersion != null && !apiVersion.isEmpty()) {       return trimVersion(apiVersion);     }     return null;   }
@Help(help = ""Delete the Security of a NetworkServiceDescriptor with specific id"")   public void deleteSecurity(final String idNsd, final String idSecurity) throws SDKException {     String url = idNsd + ""/security"" + ""/"" + idSecurity;     requestDelete(url);   }
Stage<Void> doCollectAndDiscard(       Collection<? extends Stage<?>> stages   ) {     final Completable<Void> target = completable();      final CollectAndDiscardHelper done = new CollectAndDiscardHelper(stages.size(), target);      for (final Stage<?> q : stages) {       q.handle(done);     }      bindSignals(target, stages);     return target;   }
public void copyRecord(Record recAlt, Record recMain)     {         recAlt.moveFields(recMain, null, true, DBConstants.READ_MOVE, false, false, true, false);     }
public Observable<Page<ResourceGroupInner>> listNextAsync(final String nextPageLink) {         return listNextWithServiceResponseAsync(nextPageLink)             .map(new Func1<ServiceResponse<Page<ResourceGroupInner>>, Page<ResourceGroupInner>>() {                 @Override                 public Page<ResourceGroupInner> call(ServiceResponse<Page<ResourceGroupInner>> response) {                     return response.body();                 }             });     }
public void marshall(EnablePolicyTypeRequest enablePolicyTypeRequest, ProtocolMarshaller protocolMarshaller) {          if (enablePolicyTypeRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(enablePolicyTypeRequest.getRootId(), ROOTID_BINDING);             protocolMarshaller.marshall(enablePolicyTypeRequest.getPolicyType(), POLICYTYPE_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public static boolean removeExtension(String extensionName) {         if (extensionName == null) {             throw new IllegalArgumentException(                             ""Parameter 'extensionName' can not be null"");         }         HashMap<String, String> ext = extensions.get();         return ext == null ? false : ext.remove(extensionName) != null;     }
public static void setPropValue(final Object entity, final String propName, final Object propValue) {          setPropValue(entity, propName, propValue, false);      }
public void doSetDataSource(DataSource dataSource) {     if (mediaInfo.get(dataSource) == null) {       throw new IllegalArgumentException(           ""Don't know what to do with dataSource ""               + dataSource               + "" - either add an exception with addException() or media info with addMediaInfo()"");     }     this.dataSource = dataSource;   }
private static void createFeedMapping(       AdWordsServicesInterface adWordsServices, AdWordsSession session, DSAFeedDetails feedDetails)       throws RemoteException {     // Get the FeedMappingService.     FeedMappingServiceInterface feedMappingService =         adWordsServices.get(session, FeedMappingServiceInterface.class);      // Map the FeedAttributeIds to the fieldId constants.     AttributeFieldMapping urlFieldMapping = new AttributeFieldMapping();     urlFieldMapping.setFeedAttributeId(feedDetails.urlAttributeId);     urlFieldMapping.setFieldId(DSA_PAGE_URLS_FIELD_ID);     AttributeFieldMapping labelFieldMapping = new AttributeFieldMapping();     labelFieldMapping.setFeedAttributeId(feedDetails.labelAttributeId);     labelFieldMapping.setFieldId(DSA_LABEL_FIELD_ID);      // Create the FeedMapping and operation.     FeedMapping feedMapping = new FeedMapping();     feedMapping.setCriterionType(DSA_PAGE_FEED_CRITERION_TYPE);     feedMapping.setFeedId(feedDetails.feedId);     feedMapping.setAttributeFieldMappings(         new AttributeFieldMapping[] {urlFieldMapping, labelFieldMapping});     FeedMappingOperation operation = new FeedMappingOperation();     operation.setOperand(feedMapping);     operation.setOperator(Operator.ADD);      // Add the field mapping.     FeedMapping newFeedMapping =         feedMappingService.mutate(new FeedMappingOperation[] {operation}).getValue(0);     System.out.printf(         ""Feed mapping with ID %d and criterionType %d was saved for feed with ID %d.%n"",         newFeedMapping.getFeedMappingId(),         newFeedMapping.getCriterionType(),         newFeedMapping.getFeedId());   }
private JMFType findTupleChildByName(JSTuple tup, String name) {     for (int i = 0; i < tup.getFieldCount(); i++) {       JMFType theField = getEffectiveType(tup.getField(i));       String fieldName = theField.getFeatureName();       if (fieldName != null && fieldName.equals(name))         return theField;     }     return null;   }
@Override   public void write(Fields fields) throws IOException {     delegateFieldsConsumer.write(fields);     write(state.fieldInfos, fields);   }
public static String shortenString(String text, int maxLength) {          if (text.length() <= maxLength) {             return text;         }         String newText = text.substring(0, maxLength - 1);         if (text.startsWith(""/"")) {             // file name?             newText = CmsStringUtil.formatResourceName(text, maxLength);         } else if (maxLength > 2) {             // enough space for ellipsis?             newText += CmsDomUtil.Entity.hellip.html();         }         if (CmsStringUtil.isEmptyOrWhitespaceOnly(newText)) {             // if empty, it could break the layout             newText = CmsDomUtil.Entity.nbsp.html();         }         return newText;     }
public static <K, V, NK, NV> Map<NK, NV> newChangedKeyValueMap(             Map<K, V> map, Function<K, NK> changingKeyFunction,             Function<V, NV> changingValueFunction) {         return buildEntryStream(map).collect(toMap(                 entry -> changingKeyFunction.apply(entry.getKey()),                 entry -> changingValueFunction.apply(entry.getValue())));     }
public void resetContentAndSettings() {     if (instrumentsVersion.getMajor() < 6) {       if (hasContentAndSettingsFolder()) {         boolean ok = deleteRecursive(getContentAndSettingsFolder());         if (!ok) {           System.err.println(""cannot delete content and settings folder "" + contentAndSettingsFolder);         }       }        // Wipe the system.log.       String deviceLogDir = System.getProperty(""user.home"") +           ""/Library/Logs/iOS Simulator/"" + exactSdkVersion + ((is64bit) ? ""-64"" : """");       File deviceLog = new File(deviceLogDir, ""system.log"");       if (deviceLog.exists()) {         deviceLog.delete();       }        boolean ok = contentAndSettingsFolder.mkdirs();       if (!ok) {         System.err.println(""couldn't re-create: "" + contentAndSettingsFolder);       }     } else {       if (!eraseSimulator()) {         log.info(""Erase contents and settings failed on this device: "" + deviceUUID);         tryToEraseSimulator();       }     }   }
public static Validator<CharSequence> letter(@NonNull final CharSequence errorMessage,                                                  @NonNull final Case caseSensitivity,                                                  final boolean allowSpaces,                                                  @NonNull final char... allowedCharacters) {         return new LetterValidator(errorMessage, caseSensitivity, allowSpaces, allowedCharacters);     }
public Result<Void> addPerm(AuthzTrans trans, RoleDAO.Data role, PermDAO.Data perm) {   // Note: Prepared Statements for Collection updates aren't supported   String pencode = perm.encode();   try {    getSession(trans).execute(UPDATE_SP + TABLE + "" SET perms = perms + {'"" +      pencode + ""'} WHERE "" +     ""ns = '"" + role.ns + ""' AND name = '"" + role.name + ""';"");   } catch (DriverException | APIException | IOException e) {    reportPerhapsReset(trans,e);    return Result.err(Result.ERR_Backend, CassAccess.ERR_ACCESS_MSG);   }    wasModified(trans, CRUD.update, role, ""Added permission "" + pencode + "" to role "" + role.fullName());   return Result.ok();  }
public static int type(String type)     {         if (""request"".equalsIgnoreCase(type))             return __REQUEST;         if (""forward"".equalsIgnoreCase(type))             return __FORWARD;         if (""include"".equalsIgnoreCase(type))             return __INCLUDE;         if (""error"".equalsIgnoreCase(type))             return __ERROR;         throw new IllegalArgumentException(type);     }
public FunctionList union(FunctionList that) {         Set<Function> combined = new LinkedHashSet<Function>();         combined.addAll(Arrays.asList(this.functions));         combined.addAll(Arrays.asList(that.functions));         return new FunctionList(combined);     }
public void writeMethod(ClassVisitor cw, boolean typeQueryRootBean) {      // simple why to determine the property is an associated bean type     boolean assocProperty = desc.contains(""/QAssoc"");      if (classInfo.isLog(4)) {       classInfo.log("" ... add method _"" + name + "" assocProperty:"" + assocProperty + "" rootBean:"" + typeQueryRootBean);     }      MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, ""_""+name, ""()""+desc, ""()""+signature, null);     mv.visitCode();     Label l0 = new Label();     mv.visitLabel(l0);     mv.visitLineNumber(1, l0);     mv.visitVarInsn(ALOAD, 0);     mv.visitFieldInsn(GETFIELD, classInfo.getClassName(), name, desc);     Label l1 = new Label();     mv.visitJumpInsn(IFNONNULL, l1);     Label l2 = new Label();     mv.visitLabel(l2);     mv.visitLineNumber(2, l2);     mv.visitVarInsn(ALOAD, 0);     mv.visitTypeInsn(NEW, internalName);     mv.visitInsn(DUP);     mv.visitLdcInsn(name);     mv.visitVarInsn(ALOAD, 0);      if (assocProperty) {       if (typeQueryRootBean) {         mv.visitInsn(ICONST_1);         mv.visitMethodInsn(INVOKESPECIAL, internalName, ""<init>"", ""(Ljava/lang/String;Ljava/lang/Object;I)V"", false);       } else {         mv.visitFieldInsn(GETFIELD, classInfo.getClassName(), FIELD_ROOT, ""Ljava/lang/Object;"");         mv.visitVarInsn(ALOAD, 0);         mv.visitFieldInsn(GETFIELD, classInfo.getClassName(), FIELD_PATH, ""Ljava/lang/String;"");         mv.visitInsn(ICONST_1);         mv.visitMethodInsn(INVOKESPECIAL, internalName, ""<init>"", ""(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/String;I)V"", false);       }      } else {       if (typeQueryRootBean) {         mv.visitMethodInsn(INVOKESPECIAL, internalName, ""<init>"", ""(Ljava/lang/String;Ljava/lang/Object;)V"", false);       } else {         mv.visitFieldInsn(GETFIELD, classInfo.getClassName(), FIELD_ROOT, ""Ljava/lang/Object;"");         mv.visitVarInsn(ALOAD, 0);         mv.visitFieldInsn(GETFIELD, classInfo.getClassName(), FIELD_PATH, ""Ljava/lang/String;"");         mv.visitMethodInsn(INVOKESPECIAL, internalName, ""<init>"", ""(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/String;)V"", false);       }     }      mv.visitFieldInsn(PUTFIELD, classInfo.getClassName(), name, desc);     mv.visitLabel(l1);     mv.visitLineNumber(3, l1);     mv.visitFrame(Opcodes.F_SAME, 0, null, 0, null);     mv.visitVarInsn(ALOAD, 0);     mv.visitFieldInsn(GETFIELD, classInfo.getClassName(), name, desc);     mv.visitInsn(ARETURN);     Label l3 = new Label();     mv.visitLabel(l3);     mv.visitLocalVariable(""this"", ""L"" + classInfo.getClassName() + "";"", null, l0, l3, 0);     if (assocProperty) {       if (typeQueryRootBean) {         mv.visitMaxs(6, 1);       } else {         mv.visitMaxs(7, 1);       }     } else {       if (typeQueryRootBean) {         mv.visitMaxs(5, 1);       } else {         mv.visitMaxs(6, 1);       }     }     mv.visitEnd();   }
@SuppressWarnings(""checkstyle:magicnumber"")     void writeLong(long value) {         if (value == Long.MIN_VALUE) {             write(STR_LONG_MIN_VALUE);             return;         }          if (value < 0) {             write('-');             value = -value;         }          int digitsWithoutComma = 0;         tmpSb.setLength(0);         do {             digitsWithoutComma++;             if (digitsWithoutComma == 4) {                 tmpSb.append(',');                 digitsWithoutComma = 1;             }              int mod = (int) (value % 10);             tmpSb.append(DIGITS[mod]);             value = value / 10;         } while (value > 0);          for (int k = tmpSb.length() - 1; k >= 0; k--) {             char c = tmpSb.charAt(k);             write(c);         }     }
@Override   public void run() {     List<CompactionVerifier> verifiers = this.suite.getMapReduceVerifiers();     for (CompactionVerifier verifier : verifiers) {       if (!verifier.verify(dataset).isSuccessful()) {         log.error(""Verification {} for {} is not passed."", verifier.getName(), dataset.datasetURN());         this.onMRTaskComplete (false, new IOException(""Compaction verification for MR is failed""));         return;       }     }      super.run();   }
protected static int klu_valid_LU(int n, int flag_test_start_ptr,    int[] Xip, int Xip_offset, int[] Xlen, int Xlen_offset,    double[] LU)  {   /*int[]*/double[] Xi ;   double[] Xx ;   int j, p1, p2, i, p ;   int[] len = new int[1] ;   int[] Xi_offset = new int[1] ;   int[] Xx_offset = new int[1] ;    PRINTF (""\ncolumn oriented matrix, n = %d\n"", n) ;   if (n <= 0)   {    PRINTF (""n must be >= 0: %d\n"", n) ;    return (FALSE) ;   }   if (flag_test_start_ptr != 0 && Xip [Xip_offset + 0] != 0)   {    /* column pointers must start at Xip [0] = 0*/    PRINTF (""column 0 pointer bad\n"") ;    return (FALSE) ;   }    for (j = 0 ; j < n ; j++)   {    p1 = Xip [Xip_offset + j] ;    p2 = Xip [Xip_offset + j+1] ;    PRINTF (""\nColumn: %d p1: %d p2: %d\n"", j, p1, p2) ;    if (p1 > p2)    {     /* column pointers must be ascending */     PRINTF (""column %d pointer bad\n"", j) ;     return (FALSE) ;    }    Xi = Xx = GET_POINTER (LU, Xip, Xip_offset, Xlen, Xlen_offset,      Xi_offset, Xx_offset, j, len) ;    for (p = 0 ; p < len[0] ; p++)    {     i = (int) Xi [Xi_offset[0] + p] ;     PRINTF (""row: %d"", i) ;     if (i < 0 || i >= n)     {      /* row index out of range */      PRINTF (""index out of range, col %d row %d\n"", j, i) ;      return (FALSE) ;     }     if (Xx != null)     {      PRINT_ENTRY (Xx [Xx_offset[0] + p]) ;     }     PRINTF (""\n"") ;    }   }    return (TRUE) ;  }
public Pair<String, StatusCode> sendRequest(ProjectsDetails projectsDetails) {         // send request         logger.info(""Initializing WhiteSource Client"");         Collection<AgentProjectInfo> projects = projectsDetails.getProjects();          if (checkDependenciesUpbound(projects)) {             return new Pair<>(""Number of dependencies exceeded the maximum supported"", StatusCode.SERVER_FAILURE);         }          WhitesourceService service = createService();         String resultInfo = Constants.EMPTY_STRING;         if (offlineConfig.isOffline()) {             resultInfo = offlineUpdate(service, projects);             return new Pair<>(resultInfo, this.prepStepStatusCode);         } else {             // update type             UpdateType updateType = UpdateType.OVERRIDE;             String updateTypeValue = senderConfig.getUpdateTypeValue();             try {                 updateType = UpdateType.valueOf(updateTypeValue);             } catch (Exception e) {                 logger.info(""Invalid value {} for updateType, defaulting to {}"", updateTypeValue, UpdateType.OVERRIDE);             }             logger.info(""UpdateType set to {} "", updateTypeValue);              StatusCode statusCode = StatusCode.SUCCESS;             if (senderConfig.isEnableImpactAnalysis()) {                 runViaAnalysis(projectsDetails, service);             } else if (!senderConfig.isEnableImpactAnalysis()) {                 //todo return logs when needed would be enabled for all WSE-342             }             int retries = senderConfig.getConnectionRetries();             while (retries-- > -1) {                 try {                     statusCode = checkPolicies(service, projects);                     if (senderConfig.isUpdateInventory()) {                         if (statusCode == StatusCode.SUCCESS || (senderConfig.isForceUpdate() && senderConfig.isForceUpdateFailBuildOnPolicyViolation())) {                             resultInfo = update(service, projects);                         }                     }                     break;                 } catch (WssServiceException e) {                     if (e.getCause() != null &&                             e.getCause().getClass().getCanonicalName().substring(0,                                     e.getCause().getClass().getCanonicalName().lastIndexOf(Constants.DOT)).equals(Constants.JAVA_NETWORKING)) {                         statusCode = StatusCode.CONNECTION_FAILURE;                         logger.error(""Trying "" + (retries + 1) + "" more time"" + (retries != 0 ? ""s"" : Constants.EMPTY_STRING));                     } else {                         statusCode = StatusCode.SERVER_FAILURE;                         retries = -1;                     }                     resultInfo = ""Failed to send request to WhiteSource server: "" + e.getMessage();                     logger.error(resultInfo, e.getMessage());                     logger.debug(resultInfo, e);                     if (retries > -1) {                         try {                             Thread.sleep(senderConfig.getConnectionRetriesIntervals());                         } catch (InterruptedException e1) {                             logger.error(""Failed to sleep while retrying to connect to server "" + e1.getMessage(), e1);                         }                     }                     String requestToken = e.getRequestToken();                     if (StringUtils.isNotBlank(requestToken)) {                         resultInfo += Constants.NEW_LINE + ""Support token: "" + requestToken;                         logger.info(""Support token: {}"", requestToken);                     }                 }             }             if (service != null) {                 service.shutdown();             }             if (statusCode == StatusCode.SUCCESS) {                 return new Pair<>(resultInfo, this.prepStepStatusCode);             }             return new Pair<>(resultInfo, statusCode);         }     }
public Object extractJavaFieldValue(Object object) throws SQLException {    Object val = extractRawJavaFieldValue(object);    // if this is a foreign object then we want its reference field   if (foreignRefField != null && val != null) {    val = foreignRefField.extractRawJavaFieldValue(val);   }    return val;  }
final static public char[] trim(char[] chars)  {    if (chars == null)   {    return null;   }    int start = 0, length = chars.length, end = length - 1;   while (start < length && chars[start] == ' ')   {    start++;   }   while (end > start && chars[end] == ' ')   {    end--;   }   if (start != 0 || end != length - 1)   {    return subarray(chars, start, end + 1);   }   return chars;  }
public void doGet(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException {     NameNode.getNameNodeMetrics().numListPathsServletDoGet.inc();     final UnixUserGroupInformation ugi = getUGI(request);     final PrintWriter out = response.getWriter();     final XMLOutputter doc = new XMLOutputter(out, ""UTF-8"");     try {       final Map<String, String> root = buildRoot(request, doc);       final String path = root.get(""path"");       final boolean recur = ""yes"".equals(root.get(""recursive""));       final Pattern filter = Pattern.compile(root.get(""filter""));       final Pattern exclude = Pattern.compile(root.get(""exclude""));       ClientProtocol nnproxy = createNameNodeProxy(ugi);        doc.declaration();       doc.startTag(""listing"");       for (Map.Entry<String,String> m : root.entrySet()) {         doc.attribute(m.getKey(), m.getValue());       }        HdfsFileStatus base = nnproxy.getHdfsFileInfo(path);       if ((base != null) && base.isDir()) {         writeInfo(path, base, doc);       }        Stack<String> pathstack = new Stack<String>();       pathstack.push(path);       while (!pathstack.empty()) {         String p = pathstack.pop();         try {           byte[] lastReturnedName = HdfsFileStatus.EMPTY_NAME;           DirectoryListing thisListing;           do {             assert lastReturnedName != null;             thisListing = nnproxy.getPartialListing(p, lastReturnedName);             if (thisListing == null) {               if (lastReturnedName.length == 0) {                 LOG.warn(""ListPathsServlet - Path "" + p + "" does not exist"");               }               break;             }             HdfsFileStatus[] listing = thisListing.getPartialListing();             for (HdfsFileStatus i : listing) {               String localName = i.getLocalName();               if (exclude.matcher(localName).matches()                   || !filter.matcher(localName).matches()) {                 continue;               }               if (recur && i.isDir()) {                 pathstack.push(new Path(p, localName).toUri().getPath());               }               writeInfo(p, i, doc);             }             lastReturnedName = thisListing.getLastName();           } while (thisListing.hasMore());         } catch(RemoteException re) {re.writeXml(p, doc);}       }       if (doc != null) {         doc.endDocument();       }     } finally {       if (out != null) {         out.close();       }     }   }
public static l4param get(nitro_service service) throws Exception{   l4param obj = new l4param();   l4param[] response = (l4param[])obj.get_resources(service);   return response[0];  }
private int getColor(Point p1, Point p2) {     float d = distance(p1, p2);     float dx = (p2.getX() - p1.getX()) / d;     float dy = (p2.getY() - p1.getY()) / d;     int error = 0;      float px = p1.getX();     float py = p1.getY();      boolean colorModel = image.get(p1.getX(), p1.getY());      int iMax = (int) Math.ceil(d);     for (int i = 0; i < iMax; i++) {       px += dx;       py += dy;       if (image.get(MathUtils.round(px), MathUtils.round(py)) != colorModel) {         error++;       }     }      float errRatio = error / d;      if (errRatio > 0.1f && errRatio < 0.9f) {       return 0;     }      return (errRatio <= 0.1f) == colorModel ? 1 : -1;   }
public void findModules() {         ServiceLoader<ClientModuleFactory> loader = ServiceLoader.load(ClientModuleFactory.class);          Iterator<ClientModuleFactory> iterator = loader.iterator();         while (iterator.hasNext()) {             ClientModuleFactory factory = iterator.next();             Module module = factory.create();             addModule(module);         }          objectMapper.findAndRegisterModules();     }
public void didInvoke(Method method, List<JsonNode> arguments, Object result, Throwable t, long duration) {   for (InvocationListener invocationListener : invocationListeners) {    invocationListener.didInvoke(method, arguments, result, t, duration);   }  }
public String replaceSensitiveWord(String txt,MatchType matchType,String replaceChar){   String resultTxt = txt;   Set<String> set = findSensitiveWord(txt, matchType);     //获取所有的敏感词   Iterator<String> iterator = set.iterator();   String word = null;   String replaceString = null;   while (iterator.hasNext()) {    word = iterator.next();    replaceString = getReplaceChars(replaceChar, word.length());    resultTxt = resultTxt.replaceAll(word, replaceString);   }      return resultTxt;  }
public Object parse(String value, Class type)     {         if (StringUtil.isBlank(value))         {             return null;         }          return doConvert(value.trim(), type);     }
private static double getMinPlusMaxObject(List<? extends SpatialComparable> objs, int s, int dim) {     SpatialComparable sobj = objs.get(s);     return sobj.getMin(dim) + sobj.getMax(dim);   }
protected UserDetailsService userDetailsService() {   AuthenticationManagerBuilder globalAuthBuilder = context     .getBean(AuthenticationManagerBuilder.class);   return new UserDetailsServiceDelegator(Arrays.asList(     localConfigureAuthenticationBldr, globalAuthBuilder));  }
@Override   protected String getDescription(final MBeanOperationInfo op) {      String descr = op.getDescription();     Method m = getMethod(op);     if (m != null) {       MBeanInfo d = m.getAnnotation(MBeanInfo.class);       if (d != null) {         descr = d.value();       }     }     return descr;   }
protected byte[] fileToByteArray(File file) throws IOException    {       FileInputStream in = null;        try       {          if (channel == null || !channel.isOpen())          {             in = PrivilegedFileHelper.fileInputStream(file);             channel = in.getChannel();          }           ByteBuffer bb = ByteBuffer.allocate((int)channel.size());          channel.read(bb);          if (bb.hasArray())          {             return bb.array();          }          else          {             // impossible code in most cases, as we use heap backed buffer             byte[] tmpb = new byte[bb.capacity()];             bb.get(tmpb);             return tmpb;          }       }       finally       {          if (in != null)          {             in.close();             if (channel != null)             {                channel.close();             }          }       }    }
public static String createVMJson(    String hostIpPort,    String id,    String template,    String title,    String summary,    String userData,    String user,    String password,    Map<String,String> config,    boolean waitForActive )  throws TargetException {    // Count VM creations (+ make title unique, it is used as VM ID by VMWare !)   String uniqueTitle = title + (++vmCount);    //TODO Expecting more interoperable implementation !   if(config.get(CloudautomationMixins.PROVIDER_ENDPOINT) != null) {    return createCloudAutomationVM(hostIpPort, id, template, title, summary, userData, config, false);   } else {     String vmId = null;    URL url = null;    try {     CookieHandler.setDefault(new CookieManager(null, CookiePolicy.ACCEPT_ALL));     url = new URL(""http://"" + hostIpPort + ""/vm/"");    } catch (MalformedURLException e) {     throw new TargetException(e);    }     HttpURLConnection httpURLConnection = null;    DataInputStream in = null;    DataOutputStream output = null;    try {     httpURLConnection = (HttpURLConnection) url.openConnection();     httpURLConnection.setRequestMethod(""PUT"");     httpURLConnection.setRequestProperty(""Content-Type"", ""application/json"");     httpURLConnection.setRequestProperty(""Accept"", ""application/json"");     httpURLConnection.setDoInput(true);     httpURLConnection.setDoOutput(true);      String userDataString = ""name: value"";     if(userData != null) {      userDataString =        userData.replaceAll(""\n\r"", ""\\\\n"")        .replaceAll(""\n"", ""\\\\n"")        .replaceAll(System.lineSeparator(), ""\\\\n"");     }      String request = ""{\n""       + ""\""id\"": \"""" + id + ""\"",\n""       + ""\""title\"": \"""" + uniqueTitle + ""\"",\n""       + ""\""summary\"": \"""" + summary + ""\"",\n""       + ""\""kind\"": \""http://schemas.ogf.org/occi/infrastructure#compute\"",\n""       + ""\""mixins\"": [""       + ""\""http://occiware.org/occi/infrastructure/crtp/backend#vmimage\"",\n""       + ""\""http://occiware.org/occi/infrastructure/crtp/backend#vmwarefolders\"",\n""       + ""\""http://schemas.ogf.org/occi/infrastructure/compute#user_data\"",\n""       + ""\""http://occiware.org/occi/infrastructure/crtp/backend#credential\""\n""       + ""],\n""       + ""\""attributes\"": {\n""       + ""\""occi.compute.state\"": \"""" + ""active"" + ""\"",\n""       + ""\""occi.compute.speed\"": "" + 3 + "",\n""       + ""\""occi.compute.memory\"": "" + 2 + "",\n""       + ""\""occi.compute.cores\"": "" + 2 + "",\n""       + ""\""occi.compute.architecture\"": \"""" + ""x64"" + ""\"",\n""       + ""\""imagename\"": \"""" + template + ""\"",\n""       + ""\""datacentername\"": \"""" + config.get(VmwareFoldersMixin.DATACENTERNAME) + ""\"",\n""       + ""\""datastorename\"": \"""" + config.get(VmwareFoldersMixin.DATASTORENAME) + ""\"",\n""       + ""\""clustername\"": \"""" + config.get(VmwareFoldersMixin.CLUSTERNAME) + ""\"",\n""       + ""\""hostsystemname\"": \"""" + config.get(VmwareFoldersMixin.HOSTSYSTEMNAME) + ""\"",\n""       + ""\""inventorypath\"": \"""" + config.get(VmwareFoldersMixin.INVENTORYPATH) + ""\"",\n""       + ""\""occi.compute.userdata\"": \"""" + userDataString + ""\"",\n""       + ""\""user\"": \"""" + user + ""\"",\n""       + ""\""password\"": \"""" + password + ""\""\n""       + ""}\n}"";      final Logger logger = Logger.getLogger( OcciVMUtils.class.getName());     logger.finest(request);      httpURLConnection.setRequestProperty(       ""Content-Length"",       Integer.toString(request.getBytes( StandardCharsets.UTF_8 ).length));      output = new DataOutputStream(httpURLConnection.getOutputStream());     output.writeBytes(request);     output.flush();     Utils.closeQuietly(output);     output = null;      in = new DataInputStream(httpURLConnection.getInputStream());     ByteArrayOutputStream out = new ByteArrayOutputStream();     Utils.copyStreamSafely(in, out);      // Parse JSON response to extract VM ID     ObjectMapper objectMapper = new ObjectMapper();     JsonResponse rsp = objectMapper.readValue(out.toString( ""UTF-8"" ), JsonResponse.class);     vmId = rsp.getId();      if(! Utils.isEmptyOrWhitespaces(vmId)) {      // Wait until VM is active, if requested      if(waitForActive) {       int retries = 15;       boolean active = false;       while(! active && retries-- > 0) {        logger.finest(""retry: "" + retries);        try {         Thread.sleep(10000);  // 10 seconds        } catch (InterruptedException e) {         // ignore        }        active = !Utils.isEmptyOrWhitespaces(getVMIP(hostIpPort + ""/compute"", vmId));        //active = ""ACTIVE"".equalsIgnoreCase(getVMStatus(hostIpPort, ret));       }      }     }     } catch (IOException e) {     throw new TargetException(e);     }  finally {     Utils.closeQuietly(in);     Utils.closeQuietly(output);     if (httpURLConnection != null) {      httpURLConnection.disconnect();     }    }     return (vmId);   }  }
private void checkAndValidateParameters(ConfigProperty configProperty) {         LOGGER.entering(configProperty);         try {             switch (configProperty) {             case SELENDROID_SERVER_START_TIMEOUT:             case SELENDROID_EMULATOR_START_TIMEOUT: {                 // Selendroid takes timeoutEmulatorStart/serverStartTimeout in milliseconds.                 Config.getIntConfigProperty(configProperty);                 break;             }             case MOBILE_DRIVER_SESSION_TIMEOUT: {                 // Selendroid takes sessionTimeout in seconds.                 int receivedValue = Config.getIntConfigProperty(configProperty) / 1000;                 if (receivedValue == 0) {                     String errorMessage = ""Insufficient value received for configuration property ""                             + configProperty.getName() + "", probably value is less than 1000 milliseconds."";                     throw new IllegalArgumentException(errorMessage);                 }                 break;             }             default: {                 throw new IllegalArgumentException(                         ""Invalid selendroid configuration received for validation, configuration property = ""                                 + configProperty.getName());             }             }         } catch (ConversionException exe) {             String errorMessage = ""Invalid data received for configuration property "" + configProperty.getName()                     + "", probably not an integer for milliseconds."";             throw new IllegalArgumentException(errorMessage, exe);         }          LOGGER.exiting();     }
private IChemFile readChemFile(IChemFile file) {         IChemSequence chemSequence = file.getBuilder().newInstance(IChemSequence.class);         IChemModel chemModel = file.getBuilder().newInstance(IChemModel.class);         IAtomContainerSet setOfMolecules = file.getBuilder().newInstance(IAtomContainerSet.class);         String info;          StringTokenizer tokenizer;         List<String> aroringText = new ArrayList<String>();         List<IAtomContainer> mols = new ArrayList<IAtomContainer>();          try {             String line;              // read in header info             while (true) {                 line = input.readLine();                 if (line.startsWith(""mol"")) {                     info = getMolName(line);                     break;                 }             }              // start the actual molecule data - may be multiple molecule             line = input.readLine();             while (true) {                 if (line == null) break; // end of file                 if (line.startsWith("";"")) continue; // comment line                  if (line.startsWith(""mol"")) {                     info = getMolName(line);                     line = input.readLine();                 }                 IAtomContainer m = file.getBuilder().newInstance(IAtomContainer.class);                 m.setTitle(info);                  // Each element of cons is an ArrayList of length 3 which stores                 // the start and end indices and bond order of each bond                 // found in the HIN file. Before adding bonds we need to reduce                 // the number of bonds so as not to count the same bond twice                 List<List<Object>> cons = new ArrayList<List<Object>>();                  // read data for current molecule                 int atomSerial = 0;                 while (true) {                     if (line == null || line.contains(""endmol"")) {                         break;                     }                     if (line.startsWith("";"")) continue; // comment line                      tokenizer = new StringTokenizer(line, "" "");                      int ntoken = tokenizer.countTokens();                     String[] toks = new String[ntoken];                     for (int i = 0; i < ntoken; i++)                         toks[i] = tokenizer.nextToken();                      String sym = toks[3];                     double charge = Double.parseDouble(toks[6]);                     double x = Double.parseDouble(toks[7]);                     double y = Double.parseDouble(toks[8]);                     double z = Double.parseDouble(toks[9]);                     int nbond = Integer.parseInt(toks[10]);                      IAtom atom = file.getBuilder().newInstance(IAtom.class, sym, new Point3d(x, y, z));                     atom.setCharge(charge);                      IBond.Order bo = IBond.Order.SINGLE;                      for (int j = 11; j < (11 + nbond * 2); j += 2) {                         int s = Integer.parseInt(toks[j]) - 1; // since atoms start from 1 in the file                         char bt = toks[j + 1].charAt(0);                         switch (bt) {                             case 's':                                 bo = IBond.Order.SINGLE;                                 break;                             case 'd':                                 bo = IBond.Order.DOUBLE;                                 break;                             case 't':                                 bo = IBond.Order.TRIPLE;                                 break;                             case 'a':                                 bo = IBond.Order.QUADRUPLE;                                 break;                         }                         List<Object> ar = new ArrayList<Object>(3);                         ar.add(atomSerial);                         ar.add(s);                         ar.add(bo);                         cons.add(ar);                     }                     m.addAtom(atom);                     atomSerial++;                     line = input.readLine();                 }                  // now just store all the bonds we have                 for (List<Object> ar : cons) {                     IAtom s = m.getAtom((Integer) ar.get(0));                     IAtom e = m.getAtom((Integer) ar.get(1));                     IBond.Order bo = (IBond.Order) ar.get(2);                     if (!isConnected(m, s, e)) m.addBond(file.getBuilder().newInstance(IBond.class, s, e, bo));                 }                 mols.add(m);                  // we may not get a 'mol N' immediately since                 // the aromaticring keyword might be present                 // and doesn't seem to be located within the molecule                 // block. However, if we do see this keyword we save this                 // since it can contain aromatic specs for any molecule                 // listed in the file                 //                 // The docs do not explicitly state the the keyword comes                 // after *all* molecules. So we save and then reprocess                 // all the molecules in a second pass                 while (true) {                     line = input.readLine();                     if (line == null || line.startsWith(""mol"")) break;                     if (line.startsWith(""aromaticring"")) aroringText.add(line.trim());                 }             }          } catch (IOException e) {             // FIXME: should make some noise now             file = null;         }          if (aroringText.size() > 0) { // process aromaticring annotations             for (String line : aroringText) {                 String[] toks = line.split("" "");                 int natom = Integer.parseInt(toks[1]);                 int n = 0;                 for (int i = 2; i < toks.length; i += 2) {                     int molnum = Integer.parseInt(toks[i]); // starts from 1                     int atnum = Integer.parseInt(toks[i + 1]); // starts from 1                     mols.get(molnum - 1).getAtom(atnum - 1).setFlag(CDKConstants.ISAROMATIC, true);                     n++;                 }                 assert n == natom;             }         }          for (IAtomContainer mol : mols)             setOfMolecules.addAtomContainer(mol);         chemModel.setMoleculeSet(setOfMolecules);         chemSequence.addChemModel(chemModel);         file.addChemSequence(chemSequence);          return file;     }
public static QualifiedName of(String packageName, String topLevelType, String... nestedTypes) {     requireNonNull(!packageName.isEmpty());     checkArgument(!topLevelType.isEmpty());     return new QualifiedName(         unshadedName(packageName),  // shadowJar modifies string literals; unshade them here         ImmutableList.<String>builder().add(topLevelType).add(nestedTypes).build());   }
public synchronized void update() {     SYSTEM_POWER_STATUS status = new SYSTEM_POWER_STATUS();     Kernel32.INSTANCE.GetSystemPowerStatus(status);      switch (status.ACLineStatus) {     case 0: // battery       allow(!requireAC           && (status.BatteryLifePercent < 0 || status.BatteryLifePercent >= minBatteryLifePercent));       break;      case 1:  // A/C     default:       allow((status.BatteryFlag & 0x8) == 0 // not charging           || (status.BatteryLifePercent < 0 || status.BatteryLifePercent >= minBatteryLifePercentWhileCharging));       break;      }   }
private static org.apache.maven.model.RepositoryPolicy asMavenRepositoryPolicy(             org.apache.maven.settings.RepositoryPolicy policy) {          org.apache.maven.model.RepositoryPolicy mavenPolicy = new org.apache.maven.model.RepositoryPolicy();         if (policy != null) {             mavenPolicy.setChecksumPolicy(policy.getChecksumPolicy());             mavenPolicy.setUpdatePolicy(policy.getUpdatePolicy());             mavenPolicy.setEnabled(policy.isEnabled());         }          return mavenPolicy;     }
private Number calculatePercentComplete(Row row)    {       Number result;       switch (PercentCompleteType.getInstance(row.getString(""complete_pct_type"")))       {          case UNITS:          {             result = calculateUnitsPercentComplete(row);             break;          }           case DURATION:          {             result = calculateDurationPercentComplete(row);             break;          }           default:          {             result = calculatePhysicalPercentComplete(row);             break;          }       }        return result;    }
@Nullable     public MongoCredential getCredential() {         if (getCredentialsList().size() > 1) {             throw new IllegalStateException(""Instance constructed with more than one MongoCredential"");         } else if (getCredentialsList().isEmpty()) {             return null;         } else {             return getCredentialsList().get(0);         }     }
@GwtIncompatible(""incompatible method"")     public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) {         // TODO when breaking BC, consider returning obj         if (!type.isInstance(obj)) {             throw new IllegalArgumentException(StringUtils.simpleFormat(message, values));         }     }
public static String applyFromPath(String path) throws ConverterException {     String xml = converters.get(0).convertFromPath(path, false);         xml = applyFromSecond(xml);   if (conversionDone()) {    return converters.get(converters.size()-1).changeVersion(xml);   } else {    return xml;   }  }
static int getAnimationResource(int gravity, boolean isInAnimation) {     if ((gravity & Gravity.TOP) == Gravity.TOP) {       return isInAnimation ? R.anim.slide_in_top : R.anim.slide_out_top;     }     if ((gravity & Gravity.BOTTOM) == Gravity.BOTTOM) {       return isInAnimation ? R.anim.slide_in_bottom : R.anim.slide_out_bottom;     }     if ((gravity & Gravity.CENTER) == Gravity.CENTER) {       return isInAnimation ? R.anim.fade_in_center : R.anim.fade_out_center;     }     return INVALID;   }
public void onSurfaceChanged (int pixelWidth, int pixelHeight, int orient) {     viewportChanged(pixelWidth, pixelHeight);     screenSize.setSize(viewSize);     switch (orient) {     case Configuration.ORIENTATION_LANDSCAPE:       orientDetailM.update(OrientationDetail.LANDSCAPE_LEFT);       break;     case Configuration.ORIENTATION_PORTRAIT:       orientDetailM.update(OrientationDetail.PORTRAIT);       break;     default: // Configuration.ORIENTATION_UNDEFINED       orientDetailM.update(OrientationDetail.UNKNOWN);       break;     }   }
public final EntityType getEntityType(EntityTypeName name) {      GetEntityTypeRequest request =         GetEntityTypeRequest.newBuilder().setName(name == null ? null : name.toString()).build();     return getEntityType(request);   }
public static boolean containsNone(final CharSequence cs, final String invalidChars) {         if (cs == null || invalidChars == null) {             return true;         }         return containsNone(cs, invalidChars.toCharArray());     }
public static void runExample(       AdWordsServicesInterface adWordsServices,       AdWordsSession session,       Long adGroupId,       Long keywordId)       throws RemoteException {     // Get the AdGroupCriterionService.     AdGroupCriterionServiceInterface adGroupCriterionService =         adWordsServices.get(session, AdGroupCriterionServiceInterface.class);      // Create ad group criterion with updated bid.     Criterion criterion = new Criterion();     criterion.setId(keywordId);      BiddableAdGroupCriterion biddableAdGroupCriterion = new BiddableAdGroupCriterion();     biddableAdGroupCriterion.setAdGroupId(adGroupId);     biddableAdGroupCriterion.setCriterion(criterion);      // Create bids.     BiddingStrategyConfiguration biddingStrategyConfiguration = new BiddingStrategyConfiguration();     CpcBid bid = new CpcBid();     bid.setBid(new Money(null, 10000000L));     biddingStrategyConfiguration.setBids(new Bids[] {bid});     biddableAdGroupCriterion.setBiddingStrategyConfiguration(biddingStrategyConfiguration);      // Create operations.     AdGroupCriterionOperation operation = new AdGroupCriterionOperation();     operation.setOperand(biddableAdGroupCriterion);     operation.setOperator(Operator.SET);      AdGroupCriterionOperation[] operations = new AdGroupCriterionOperation[] {operation};      // Update ad group criteria.     AdGroupCriterionReturnValue result = adGroupCriterionService.mutate(operations);      // Display ad group criteria.     for (AdGroupCriterion adGroupCriterionResult : result.getValue()) {       if (adGroupCriterionResult instanceof BiddableAdGroupCriterion) {         biddableAdGroupCriterion = (BiddableAdGroupCriterion) adGroupCriterionResult;         CpcBid criterionCpcBid = null;         // Find the criterion-level CpcBid among the keyword's bids.         for (Bids bids : biddableAdGroupCriterion.getBiddingStrategyConfiguration().getBids()) {           if (bids instanceof CpcBid) {             CpcBid cpcBid = (CpcBid) bids;             if (BidSource.CRITERION.equals(cpcBid.getCpcBidSource())) {               criterionCpcBid = cpcBid;             }           }         }          System.out.printf(             ""Ad group criterion with ad group ID %d, criterion ID %d, type ""                 + ""'%s', and bid %d was updated.%n"",             biddableAdGroupCriterion.getAdGroupId(),             biddableAdGroupCriterion.getCriterion().getId(),             biddableAdGroupCriterion.getCriterion().getCriterionType(),             criterionCpcBid.getBid().getMicroAmount());       }     }   }
public void deleteCrowdIndiv_same(int crowdIdx, int nicheCount, double indivFitness, S indiv) {      // find the solution indices within this crowdIdx subregion     ArrayList<Integer> indList = new ArrayList<>();     for (int i = 0; i < populationSize; i++) {       if (subregionIdx[crowdIdx][i] == 1) {         indList.add(i);       }     }      // find the solution with the worst fitness value     int listSize = indList.size();     int worstIdx = indList.get(0);     double maxFitness = fitnessFunction(population.get(worstIdx), lambda[crowdIdx]);     for (int i = 1; i < listSize; i++) {       int curIdx = indList.get(i);       double curFitness = fitnessFunction(population.get(curIdx), lambda[crowdIdx]);       if (curFitness > maxFitness) {         worstIdx = curIdx;         maxFitness = curFitness;       }     }      // if indiv has a better fitness, use indiv to replace the worst one     if (indivFitness < maxFitness) {       replace(worstIdx, indiv);     }   }
public int addDocument(String document) {     if (root().getNumberOfChildren() >= 0) {       throw new IllegalStateException(""Tree sorting has begun"");     }     final int index;     synchronized (this) {       index = documents.size();       documents.add(document);     }     cursors.addAll(       IntStream.range(0, document.length() + 1).mapToObj(i -> new CursorData(index, i)).collect(Collectors.toList()));     nodes.update(0, node -> node.setCursorCount(cursors.length()));     return index;   }
@UiHandler(""m_button"")     protected void onClick(ClickEvent event) {          m_tab.removeParam(m_paramKey);         m_tab = null;         removeFromParent();     }
public MBeanInfo getMBeanInfo(ObjectName name) throws InstanceNotFoundException, IntrospectionException, ReflectionException {         return delegate.getMBeanInfo(name);     }
static void parseCoreEnvironmentElement(final XMLExtendedStreamReader reader, final ModelNode operation) throws XMLStreamException {          final int count = reader.getAttributeCount();         for (int i = 0; i < count; i++) {             requireNoNamespaceAttribute(reader, i);             final String value = reader.getAttributeValue(i);             final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));             switch (attribute) {                 case NODE_IDENTIFIER:                     TransactionSubsystemRootResourceDefinition.NODE_IDENTIFIER.parseAndSetParameter(value, operation, reader);                     break;                 case PATH:                 case RELATIVE_TO:                     throw TransactionLogger.ROOT_LOGGER.unsupportedAttribute(attribute.getLocalName(), reader.getLocation());                 default:                     throw unexpectedAttribute(reader, i);             }         }         // elements         final EnumSet<Element> required = EnumSet.of(Element.PROCESS_ID);         final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);         while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {             final Element element = Element.forName(reader.getLocalName());             required.remove(element);             switch (element) {                 case PROCESS_ID: {                     if (!encountered.add(element)) {                         throw duplicateNamedElement(reader, reader.getLocalName());                     }                     parseProcessIdEnvironmentElement(reader, operation);                     break;                 }                 default:                     throw unexpectedElement(reader);             }         }         if (!required.isEmpty()) {             throw missingRequiredElement(reader, required);         }     }
public Observable<Void> publishAsync(String resourceGroupName, String labAccountName, String labName, String environmentSettingName) {         return publishWithServiceResponseAsync(resourceGroupName, labAccountName, labName, environmentSettingName).map(new Func1<ServiceResponse<Void>, Void>() {             @Override             public Void call(ServiceResponse<Void> response) {                 return response.body();             }         });     }
public void finest(String message) throws NullPointerException,     FacilityException {    sendNotification(TraceLevel.FINEST, message, null);    logger.trace(message);       }
protected void configureObjectMapper(final ObjectMapper mapper) {         mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false)             .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);          mapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);         mapper.setVisibility(PropertyAccessor.SETTER, JsonAutoDetect.Visibility.PROTECTED_AND_PUBLIC);         mapper.setVisibility(PropertyAccessor.GETTER, JsonAutoDetect.Visibility.PROTECTED_AND_PUBLIC);         mapper.setVisibility(PropertyAccessor.IS_GETTER, JsonAutoDetect.Visibility.PROTECTED_AND_PUBLIC);          if (isDefaultTypingEnabled()) {             mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);         }         mapper.findAndRegisterModules();     }
@Override     public InputSource resolveEntity(String publicId, String systemId) throws SAXException {         if (validating) {             try {                 InputSource source = null;                 if (publicId != null) {                     String path = doctypeMap.get(publicId.toUpperCase());                     source = getInputSource(path);                 }                 if (source == null && systemId != null) {                     String path = doctypeMap.get(systemId.toUpperCase());                     source = getInputSource(path);                 }                 return source;             } catch (Exception e) {                 throw new SAXException(e.toString());             }         } else {             return new InputSource(new StringReader(""""));         }     }
public static void calcPoints(final double lat1, final double lon1,                                   final double lat2, final double lon2,                                   final PointEmitter emitter,                                   final double offsetLat, final double offsetLon,                                   final double deltaLat, final double deltaLon) {         // round to make results of bresenham closer to correct solution         int y1 = (int) ((lat1 - offsetLat) / deltaLat);         int x1 = (int) ((lon1 - offsetLon) / deltaLon);         int y2 = (int) ((lat2 - offsetLat) / deltaLat);         int x2 = (int) ((lon2 - offsetLon) / deltaLon);         bresenham(y1, x1, y2, x2, new PointEmitter() {             @Override             public void set(double lat, double lon) {                 // +.1 to move more near the center of the tile                 emitter.set((lat + .1) * deltaLat + offsetLat, (lon + .1) * deltaLon + offsetLon);             }         });     }
public Alignment<S> move(int offset) {         return new Alignment<>(sequence1, mutations, sequence1Range, sequence2Range.move(offset), score);     }
public void enableForegroundServiceScanning(Notification notification, int notificationId)             throws IllegalStateException {         if (isAnyConsumerBound()) {             throw new IllegalStateException(""May not be called after consumers are already bound."");         }         if (notification == null) {             throw new NullPointerException(""Notification cannot be null"");         }         setEnableScheduledScanJobs(false);         mForegroundServiceNotification = notification;         mForegroundServiceNotificationId = notificationId;     }
private void openButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openButtonActionPerformed   final File dir = lastOpenDirectory();   final JFileChooser chooser = dir != null    ? new JFileChooser(dir)    : new JFileChooser();   chooser.setDialogTitle(""Choose Image"");   chooser.setDialogType(JFileChooser.OPEN_DIALOG);   chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);   chooser.setMultiSelectionEnabled(false);   chooser.addChoosableFileFilter(new FileNameExtensionFilter(    format(     ""Images (%s)"",     Stream.of(ImageIO.getReaderFileSuffixes())      .map(s -> format("" *.%s"", s))      .collect(Collectors.joining("",""))    ),    ImageIO.getReaderFileSuffixes()   ));    final int returnVal = chooser.showOpenDialog(this);   if (returnVal == JFileChooser.APPROVE_OPTION) {    final File imageFile = chooser.getSelectedFile();    try {     update(ImageIO.read(imageFile));     if (imageFile.getParentFile() != null) {      lastOpenDirectory(imageFile.getParentFile());     }    } catch (IOException e) {     JOptionPane.showMessageDialog(      rootPane,      format(""Error while loading image '%s'."", imageFile),      e.toString(),      JOptionPane.ERROR_MESSAGE     );    }   }  }
@Override   public Object processTask(String taskName, Map<String, String[]> parameterMap) {      if (""createAdmin"".equalsIgnoreCase(taskName)) {       return userService.createDefaultAdmin();     }      return null;    }
public SipTransaction sendReply(SipTransaction transaction, Response response) {     initErrorInfo();      if ((transaction == null) || (transaction.getServerTransaction() == null)) {       setErrorMessage(""Cannot send reply, transaction information is null"");       setReturnCode(INVALID_ARGUMENT);       return null;     }      // send the message     try {       SipStack.dumpMessage(""Response before sending out through stack"", response);       transaction.getServerTransaction().sendResponse(response);     } catch (Exception ex) {       setException(ex);       setErrorMessage(""Exception: "" + ex.getClass().getName() + "": "" + ex.getMessage());       setReturnCode(EXCEPTION_ENCOUNTERED);       return null;     }      return transaction;   }
public static    TaskAttemptID downgrade(org.apache.hadoop.mapreduce.TaskAttemptID old) {     if (old instanceof TaskAttemptID) {       return (TaskAttemptID) old;     } else {       return new TaskAttemptID(TaskID.downgrade(old.getTaskID()), old.getId());     }   }
public void decodeBulk(byte[][] readBufs, byte[][] writeBufs,       int[] erasedLocations) throws IOException {     int[] tmpInput = new int[readBufs.length];     int[] tmpOutput = new int[erasedLocations.length];      int numBytes = readBufs[0].length;     for (int idx = 0; idx < numBytes; idx++) {       for (int i = 0; i < tmpOutput.length; i++) {         tmpOutput[i] = 0;       }       for (int i = 0; i < tmpInput.length; i++) {         tmpInput[i] = readBufs[i][idx] & 0x000000FF;       }       decode(tmpInput, erasedLocations, tmpOutput);       for (int i = 0; i < tmpOutput.length; i++) {         writeBufs[i][idx] = (byte) tmpOutput[i];       }     }   }
@Override     public AtomicValue evaluate() {          boolean satisfiesCond = false;          for (AbsAxis axis : mVars) {             while (axis.hasNext()) {                 if (mSatisfy.hasNext()) {                     // condition is satisfied for this item -> expression is                     // true                     satisfiesCond = true;                     break;                 }             }         }          AtomicValue val =             new AtomicValue(TypedValue.getBytes(Boolean.toString(satisfiesCond)), NamePageHash                 .generateHashForString(""xs:boolean""));         final int mItemKey = getItemList().addItem(val);         moveTo(mItemKey);         return val;      }
public static boolean isExtension(GeometryType geometryType) {   return GeometryCodes.getCode(geometryType) > GeometryCodes     .getCode(GeometryType.GEOMETRYCOLLECTION);  }
private void orderResults(ResultSet cqlRows) throws InvalidRequestException     {         if (cqlRows.size() == 0 || !needsPostQueryOrdering())             return;          assert orderingIndexes != null;          List<Integer> idToSort = new ArrayList<Integer>();         List<Comparator<ByteBuffer>> sorters = new ArrayList<Comparator<ByteBuffer>>();          for (ColumnIdentifier.Raw identifier : parameters.orderings.keySet())         {             ColumnDefinition orderingColumn = cfm.getColumnDefinition(identifier.prepare(cfm));             idToSort.add(orderingIndexes.get(orderingColumn.name));             sorters.add(orderingColumn.type);         }          Comparator<List<ByteBuffer>> comparator = idToSort.size() == 1                                                 ? new SingleColumnComparator(idToSort.get(0), sorters.get(0))                                                 : new CompositeComparator(sorters, idToSort);         Collections.sort(cqlRows.rows, comparator);     }
private void makeIncoming() {         if (stays == null && move == null) {             for (BitSet in : ins) {                 in.clear();             }             stays = new BitSet();             move = new BitSet();             for (int i = 0; i < hosts.length; i++) {                 if (hosts[i] != null && hosts[i].isInstantiated()) {                     int newPos = hosts[i].getValue();                     if (oldPos[i] != -1 && newPos != oldPos[i]) {                         //The VM has move                         ins[newPos].set(i);                         move.set(i);                     } else if (newPos == oldPos[i]) {                         stays.set(i);                     }                 }             }         }     }
@Override     public R visitValue(ValueTree node, P p) {         return defaultAction(node, p);     }
public void addParameter(String name, String[] values) {         if (WCCustomProperties.CHECK_REQUEST_OBJECT_IN_USE){             checkRequestObjectInUse();         }         Hashtable aParam = new Hashtable(3);         aParam.put(name, values);         mergeQueryParams(aParam);     }
@Override    public IRoSessionData getAppSessionData(Class<? extends AppSession> clazz, String sessionId) {      if (clazz.equals(ClientRoSession.class)) {        ClientRoSessionDataLocalImpl data = new ClientRoSessionDataLocalImpl();        data.setSessionId(sessionId);        return data;      }      else if (clazz.equals(ServerRoSession.class)) {        ServerRoSessionDataLocalImpl data = new ServerRoSessionDataLocalImpl();        data.setSessionId(sessionId);        return data;      }      throw new IllegalArgumentException(clazz.toString());    }
public byte[] bind(int commandId, int sequenceNumber, String systemId,             String password, String systemType, byte interfaceVersion,             byte addrTon, byte addrNpi, String addressRange)             throws PDUStringException {         StringValidator.validateString(systemId, StringParameter.SYSTEM_ID);         StringValidator.validateString(password, StringParameter.PASSWORD);         StringValidator.validateString(systemType, StringParameter.SYSTEM_TYPE);         StringValidator.validateString(addressRange,                 StringParameter.ADDRESS_RANGE);          PDUByteBuffer buf = new PDUByteBuffer(commandId, 0, sequenceNumber);          buf.append(systemId);         buf.append(password);         buf.append(systemType);         buf.append(interfaceVersion);         buf.append(addrTon);         buf.append(addrNpi);         buf.append(addressRange);         return buf.toBytes();     }
private void copyDetails(Authentication source, Authentication dest) {   if ((dest instanceof AbstractAuthenticationToken) && (dest.getDetails() == null)) {    AbstractAuthenticationToken token = (AbstractAuthenticationToken) dest;     token.setDetails(source.getDetails());   }  }
@SuppressWarnings(""unchecked"")     public Object[] getInUse() {         return inUseTable != null ? (((Hashtable<PooledWsByteBufferImpl, PooledWsByteBufferImpl>) inUseTable.clone()).keySet().toArray()) : new Object[0];     }
public static String getPathName(String path) {    String pathName = null;   if (StringUtils.isEmpty(path)) {    pathName = """";   } else {    pathName = path;    if (pathName.length() > 1 && pathName.endsWith(JawrConstant.URL_SEPARATOR)) {     pathName = pathName.substring(0, pathName.length() - 1);    }    int index = pathName.lastIndexOf(JawrConstant.URL_SEPARATOR);    if (index > 0) {     pathName = pathName.substring(index + 1);    } else {     pathName = JawrConstant.URL_SEPARATOR;    }   }    return pathName;  }
protected void setError(int newPosition, String error,       boolean currentExisting) {     if (!currentExisting) {       newBasicValueSumList[newPosition] = operations.getZero1();       newBasicValueNList[newPosition] = 0;     }     newErrorNumber[newPosition]++;     if (newErrorList[newPosition].containsKey(error)) {       newErrorList[newPosition].put(error,           newErrorList[newPosition].get(error) + 1);     } else {       newErrorList[newPosition].put(error, 1);     }   }
public EClass getIfcCurtainWall() {    if (ifcCurtainWallEClass == null) {     ifcCurtainWallEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc2x3tc1Package.eNS_URI)       .getEClassifiers().get(133);    }    return ifcCurtainWallEClass;   }
void saveNamespace(boolean force, boolean uncompressed)   throws AccessControlException, IOException {     try {       if (namenodeProtocolProxy == null) {         versionBasedSaveNamespace(force, uncompressed);       } else {         methodBasedSaveNamespace(force, uncompressed);       }     } catch(RemoteException re) {       throw re.unwrapRemoteException(AccessControlException.class);     }   }
public void setLat(final int LAT_DEG, final double LAT_MIN) {         this.lat = convert(LAT_DEG, LAT_MIN);         this.LOCATION.setLocation(this.lat, this.lon);         adjustDirection();     }
public static ITemplateBoundariesProcessor unwrap(final ITemplateBoundariesProcessor processor) {         if (processor == null) {             return null;         }         if (processor instanceof AbstractProcessorWrapper) {             return (ITemplateBoundariesProcessor)((AbstractProcessorWrapper) processor).unwrap();         }         return processor;     }
public static void move(String srcPath, String dstPath) throws IOException {     Files.move(Paths.get(srcPath), Paths.get(dstPath), StandardCopyOption.REPLACE_EXISTING);   }
public static synchronized <T> T activateDI(T instance) {     if (bootstrapedNeeded) bootstrap();      injectAttributes(instance);     initialize(instance);     return instance;   }
@SuppressWarnings(""unchecked"")     private UNode optionValueToUNode(String optName, Object optValue) {         if (!(optValue instanceof Map)) {             if (optValue == null) {                 optValue = """";             }             return UNode.createValueNode(optName, optValue.toString(), ""option"");         }         UNode optNode = UNode.createMapNode(optName, ""option"");         Map<String, Object> suboptMap = (Map<String,Object>)optValue;         for (String suboptName : suboptMap.keySet()) {             optNode.addChildNode(optionValueToUNode(suboptName, suboptMap.get(suboptName)));         }         return optNode;     }
private List<IAtomContainer> toList(IAtomContainerSet frags) {         return new ArrayList<>(FluentIterable.from(frags.atomContainers()).toList());     }
public void start() {     proxy.setTrustAllServers(true);     if (outsideProxy != null) {       proxy.setChainedProxy(getProxyAddress(outsideProxy));     }      addRequestFilter(""authentication"", new AuthenticationFilter());     addRequestFilter(""requestSizeWatchdog"", new RequestSizeWatchdog());     addResponseFilter(""responseSizeWatchdog"", new ResponseSizeWatchdog());     addResponseFilter(""download"", new FileDownloadFilter(config));      proxy.start(config.proxyPort());     port = proxy.getPort();   }
public int getItemPosition(int id) {         for(int index = getCount()-1; index >= 0; index--) {             TwinTextItem item = getItem(index);             if(item.getId() == id)                 return index;         }         return -1;     }
@Nonnull   public static BootstrapButtonGroup createButtonAsDropDownMenuWithSeparateCaret (@Nonnull final BootstrapButton aButton,                                                                                   @Nonnull final Consumer <? super BootstrapDropdownMenu> aMenuItemProvider)   {     final BootstrapButtonGroup aBG = new BootstrapButtonGroup ();     aBG.addChild (aButton);      final BootstrapButton aCaret = new BootstrapButton (aButton.getButtonType (), aButton.getButtonSize ());     BootstrapDropdown.makeDropdownToggle (aCaret);     aBG.addChild (aCaret);      final BootstrapDropdownMenu aMenu = aBG.addDropDownMenu ();     aMenuItemProvider.accept (aMenu);     return aBG;   }
private Page<CollectorItem> removeJobUrlAndInstanceUrl(Page<CollectorItem> collectorItems) {         for (CollectorItem cItem : collectorItems) {             if(cItem.getOptions().containsKey(""jobUrl"")) cItem.getOptions().remove(""jobUrl"");             if(cItem.getOptions().containsKey(""instanceUrl"")) cItem.getOptions().remove(""instanceUrl"");         }         return collectorItems;     }
public void loadForward(String query, Long afterSortKey, int limit, ListEngineDisplayLoadCallback<T> callback) {         storageActor.send(new AsyncStorageActor.LoadForward<T>(query, afterSortKey, limit, callback));     }
@Override     public void validate(final FacesContext context) {         // iterate over submitted values and attempt to convert to the proper         // data type. For successful values, remove from submitted and add to         // local values map. for failures, add a conversion message and leave in         // the submitted state         final Iterator<Entry<SheetRowColIndex, String>> entries = submittedValues.entrySet().iterator();         final boolean hadBadUpdates = !getInvalidUpdates().isEmpty();         getInvalidUpdates().clear();         while (entries.hasNext()) {             final Entry<SheetRowColIndex, String> entry = entries.next();             final SheetColumn column = getColumns().get(entry.getKey().getColIndex());             final String newValue = entry.getValue();             final String rowKey = entry.getKey().getRowKey();             final int col = entry.getKey().getColIndex();             setRowVar(context, rowKey);              // attempt to convert new value from string to correct object type             // based on column converter. Use PF util as helper             final Converter converter = ComponentUtils.getConverter(context, column);              // assume string value if converter not found             Object newValueObj = newValue;             if (converter != null) {                 try {                     newValueObj = converter.getAsObject(context, this, newValue);                 }                 catch (final ConverterException e) {                     // add offending cell to list of bad updates                     // and to a StringBuilder for error messages (so we have one                     // message for the component)                     setValid(false);                     FacesMessage message = e.getFacesMessage();                     if (message == null) {                         message = new FacesMessage(FacesMessage.SEVERITY_ERROR, e.getMessage(), e.getMessage());                     }                     context.addMessage(this.getClientId(context), message);                      final String messageText = message.getDetail();                     getInvalidUpdates()                                 .add(new SheetInvalidUpdate(getRowKeyValue(context), col, column, newValue, messageText));                     continue;                 }             }             // value is fine, no further validations (again, not to be confused             // with validators. until we have a ""required"" or something like             // that, nothing else to do).             setLocalValue(rowKey, col, newValueObj);              // process validators on column             column.setValue(newValueObj);             try {                 column.validate(context);             }             finally {                 column.resetValue();             }              entries.remove();         }         setRowVar(context, null);          final boolean newBadUpdates = !getInvalidUpdates().isEmpty();         final String errorMessage = getErrorMessage();          if (hadBadUpdates || newBadUpdates) {             // update the bad data var if partial request             if (context.getPartialViewContext().isPartialRequest()) {                 renderBadUpdateScript(context);             }         }          if (newBadUpdates && errorMessage != null) {             final FacesMessage message = new FacesMessage(FacesMessage.SEVERITY_ERROR, errorMessage, errorMessage);             context.addMessage(null, message);         }     }
public static Buffer nextHeaderNameDontCheckHColon(final Buffer buffer) {         try {             final int startIndex = buffer.getReaderIndex();             int nameIndex = 0;             while (buffer.hasReadableBytes() && nameIndex == 0) {                 if (isNext(buffer, SP) || isNext(buffer, HTAB) || isNext(buffer, COLON)) {                     nameIndex = buffer.getReaderIndex();                 } else {                     buffer.readByte();                 }             }              // Bad header! No HCOLON found! (or beginning thereof anyway)             if (nameIndex == 0) {                 // probably ran out of bytes to read so lets just return null                 buffer.setReaderIndex(startIndex);                 return null;             }              return buffer.slice(startIndex, nameIndex);         } catch (final IOException e) {             throw new SipParseException(buffer.getReaderIndex(), UNABLE_TO_READ_FROM_STREAM, e);         }      }
@Provides  @Singleton  @Named(GuiceProperties.REST_SERVICES_PREFIX)  public String getRestServicesPrefix(ServletContext context)  {   String restPath = context.getInitParameter(RESTEASY_MAPPING_PREFIX);    if (restPath == null || restPath.isEmpty() || restPath.equals(""/""))   {    return """";   }   else   {    return restPath;   }  }
private final void fixReportTeamList(final Element root) {         for (final Element head : root.getElementsByTag(""h2"")) {             head.tagName(""h1"");         }          for (final Element head : root.getElementsByTag(""h3"")) {             head.tagName(""h2"");         }     }
public SDVariable assign(String name, SDVariable x, SDVariable y) {         SDVariable ret = f().assign(x, y);         return updateVariableNameAndReference(ret, name);     }
public DatanodeInfo[] bestNode(LocatedBlocks blks) throws IOException {     // insert all known replica locations into a tree map where the     // key is the DatanodeInfo     TreeMap<DatanodeInfo, NodeRecord> map =        new TreeMap<DatanodeInfo, NodeRecord>();     for (int i = 0; i < blks.getLocatedBlocks().size(); i++) {       DatanodeInfo [] nodes = blks.get(i).getLocations();       for (int j = 0; j < nodes.length; j++) {         NodeRecord obj = map.get(nodes[j]);         if (obj != null) {           obj.frequency++;         } else {           map.put(nodes[j], new NodeRecord(nodes[j], 1));         }       }     }     // sort all locations by their frequency of occurance     Collection<NodeRecord> values = map.values();     NodeRecord[] nodes = (NodeRecord[])                           values.toArray(new NodeRecord[values.size()]);     Arrays.sort(nodes, new NodeRecordComparator());     try {       List<NodeRecord> candidates = bestNode(nodes, false);       return candidates.toArray(new DatanodeInfo[candidates.size()]);     } catch (IOException e) {       return new DatanodeInfo[] {randomNode()};     }   }
private void visit(XmlSchema xmlSchema, final XmlSchemaElement xsdElement,             final int level, final ArrayNode avroFields)             throws Xsd2AvroTranslatorException {          /*          * If this element is referencing another, it might not be useful to          * process it.          */         if (xsdElement.getRef().getTarget() != null) {             return;         }         log.debug(""process started for element = "" + xsdElement.getName());          if (xsdElement.getSchemaType() instanceof XmlSchemaComplexType) {             XmlSchemaComplexType xsdType = (XmlSchemaComplexType) xsdElement                     .getSchemaType();              int nextLevel = level + 1;             final ArrayNode avroChildrenFields = MAPPER.createArrayNode();             visit(xmlSchema, xsdType, nextLevel, avroChildrenFields);             ContainerNode avroRecordType = buildAvroCompositeType(                     getAvroTypeName(xsdType), avroChildrenFields,                     xsdElement.getMaxOccurs() > 1,                     xsdElement.getMinOccurs() == 0                             && xsdElement.getMaxOccurs() == 1);             ObjectNode avroRecordElement = MAPPER.createObjectNode();             avroRecordElement.put(""type"", avroRecordType);             avroRecordElement.put(""name"", getAvroFieldName(xsdElement));             avroFields.add(avroRecordElement);          } else if (xsdElement.getSchemaType() instanceof XmlSchemaSimpleType) {             visit((XmlSchemaSimpleType) xsdElement.getSchemaType(), level,                     getAvroFieldName(xsdElement), xsdElement.getMinOccurs(),                     xsdElement.getMaxOccurs(), avroFields);         }          log.debug(""process ended for element = "" + xsdElement.getName());     }
public static Version from(int major, int minor, int patch, String preRelease) {         return new Version(buildSemVer(major, minor, patch, preRelease, null));     }
protected String columnToPropertyName(ResultSetMetaData rsmd, int col) throws SQLException{    String columnName = rsmd.getColumnLabel(col);    if (null == columnName || 0 == columnName.length()) {     columnName = rsmd.getColumnName(col);    }    return columnNameToPropertyName(columnName);   }
public CorsConfig build() {         if (preflightHeaders.isEmpty() && !noPreflightHeaders) {             preflightHeaders.put(HttpHeaderNames.DATE, DateValueGenerator.INSTANCE);             preflightHeaders.put(HttpHeaderNames.CONTENT_LENGTH, new ConstantValueGenerator(""0""));         }         return new CorsConfig(this);     }
public ProductPartitionNode removeCustomParameter(String key) {     if (!nodeState.supportsCustomParameters()) {       throw new IllegalStateException(           String.format(""Cannot remove custom parameters on a %s node"", nodeState.getNodeType()));     }     Preconditions.checkNotNull(key, ""Null key"");     if (!nodeState.getCustomParams().containsKey(key)) {       throw new IllegalArgumentException(""No custom parameter exists for key: "" + key);     }     this.nodeState.getCustomParams().remove(key);     return this;   }
@Override  public void execute() throws BuildException {   if (null != this.echo) {    out.emitText(echo);   }   validateAttributes();    StatisticProvidingMixinGenerator generator = makeInterfaceItGenerator();    try {    if (debug) {     out.emitText(this.toString());    }     if (null == this.targetInterfaceParentName || targetInterfaceParentName.trim().length() < 1) {     File wroteFile = generator.generateMixinJavaFile(getOutputDirectory(), getTargetInterfaceName(),       getDelegateClassObject(), getTargetPackageName(), makeArgumentNameSource());      GenerationStatistics stats = generator.getStatistics();     emitGenerationResult(wroteFile, stats);    } else {     final Class<?> delegateClassObject = this.getDelegateClassObject();     final Class<?> superclass = delegateClassObject.getSuperclass();     if(null == superclass || java.lang.Object.class.equals(superclass)) {      out.emitText(""Execution halted without generation. The attribute 'targetInterfaceParentName' should be empty if the delegate class has no superclass other than Object."");      return;     }     MultiFileOutputOptions options = new OptionsForSplittingChildAndParent(this.targetPackageName,       getOutputDirectory(), this.targetInterfaceName, this.targetInterfaceParentName,       delegateClassObject);     List<File> results = generator.generateMixinJavaFiles(options, makeArgumentNameSource(),       delegateClassObject, superclass);     for (File result : results) {      emitGenerationResult(result,        generator.getStatisticsFor(result.getName()).orElse(generator.getStatistics()));     }    }   } catch (IOException e) {    handleIOException(e);   } catch (ClassNotFoundException e) {    handleClassNotFound(e);   } catch (Throwable t) {    handleUnexpectedError(t);   }  }
public static String getBufferTraceInfo(WsByteBuffer buffers[]) {         if (null == buffers) {             return ""Null buffer array"";         }         StringBuilder sb = new StringBuilder(32 + (64 * buffers.length));         for (int i = 0; i < buffers.length; i++) {             sb.append(""\r\n\t  Buffer ["");             sb.append(i);             sb.append(""]: "");             getBufferTraceInfo(sb, buffers[i]);         }         return sb.toString();     }
public void setName(String name) {         Validate.notNull(name);         Validate.notEmpty(name);         setProperty(ACModelProperty.NAME, name);     }
public Query select(final Expression... selectColumns) {         if (selectColumns == null) {             return this;         }          return select(Arrays.asList(selectColumns));     }
public ServiceFuture<VirtualMachineInner> getByResourceGroupAsync(String resourceGroupName, String vmName, final ServiceCallback<VirtualMachineInner> serviceCallback) {         return ServiceFuture.fromResponse(getByResourceGroupWithServiceResponseAsync(resourceGroupName, vmName), serviceCallback);     }
public static void forceAccess(final AccessibleObject accObject) {   try {    if (System.getSecurityManager() == null)     accObject.setAccessible(true);    else {     AccessController.doPrivileged((PrivilegedAction) () -> {      accObject.setAccessible(true);      return null;     });    }   } catch (SecurityException sex) {    // ignore   }  }
public void setGridScreen(JComponent gridScreen, boolean bSetupJTable)     {         if (gridScreen instanceof JTable)         {             JTable control = (JTable)gridScreen;             ThinTableModelListener thinTableModelListener = new ThinTableModelListener(control, this);             if (m_modelListeners == null)                 m_modelListeners = new HashSet<ThinTableModelListener>();             m_modelListeners.add(thinTableModelListener);             control.getSelectionModel().addListSelectionListener(thinTableModelListener);   // Listen for selection change to update             if (bSetupJTable)             {                 FontMetrics fm = control.getFontMetrics(control.getFont());                 int rowHeight = (int)(Math.max(control.getRowHeight(), fm.getHeight()) * 1.5);                 int iCharWidth = (int)(fm.charWidth('X') * 1.5);                 control.setAutoResizeMode(JTable.AUTO_RESIZE_OFF); //              control.setAutoCreateColumnsFromModel(false);                 control.setColumnSelectionAllowed(false); // Don't allow column selections                 control.setModel(this);                 JTableHeader tableHeader = control.getTableHeader();                 TableColumnModel columnModel = tableHeader.getColumnModel();                 for (int iIndex = 0; iIndex < this.getColumnCount(); iIndex++)                 {                     Convert field = this.getFieldInfo(iIndex);                     int iWidth = JScreenConstants.ICON_SIZE.width;                     if (field != null)                         iWidth = field.getMaxLength() * iCharWidth;                     TableColumn tableColumn = columnModel.getColumn(iIndex);                     TableCellRenderer cellRenderer = this.createColumnCellRenderer(iIndex);                     if (cellRenderer == null)                         if (field instanceof FieldInfo)                     {                         if (Number.class.isAssignableFrom(((FieldInfo)field).getDataClass()))                         {                             tableColumn.setCellRenderer(new JCellTextField(field.getMaxLength(), true));    // Align right, use calc length.                             tableColumn.setCellEditor(new JCellTextField(field.getMaxLength(), true));  // Align right, use calc length.                         }                         if (Boolean.class.isAssignableFrom(((FieldInfo)field).getDataClass()))                         {                             cellRenderer = new JCellCheckBox(null);                             tableColumn.setCellEditor(new JCellCheckBox(null));                         }                     }                     if (cellRenderer != null)                     {                         tableColumn.setCellRenderer(cellRenderer);                         if (cellRenderer instanceof JComponent)                             iWidth = ((JComponent)cellRenderer).getPreferredSize().width;                         if (field != null)                             field.addComponent(cellRenderer);                     }                     TableCellEditor cellEditor = this.createColumnCellEditor(iIndex);                     if (cellEditor != null)                     {                         tableColumn.setCellEditor(cellEditor);                         if (field != null)                             field.addComponent(cellEditor);                     }                     tableColumn.setPreferredWidth(iWidth);  // Fixed column width                      String strFieldName = this.getColumnName(iIndex);                     tableColumn.setHeaderValue(strFieldName);                 }         //      this.addMouseListenerToHeaderInTable(control);      // Notify model of row order changed (clicks in the header bar)                 if (rowHeight > 10)                     control.setRowHeight(rowHeight);             }             if (control.getModel() == null)                 control.setModel(this);                          control.getModel().addTableModelListener(new FixScrollersOnNewTable(control));         }     }
public Color getFromString(final String hexValue) {         final String hv = hexValue.toLowerCase(Locale.US);         Color color = this.colorByHexValue.get(hv);         if (color == null) {             color = new Color() {                 @Override                 public String hexValue() {                     return hv;                 }             };             this.colorByHexValue.put(hv, color);         }         return color;     }
void setObject(final int index, final Object object, final int targetSqlType, final int scale) {   initPrepared();      try {       preparedStatement.setObject(index, object, targetSqlType, scale);      } catch (SQLException sex) {    throwSetParamError(index, sex);      }     }
public void init(Record recLayout, PrintWriter out)     {         boolean bFirstTime = false;         boolean bNewRecord = false;         if (out == null)         { // First time             bFirstTime = true;             if (recLayout == null)             {                 recLayout = new Layout((Record.findRecordOwner(null)));                 bNewRecord = true;             }             recLayout.getField(Layout.ID).setValue(1);             try   {                 if (!recLayout.seek(""=""))                 { // Error - top level not found?                 }             } catch   (DBException ex)  {                 ex.printStackTrace();                 return;             }             String strFileName = recLayout.getField(Layout.NAME).toString() + "".idl"";             try   {                 FileOutputStream outStream = new FileOutputStream(strFileName);                 BufferedOutputStream buffOut = new BufferedOutputStream(outStream);                 out = new PrintWriter(buffOut);             } catch (IOException ex)    {                 ex.printStackTrace();                 return;             }         }                      this.printIt(recLayout, out, 0, "";"");                  if (bFirstTime)             out.close();         if (bNewRecord)             recLayout.free();     }
public EClass getGCCBEZRG() {   if (gccbezrgEClass == null) {    gccbezrgEClass = (EClass)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(493);   }   return gccbezrgEClass;  }
public void paint (Graphics g, int x, int y, int width, int height)     {         // bail out now if we were passed a bogus source image at construct time         if (_tiles == null) {             return;         }          int rwid = width-2*_w3, rhei = height-2*_h3;          g.drawImage(_tiles[0], x, y, _w3, _h3, null);         g.drawImage(_tiles[1], x + _w3, y, rwid, _h3, null);         g.drawImage(_tiles[2], x + _w3 + rwid, y, _w3, _h3, null);          y += _h3;         g.drawImage(_tiles[3], x, y, _w3, rhei, null);         g.drawImage(_tiles[4], x + _w3, y, rwid, rhei, null);         g.drawImage(_tiles[5], x + _w3 + rwid, y, _w3, rhei, null);          y += rhei;         g.drawImage(_tiles[6], x, y, _w3, _h3, null);         g.drawImage(_tiles[7], x + _w3, y, rwid, _h3, null);         g.drawImage(_tiles[8], x + _w3 + rwid, y, _w3, _h3, null);     }
public static List<Object> getDecoratorLineage(Object obj) {     List<Object> lineage = Lists.newArrayList(obj);     Object currentObject = obj;     while(currentObject instanceof Decorator) {       currentObject = ((Decorator)currentObject).getDecoratedObject();       lineage.add(currentObject);     }      return Lists.reverse(lineage);   }
@Override      protected void onStop()      {          m_context.removeBundleListener( m_bundleListener );          final Bundle[] toBeRemoved =              m_mappings.keySet().toArray( new Bundle[m_mappings.keySet().size()] );          for( Bundle bundle : toBeRemoved )          {              unregister( bundle );          }            m_bundleListener = null;          m_mappings = null;      }
Symbol addConstantFieldref(final String owner, final String name, final String descriptor) {     return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor);   }
public static boolean intersectLineSegmentTriangle(double p0X, double p0Y, double p0Z, double p1X, double p1Y, double p1Z,             double v0X, double v0Y, double v0Z, double v1X, double v1Y, double v1Z, double v2X, double v2Y, double v2Z,             double epsilon, Vector3d intersectionPoint) {         double dirX = p1X - p0X;         double dirY = p1Y - p0Y;         double dirZ = p1Z - p0Z;         double t = intersectRayTriangle(p0X, p0Y, p0Z, dirX, dirY, dirZ, v0X, v0Y, v0Z, v1X, v1Y, v1Z, v2X, v2Y, v2Z, epsilon);         if (t >= 0.0 && t <= 1.0) {             intersectionPoint.x = p0X + dirX * t;             intersectionPoint.y = p0Y + dirY * t;             intersectionPoint.z = p0Z + dirZ * t;             return true;         }         return false;     }
protected static Log getLogger() {         Log l = logger;         if (l == null) {             l = LogFactory.getLog(LOGGER_NAME);             logger = l;         }         return l;     }
@Override     protected AuthenticationHandlerExecutionResult doAuthentication(final Credential credential) throws GeneralSecurityException {          val x509Credential = (X509CertificateCredential) credential;         val certificates = x509Credential.getCertificates();          var clientCert = (X509Certificate) null;         var hasTrustedIssuer = false;         for (var i = certificates.length - 1; i >= 0; i--) {             val certificate = certificates[i];             LOGGER.debug(""Evaluating [{}]"", CertUtils.toString(certificate));              validate(certificate);              if (!hasTrustedIssuer) {                 hasTrustedIssuer = isCertificateFromTrustedIssuer(certificate);             }              val pathLength = certificate.getBasicConstraints();             if (pathLength < 0) {                 LOGGER.debug(""Found valid client certificate"");                 clientCert = certificate;             } else {                 LOGGER.debug(""Found valid CA certificate"");             }         }         if (hasTrustedIssuer && clientCert != null) {             x509Credential.setCertificate(clientCert);             return new DefaultAuthenticationHandlerExecutionResult(this, x509Credential,                 this.principalFactory.createPrincipal(x509Credential.getId()));         }         LOGGER.warn(""Either client certificate could not be determined, or a trusted issuer could not be located"");         throw new FailedLoginException();     }
@Override  public void registerOsgiProviders (Collection<Object> providers) throws FhirConfigurationException {   if (null == providers) {    throw new NullPointerException(""FHIR Provider list cannot be null"");   }   try {    super.registerProviders(providers);    for (Object provider : providers) {     log.trace(""registered provider. class [""+provider.getClass().getName()+""]"");     this.serverProviders.add(provider);    }   } catch (Exception e) {    log.error(""Error registering FHIR Providers"", e);    throw new FhirConfigurationException(""Error registering FHIR Providers"", e);   }  }
public static Field[] getFieldArrayIncludeSupClassExcludeUID(Class<?> clazz) {         Field[] currField = clazz.getDeclaredFields();         clazz = clazz.getSuperclass();         Field[] supField = clazz.getDeclaredFields();         Field[] temp = new Field[currField.length + supField.length];         int length = 0;         for (Field curr : currField) {             if (""serialVersionUID"".equals(curr.getName())) {                 continue;             }             temp[length] = curr;             length++;         }         for (Field sup : supField) {             if (""serialVersionUID"".equals(sup.getName())) {                 continue;             }             temp[length] = sup;             length++;         }         Field[] all = new Field[length];         for (int i = 0; i < all.length; i++) {             all[i] = temp[i];         }         return all;     }
@NonNull   public static Point nearestPoint(@NonNull Point targetPoint, @NonNull List<Point> points) {     if (points.isEmpty()) {       return targetPoint;     }     Point nearestPoint = points.get(0);     double minDist = Double.POSITIVE_INFINITY;     for (Point point : points) {       double distanceToPoint = TurfMeasurement.distance(targetPoint, point);       if (distanceToPoint < minDist) {         nearestPoint = point;         minDist = distanceToPoint;       }     }     return nearestPoint;   }
@Override     public int enqueue(JobRequest jd)     {         try         {             return target.path(""ji"").request().post(Entity.entity(jd, MediaType.APPLICATION_XML), JobInstance.class).getId();         }         catch (BadRequestException e)         {             throw new JqmInvalidRequestException(e.getResponse().readEntity(String.class), e);         }         catch (Exception e)         {             throw new JqmClientException(e);         }     }
private TypeSpec getBinderWrapper() {         TypeSpec.Builder staticBinderWrapperClassBuilder = TypeSpec                 .classBuilder(""BinderWrapper"")                 .addModifiers(Modifier.PRIVATE)                 .addModifiers(Modifier.STATIC)                 .addField(ClassName.get(""android.os"", ""IBinder""), ""binder"", Modifier.PRIVATE)                 .addMethod(MethodSpec.constructorBuilder()                         .addParameter(ClassName.get(""android.os"", ""IBinder""), ""binder"")                         .addStatement(""this.binder = binder"")                         .build())                 .addMethod(MethodSpec.methodBuilder(""asBinder"")                         .addModifiers(Modifier.PUBLIC)                         .addAnnotation(Override.class)                         .returns(ClassName.get(""android.os"", ""IBinder""))                         .addStatement(""return binder"")                         .build())                 .addSuperinterface(ClassName.get(""android.os"", ""IInterface""));          return staticBinderWrapperClassBuilder.build();     }
@Override     public void initializeParsers(ExtensionParsingContext context) {         for (InfinispanSchema namespace: InfinispanSchema.SCHEMAS) {             context.setSubsystemXmlMapping(SUBSYSTEM_NAME, namespace.getNamespaceUri(), () -> new InfinispanSubsystemXMLReader(namespace));         }     }
public static String createCookieToken(String clientUserName) {     StringBuffer sb = new StringBuffer();     sb.append(COOKIE_CLIENT_USER_NAME).append(COOKIE_KEY_VALUE_SEPARATOR).append(clientUserName)       .append(COOKIE_ATTR_SEPARATOR);     sb.append(COOKIE_CLIENT_RAND_NUMBER).append(COOKIE_KEY_VALUE_SEPARATOR)       .append((new Random(System.currentTimeMillis())).nextLong());     return sb.toString();   }
@Override     protected void paintComponent(Graphics g) {         if (!isInitialized()) {             return;         }          final Graphics2D G2 = (Graphics2D) g.create();          G2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);         G2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);         G2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);         G2.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);          G2.translate(getFramelessOffset().getX(), getFramelessOffset().getY());         final AffineTransform OLD_TRANSFORM = G2.getTransform();          // Draw combined background image         G2.drawImage(bImage, 0, 0, null);          // Draw an Arc2d object that will visualize the range of measured values         if (isRangeOfMeasuredValuesVisible()) {             G2.setPaint(getModel().getRangeOfMeasuredValuesPaint());             if ((getGaugeType() == GaugeType.TYPE3 || getGaugeType() == GaugeType.TYPE4) && isLcdVisible()) {                 final Area area = getModel().getRadialAreaOfMeasuredValues();                 area.subtract(lcdArea);                 G2.fill(area);             } else {                 G2.fill(getModel().getRadialShapeOfMeasuredValues());             }         }          // Highlight active area         if (isHighlightArea()) {             for(Section area : getAreas()) {                 if (area.contains(getValue())) {                     G2.setColor(area.getHighlightColor());                     if ((getGaugeType() == GaugeType.TYPE3 || getGaugeType() == GaugeType.TYPE4) && isLcdVisible()) {                         final Area currentArea = new Area(area.getFilledArea());                         currentArea.subtract(lcdArea);                         G2.fill(currentArea);                     } else {                         G2.fill(area.getFilledArea());                     }                     break;                 }             }         }          // Highlight active section         if (isHighlightSection()) {             for(Section section : getSections()) {                 if (section.contains(getValue())) {                     G2.setColor(section.getHighlightColor());                     G2.fill(section.getSectionArea());                     break;                 }             }         }          // Draw threshold indicator         if (isThresholdVisible()) {             if (!isLogScale()) {                 G2.rotate(getRotationOffset() + (getThreshold() - getMinValue()) * getAngleStep(), CENTER.getX(), CENTER.getY());             } else {                 G2.rotate(getRotationOffset() + UTIL.logOfBase(BASE, getThreshold() - getMinValue()) * getLogAngleStep(), CENTER.getX(), CENTER.getY());             }             G2.drawImage(thresholdImage, (int) (getGaugeBounds().width * 0.4813084112), (int) (getGaugeBounds().height * 0.0841121495), null);             G2.setTransform(OLD_TRANSFORM);         }          // Draw min measured value indicator         if (isMinMeasuredValueVisible()) {             if (!isLogScale()) {                 G2.rotate(getRotationOffset() + (getMinMeasuredValue() - getMinValue()) * getAngleStep(), CENTER.getX(), CENTER.getY());             } else {                 G2.rotate(getRotationOffset() + UTIL.logOfBase(BASE, getMinMeasuredValue() - getMinValue()) * getLogAngleStep(), CENTER.getX(), CENTER.getY());             }             G2.drawImage(minMeasuredImage, (int) (getGaugeBounds().width * 0.4865), (int) (getGaugeBounds().height * 0.105), null);             G2.setTransform(OLD_TRANSFORM);         }          // Draw max measured value indicator         if (isMaxMeasuredValueVisible()) {             if (!isLogScale()) {                 G2.rotate(getRotationOffset() + (getMaxMeasuredValue() - getMinValue()) * getAngleStep(), CENTER.getX(), CENTER.getY());             } else {                 G2.rotate(getRotationOffset() + UTIL.logOfBase(BASE, getMaxMeasuredValue() - getMinValue()) * getLogAngleStep(), CENTER.getX(), CENTER.getY());             }             G2.drawImage(maxMeasuredImage, (int) (getGaugeBounds().width * 0.4865), (int) (getGaugeBounds().height * 0.105), null);             G2.setTransform(OLD_TRANSFORM);         }          // Draw LED if enabled         if (isLedVisible()) {             G2.drawImage(getCurrentLedImage(), (int) (getGaugeBounds().width * getLedPosition().getX()), (int) (getGaugeBounds().height * getLedPosition().getY()), null);         }          // Draw user LED if enabled         if (isUserLedVisible()) {             G2.drawImage(getCurrentUserLedImage(), (int) (getGaugeBounds().width * getUserLedPosition().getX()), (int) (getGaugeBounds().height * getUserLedPosition().getY()), null);         }          // Draw LCD display         if (isLcdVisible()) {             if (getLcdColor() == LcdColor.CUSTOM) {                 G2.setColor(getCustomLcdForeground());             } else {                 G2.setColor(getLcdColor().TEXT_COLOR);             }             // Draw LCD text only if isVisible() in AbstractGauge (this is needed for lcd blinking)             if (isLcdTextVisible()) {             G2.setFont(getLcdUnitFont());             if (isLcdUnitStringVisible()) {                 unitLayout = new TextLayout(getLcdUnitString(), G2.getFont(), RENDER_CONTEXT);                 UNIT_BOUNDARY.setFrame(unitLayout.getBounds());                 G2.drawString(getLcdUnitString(), (int) (LCD.getX() + (LCD.getWidth() - UNIT_BOUNDARY.getWidth()) - LCD.getWidth() * 0.03), (int) (LCD.getY() + LCD.getHeight() * 0.76));                 unitStringWidth = UNIT_BOUNDARY.getWidth();             } else {                 unitStringWidth = 0;             }             G2.setFont(getLcdValueFont());             switch (getModel().getNumberSystem()) {                 case HEX:                     valueLayout = new TextLayout(Integer.toHexString((int) getLcdValue()).toUpperCase(), G2.getFont(), RENDER_CONTEXT);                     VALUE_BOUNDARY.setFrame(valueLayout.getBounds());                     G2.drawString(Integer.toHexString((int) getLcdValue()).toUpperCase(), (float) (LCD.getX() + (LCD.getWidth() - unitStringWidth - VALUE_BOUNDARY.getWidth()) - LCD.getHeight() * 0.333333333), (float) (LCD.getY() + LCD.getHeight() * 0.76));                     break;                  case OCT:                     valueLayout = new TextLayout(Integer.toOctalString((int) getLcdValue()), G2.getFont(), RENDER_CONTEXT);                     VALUE_BOUNDARY.setFrame(valueLayout.getBounds());                     G2.drawString(Integer.toOctalString((int) getLcdValue()), (float) (LCD.getX() + (LCD.getWidth() - unitStringWidth - VALUE_BOUNDARY.getWidth()) - LCD.getHeight() * 0.333333333), (float) (LCD.getY() + LCD.getHeight() * 0.76));                     break;                  case DEC:                  default:                     int digitalFontNo_1Offset = 0;                     if (isDigitalFont() && Double.toString(getLcdValue()).startsWith(""1"")) {                         digitalFontNo_1Offset = (int) (LCD.getHeight() * 0.2166666667);                     }                     valueLayout = new TextLayout(formatLcdValue(getLcdValue()), G2.getFont(), RENDER_CONTEXT);                     VALUE_BOUNDARY.setFrame(valueLayout.getBounds());                     G2.drawString(formatLcdValue(getLcdValue()), (float) (LCD.getX() + (LCD.getWidth() - unitStringWidth - VALUE_BOUNDARY.getWidth()) - LCD.getHeight() * 0.333333333) - digitalFontNo_1Offset, (float) (LCD.getY() + LCD.getHeight() * 0.76));                     break;             }             }             // Draw lcd info string             if (!getLcdInfoString().isEmpty()) {                 G2.setFont(getLcdInfoFont());                 infoLayout = new TextLayout(getLcdInfoString(), G2.getFont(), RENDER_CONTEXT);                 INFO_BOUNDARY.setFrame(infoLayout.getBounds());                 G2.drawString(getLcdInfoString(), (float) LCD.getBounds().x + 5f, LCD.getBounds().y + (float) INFO_BOUNDARY.getHeight() + 5f);             }             // Draw lcd threshold indicator             if (getLcdNumberSystem() == NumberSystem.DEC && isLcdThresholdVisible() && getLcdValue() >= getLcdThreshold()) {                 G2.drawImage(lcdThresholdImage, (int) (LCD.getX() + LCD.getHeight() * 0.0568181818), (int) (LCD.getY() + LCD.getHeight() - lcdThresholdImage.getHeight() - LCD.getHeight() * 0.0568181818), null);             }         }          // Draw the pointer         if (!isLogScale()) {             angle = getRotationOffset() + (getValue() - getMinValue()) * getAngleStep();             G2.rotate(angle + (Math.cos(Math.toRadians(angle - getRotationOffset() - 91.5))), CENTER.getX(), CENTER.getY());         } else {             angle = getRotationOffset() + UTIL.logOfBase(BASE, getValue() - getMinValue()) * getLogAngleStep();             G2.rotate(angle, CENTER.getX(), CENTER.getY() + 2);         }         G2.drawImage(pointerShadowImage, 0, 0, null);         G2.setTransform(OLD_TRANSFORM);         G2.rotate(angle, CENTER.getX(), CENTER.getY());         G2.drawImage(pointerImage, 0, 0, null);         G2.setTransform(OLD_TRANSFORM);          // Draw combined foreground image         G2.drawImage(fImage, 0, 0, null);          // Draw glow indicator         if (isGlowVisible()) {             if (isGlowing()) {                 G2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, getGlowAlpha()));                 G2.drawImage(glowImageOn, 0, 0, null);                 G2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));             } else {                 G2.drawImage(glowImageOff, 0, 0, null);             }         }          // Draw disabled image if component isEnabled() == false         if (!isEnabled()) {             G2.drawImage(disabledImage, 0, 0, null);         }          G2.dispose();     }
public StatementBuilder withQualifier(Snak qualifier) {   getQualifierList(qualifier.getPropertyId()).add(qualifier);   return getThis();  }
protected ApacheLog createEntity(Map<String, String> logInfoMap) throws ParseException     {         String serverName = logInfoMap.get(""hostname"");         String sizeStr = logInfoMap.get(""size"");         String timeStr = logInfoMap.get(""reqtime_microsec"");         String recordedTimeStr = logInfoMap.get(""time"");          long size = 0;         long time = 0;         Date recordedTime = null;          if (sizeStr != null && StringUtils.equals(sizeStr, ""-"") == false)         {             size = Long.valueOf(sizeStr);         }          if (timeStr != null && StringUtils.equals(timeStr, ""-"") == false)         {             time = Long.valueOf(timeStr);         }          if (recordedTimeStr != null)         {             recordedTime = this.javaDateFormat.parse(recordedTimeStr);         }         else         {             recordedTime = new Date();         }          ApacheLog result = new ApacheLog(serverName, 1, size, time, recordedTime, 0d);         return result;     }
public static Logger getLogger(final String aName, final String aBundleName) {         final ILoggerFactory factory = org.slf4j.LoggerFactory.getILoggerFactory();         final Logger logger;          if (aBundleName != null) {             logger = new Logger(factory.getLogger(aName), aBundleName);         } else {             logger = new Logger(factory.getLogger(aName));         }          return logger;     }
public boolean replace( Long key, TypeV oldValue, TypeV newValue ) {     return replace(key.longValue(), oldValue, newValue);   }
public HBaseDataHandler getHandle()     {         HBaseDataHandler handler = new HBaseDataHandler(this.kunderaMetadata, this.connection);         handler.filter = this.filter;         handler.filters = this.filters;         return handler;     }
public static boolean isMethodDirectlyExists(Object object, String methodName, Class<?>... params) {    try {     Method method = object.getClass().getDeclaredMethod(methodName, params);     return true;    } catch (NoSuchMethodException e) {     return false;    } catch (SecurityException e) {     throw new RuntimeException(e);    }   }
@BetaApi   public final Operation setLabelsInstance(       ProjectZoneInstanceName instance,       InstancesSetLabelsRequest instancesSetLabelsRequestResource) {      SetLabelsInstanceHttpRequest request =         SetLabelsInstanceHttpRequest.newBuilder()             .setInstance(instance == null ? null : instance.toString())             .setInstancesSetLabelsRequestResource(instancesSetLabelsRequestResource)             .build();     return setLabelsInstance(request);   }
public void setItems(java.util.Collection<Route> items) {         if (items == null) {             this.items = null;             return;         }          this.items = new java.util.ArrayList<Route>(items);     }
public static Map<String, Object> verify(String token, final RSAPublicKey pk) throws InvalidTokenException {         // RS256签名验证器         Verifier verifier = new Verifier() {             @Override             public boolean verifySignature(String content, String payload, String signature) {                 return JWT.verifySignature(content,signature,pk);             }         };         return verify(token, verifier);     }
public static AsyncSemaphoreBuilder newBuilder(Supplier<Integer> concurrentRequestLimit, ScheduledExecutorService flushingExecutor) {     return new AsyncSemaphoreBuilder(new PermitSource(concurrentRequestLimit), flushingExecutor);   }
public static String encodeQueryParamSaveEncodings(String segment) {          String result = encodeFromArray(segment, queryNameValueEncoding, false);          result = encodeNonCodes(result);          return result;      }
public CellField<T> add(final FieldValidator<T> validator) {          ArgUtils.notNull(validator, ""validator"");          this.validators.add(validator);            return this;      }
@Override  protected String getRewrittenImagePath(String originalCssPath, String newCssPath, String url) throws IOException {    String imgUrl = null;    // Retrieve the current CSS file from which the CSS image is referenced   String currentCss = originalCssPath;   boolean generatedImg = false;   if (binaryRsHandler != null) {    GeneratorRegistry imgRsGeneratorRegistry = binaryRsHandler.getConfig().getGeneratorRegistry();    generatedImg = imgRsGeneratorRegistry.isGeneratedBinaryResource(url);   }    boolean cssGeneratorIsHandleCssImage = isCssGeneratorHandlingCssImage(currentCss);    String rootPath = currentCss;    // If the CSS image is taken from the classpath, add the classpath cache   // prefix   if (generatedImg || cssGeneratorIsHandleCssImage) {     String tempUrl = url;     // If it's a classpath CSS, the url of the CSS image is defined    // relatively to it.    if (cssGeneratorIsHandleCssImage && !generatedImg) {     tempUrl = PathNormalizer.concatWebPath(rootPath, url);    }     // generate image cache URL    imgUrl = rewriteURL(tempUrl, binaryServletPath, newCssPath, binaryRsHandler);   } else {     if (config.getGeneratorRegistry().isPathGenerated(rootPath)) {     rootPath = rootPath.substring(rootPath.indexOf(GeneratorRegistry.PREFIX_SEPARATOR) + 1);    }     // Generate the image URL from the current CSS path    imgUrl = PathNormalizer.concatWebPath(rootPath, url);    imgUrl = rewriteURL(imgUrl, binaryServletPath, newCssPath, binaryRsHandler);   }    // This following condition should never be true.   // If it does, it means that the image path is wrongly defined.   if (imgUrl == null) {    LOGGER.error(""The CSS image path for '"" + url + ""' defined in '"" + currentCss      + ""' is out of the application context. Please check your CSS file."");   }    return imgUrl;  }
public static String getHost(final URI uri) throws NormalizationException {         final String host = Strings.emptyToNull(uri.getHost());         if (host == null) {             throw new NormalizationException(uri.toString(), ""No host in URI"");         }         return host;     }
boolean tryAdd(TaskMessage taskMsg) {         if ((encodedLength + msgEncodeLength(taskMsg)) > buffer_size)             return false;         add(taskMsg);         return true;     }
@SuppressWarnings({""ConstantConditions"",""deprecation""})     @SuppressFBWarnings(""RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE"")     public void addAction(@Nonnull Action a) {         if(a==null) {             throw new IllegalArgumentException(""Action must be non-null"");         }         getActions().add(a);     }
@Deprecated  @Override  public void setTag(final String tag) {   ComponentModel model = getOrCreateComponentModel();   model.setTag(tag);  }
private void buildPolicyErrorMessage(String msgKey, String defaultMessage, Object... arg1) {         /* The message need to be logged only for level below 'Warning' */         if (TraceComponent.isAnyTracingEnabled() && tc.isWarningEnabled()) {             String messageFromBundle = Tr.formatMessage(tc, msgKey, arg1);             Tr.error(tc, messageFromBundle);         }     }
public static void multAddTransA(double realAlpha , double imagAlpha , ZMatrixRMaj a , ZMatrixRMaj b , ZMatrixRMaj c )     {         // TODO add a matrix vectory multiply here         if( a.numCols >= EjmlParameters.CMULT_COLUMN_SWITCH ||                 b.numCols >= EjmlParameters.CMULT_COLUMN_SWITCH ) {             MatrixMatrixMult_ZDRM.multAddTransA_reorder(realAlpha, imagAlpha, a, b, c);         } else {             MatrixMatrixMult_ZDRM.multAddTransA_small(realAlpha, imagAlpha, a, b, c);         }     }
@Nonnull     public List<String> getRemainingLines(boolean trimAndSkipEmpty) throws IOException {         List<String> out = new ArrayList<>();          StringBuilder builder = new StringBuilder();         while (bufferOffset <= bufferLimit || !bufferLineEnd) {             if (!readNextChar()) {                 break;             }             if (lastChar == '\n') {                 String line = builder.toString();                 if (!trimAndSkipEmpty || !line.trim().isEmpty()) {                     out.add(trimAndSkipEmpty ? line.trim() : line);                 }                 builder = new StringBuilder();             } else {                 builder.append((char) lastChar);             }         }         if (builder.length() > 0) {             String line = builder.toString();             if (!trimAndSkipEmpty || !line.trim().isEmpty()) {                 out.add(builder.toString());             }         }         return out;     }
public boolean verify() {     boolean success = false;     try {       TransactionAwareHTable table = new TransactionAwareHTable(conn.getTable(TABLE));       TransactionContext context = new TransactionContext(txClient, table);        LOG.info(""VERIFYING BALANCES"");       context.start();       long totalBalance = 0;       ResultScanner scanner = table.getScanner(new Scan());       try {         for (Result r : scanner) {           if (!r.isEmpty()) {             int rowId = Bytes.toInt(r.getRow());             long balance = Bytes.toLong(r.getValue(FAMILY, COL));             totalBalance += balance;             LOG.info(""Client #{}: balance = ${}"", rowId, balance);           }         }       } finally {         if (scanner != null) {           Closeables.closeQuietly(scanner);         }       }       if (totalBalance == 0) {         LOG.info(""PASSED!"");         success = true;       } else {         LOG.info(""FAILED! Total balance should be 0 but was {}"", totalBalance);       }       context.finish();     } catch (Exception e) {       LOG.error(""Failed verification check"", e);     }     return success;   }
public static SecurityException newSecurityException(String message, Object... args) {     return newSecurityException(null, message, args);   }
private void startDisseminators(String localName, Attributes a)             throws SAXException {         if (localName.equals(""structMap"")) {             // this is a component of a disseminator.  here we assume the rest             // of the disseminator's information will be seen later, so we             // construct a new Disseminator object to hold the structMap...             // and later, the other info             //             // Building up a global map of Disseminators, m_dissems,             // keyed by bindingmap ID.             //             if (grab(a, METS.uri, ""TYPE"").equals(""fedora:dsBindingMap"")) {                 String bmId = grab(a, METS.uri, ""ID"");                 if (bmId == null || bmId.isEmpty()) {                     throw new SAXException(""structMap with TYPE ""                             + ""fedora:dsBindingMap must specify a non-empty ""                             + ""ID attribute."");                 } else {                     Disseminator diss = new Disseminator();                     diss.dsBindMapID = bmId;                     m_dissems.put(bmId, diss);                     m_diss = diss;                     m_diss.dsBindMap = new DSBindingMap();                     m_diss.dsBindMap.dsBindMapID = bmId;                     m_indiv = false; // flag we're not looking at inner part yet                 }             } else {                 throw new SAXException(""StructMap must have TYPE fedora:dsBindingMap"");             }         } else if (localName.equals(""div"")) {             if (m_indiv) {                 // inner part of structmap                 DSBinding binding = new DSBinding();                 if (m_diss.dsBindMap.dsBindings == null) {                     // none yet.. create array of size one                     DSBinding[] bindings = new DSBinding[1];                     m_diss.dsBindMap.dsBindings = bindings;                     m_diss.dsBindMap.dsBindings[0] = binding;                 } else {                     // need to expand the array size by one,                     // and do an array copy.                     int curSize = m_diss.dsBindMap.dsBindings.length;                     DSBinding[] oldArray = m_diss.dsBindMap.dsBindings;                     DSBinding[] newArray = new DSBinding[curSize + 1];                     for (int i = 0; i < curSize; i++) {                         newArray[i] = oldArray[i];                     }                     newArray[curSize] = binding;                     m_diss.dsBindMap.dsBindings = newArray;                 }                 // now populate 'binding' values...we'll have                 // everything at this point except datastreamID...                 // that comes as a child: <fptr FILEID=""DS2""/>                 binding.bindKeyName = grab(a, METS.uri, ""TYPE"");                 binding.bindLabel = grab(a, METS.uri, ""LABEL"");                 binding.seqNo = grab(a, METS.uri, ""ORDER"");             } else {                 m_indiv = true;                 // first (outer div) part of structmap                 m_diss.dsBindMap.dsBindMechanismPID = grab(a, METS.uri, ""TYPE"");                 m_diss.dsBindMap.dsBindMapLabel = grab(a, METS.uri, ""LABEL"");             }         } else if (localName.equals(""fptr"")) {             // assume we're inside the inner div... that's the             // only place the fptr element is valid.             DSBinding binding =                     m_diss.dsBindMap.dsBindings[m_diss.dsBindMap.dsBindings.length - 1];             binding.datastreamID = grab(a, METS.uri, ""FILEID"");         } else if (localName.equals(""behaviorSec"")) {             // looks like we're in a disseminator... it should be in the             // hash by now because we've already gone through structmaps             // ...keyed by structmap id... remember the id (group id)             // so we can put it in when parsing serviceBinding             m_dissemId = grab(a, METS.uri, ""ID"");             m_dissemState = grab(a, METS.uri, ""STATUS"");         } else if (localName.equals(""serviceBinding"")) {             // remember the structId so we can grab the right dissem             // when parsing children             m_structId = grab(a, METS.uri, ""STRUCTID"");             // grab the disseminator associated with the provided structId             Disseminator dissem = m_dissems.get(m_structId);             // plug known items in..             dissem.dissID = m_dissemId;             dissem.dissState = m_dissemState;             // then grab the new stuff for the dissem for this element, and             // put it in.             dissem.dissVersionID = grab(a, METS.uri, ""ID"");             dissem.bDefID = grab(a, METS.uri, ""BTYPE"");             dissem.dissCreateDT =                     DateUtility                             .convertStringToDate(grab(a, METS.uri, ""CREATED""));             dissem.dissLabel = grab(a, METS.uri, ""LABEL"");         } else if (localName.equals(""interfaceMD"")) {             // no-op?             // Disseminator dissem = m_dissems.get(m_structId);         } else if (localName.equals(""serviceBindMD"")) {             Disseminator dissem = m_dissems.get(m_structId);             dissem.sDepID = grab(a, m_xlink.uri, ""href"");         }     }
public void marshall(DeleteTrailRequest deleteTrailRequest, ProtocolMarshaller protocolMarshaller) {          if (deleteTrailRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(deleteTrailRequest.getName(), NAME_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
@CheckResult     @NonNull     public static PowerAdapter asAdapter(@NonNull ViewFactory... views) {         checkNotNull(views, ""views"");         if (views.length == 0) {             return EMPTY;         }         return new ItemAdapter(ItemAdapter.toItems(asList(views)));     }
private List<String> getSchemaStringsFromDir(File dir) {     List<String> schemaStrings = new ArrayList<String>();     Collection<File> schemaFiles = FileUtils.listFiles(dir,         new SuffixFileFilter("".avsc""), TrueFileFilter.INSTANCE);     for (File schemaFile : schemaFiles) {       schemaStrings.add(getSchemaStringFromFile(schemaFile));     }     return schemaStrings;   }
public void setAllowedPrefixesToDirectConnectGateway(java.util.Collection<RouteFilterPrefix> allowedPrefixesToDirectConnectGateway) {         if (allowedPrefixesToDirectConnectGateway == null) {             this.allowedPrefixesToDirectConnectGateway = null;             return;         }          this.allowedPrefixesToDirectConnectGateway = new com.amazonaws.internal.SdkInternalList<RouteFilterPrefix>(allowedPrefixesToDirectConnectGateway);     }
public PassiveScanner getScanner(int pluginId) {         for (PassiveScanner scanner : passiveScanners) {             if (scanner instanceof PluginPassiveScanner) {                 if (((PluginPassiveScanner)scanner).getPluginId() == pluginId) {                     return scanner;                 }             }         }         return null;     }
public User login(final String username,             final String password) throws IOException, GroovesharkException {         JsonNode node = sendRequest(new RequestBuilder(""authenticateUser"", true) {              @Override             void populateParameters(Session session, ObjectNode parameters) {                 parameters.put(""username"", username);                 parameters.put(""password"", password);             }         });         // Success: the session that created this request is now authenticated,         // so we can mark is as such.         User user = new User(this, username, password, node);         session.setAuthenticated(user);         return user;     }
@Implementation   protected int load(String path, int priority) {     int soundId = soundIds.getAndIncrement();     idToPaths.put(soundId, path);     return soundId;   }
public static boolean isNullOrEmpty(@Nullable String string)   {     if (string == null || string.isEmpty())     {       return true;     }     return false;   }
public void copyFromMaster(Storable reference, S master) throws FetchException {          try {              mCopyFromMasterMethod.invoke(reference, master);          } catch (Exception e) {              ThrowUnchecked.fireFirstDeclaredCause(e, FetchException.class);          }      }
public Observable<ServiceResponse<List<AzureSkuInner>>> listSkusWithServiceResponseAsync() {         if (this.client.subscriptionId() == null) {             throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");         }         if (this.client.apiVersion() == null) {             throw new IllegalArgumentException(""Parameter this.client.apiVersion() is required and cannot be null."");         }         return service.listSkus(this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())             .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<AzureSkuInner>>>>() {                 @Override                 public Observable<ServiceResponse<List<AzureSkuInner>>> call(Response<ResponseBody> response) {                     try {                         ServiceResponse<PageImpl<AzureSkuInner>> result = listSkusDelegate(response);                         List<AzureSkuInner> items = null;                         if (result.body() != null) {                             items = result.body().items();                         }                         ServiceResponse<List<AzureSkuInner>> clientResponse = new ServiceResponse<List<AzureSkuInner>>(items, result.response());                         return Observable.just(clientResponse);                     } catch (Throwable t) {                         return Observable.error(t);                     }                 }             });     }
@Override    protected ResultSet findItemQPathByIdentifierCQ(String identifier) throws SQLException    {       if (findItemQPathByIdentifierCQ == null)       {          findItemQPathByIdentifierCQ = dbConnection.prepareStatement(FIND_ITEM_QPATH_BY_ID_CQ);       }       else       {          findItemQPathByIdentifierCQ.clearParameters();       }        findItemQPathByIdentifierCQ.setString(1, identifier);       return findItemQPathByIdentifierCQ.executeQuery();    }
@Override     public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpMessage request,                                  Class<?> expectedResultType) throws Exception {         final String ifNoneMatch = request.headers().get(HttpHeaderNames.IF_NONE_MATCH);         if (!isNullOrEmpty(ifNoneMatch)) {             final Revision lastKnownRevision = new Revision(ifNoneMatch);             final String prefer = request.headers().get(HttpHeaderNames.PREFER);             final long timeoutMillis;             if (!isNullOrEmpty(prefer)) {                 timeoutMillis = getTimeoutMillis(prefer);             } else {                 timeoutMillis = DEFAULT_TIMEOUT_MILLIS;             }             // Update timeout according to the watch API specifications.             ctx.setRequestTimeoutMillis(                     WatchTimeout.makeReasonable(timeoutMillis, ctx.requestTimeoutMillis()));             return Optional.of(new WatchRequest(lastKnownRevision, timeoutMillis));         }         return Optional.empty();     }
public void setOrdererProperties(String name, Properties properties) throws InvalidArgumentException {         setNodeProperties(""Orderer"", name, orderers, properties);     }
@Override   public String getReturnAuthnContextClassRef(ProfileRequestContext<?, ?> context, String authnContextUri, boolean displayedSignMessage)       throws ExternalAutenticationErrorCodeException {      final String logId = this.getLogString(context);      AuthnContextClassContext authnContextClassContext = this.getAuthnContextClassContext(context);      // Make sure we received one of the requested AuthnContextClassRef URI:s.     //     if (!this.isIssuedAuthnContextClassRefAccepted(context, authnContextUri)) {       final String msg = String.format(         ""AuthnContextClassRef URI received in assertion from IdP (%s) does not match any of the URI:s sent in the AuthnRequest (%s)"",         authnContextUri, authnContextClassContext.getProxiedAuthnContextClassRefs());       log.info(""{} [{}]"", msg, logId);       throw new ExternalAutenticationErrorCodeException(AuthnEventIds.AUTHN_EXCEPTION, msg);     }      // OK, that seems OK. Next, we will have to cover up for signing and for transformation.     //     String authnContextUriForSp = this.transformForSp(context, authnContextUri);     if (authnContextUriForSp == null) {       // Should never happen since we matched everything before sending the request.       final String msg = String.format(""AuthnContextClassRef received from IdP '{}' cannot be transformed"", authnContextUri);       log.info(""{} [{}]"", msg, logId);       throw new ExternalAutenticationErrorCodeException(AuthnEventIds.AUTHN_EXCEPTION, msg);     }      // OK, now we have the URI in a format that the SP understands. Let's check if we need to add     // a sigmessage extension to it.     //     if (!authnContextClassContext.isProxiedIdPSupportsSignMessage() && displayedSignMessage) {        // The remote IdP does not support sign messages, but the Proxy IdP has displayed the       // sign message. See if a sigmessage URI corresponding to the one we got back from the       // remote IdP was requested by the SP. If so, use that.       //       String sigmessageUri = this.toSignMessageURI(authnContextUriForSp);       if (sigmessageUri != null) {         if (authnContextClassContext.getAuthnContextClassRefs().contains(sigmessageUri)) {           authnContextUriForSp = sigmessageUri;         }       }     }      return authnContextUriForSp;   }
@Override     public void visitFormalTypeParameter(final String name) {         if (!hasFormals) {             hasFormals = true;             buf.append('<');         }         buf.append(name);         buf.append(':');     }
public TomcatServiceBuilder baseDir(Path baseDir) {         baseDir = requireNonNull(baseDir, ""baseDir"").toAbsolutePath();         if (!Files.isDirectory(baseDir)) {             throw new IllegalArgumentException(""baseDir: "" + baseDir + "" (expected: a directory)"");         }          this.baseDir = baseDir;         return this;     }
private HamtPMap<K, V> minus(K key, int hash, V[] value) {     if (hash == this.hash && key.equals(this.key)) {       HamtPMap<K, V> result = deleteRoot(mask, children);       if (value != null) {         value[0] = this.value;       }       return result != null ? result : empty();     }     int bucket = bucket(hash);     int bucketMask = 1 << bucket;     if ((mask & bucketMask) == 0) {       // not present, stop looking       return this;     }     hash = shift(hash);     int index = index(bucketMask);     HamtPMap<K, V> child = children[index];     HamtPMap<K, V> newChild = child.minus(key, hash, value);     if (newChild == child) {       return this;     } else if (newChild == EMPTY) {       return withChildren(mask & ~bucketMask, deleteChild(children, index));     } else {       return withChildren(mask, replaceChild(children, index, newChild));     }   }
protected void handleResponse(int responseCode, InputStream inputStream) {         BufferedReader rd = null;         try {             // Buffer the result into a string             rd = new BufferedReader(new InputStreamReader(inputStream));             StringBuilder sb = new StringBuilder();             String line;             while((line = rd.readLine()) != null) {                 sb.append(line);             }             log.info(""HttpHook ["" + hookName + ""] received "" + responseCode + "" response: "" + sb);         } catch (IOException e) {             log.error(""Error while reading response for HttpHook ["" + hookName + ""]"", e);         } finally {             if (rd != null) {                 try {                     rd.close();                 } catch (IOException e) {                     // no-op                 }             }         }     }
public static CreateObjectOptions objectOptionsFromFileOptions(CreateFileOptions options) {     return new CreateObjectOptions(         options.overwriteExisting(), options.getContentType(), options.getAttributes());   }
@GwtIncompatible(""incompatible method"")     private void reflectionAppend(         final Object lhs,         final Object rhs,         final Class<?> clazz) {          if (isRegistered(lhs, rhs)) {             return;         }          try {             register(lhs, rhs);             final Field[] fields = clazz.getDeclaredFields();             AccessibleObject.setAccessible(fields, true);             for (int i = 0; i < fields.length && isEquals; i++) {                 final Field f = fields[i];                 if (!ArrayUtils.contains(excludeFields, f.getName())                     && !f.getName().contains(""$"")                     && (testTransients || !Modifier.isTransient(f.getModifiers()))                     && !Modifier.isStatic(f.getModifiers())                     && !f.isAnnotationPresent(EqualsExclude.class)) {                     try {                         append(f.get(lhs), f.get(rhs));                     } catch (final IllegalAccessException e) {                         //this can't happen. Would get a Security exception instead                         //throw a runtime exception in case the impossible happens.                         throw new InternalError(""Unexpected IllegalAccessException"");                     }                 }             }         } finally {             unregister(lhs, rhs);         }     }
public void marshall(DeleteJobRequest deleteJobRequest, ProtocolMarshaller protocolMarshaller) {          if (deleteJobRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(deleteJobRequest.getJobName(), JOBNAME_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public ComponentView createComponentView(Container container, String key, String description) {         assertThatTheContainerIsNotNull(container);         assertThatTheViewKeyIsSpecifiedAndUnique(key);          ComponentView view = new ComponentView(container, key, description);         view.setViewSet(this);         componentViews.add(view);         return view;     }
public static FDBigInteger valueOfMulPow52(long value, int p5, int p2) {         assert p5 >= 0 : p5;         assert p2 >= 0 : p2;         int v0 = (int) value;         int v1 = (int) (value >>> 32);         int wordcount = p2 >> 5;         int bitcount = p2 & 0x1f;         if (p5 != 0) {             if (p5 < SMALL_5_POW.length) {                 long pow5 = SMALL_5_POW[p5] & LONG_MASK;                 long carry = (v0 & LONG_MASK) * pow5;                 v0 = (int) carry;                 carry >>>= 32;                 carry = (v1 & LONG_MASK) * pow5 + carry;                 v1 = (int) carry;                 int v2 = (int) (carry >>> 32);                 if (bitcount == 0) {                     return new FDBigInteger(new int[]{v0, v1, v2}, wordcount);                 } else {                     return new FDBigInteger(new int[]{                             v0 << bitcount,                             (v1 << bitcount) | (v0 >>> (32 - bitcount)),                             (v2 << bitcount) | (v1 >>> (32 - bitcount)),                             v2 >>> (32 - bitcount)                     }, wordcount);                 }             } else {                 FDBigInteger pow5 = big5pow(p5);                 int[] r;                 if (v1 == 0) {                     r = new int[pow5.nWords + 1 + ((p2 != 0) ? 1 : 0)];                     mult(pow5.data, pow5.nWords, v0, r);                 } else {                     r = new int[pow5.nWords + 2 + ((p2 != 0) ? 1 : 0)];                     mult(pow5.data, pow5.nWords, v0, v1, r);                 }                 return (new FDBigInteger(r, pow5.offset)).leftShift(p2);             }         } else if (p2 != 0) {             if (bitcount == 0) {                 return new FDBigInteger(new int[]{v0, v1}, wordcount);             } else {                 return new FDBigInteger(new int[]{                          v0 << bitcount,                         (v1 << bitcount) | (v0 >>> (32 - bitcount)),                         v1 >>> (32 - bitcount)                 }, wordcount);             }         }         return new FDBigInteger(new int[]{v0, v1}, 0);     }
public static STSClient createSTSX509Client(Bus bus, Map<String, String> stsProps) {          final STSClient stsClient = createClient(bus, stsProps);            stsClient.setWsdlLocation(stsProps.get(STS_X509_WSDL_LOCATION));          stsClient.setEndpointQName(new QName(stsProps.get(STS_NAMESPACE), stsProps.get(STS_X509_ENDPOINT_NAME)));            return stsClient;      }
public int compareTo (Name other)     {         Integer override = overrideCompareTo(other);         if (override != null) {             return override;         } else if ((override = other.overrideCompareTo(this)) != null) {             return -override;         }         Class<?> c = getClass();         Class<?> oc = other.getClass();         if (c == oc || c.getName().equals(oc.getName())) {             return getNormal().compareTo(other.getNormal());         } else {             return c.getName().compareTo(oc.getName());         }     }
public static String daoName(SQLiteDaoDefinition value) {   String classTableName = value.getName();   classTableName = classTableName + SUFFIX;   return classTableName;  }
@CheckReturnValue(when = When.NEVER)   public boolean isLoggedInInterruptibly() throws InterruptedException {     authLock.readLock().lockInterruptibly();     try {       return activeUser != null && activeUser.isLoggedIn();     } finally {       authLock.readLock().unlock();     }   }
public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {         if (fieldType == null) {             throw new IllegalArgumentException(""Field type must not be null"");         }         return append0(new TextField(fieldType, false));     }
@Override     public void readFragmentFrom(MwsReader r) {         invoiceRequirement = r.read(""InvoiceRequirement"", String.class);         buyerSelectedInvoiceCategory = r.read(""BuyerSelectedInvoiceCategory"", String.class);         invoiceTitle = r.read(""InvoiceTitle"", String.class);         invoiceInformation = r.read(""InvoiceInformation"", String.class);     }
public static JobDescFactoryBase getFrameworkSpecificJobDescFactory(Configuration jobConf) {     Framework framework = getFramework(jobConf);      switch (framework) {     case PIG:       return PIG_JOB_DESC_FACTORY;     case SCALDING:       return SCALDING_JOB_DESC_FACTORY;     default:       return MR_JOB_DESC_FACTORY;     }   }
@SuppressWarnings({""unused"", ""WeakerAccess""})     public ArrayList<CTInboxMessage> getAllInboxMessages(){         ArrayList<CTInboxMessage> inboxMessageArrayList = new ArrayList<>();         synchronized (inboxControllerLock) {             if(ctInboxController != null){                 ArrayList<CTMessageDAO> messageDAOArrayList = ctInboxController.getMessages();                 for (CTMessageDAO messageDAO : messageDAOArrayList) {                     Logger.v(""CTMessage Dao - ""+messageDAO.toJSON().toString());                     inboxMessageArrayList.add(new CTInboxMessage(messageDAO.toJSON()));                 }                 return inboxMessageArrayList;             }else{                 getConfigLogger().debug(getAccountId(),""Notification Inbox not initialized"");                 return null;             }         }     }
@Override  public CommerceVirtualOrderItem findByUUID_G(String uuid, long groupId)   throws NoSuchVirtualOrderItemException {   CommerceVirtualOrderItem commerceVirtualOrderItem = fetchByUUID_G(uuid,     groupId);    if (commerceVirtualOrderItem == null) {    StringBundler msg = new StringBundler(6);     msg.append(_NO_SUCH_ENTITY_WITH_KEY);     msg.append(""uuid="");    msg.append(uuid);     msg.append("", groupId="");    msg.append(groupId);     msg.append(""}"");     if (_log.isDebugEnabled()) {     _log.debug(msg.toString());    }     throw new NoSuchVirtualOrderItemException(msg.toString());   }    return commerceVirtualOrderItem;  }
public EClass getIfcLoop() {    if (ifcLoopEClass == null) {     ifcLoopEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc2x3tc1Package.eNS_URI).getEClassifiers()       .get(303);    }    return ifcLoopEClass;   }
public Object invokeMethod(Object object, String methodName, Object[] originalArguments) {         return invokeMethod(theClass, object, methodName, originalArguments, false, false);     }
public static IAtom[] findClosestByBond(IAtomContainer atomContainer, IAtom atom, int max) {         IAtomContainer mol = atomContainer.getBuilder().newInstance(IAtomContainer.class);         List<IAtom> v = new ArrayList<IAtom>();         v.add(atom);         breadthFirstSearch(atomContainer, v, mol, max);         IAtom[] returnValue = new IAtom[mol.getAtomCount() - 1];         int k = 0;         for (int i = 0; i < mol.getAtomCount(); i++) {             if (!mol.getAtom(i).equals(atom)) {                 returnValue[k] = mol.getAtom(i);                 k++;             }         }         return (returnValue);     }
public void errorv(Throwable t, String format, Object... params) {         doLog(Level.ERROR, FQCN, format, params, t);     }
public final <K> Mono<Map<K, T>> collectMap(Function<? super T, ? extends K> keyExtractor) {   return collectMap(keyExtractor, identityFunction());  }
public static void fe_add(int[] h,int[] f,int[] g) {   int f0 = f[0];   int f1 = f[1];   int f2 = f[2];   int f3 = f[3];   int f4 = f[4];   int f5 = f[5];   int f6 = f[6];   int f7 = f[7];   int f8 = f[8];   int f9 = f[9];   int g0 = g[0];   int g1 = g[1];   int g2 = g[2];   int g3 = g[3];   int g4 = g[4];   int g5 = g[5];   int g6 = g[6];   int g7 = g[7];   int g8 = g[8];   int g9 = g[9];   int h0 = f0 + g0;   int h1 = f1 + g1;   int h2 = f2 + g2;   int h3 = f3 + g3;   int h4 = f4 + g4;   int h5 = f5 + g5;   int h6 = f6 + g6;   int h7 = f7 + g7;   int h8 = f8 + g8;   int h9 = f9 + g9;   h[0] = (int)h0;   h[1] = (int)h1;   h[2] = (int)h2;   h[3] = (int)h3;   h[4] = (int)h4;   h[5] = (int)h5;   h[6] = (int)h6;   h[7] = (int)h7;   h[8] = (int)h8;   h[9] = (int)h9; }
public void print(char c) throws IOException {      if (writer != null) {          writer.write(String.valueOf(c));      } else {          write(String.valueOf(c));      }     }
@Override     public boolean accept(final Packet packet) throws FilterException {         try {             if (super.accept(packet)) {                 final SipPacket msg = (SipPacket) packet.getPacket(Protocol.SIP);                 return msg.getCallIDHeader().getValue().equals(this.callId);             }         } catch (final SipPacketParseException e) {             throw new FilterException(""Unable to process the frame due to SipParseException"", e);         } catch (final IOException e) {             throw new FilterException(""Unable to process the frame due to IOException"", e);         } catch (final PacketParseException e) {             throw new FilterException(""Unable to process the frame due to parse issue of the SIP Message"", e);         }         return false;     }
public static BorderStyle getBorderBottom(final Cell cell) {            ArgUtils.notNull(cell, ""cell"");            final Sheet sheet = cell.getSheet();          CellRangeAddress mergedRegion = getMergedRegion(sheet, cell.getRowIndex(), cell.getColumnIndex());            final Cell target;          if(mergedRegion == null) {              // 結合されていない場合              target = cell;            } else {              if(mergedRegion.getLastRow() == cell.getRowIndex()) {                  // 引数のCellが下部のセルの場合                  target = cell;              } else {                  target = getCell(sheet, cell.getColumnIndex(), mergedRegion.getLastRow());              }            }            final CellStyle style = target.getCellStyle();          if(style == null) {              return BorderStyle.NONE;          } else {              return style.getBorderBottomEnum();          }        }
protected void zSetData(MithraDataObject data)      {          this.currentData = data;          this.persistenceState = PersistenceState.PERSISTED;            MithraTransaction currentTransaction = MithraManagerProvider.getMithraManager().getCurrentTransaction();          if (currentTransaction != null && zGetPortal().getTxParticipationMode(currentTransaction).mustParticipateInTxOnRead())          {              this.transactionalState = currentTransaction.getReadLockedTransactionalState(null, PersistenceState.PERSISTED);          }      }
public String getELExpression()    {        // build the expression if not already done       if (expression == null)       {           /*           * Build the expression. Note that findBeanName() will either           * return the resolved bean name or throw a runtime exception           */          expression = ""#{"" + finder.findBeanName(beanClass) + ""."" + component + ""}"";           // log the resolved expression on trace level          if (log.isTraceEnabled())          {             log.trace(""Lazy expression resolved to: "" + expression);          }        }       return expression;    }
public static String adviceFieldName(final String name, final int index) {   return ProxettaNames.fieldPrefix + name + ProxettaNames.fieldDivider + index;  }
public Nature getNature()     {         Nature nature = Nature.nz;         switch (nPOS)         {             case CharType.CT_CHINESE:                 break;             case CharType.CT_NUM:             case CharType.CT_INDEX:             case CharType.CT_CNUM:                 nature = Nature.m;                 sWord = Predefine.TAG_NUMBER;                 break;             case CharType.CT_DELIMITER:                 nature = Nature.w;                 break;             case CharType.CT_LETTER:                 nature = Nature.nx;                 sWord = Predefine.TAG_CLUSTER;                 break;             case CharType.CT_SINGLE://12021-2129-3121                 if (Predefine.PATTERN_FLOAT_NUMBER.matcher(sWord).matches())//匹配浮点数                 {                     nature = Nature.m;                     sWord = Predefine.TAG_NUMBER;                 } else                 {                     nature = Nature.nx;                     sWord = Predefine.TAG_CLUSTER;                 }                 break;             default:                 break;         }         return nature;     }
public static Class<?>[] toTypeArray(String[] s) throws ClassNotFoundException {         if (s == null)             return null;         Class<?>[] c = new Class[s.length];         for (int i = 0; i < s.length; i++) {             c[i] = forName(s[i]);         }         return c;     }
public static Date truncate(final Date date, final int field) {         validateDateNotNull(date);         final Calendar gval = Calendar.getInstance();         gval.setTime(date);         modify(gval, field, ModifyType.TRUNCATE);         return gval.getTime();     }
public static void zipFiles(final ZipFile zipFile4j, final int compressionMethod,   final int compressionLevel, final File... toAdd) throws ZipException  {   // Initiate Zip Parameters which define various properties such   // as compression method, etc.   final ZipParameters parameters = new ZipParameters();    // set compression method to store compression   // Zip4jConstants.COMP_STORE is for no compression   // Zip4jConstants.COMP_DEFLATE is for compression   parameters.setCompressionMethod(compressionMethod);    // Set the compression level   // DEFLATE_LEVEL_ULTRA = ultra maximum compression   // DEFLATE_LEVEL_MAXIMUM = maximum compression   // DEFLATE_LEVEL_NORMAL = normal compression   // DEFLATE_LEVEL_FAST = fast compression   // DEFLATE_LEVEL_FASTEST = fastest compression   parameters.setCompressionLevel(compressionLevel);   zipFiles(zipFile4j, parameters, toAdd);  }
public void setTotalLocalCost(com.google.api.ads.adwords.axis.v201809.cm.Money totalLocalCost) {         this.totalLocalCost = totalLocalCost;     }
public static final String makeJavaPackage(String path) {         String classNameComponents[] = split(path,""/"");         StringBuilder legalClassNames = new StringBuilder();         for (int i = 0; i < classNameComponents.length; i++) {             legalClassNames.append(makeJavaIdentifier(classNameComponents[i]));             if (i < classNameComponents.length - 1) {                 legalClassNames.append('.');             }         }         return legalClassNames.toString();     }
public static Result newUpdateResultRequest(Type[] types, long id) {          Result result = newResult(ResultConstants.UPDATE_RESULT);          result.metaData = ResultMetaData.newUpdateResultMetaData(types);         result.id       = id;          result.navigator.add(new Object[]{});          return result;     }
public DescribeInterconnectsResult withInterconnects(Interconnect... interconnects) {         if (this.interconnects == null) {             setInterconnects(new com.amazonaws.internal.SdkInternalList<Interconnect>(interconnects.length));         }         for (Interconnect ele : interconnects) {             this.interconnects.add(ele);         }         return this;     }
public double[] randSphere(int dimension, double center, double radius) {     int d = dimension;     double[] x = new double[dimension];      double length = 0;     for (int i = 0; i < dimension; i++) {       x[i] = 0.0;     }      // --------- Step 1. Direction      for (int i = 0; i < d; i++) {       x[i] = randNormal(0, 1);       length += length + x[i] * x[i];     }      length = Math.sqrt(length);      // --------- Step 2. Random radius      double r = randomGenerator.nextDouble(0, 1);      for (int i = 0; i < d; i++) {       x[i] = center + radius * r * x[i] / length;     }      return x;   }
@Override     public Timer getTimer() throws IllegalStateException, NoSuchObjectLocalException, EJBException {          final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();         if (isTraceOn && tc.isEntryEnabled())             Tr.entry(tc, ""getTimer: "" + this);          // Throw NoSuchObjectLocalException if invoked when running in the adjunct control region on z/OS         if (EJSPlatformHelper.isZOSCRA()) {             NoSuchObjectLocalException nsoe = new NoSuchObjectLocalException(this.toString() + "" -- called from the adjunct control region."");             if (isTraceOn && tc.isEntryEnabled())                 Tr.exit(tc, ""getTimer: "" + nsoe);             throw nsoe;         }          // Determine if the calling bean is in a state that allows timer         // method access - throws IllegalStateException if not allowed.         checkTimerAccess();          EJBRuntime ejbRuntime = EJSContainer.getDefaultContainer().getEJBRuntime();         Timer timer = ejbRuntime.getPersistentTimerFromStore(taskId);          if (isTraceOn && tc.isEntryEnabled())             Tr.exit(tc, ""getTimer: "" + timer);          return timer;     }
private String getJavaScriptAsString() {   InputStream fis = getClass().getResourceAsStream(""RobotiumWeb.js"");   StringBuffer javaScript = new StringBuffer();    try {    BufferedReader input =  new BufferedReader(new InputStreamReader(fis));    String line = null;    while (( line = input.readLine()) != null){     javaScript.append(line);     javaScript.append(""\n"");    }    input.close();   } catch (IOException e) {    throw new RuntimeException(e);   }   return javaScript.toString();  }
@Override     public PutAccountSettingResult putAccountSetting(PutAccountSettingRequest request) {         request = beforeClientExecution(request);         return executePutAccountSetting(request);     }
public Map<String, Object> create(Map<String, Object> body, Setup setup) {         this.requestMaker = new RequestMaker(setup);         RequestProperties props = new RequestPropertiesBuilder()                 .method(""POST"")                 .endpoint(ENDPOINT)                 .body(body)                 .type(Accounts.class)                 .contentType(CONTENT_TYPE)                 .build();          return this.requestMaker.doRequest(props);     }
public void remove(QPath rootPath)    {       for (int i = items.size() - 1; i >= 0; i--)       {          ItemState item = items.get(i);           QPath qPath = item.getData().getQPath();          if (qPath.isDescendantOf(rootPath) || item.getAncestorToSave().isDescendantOf(rootPath)             || item.getAncestorToSave().equals(rootPath) || qPath.equals(rootPath))          {                          if (item.isNode())             {                removeNode(item, i);             }             else             {                removeProperty(item, i);             }          }       }    }
@Pure  public BusHub getNearestBusHub(double x, double y) {   double distance = Double.POSITIVE_INFINITY;   BusHub bestHub = null;   double dist;    for (final BusHub hub : this.validBusHubs) {    dist = hub.distance(x, y);    if (dist < distance) {     distance = dist;     bestHub = hub;    }   }    return bestHub;  }
public static void decodeMultiple(final byte[] input, int inoff,                                       final byte[] output, int outoff,                                       final int count) {          if (count < 0) {             throw new IllegalArgumentException(""count("" + count + "") < 0"");         }          for (int i = 0; i < count; i++) {             decodeSingle(input, inoff, output, outoff);             inoff += 2;             outoff += 1;         }     }
public LanguageProfileBuilder addText(CharSequence text) {         if (ngramExtractor==null) {             throw new IllegalStateException(""NgramExtractor has not been set yet!"");         }         for (Map.Entry<String, Integer> entry : ngramExtractor.extractCountedGrams(text).entrySet()) {             addGram(entry.getKey(), entry.getValue());         }         return this;     }
public long addUserProfile(UserHandle userHandle) {     long serialNumber = nextUserSerial++;     userProfiles.put(userHandle, serialNumber);     return serialNumber;   }
static String generateTaskName(final Request<?> request) {     return request.getBaseUriTemplate() + "" ""         + OperationNameGenerator.generate(request.getMethod(), request.getMethodName());   }
public void setBaselineDuration(int baselineNumber, Duration value)    {       set(selectField(TaskFieldLists.BASELINE_DURATIONS, baselineNumber), value);    }
AmazonInfo getNewAmazonInfo() {         return AmazonInfo.Builder                         .newBuilder()                         .withAmazonInfoConfig(amazonInfoConfig)                         .autoBuild(amazonInfoConfig.getNamespace());     }
public void decompress(String path)   throws IOException  {   File bzip2 = new File(path);    //   File unarchived = new File(bzip2.getName().replace("".bz2"", """"));    unarchived.createNewFile();    BufferedInputStream inputStr = new BufferedInputStream(new FileInputStream(bzip2));    // read bzip2 prefix   inputStr.read();   inputStr.read();    BufferedInputStream buffStr = new BufferedInputStream(inputStr);    CBZip2InputStream input = new CBZip2InputStream(buffStr);    FileOutputStream outStr = new FileOutputStream(unarchived);    while (true) {    byte[] compressedBytes = new byte[DECOMPRESSION_CACHE];     int byteRead = input.read(compressedBytes);     outStr.write(compressedBytes, 0, byteRead);    if (byteRead != DECOMPRESSION_CACHE) {     break;    }   }    input.close();   buffStr.close();   inputStr.close();   outStr.close();  }
public void invoke(HttpServletRequest req, HttpServletResponse rsp, Object root, String url) throws IOException, ServletException {         RequestImpl sreq = new RequestImpl(this, req, new ArrayList<AncestorImpl>(), new TokenList(url));         RequestImpl oreq = CURRENT_REQUEST.get();         CURRENT_REQUEST.set(sreq);          ResponseImpl srsp = new ResponseImpl(this, rsp);         ResponseImpl orsp = CURRENT_RESPONSE.get();         CURRENT_RESPONSE.set(srsp);          try {             invoke(sreq,srsp,root);         } finally {             CURRENT_REQUEST.set(oreq);             CURRENT_RESPONSE.set(orsp);         }     }
protected void initNestedFormatters(Element element, CmsXmlContentDefinition contentDefinition)     throws CmsXmlException {          Iterator<Element> i = CmsXmlGenericWrapper.elementIterator(element, APPINFO_NESTED_FORMATTER);         while (i.hasNext()) {             // iterate all ""default"" elements in the ""defaults"" node             Element handlerElement = i.next();             String formatterElement = handlerElement.attributeValue(APPINFO_ATTR_ELEMENT);             addNestedFormatter(formatterElement, contentDefinition);         }     }
public static Map<String, Object> xmlToMap(String xmlStr, Map<String, Object> result) {    final Document doc = parseXml(xmlStr);    final Element root = getRootElement(doc);    root.normalize();      return xmlToMap(root, result);   }
@Override  public Response getCommandHistoryNumberOfPages( String applicationName, int itemsPerPage ) {    this.logger.fine(""Request: get the number of pages for commands history."");   int number = this.manager.commandsMngr().getHistoryNumberOfPages( itemsPerPage, applicationName );   return Response.ok( String.valueOf( number )).build();  }
private synchronized void trimHead() {     if(offsets.size()<=1) {       return;     }     FileOffset head = offsets.first();     FileOffset head2 = offsets.higher(head);     if( head.isNextOffset(head2) ) {       offsets.pollFirst();       trimHead();     }     return;   }
static void quoteListenerAndHostAttributeKeys(Node objLit, AbstractCompiler compiler) {     checkState(objLit.isObjectLit());     for (Node keyNode : objLit.children()) {       if (keyNode.isComputedProp()) {         continue;       }       if (!keyNode.getString().equals(""listeners"")           && !keyNode.getString().equals(""hostAttributes"")) {         continue;       }       for (Node keyToQuote : keyNode.getFirstChild().children()) {         if (!keyToQuote.isQuotedString()) {           keyToQuote.setQuotedString();           compiler.reportChangeToEnclosingScope(keyToQuote);         }       }     }   }
@Override   public void createAdjacencyMatrix(SDocumentGraph graph,     Map<String, String> args, int matchNumber, int nodeCount) throws IOException, IllegalArgumentException   {     // first match     if (matchNumber == 0)     {       // get list of metakeys to export       metakeys = new HashSet<>();       if (args.containsKey(""metakeys""))       {         metakeys.addAll(Arrays.asList(args.get(""metakeys"").split("","")));       }       // initialize list of annotations for the matched nodes       annotationsForMatchedNodes = new TreeMap<>();     }     for (SNode node: this.getMatchedNodes(graph)) {       int node_id = node           .getFeature(AnnisConstants.ANNIS_NS, AnnisConstants.FEAT_MATCHEDNODE)           .getValue_SNUMERIC().intValue();       if(!annotationsForMatchedNodes.containsKey(node_id))         annotationsForMatchedNodes.put(node_id, new TreeSet<String>());       List<SAnnotation> annots = new ArrayList<>(node.getAnnotations());       Set<String> annoNames = annotationsForMatchedNodes.get(node_id);       for (SAnnotation annot: annots) {         annoNames.add(annot.getNamespace() + ""::"" + annot.getName());       }     }   }
@GetMapping(""/setting/scan/{maxdeeplevel}"")     public void annotationScan(@PathVariable int maxdeeplevel, HttpServletRequest req, HttpServletResponse res) {         this.validationSessionComponent.sessionCheck(req);         this.msgSaver.annotationScan(maxdeeplevel);     }
public static long scale(DMatrixRMaj mat , int numTrials) {         long prev = System.currentTimeMillis();          for( int i = 0; i < numTrials; i++ ) {             CommonOps_DDRM.scale(10,mat);             CommonOps_DDRM.scale(0.1,mat);         }          long curr = System.currentTimeMillis();         return curr-prev;     }
@Override  public CheckResult check() {   try {    post(new byte[] { '[', ']' });    return CheckResult.OK;   }   catch (Exception e) {    return CheckResult.failed(e);   }  }
public void configure(InputStream in, Object obj, String xpath) throws XPathNotFoundException, XmlBeanException, IOException, SAXException {         XmlParser parser = new XmlParser();         XmlParser.Node rootNode = parser.parse(in);         configure(rootNode, obj);     }
public SlackService updateSlackService(Object projectIdOrPath, SlackService slackNotifications) throws GitLabApiException {         GitLabApiForm formData = new GitLabApiForm()                 .withParam(""webhook"", slackNotifications.getWebhook(), true)                 .withParam(""username"", slackNotifications.getUsername())                 .withParam(""channel"", slackNotifications.getDefaultChannel())                 .withParam(""notify_only_broken_pipelines"", slackNotifications.getNotifyOnlyBrokenPipelines())                 .withParam(""notify_only_default_branch"", slackNotifications.getNotifyOnlyDefaultBranch())                 .withParam(""push_events"", slackNotifications.getPushEvents())                 .withParam(""issues_events"", slackNotifications.getIssuesEvents())                 .withParam(""confidential_issues_events"", slackNotifications.getConfidentialIssuesEvents())                 .withParam(""merge_requests_events"", slackNotifications.getMergeRequestsEvents())                 .withParam(""tag_push_events"", slackNotifications.getTagPushEvents())                 .withParam(""note_events"", slackNotifications.getNoteEvents())                 .withParam(""confidential_note_events"", slackNotifications.getConfidentialNoteEvents())                 .withParam(""pipeline_events"", slackNotifications.getPipelineEvents())                 .withParam(""wiki_page_events"", slackNotifications.getWikiPageEvents())                 .withParam(""push_channel"", slackNotifications.getPushChannel())                 .withParam(""issue_channel"", slackNotifications.getIssueChannel())                 .withParam(""confidential_issue_channel"", slackNotifications.getConfidentialIssueChannel())                 .withParam(""merge_request_channel"", slackNotifications.getMergeRequestChannel())                 .withParam(""note_channel"", slackNotifications.getNoteChannel())                 .withParam(""confidential_note_channel"", slackNotifications.getConfidentialNoteChannel())                 .withParam(""tag_push_channel"", slackNotifications.getTagPushChannel())                 .withParam(""pipeline_channel"", slackNotifications.getPipelineChannel())                 .withParam(""wiki_page_channel"", slackNotifications.getWikiPageChannel());         Response response = put(Response.Status.OK, formData.asMap(), ""projects"", getProjectIdOrPath(projectIdOrPath), ""services"", ""slack"");         return (response.readEntity(SlackService.class));     }
public Observable<ServiceResponse<Void>> beginScaleWithServiceResponseAsync(String resourceGroupName, String accountName, String streamingEndpointName) {         if (this.client.subscriptionId() == null) {             throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");         }         if (resourceGroupName == null) {             throw new IllegalArgumentException(""Parameter resourceGroupName is required and cannot be null."");         }         if (accountName == null) {             throw new IllegalArgumentException(""Parameter accountName is required and cannot be null."");         }         if (streamingEndpointName == null) {             throw new IllegalArgumentException(""Parameter streamingEndpointName is required and cannot be null."");         }         if (this.client.apiVersion() == null) {             throw new IllegalArgumentException(""Parameter this.client.apiVersion() is required and cannot be null."");         }         final Integer scaleUnit = null;         StreamingEntityScaleUnit parameters = new StreamingEntityScaleUnit();         parameters.withScaleUnit(null);         return service.beginScale(this.client.subscriptionId(), resourceGroupName, accountName, streamingEndpointName, this.client.apiVersion(), this.client.acceptLanguage(), parameters, this.client.userAgent())             .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {                 @Override                 public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {                     try {                         ServiceResponse<Void> clientResponse = beginScaleDelegate(response);                         return Observable.just(clientResponse);                     } catch (Throwable t) {                         return Observable.error(t);                     }                 }             });     }
public void updateWaynameQueryMap(boolean isEnabled) {     if (mapWayName != null) {       mapWayName.updateWayNameQueryMap(isEnabled);     } else {       settings.updateWayNameEnabled(isEnabled);     }   }
public static void setXMLEntityExpansionLimitIfLarger (final int nMaxOccur)   {     final int nOldValue = getXMLEntityExpansionLimit ();     if (nOldValue > 0)     {       // Current value is limited       if (nMaxOccur <= 0 || nMaxOccur > nOldValue)       {         // New value is unlimited or higher         setXMLEntityExpansionLimit (nMaxOccur);       }     }     // else -> cannot be increased   }
private boolean injectConstructorHasMatchingParams(TypeLiteral<?> type,       Constructor<?> constructor, List<Key<?>> paramList, Errors errors) throws ErrorsException {     List<TypeLiteral<?>> params = type.getParameterTypes(constructor);     Annotation[][] paramAnnotations = constructor.getParameterAnnotations();     int p = 0;     for (TypeLiteral<?> param : params) {       Key<?> paramKey = getKey(param, constructor, paramAnnotations[p++], errors);       if (paramKey.getAnnotationType() == Assisted.class && !paramList.contains(paramKey)) {         return false;       }     }      return true;   }
private DataColumnsDao getDataColumnsDao() throws SQLException {   if (dataColumnsDao == null) {    dataColumnsDao = DaoManager.createDao(connectionSource,      DataColumns.class);   }   return dataColumnsDao;  }
public Matrix4x3f set(Matrix3fc mat) {         if (mat instanceof Matrix3f) {             MemUtil.INSTANCE.copy((Matrix3f) mat, this);         } else {             setMatrix3fc(mat);         }         properties = 0;         return this;     }
public KeyArea setupKey(int iKeyArea)     {         KeyArea keyArea = null;         if (iKeyArea == 0)         {             keyArea = this.makeIndex(DBConstants.UNIQUE, ID_KEY);             keyArea.addKeyField(ID, DBConstants.ASCENDING);         }         if (iKeyArea == 1)         {             keyArea = this.makeIndex(DBConstants.NOT_UNIQUE, DESCRIPTION_KEY);             keyArea.addKeyField(DESCRIPTION, DBConstants.ASCENDING);         }         if (keyArea == null)             keyArea = super.setupKey(iKeyArea);              return keyArea;     }
public CoinbaseTransaction getCoinbaseTransaction(String transactionIdOrIdemField)       throws IOException {      final CoinbaseTransaction transaction =         coinbase.getTransactionDetails(             transactionIdOrIdemField,             exchange.getExchangeSpecification().getApiKey(),             signatureCreator,             exchange.getNonceFactory());     return handleResponse(transaction);   }
private String getCheckstyleVersion() {         Package checkstyleApiPackage = Configuration.class.getPackage();          return (checkstyleApiPackage == null) ? null : checkstyleApiPackage.getImplementationVersion();     }
protected void writeConstructor(TreeLogger logger, GeneratorContext context, SourceWriter srcWriter) {   srcWriter.println(""public %s() {"", this.proxyName);   srcWriter.indent();   for (InjectorWritterConstructor delegate : Iterables.filter(this.delegates, InjectorWritterConstructor.class)) {    delegate.writeConstructor(srcWriter);   }   srcWriter.outdent();   srcWriter.println(""}"");  }
public List<Data> getRange(byte[] lowerKey, byte[] upperKey)     throws IOException {    if (!filesAreOpened) {     throw new IOException(       ""The files are not opened yet. Use openFiles() to open all files."");    }    // estimate first and last bucket    int lowerBucket = drums.getHashFunction().getBucketId(lowerKey);    int upperBucket = drums.getHashFunction().getBucketId(upperKey);    if (lowerBucket > upperBucket) {     lowerBucket = 0;     upperBucket = drums.getHashFunction().getNumberOfBuckets() - 1;    }      // estimate first chunk in the first file    long lowerChunkOffset = files[lowerBucket].getIndex()      .getStartOffsetOfChunkByKey(lowerKey);    // estimate last chunk in the last file    long upperChunkOffset = files[lowerBucket].getIndex()      .getStartOffsetOfChunkByKey(upperKey);    long filesize, startOffset, endOffset;    byte[] tmpB = new byte[elementSize];      ArrayList<Data> elements = new ArrayList<Data>();    // run over all files    OUTER: for (int i = lowerBucket; i <= upperBucket; i++) {     HeaderIndexFile<Data> aktFile = files[i];     filesize = aktFile.getFilledUpFromContentStart();       // start reading at lowerChunkOffset in first file, else start     // reading from beginning     startOffset = i == lowerBucket ? lowerChunkOffset : 0;     // stop reading at upperChunkOffset in last file, else read till end     // fo file     endOffset = i == upperBucket ? Math.max(       upperChunkOffset + aktFile.getChunkSize(), filesize)       : filesize;       while (startOffset < endOffset) {      destBuffer.clear();      aktFile.read(startOffset, destBuffer);      destBuffer.flip();      while (destBuffer.remaining() >= elementSize) {       destBuffer.get(tmpB); // get the element       @SuppressWarnings(""unchecked"")       Data record = (Data) prototype.fromByteBuffer(ByteBuffer         .wrap(tmpB));       if (KeyUtils.compareKey(record.getKey(), lowerKey) >= 0         && KeyUtils.compareKey(record.getKey(), upperKey) <= 0) {        elements.add(record);       } else if (KeyUtils.compareKey(record.getKey(), upperKey) > 0) {        // we have read all relevant elements        break OUTER;       }       startOffset += elementSize;      }     }    }    return elements;   }
public boolean validate() {         int validationTimeout = dsConfig.get().validationTimeout;          final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();         if (isTraceOn && tc.isEntryEnabled())              Tr.entry(this, tc, ""validate"", ""timeout: "" + validationTimeout);          try {             if (validationTimeout >= 0 && mcf.jdbcDriverSpecVersion >= 40) // validation by timeout             {                 // Validation by timeout is available only on JDBC 4.0 & higher                 if (!sqlConn.isValid(validationTimeout))                  {                     if (isTraceOn && tc.isEntryEnabled())                         Tr.exit(this, tc, ""validate"", false);                     return false;                 }             } else // validation by SQL query for JDBC drivers at spec level prior to v4.0             {                 Statement stmt = sqlConn.createStatement();                 try {                     stmt.executeQuery(""SELECT 1"").close(); // if this fails, the SQLException is checked for stale                 } finally {                     stmt.close();                 }             }              //  - if currentAutoCommit is false, rollback the connection.             if (!currentAutoCommit) {                 if (isTraceOn && tc.isDebugEnabled())                      Tr.debug(this, tc, ""AutoCommit is false.  Rolling back the connection after validation"");                 sqlConn.rollback();             }              // Clean up the connection.             mcf.helper.doConnectionCleanup(sqlConn);              // Clear the warning.             sqlConn.clearWarnings();          } catch (SQLException sqle) {             // No FFDC coded needed              // The SQLException could be a StaleConnectionException or a normal SQLException             // resulted from invalid SQLStatement.              ResourceException resX = AdapterUtil.translateSQLException(sqle, this, false, getClass()); // no need to fire connection event here, J2C handles on pretest failure              // Remove this if the helpers ever start tracing exceptions.             if (isTraceOn && tc.isDebugEnabled())                  Tr.debug(this, tc, ""validate"", AdapterUtil.getStackTraceWithState(sqle));              if (helper.isConnectionError(sqle)) {                 // Don't do any cleanup                 if (isTraceOn && tc.isEntryEnabled())                     Tr.exit(this, tc, ""validate"", false);                 return false;             } else if (!(resX instanceof SecurityException)) {                 // This exception is due to an invalid SQL statement.                  //  - if currentAutoCommit is false, rollback the connection.                 if (!currentAutoCommit) {                     try {                         if (isTraceOn && tc.isDebugEnabled())                              Tr.debug(this, tc, ""AutoCommit is false.  Rolling back the connection after validation"");                         sqlConn.rollback();                     } catch (SQLException rollbackEx) {                         // No FFDC coded needed                          // There is a possiblility that now the connection is stale.                          if (helper.isConnectionError(rollbackEx)) {                             if (isTraceOn && tc.isEntryEnabled())                                 Tr.exit(this, tc, ""validate"", AdapterUtil.getStackTraceWithState(rollbackEx));                             return false;                         }                     }                 }                  try {                     mcf.helper.doConnectionCleanup(sqlConn);                 } catch (SQLException cleanEx) {                     // No FFDC coded needed                      // There is a possiblility that now the connection is stale.                      if (helper.isConnectionError(cleanEx)) {                         if (isTraceOn && tc.isEntryEnabled())                             Tr.exit(this, tc, ""validate"", AdapterUtil.getStackTraceWithState(cleanEx));                         return false;                     }                 }                  try {                     sqlConn.clearWarnings();                 } catch (SQLException cleanEx) {                     // No FFDC coded needed                      // There is a possibility that now the connection is stale.                      if (helper.isConnectionError(cleanEx)) {                         if (isTraceOn && tc.isEntryEnabled())                             Tr.exit(this, tc, ""validate"", AdapterUtil.getStackTraceWithState(cleanEx));                         return false;                     }                 }             }         }          if (isTraceOn && tc.isEntryEnabled())             Tr.exit(this, tc, ""validate"", true);         return true;     }
public OvhOption serviceName_option_option_GET(String serviceName, net.minidev.ovh.api.vps.OvhVpsOptionEnum option) throws IOException {   String qPath = ""/vps/{serviceName}/option/{option}"";   StringBuilder sb = path(qPath, serviceName, option);   String resp = exec(qPath, ""GET"", sb.toString(), null);   return convertTo(resp, OvhOption.class);  }
public static ChaiGroup createGroup( final String parentDN, final String name, final ChaiProvider provider )             throws ChaiOperationException, ChaiUnavailableException     {         //Get a good CN for it         final String objectCN = findUniqueName( name, parentDN, provider );          //Concantonate the entryDN         final StringBuilder entryDN = new StringBuilder();         entryDN.append( ""cn="" );         entryDN.append( objectCN );         entryDN.append( ',' );         entryDN.append( parentDN );          //First create the base group.         provider.createEntry( entryDN.toString(), ChaiConstant.OBJECTCLASS_BASE_LDAP_GROUP, Collections.emptyMap() );          //Now build an ldapentry object to add attributes to it         final ChaiEntry theObject = provider.getEntryFactory().newChaiEntry( entryDN.toString() );          //Add the description         theObject.writeStringAttribute( ChaiConstant.ATTR_LDAP_DESCRIPTION, name );          //Return the newly created group.         return provider.getEntryFactory().newChaiGroup( entryDN.toString() );     }
public void isEqualToDefaultInstance() {     if (actual() == null) {       failWithoutActual(           simpleFact(               lenientFormat(                   ""Not true that %s is a default proto instance. It is null."", actualAsString())));     } else if (!actual().equals(actual().getDefaultInstanceForType())) {       failWithoutActual(           simpleFact(               lenientFormat(                   ""Not true that %s is a default proto instance. It has set values."",                   actualAsString())));     }   }
public void addSVBar(SVBar bar) {   mSVbar = bar;   // Give an instance of the color picker to the Saturation/Value bar.   mSVbar.setColorPicker(this);   mSVbar.setColor(mColor);  }
public static CacheBuilderSpec parse(String cacheBuilderSpecification) {     CacheBuilderSpec spec = new CacheBuilderSpec(cacheBuilderSpecification);     if (!cacheBuilderSpecification.isEmpty()) {       for (String keyValuePair : KEYS_SPLITTER.split(cacheBuilderSpecification)) {         List<String> keyAndValue = ImmutableList.copyOf(KEY_VALUE_SPLITTER.split(keyValuePair));         checkArgument(!keyAndValue.isEmpty(), ""blank key-value pair"");         checkArgument(             keyAndValue.size() <= 2,             ""key-value pair %s with more than one equals sign"",             keyValuePair);          // Find the ValueParser for the current key.         String key = keyAndValue.get(0);         ValueParser valueParser = VALUE_PARSERS.get(key);         checkArgument(valueParser != null, ""unknown key %s"", key);          String value = keyAndValue.size() == 1 ? null : keyAndValue.get(1);         valueParser.parse(spec, key, value);       }     }      return spec;   }
public List<String> getSetPortUsedBySupervisor(String supervisorHost, int slotCount) throws Exception {          String appPath = RegistryUtils.serviceclassPath(                 JOYConstants.APP_TYPE, JOYConstants.EMPTY);          String path = RegistryUtils.serviceclassPath(                 JOYConstants.APP_TYPE, instanceName);          String containerPath = RegistryUtils.componentPath(                 JOYConstants.APP_TYPE, instanceName, containerId.getApplicationAttemptId().getApplicationId().toString(), containerId.toString());          List<String> reList = new ArrayList<String>();         try {              List<ServiceRecord> hostContainers = new ArrayList<ServiceRecord>();             Set<String> hostUsedPorts = new HashSet<String>();               List<String> instanceNames = registryOperations.list(appPath);             for (String instance : instanceNames) {                  String servicePath = RegistryUtils.serviceclassPath(                         JOYConstants.APP_TYPE, instance);                  List<String> apps = registryOperations.list(servicePath);                  for (String subapp : apps) {                      String subAppPath = RegistryUtils.servicePath(                             JOYConstants.APP_TYPE, instance, subapp);                     String componentsPath = subAppPath + JOYConstants.COMPONENTS;                     if (!registryOperations.exists(componentsPath))                         continue;                     Map<String, ServiceRecord> containers = RegistryUtils.listServiceRecords(registryOperations, componentsPath);                      for (String container : containers.keySet()) {                         ServiceRecord sr = containers.get(container);                         LOG.info(sr.toString());                          if (!sr.get(JOYConstants.HOST).equals(supervisorHost))                             continue;                         hostContainers.add(sr);                         String[] portList = new String[]{};                         if (sr.get(JOYConstants.PORT_LIST) != null)                             portList = sr.get(JOYConstants.PORT_LIST).split(JOYConstants.COMMA);                         for (String usedport : portList) {                             hostUsedPorts.add(usedport);                         }                     }                 }             }              //scan port range from 9000 to 15000             for (int i = getMinPort(); i < getMaxPort(); i++) {                 if (JstormYarnUtils.isPortAvailable(supervisorHost, i)) {                     if (!hostUsedPorts.contains(String.valueOf(i)))                         reList.add(String.valueOf(i));                 }                 if (reList.size() >= slotCount) {                     break;                 }             }               if (registryOperations.exists(containerPath)) {                 ServiceRecord sr = registryOperations.resolve(containerPath);                 String portListUpdate = JstormYarnUtils.join(reList, JOYConstants.COMMA, false);                 if (sr.get(JOYConstants.PORT_LIST) != null) {                     String[] portList = sr.get(JOYConstants.PORT_LIST).split(JOYConstants.COMMA);                     portListUpdate = JstormYarnUtils.join(portList, JOYConstants.COMMA, true) + JstormYarnUtils.join(reList, JOYConstants.COMMA, false);                 }                 sr.set(JOYConstants.PORT_LIST, portListUpdate);                 registryOperations.bind(containerPath, sr, BindFlags.OVERWRITE);             } else {                 registryOperations.mknode(containerPath, true);                 ServiceRecord sr = new ServiceRecord();                 sr.set(JOYConstants.HOST, supervisorHost);                 String portListUpdate = JstormYarnUtils.join(reList, JOYConstants.COMMA, false);                 sr.set(JOYConstants.PORT_LIST, portListUpdate);                 sr.set(YarnRegistryAttributes.YARN_ID, containerId.toString());                 sr.description = JOYConstants.CONTAINER;                 sr.set(YarnRegistryAttributes.YARN_PERSISTENCE,                         PersistencePolicies.CONTAINER);                 registryOperations.bind(containerPath, sr, BindFlags.OVERWRITE);             }             return reList;         } catch (Exception ex) {             LOG.error(ex);             throw ex;         }     }
private void addTaskPart(List<DataSource> bodyPartContents, URI taskURI,             int contentId) throws JAXBException {         for (EntityBatchOperation entityBatchOperation : entityBatchOperations) {             DataSource bodyPartContent = null;             if (entityBatchOperation instanceof Task.CreateBatchOperation) {                 Task.CreateBatchOperation createTaskOperation = (Task.CreateBatchOperation) entityBatchOperation;                 bodyPartContent = createBatchCreateEntityPart(                         createTaskOperation.getVerb(), ""Tasks"",                         createTaskOperation.getEntryType(), taskURI, contentId);                 contentId++;             }              if (bodyPartContent != null) {                 bodyPartContents.add(bodyPartContent);             }         }     }
private void notifyListener(ChangeNotification<T> changeNotification, boolean newListener) {     lock.lock();     try {       checkNotNull(changeNotification, ""changeNotification"");        final Listener<T> listener = listenerRef.get();       if (listener != null) {         try {           final boolean notified = listenerNotified.getAndSet(true);           if (!(newListener && notified)) {             listener.onChange(changeNotification);           }         } catch (Throwable e) {           log.error(""Change notification listener threw exception"", e);         }       }     } finally {       lock.unlock();     }   }
@Nullable     public final Resources getResources() {         Activity activity = getActivity();         return activity != null ? activity.getResources() : null;     }
public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMultiRolePoolInstanceMetricsWithServiceResponseAsync(final String resourceGroupName, final String name, final String instance, final Boolean details) {         return listMultiRolePoolInstanceMetricsSinglePageAsync(resourceGroupName, name, instance, details)             .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {                 @Override                 public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {                     String nextPageLink = page.body().nextPageLink();                     if (nextPageLink == null) {                         return Observable.just(page);                     }                     return Observable.just(page).concatWith(listMultiRolePoolInstanceMetricsNextWithServiceResponseAsync(nextPageLink));                 }             });     }
@Override     public BackchannelAuthenticationResponse backchannelAuthentication(BackchannelAuthenticationRequest request) throws AuthleteApiException     {         return executeApiCall(                 new ServicePostApiCaller<BackchannelAuthenticationResponse>(                         BackchannelAuthenticationResponse.class, request, BACKCHANNEL_AUTHENTICATION_API_PATH));     }
public void setProperties(Properties properties) {   baseDir = properties.getProperty(""base_dir"", baseDir);   inputFileLocation = baseDir + '/' + properties.getProperty(""input_file_location"", inputFileLocation);   outputFileLocation = baseDir + '/' + properties.getProperty(""output_file_location"", outputFileLocation);   tempOutputFileLocation = baseDir + '/' + properties.getProperty(""temp_output_file_location"", tempOutputFileLocation);  }
public void retryLastFailedTask(String workflowId) {         Preconditions.checkArgument(StringUtils.isNotBlank(workflowId), ""workflow id cannot be blank"");         stub.retryWorkflow(WorkflowServicePb.RetryWorkflowRequest.newBuilder()                 .setWorkflowId(workflowId)                 .build()         );     }
private void removeObjectId(int dtx, int dty)     {         final int tw = transformable.getWidth() / map.getTileWidth();         final int th = transformable.getHeight() / map.getTileHeight();         for (int tx = dtx; tx < dtx + tw; tx++)         {             for (int ty = dty; ty < dty + th; ty++)             {                 if (mapPath.getObjectsId(tx, ty).contains(id))                 {                     mapPath.removeObjectId(tx, ty, id);                 }             }         }     }
@Override     public GetApnsVoipSandboxChannelResult getApnsVoipSandboxChannel(GetApnsVoipSandboxChannelRequest request) {         request = beforeClientExecution(request);         return executeGetApnsVoipSandboxChannel(request);     }
private void sanitizeDiskCache() {         File[] cachedFiles = new File(diskCacheDirectory).listFiles();         if (cachedFiles == null) {             return;         }         for (File f : cachedFiles) {          // if file older than expirationInMinutes, remove it          long lastModified = f.lastModified();          Date now = new Date();          long ageInMinutes = ((now.getTime() - lastModified) / (1000*60));                    if (ageInMinutes >= expirationInMinutes) {           Log.d(name, ""DISK cache expiration for file "" + f.toString());           f.delete();          }         }  }
public JavaMailBuilder port(String... port) {   for (String p : port) {    if (p != null) {     ports.add(p);    }   }   return this;  }
public static String toDateString(long time) {    GregorianCalendar cal = new GregorianCalendar(0, 0, 0);    cal.setTimeInMillis(time);    return toDateString(cal);   }
@GetMapping(path = {""/swivel/turingImage""})     public void generate(final HttpServletResponse response, final HttpServletRequest request) throws Exception {         response.setContentType(""image/png"");         val principal = request.getParameter(""principal"");         if (StringUtils.isBlank(principal)) {             throw new IllegalArgumentException(""No principal is specified in the turing image request"");         }         generateImage(response.getOutputStream(), principal);     }
public JSONObject updateApiKey(String key, List<String> acls) throws AlgoliaException {     return this.updateApiKey(key, acls, RequestOptions.empty);   }
public List<Term> seg(String text)     {         char[] charArray = text.toCharArray();         if (HanLP.Config.Normalization)         {             CharTable.normalization(charArray);         }         if (config.threadNumber > 1 && charArray.length > 10000)    // 小文本多线程没意义，反而变慢了         {             List<String> sentenceList = SentencesUtil.toSentenceList(charArray);             String[] sentenceArray = new String[sentenceList.size()];             sentenceList.toArray(sentenceArray);             //noinspection unchecked             List<Term>[] termListArray = new List[sentenceArray.length];             final int per = sentenceArray.length / config.threadNumber;             WorkThread[] threadArray = new WorkThread[config.threadNumber];             for (int i = 0; i < config.threadNumber - 1; ++i)             {                 int from = i * per;                 threadArray[i] = new WorkThread(sentenceArray, termListArray, from, from + per);                 threadArray[i].start();             }             threadArray[config.threadNumber - 1] = new WorkThread(sentenceArray, termListArray, (config.threadNumber - 1) * per, sentenceArray.length);             threadArray[config.threadNumber - 1].start();             try             {                 for (WorkThread thread : threadArray)                 {                     thread.join();                 }             }             catch (InterruptedException e)             {                 logger.severe(""线程同步异常："" + TextUtility.exceptionToString(e));                 return Collections.emptyList();             }             List<Term> termList = new LinkedList<Term>();             if (config.offset || config.indexMode > 0)  // 由于分割了句子，所以需要重新校正offset             {                 int sentenceOffset = 0;                 for (int i = 0; i < sentenceArray.length; ++i)                 {                     for (Term term : termListArray[i])                     {                         term.offset += sentenceOffset;                         termList.add(term);                     }                     sentenceOffset += sentenceArray[i].length();                 }             }             else             {                 for (List<Term> list : termListArray)                 {                     termList.addAll(list);                 }             }              return termList;         } //        if (text.length() > 10000)  // 针对大文本，先拆成句子，后分词，避免内存峰值太大 //        { //            List<Term> termList = new LinkedList<Term>(); //            if (config.offset || config.indexMode) //            { //                int sentenceOffset = 0; //                for (String sentence : SentencesUtil.toSentenceList(charArray)) //                { //                    List<Term> termOfSentence = segSentence(sentence.toCharArray()); //                    for (Term term : termOfSentence) //                    { //                        term.offset += sentenceOffset; //                        termList.add(term); //                    } //                    sentenceOffset += sentence.length(); //                } //            } //            else //            { //                for (String sentence : SentencesUtil.toSentenceList(charArray)) //                { //                    termList.addAll(segSentence(sentence.toCharArray())); //                } //            } // //            return termList; //        }         return segSentence(charArray);     }
public DimensionSelector makeDimensionSelector(DimensionSpec dimensionSpec, ColumnSelectorFactory factory)   {     final VirtualColumn virtualColumn = getVirtualColumn(dimensionSpec.getDimension());     if (virtualColumn == null) {       throw new IAE(""No such virtual column[%s]"", dimensionSpec.getDimension());     } else {       final DimensionSelector selector = virtualColumn.makeDimensionSelector(dimensionSpec, factory);       Preconditions.checkNotNull(selector, ""selector"");       return selector;     }   }
private void inflateContentView() {         contentContainer = rootView.findViewById(R.id.content_container);         contentContainer.removeAllViews();          if (customView != null) {             contentContainer.setVisibility(View.VISIBLE);             contentContainer.addView(customView);         } else if (customViewId != -1) {             contentContainer.setVisibility(View.VISIBLE);             LayoutInflater layoutInflater = LayoutInflater.from(getContext());             View view = layoutInflater.inflate(customViewId, contentContainer, false);             contentContainer.addView(view);         } else {             LayoutInflater layoutInflater = LayoutInflater.from(getContext());             View view = layoutInflater                     .inflate(R.layout.bottom_sheet_grid_view, contentContainer, false);             contentContainer.addView(view);         }          showGridView();     }
public void deploy(String deploymentName, InputStream content, boolean enabled, Set<String> serverGroups,             boolean forceDeploy) {         if (serverGroups == null) {             serverGroups = Collections.emptySet();         }          DeploymentResult result = null;          try {             DeploymentManager dm = DeploymentManager.Factory.create(getModelControllerClient());             Deployment deployment = Deployment.of(content, deploymentName)                     .addServerGroups(serverGroups)                     .setEnabled(enabled);             if (forceDeploy) {                 result = dm.forceDeploy(deployment);             } else {                 result = dm.deploy(deployment);             }         } catch (Exception e) {             String errMsg;             if (serverGroups.isEmpty()) {                 errMsg = String.format(""Failed to deploy [%s] (standalone mode)"", deploymentName);             } else {                 errMsg = String.format(""Failed to deploy [%s] to server groups: %s"", deploymentName, serverGroups);             }             throw new FailureException(errMsg, e);         }          if (!result.successful()) {             String errMsg;             if (serverGroups.isEmpty()) {                 errMsg = String.format(""Failed to deploy [%s] (standalone mode)"", deploymentName);             } else {                 errMsg = String.format(""Failed to deploy [%s] to server groups [%s]"", deploymentName, serverGroups);             }             throw new FailureException(errMsg + "": "" + result.getFailureMessage());         }          return; // everything is OK     }
@Override   public void close() throws IOException {     try {       if (consumer != null && consumer instanceof Closeable) {         // Call close in a new transaction.         // TODO (terence): Actually need to coordinates with other flowlets to drain the queue.         TransactionContext txContext = dataFabricFacade.createTransactionManager();         txContext.start();         try {           ((Closeable) consumer).close();           txContext.finish();         } catch (TransactionFailureException e) {           LOG.warn(""Fail to commit transaction when closing consumer."");           txContext.abort();         }       }     } catch (Exception e) {       LOG.warn(""Fail to close queue consumer."", e);     }     consumer = null;   }
@Inline     public final int compareTo(final Composite that)     {         if (isStatic() != that.isStatic())         {             // Static sorts before non-static no matter what, except for empty which             // always sort first             if (isEmpty())                 return that.isEmpty() ? 0 : -1;             if (that.isEmpty())                 return 1;             return isStatic() ? -1 : 1;         }          int size = size();         int size2 = that.size();         int minSize = Math.min(size, size2);         int startDelta = 0;         int cellNamesOffset = nameDeltaOffset(size);         for (int i = 0 ; i < minSize ; i++)         {             int endDelta = i < size - 1 ? getShort(nameDeltaOffset(i + 1)) : valueStartOffset() - cellNamesOffset;             long offset = peer + cellNamesOffset + startDelta;             int length = endDelta - startDelta;             int cmp = FastByteOperations.UnsafeOperations.compareTo(null, offset, length, that.get(i));             if (cmp != 0)                 return cmp;             startDelta = endDelta;         }          EOC eoc = that.eoc();         if (size == size2)             return this.eoc().compareTo(eoc);          return size < size2 ? this.eoc().prefixComparisonResult : -eoc.prefixComparisonResult;     }
@Override     public boolean implies(Permission p) {         if (!(p instanceof WebSphereSecurityPermission))             return false;          WebSphereSecurityPermission that = (WebSphereSecurityPermission) p;          if (tc.isDebugEnabled()) {             Tr.debug(tc, ""Permission "" + this.max + ""impliles "" + that.max + "" = "" + (this.max > that.max));         }          return (this.max >= that.max);     }
public static void siftDown(float[] arr, int k, int n) {         while (2*k <= n) {             int j = 2 * k;             if (j < n && arr[j] < arr[j + 1]) {                 j++;             }             if (arr[k] >= arr[j]) {                 break;             }             swap(arr, k, j);             k = j;         }     }
@UiThread     public void notifyChildRemoved(int parentPosition, int childPosition) {         int flatParentPosition = getFlatParentPosition(parentPosition);         ExpandableWrapper<P, C> parentWrapper = mFlatItemList.get(flatParentPosition);         parentWrapper.setParent(mParentList.get(parentPosition));          if (parentWrapper.isExpanded()) {             mFlatItemList.remove(flatParentPosition + childPosition + 1);             notifyItemRemoved(flatParentPosition + childPosition + 1);         }     }
public void postMessage (Transport transport, String name, Object... args)     {         postEvent(new MessageEvent(_oid, name, args).setTransport(transport));     }
public static <T extends MethodDescription> ElementMatcher.Junction<T> isGenericSetter(ElementMatcher<? super TypeDescription.Generic> matcher) {         return isSetter().and(takesGenericArguments(new CollectionOneToOneMatcher<TypeDescription.Generic>(Collections.singletonList(matcher))));     }
private List<Boolean> asBooleanList(Object value) {         boolean[] values = (boolean[]) value;         List<Boolean> list = new ArrayList<Boolean>(values.length);         for (boolean booleanValue : values) {             list.add(booleanValue);         }         return list;     }
@Nonnull  public static LLongToSrtFunction longToSrtFunctionFrom(Consumer<LLongToSrtFunctionBuilder> buildingFunction) {   LLongToSrtFunctionBuilder builder = new LLongToSrtFunctionBuilder();   buildingFunction.accept(builder);   return builder.build();  }
public AbstractBuilder getPropertyBuilder(ClassWriter classWriter) {         final PropertyWriter propertyWriter =                 writerFactory.getPropertyWriter(classWriter);         return PropertyBuilder.getInstance(context,                                            classWriter.getTypeElement(),                                            propertyWriter);     }
public static crvserver_crpolicy_binding[] get(nitro_service service, String name) throws Exception{   crvserver_crpolicy_binding obj = new crvserver_crpolicy_binding();   obj.set_name(name);   crvserver_crpolicy_binding response[] = (crvserver_crpolicy_binding[]) obj.get_resources(service);   return response;  }
public boolean hasDirectory(final String name) throws IOException    {       return SecurityHelper.doPrivilegedIOExceptionAction(new PrivilegedExceptionAction<Boolean>()       {          public Boolean run() throws Exception          {             return new File(baseDir, name).exists();           }       });    }
public static String md5Encode(String strIn) {          try {              MessageDigest md5 = MessageDigest.getInstance(""md5"");              byte[] bin = toBytes(strIn);              byte[] bout = md5.digest(bin);              String strOut = javax.xml.bind.DatatypeConverter.printBase64Binary(bout);              return strOut;          }catch (Exception e) {              throw new RuntimeException(e.getMessage(), e);          }      }
public Observable<Page<VirtualNetworkTapInner>> listByResourceGroupNextAsync(final String nextPageLink) {         return listByResourceGroupNextWithServiceResponseAsync(nextPageLink)             .map(new Func1<ServiceResponse<Page<VirtualNetworkTapInner>>, Page<VirtualNetworkTapInner>>() {                 @Override                 public Page<VirtualNetworkTapInner> call(ServiceResponse<Page<VirtualNetworkTapInner>> response) {                     return response.body();                 }             });     }
public CountDownLatch requestJoin(final long joiningSite) throws Exception {         final CountDownLatch cdl = new CountDownLatch(1);         final Runnable r = new Runnable() {             @Override             public void run() {                 try {                     final long txnId = m_idManager.getNextUniqueTransactionId();                      for (long initiatorHSId : m_hsIds) {                         if (initiatorHSId == m_hsId) continue;                         JSONObject jsObj = new JSONObject();                         jsObj.put(""txnId"", txnId);                         jsObj.put(""initiatorHSId"", m_hsId);                         jsObj.put(""joiningHSId"", joiningSite);                         jsObj.put(""lastSafeTxnId"", m_safetyState.getNewestSafeTxnIdForExecutorBySiteId(initiatorHSId));                         byte payload[] = jsObj.toString(4).getBytes(""UTF-8"");                         ByteBuffer metadata = ByteBuffer.allocate(1);                         metadata.put(BINARY_PAYLOAD_JOIN_REQUEST);                         BinaryPayloadMessage bpm = new BinaryPayloadMessage(metadata.array(), payload);                         m_mailbox.send( initiatorHSId, bpm);                     }                      m_txnQueue.noteTransactionRecievedAndReturnLastSeen(m_hsId,                             txnId,                             m_safetyState.getNewestGloballySafeTxnId());                      AgreementRejoinTransactionState arts =                         new AgreementRejoinTransactionState( txnId, m_hsId, joiningSite, cdl );                      if (!m_txnQueue.add(arts)) {                         org.voltdb.VoltDB.crashLocalVoltDB(""Shouldn't have failed to add txn"", true, null);                     }                     m_transactionsById.put(arts.txnId, arts);                 } catch (Throwable e) {                     org.voltdb.VoltDB.crashLocalVoltDB(""Error constructing JSON"", false, e);                 }             }         };         LocalObjectMessage lom = new LocalObjectMessage(r);         lom.m_sourceHSId = m_hsId;         m_mailbox.deliver(lom);         return cdl;     }
@XmlElementDecl(namespace = ""http://www.opengis.net/citygml/tunnel/2.0"", name = ""IntTunnelInstallation"", substitutionHeadNamespace = ""http://www.opengis.net/citygml/2.0"", substitutionHeadName = ""_CityObject"")     public JAXBElement<IntTunnelInstallationType> createIntTunnelInstallation(IntTunnelInstallationType value) {         return new JAXBElement<IntTunnelInstallationType>(_IntTunnelInstallation_QNAME, IntTunnelInstallationType.class, null, value);     }
public static void removeEntry(File zip, String path, File destZip) {     removeEntries(zip, new String[] { path }, destZip);   }
public final void ruleArrayBrackets() throws RecognitionException {            int stackSize = keepStackSize();                   try {             // InternalXbase.g:1629:2: ( ( ( rule__ArrayBrackets__Group__0 ) ) )             // InternalXbase.g:1630:2: ( ( rule__ArrayBrackets__Group__0 ) )             {             // InternalXbase.g:1630:2: ( ( rule__ArrayBrackets__Group__0 ) )             // InternalXbase.g:1631:3: ( rule__ArrayBrackets__Group__0 )             {             if ( state.backtracking==0 ) {                before(grammarAccess.getArrayBracketsAccess().getGroup());              }             // InternalXbase.g:1632:3: ( rule__ArrayBrackets__Group__0 )             // InternalXbase.g:1632:4: rule__ArrayBrackets__Group__0             {             pushFollow(FOLLOW_2);             rule__ArrayBrackets__Group__0();              state._fsp--;             if (state.failed) return ;              }              if ( state.backtracking==0 ) {                after(grammarAccess.getArrayBracketsAccess().getGroup());              }              }               }          }         catch (RecognitionException re) {             reportError(re);             recover(input,re);         }         finally {               restoreStackSize(stackSize);          }         return ;     }
public double distance(Vector2D vector2d) {   double a = vector2d.x - x;   double b = vector2d.y - y;   return Math.sqrt(a * a + b * b);  }
public static HashValue murmurhash3_x64_128(final byte[] key, final int offset, final int len, final int seed) {   // The original algorithm does have a 32 bit unsigned seed.   // We have to mask to match the behavior of the unsigned types and prevent sign extension.   long h1 = seed & 0x00000000FFFFFFFFL;   long h2 = seed & 0x00000000FFFFFFFFL;    final long c1 = 0x87c37b91114253d5L;   final long c2 = 0x4cf5ad432745937fL;    int roundedEnd = offset + (len & 0xFFFFFFF0);  // round down to 16 byte block   for (int i = offset; i < roundedEnd; i += 16) {    long k1 = getLongLittleEndian(key, i);    long k2 = getLongLittleEndian(key, i + 8);    k1 *= c1;    k1 = Long.rotateLeft(k1, 31);    k1 *= c2;    h1 ^= k1;    h1 = Long.rotateLeft(h1, 27);    h1 += h2;    h1 = h1 * 5 + 0x52dce729;    k2 *= c2;    k2 = Long.rotateLeft(k2, 33);    k2 *= c1;    h2 ^= k2;    h2 = Long.rotateLeft(h2, 31);    h2 += h1;    h2 = h2 * 5 + 0x38495ab5;   }    long k1 = 0;   long k2 = 0;    switch (len & 15) {    case 15:     k2 = (key[roundedEnd + 14] & 0xffL) << 48;    case 14:     k2 |= (key[roundedEnd + 13] & 0xffL) << 40;    case 13:     k2 |= (key[roundedEnd + 12] & 0xffL) << 32;    case 12:     k2 |= (key[roundedEnd + 11] & 0xffL) << 24;    case 11:     k2 |= (key[roundedEnd + 10] & 0xffL) << 16;    case 10:     k2 |= (key[roundedEnd + 9] & 0xffL) << 8;    case 9:     k2 |= (key[roundedEnd + 8] & 0xffL);     k2 *= c2;     k2 = Long.rotateLeft(k2, 33);     k2 *= c1;     h2 ^= k2;    case 8:     k1 = ((long) key[roundedEnd + 7]) << 56;    case 7:     k1 |= (key[roundedEnd + 6] & 0xffL) << 48;    case 6:     k1 |= (key[roundedEnd + 5] & 0xffL) << 40;    case 5:     k1 |= (key[roundedEnd + 4] & 0xffL) << 32;    case 4:     k1 |= (key[roundedEnd + 3] & 0xffL) << 24;    case 3:     k1 |= (key[roundedEnd + 2] & 0xffL) << 16;    case 2:     k1 |= (key[roundedEnd + 1] & 0xffL) << 8;    case 1:     k1 |= (key[roundedEnd] & 0xffL);     k1 *= c1;     k1 = Long.rotateLeft(k1, 31);     k1 *= c2;     h1 ^= k1;   }    //----------   // finalization    h1 ^= len;   h2 ^= len;    h1 += h2;   h2 += h1;    h1 = fmix64(h1);   h2 = fmix64(h2);    h1 += h2;   h2 += h1;    return new HashValue(h1, h2);  }
public FeatureList selectOverlapping(String seqname, Location location, boolean useBothStrands)    throws Exception {   FeatureList list = new FeatureList();    for (FeatureI feature : this) {    boolean overlaps = false;    if (feature.seqname().equals(seqname)) {     if (location.isSameStrand(feature.location())) {      overlaps = feature.location().overlaps(location);     } else if (useBothStrands) {      overlaps = feature.location().overlaps(location.opposite());     }    }    if (overlaps) {     list.add(feature);    }   }   return list;  }
public List<GitFileSystemObject> getChildren() throws IOException, JavaGitException {     List<GitFileSystemObject> children = new ArrayList<GitFileSystemObject>();      // get all of the file system objects currently located under this directory     for (File memberFile : file.listFiles()) {       // check if this file is hidden also some times the .git and        //other unix hidden directories are not hidden in Windows       if (memberFile.isHidden()||memberFile.getName().startsWith(""."")) {         // ignore (could be .git directory)         continue;       }        // now, just check for the type of the filesystem object       if (memberFile.isDirectory()) {         children.add(new GitDirectory(memberFile, workingTree));       } else {         children.add(new GitFile(memberFile, workingTree));       }     }      return children;   }
static RollupStats getOrNull(Vec vec, final Key rskey ) {     Value val = DKV.get(rskey);     if( val == null )           // No rollup stats present?       return vec.length() > 0 ? /*not computed*/null : /*empty vec*/new RollupStats(0);     RollupStats rs = val.get(RollupStats.class);     return rs.isReady() ? rs : null;   }
@Override   protected Iterator<T> search(final IndexSearcher searcher, final Query query) throws IOException {     // grow the bit set if needed     docIds.set(searcher.getIndexReader().maxDoc());     // clear it     docIds.clear();     searcher.search(query, new Collector() {       private int docBase;        @Override       public void setScorer(Scorer scorer) {       }        @Override       public boolean acceptsDocsOutOfOrder() {         return true;       }        @Override       public void collect(int doc) {         docIds.set(doc + docBase);       }        public void setNextReader(AtomicReaderContext context) {         this.docBase = context.docBase;       }     });      return new AbstractIterator<T>() {       private int doc = docIds.nextSetBit(0);        @Override       protected T computeNext() {         ((Progressable)context).progress(); // casting to avoid Hadoop 2 incompatibility         if (doc < 0) {           return endOfData();         }         try {           T ret = docToValue(searcher.doc(doc));           doc = docIds.nextSetBit(doc + 1);           return  ret;         } catch (IOException e) {           throw new RuntimeException(e);         }       }     };   }
public Recommender buildRecommender(final DataModel dataModel,             final String recType,             final String similarityType,             final int neighborhoodSize,             final int factors,             final int iterations,             final String facType)             throws RecommenderException {         String neighborhoodType = ""org.apache.mahout.cf.taste.impl.neighborhood.NearestNUserNeighborhood"";         Object simObj = null;         /**          * Instantiate similarity class          */         if (similarityType != null) {             Class<?> similarityClass = null;             try {                 similarityClass = Class.forName(similarityType);                 simObj = similarityClass.getConstructor(DataModel.class).newInstance(dataModel);             } catch (ClassNotFoundException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Similarity class "" + e.getMessage());             } catch (IllegalAccessException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Similarity class "" + e.getMessage());             } catch (IllegalArgumentException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Similarity class "" + e.getMessage());             } catch (InstantiationException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Similarity class "" + e.getMessage());             } catch (InvocationTargetException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Similarity class "" + e.getMessage());             } catch (NoSuchMethodException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Similarity class "" + e.getMessage());             } catch (SecurityException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Similarity class "" + e.getMessage());             }         }         /**          * Instantiate neighborhood class          */         Object neighObj = null;         if (neighborhoodSize != NO_N) {             Class<?> neighborhoodClass = null;             try {                 neighborhoodClass = Class.forName(neighborhoodType);                 neighObj = neighborhoodClass.getConstructor(int.class, UserSimilarity.class, DataModel.class).newInstance(neighborhoodSize, simObj, dataModel);             } catch (ClassNotFoundException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Neighborhood class "" + e.getMessage());             } catch (IllegalAccessException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Neighborhood class "" + e.getMessage());             } catch (IllegalArgumentException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Neighborhood class "" + e.getMessage());             } catch (InstantiationException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Neighborhood class "" + e.getMessage());             } catch (InvocationTargetException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Neighborhood class "" + e.getMessage());             } catch (NoSuchMethodException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Neighborhood class "" + e.getMessage());             } catch (SecurityException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Neighborhood class "" + e.getMessage());             }         }         /**          * Instantiate factorizer class          */         if (facType != null) {             Class<?> factorizerClass = null;             try {                 factorizerClass = Class.forName(facType);                 simObj = factorizerClass.getConstructor(DataModel.class, int.class, int.class).newInstance(dataModel, factors, iterations);             } catch (ClassNotFoundException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Factorizer "" + e.getMessage());             } catch (IllegalAccessException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Factorizer "" + e.getMessage());             } catch (IllegalArgumentException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Factorizer "" + e.getMessage());             } catch (InstantiationException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Factorizer "" + e.getMessage());             } catch (InvocationTargetException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Factorizer "" + e.getMessage());             } catch (NoSuchMethodException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Factorizer "" + e.getMessage());             } catch (SecurityException e) {                 e.printStackTrace();                 throw new RecommenderException(""Could not create Factorizer "" + e.getMessage());             }         }         /**          * Instantiate recommender class          */         final Class<?> recommenderClass;         try {             recommenderClass = Class.forName(recType);         } catch (ClassNotFoundException e) {             throw new RecommenderException(""Could not create Recommender class "" + e.getMessage());         }         final Object recObj;         try {             if (facType != null) {                 recObj = recommenderClass.getConstructor(DataModel.class, Factorizer.class).newInstance(dataModel, (Factorizer) simObj);             } else if (recType.contains(""UserBased"")) {                 // user-based similarity with neighborhood                 recObj = recommenderClass.getConstructor(DataModel.class, UserNeighborhood.class, UserSimilarity.class).newInstance(dataModel, neighObj, simObj);             } else if (similarityType != null) {                 // item-based similarity, no neighborhood                 recObj = recommenderClass.getConstructor(DataModel.class, ItemSimilarity.class).newInstance(dataModel, simObj);             } else {                 recObj = recommenderClass.getConstructor(DataModel.class).newInstance(dataModel);             }         } catch (IllegalAccessException e) {             throw new RecommenderException(""Could not create Recommender: "" + e.getMessage());         } catch (IllegalArgumentException e) {             throw new RecommenderException(""Could not create Recommender: "" + e.getMessage());         } catch (InstantiationException e) {             throw new RecommenderException(""Could not create Recommender: "" + e.getMessage());         } catch (InvocationTargetException e) {             throw new RecommenderException(""Could not create Recommender: "" + e.getMessage());         } catch (NoSuchMethodException e) {             throw new RecommenderException(""Could not create Recommender: "" + e.getMessage());         } catch (SecurityException e) {             throw new RecommenderException(""Could not create Recommender: "" + e.getMessage());         }         return (Recommender) recObj;     }
public static CPDAvailabilityEstimate[] findByUuid_C_PrevAndNext(   long CPDAvailabilityEstimateId, String uuid, long companyId,   OrderByComparator<CPDAvailabilityEstimate> orderByComparator)   throws com.liferay.commerce.exception.NoSuchCPDAvailabilityEstimateException {   return getPersistence()        .findByUuid_C_PrevAndNext(CPDAvailabilityEstimateId, uuid,    companyId, orderByComparator);  }
public void destroySubcontext(Name name)             throws NamingException {         if (_nc == null)             throw IIOPLogger.ROOT_LOGGER.notANamingContext(name.toString());         NamingContext the_nc = _nc;         NameComponent[] path = org.wildfly.iiop.openjdk.naming.jndi.CNNameParser.nameToCosName(name);         if (name.size() > 0) {             try {                 javax.naming.Context ctx =                         (javax.naming.Context) callResolve(path);                 CNCtx cnc = (CNCtx) ctx;                 the_nc = cnc._nc;                 cnc.close(); //remove the reference to the context             } catch (ClassCastException e) {                 throw new NotContextException(name.toString());             } catch (CannotProceedException e) {                 javax.naming.Context cctx = getContinuationContext(e);                 cctx.destroySubcontext(e.getRemainingName());                 return;             } catch (NameNotFoundException e) {                 // If leaf is the one missing, return success                 // as per JNDI spec                  if (e.getRootCause() instanceof NotFound &&                         leafNotFound((NotFound) e.getRootCause(),                                 path[path.length - 1])) {                     return; // leaf missing OK                 }                 throw e;             } catch (NamingException e) {                 throw e;             }         }         callDestroy(the_nc);         callUnbind(path);     }
@Nonnull   @Nonempty   public static String getObjectAddress (@Nullable final Object aObject)   {     if (aObject == null)       return ""0x00000000"";     return ""0x"" + StringHelper.getHexStringLeadingZero (System.identityHashCode (aObject), 8);   }
private synchronized void emitRecords() throws IOException {      for (String recordName : bufferedData.keySet()) {        RecordMap recordMap = bufferedData.get(recordName);        synchronized (recordMap) {          Set<Entry<TagMap, MetricMap>> entrySet = recordMap.entrySet ();          for (Entry<TagMap, MetricMap> entry : entrySet) {            OutputRecord outRec = new OutputRecord(entry.getKey(), entry.getValue());            emitRecord(contextName, recordName, outRec);          }        }      }      flush();    }
public static HystrixCommandMetrics getInstance(HystrixCommandKey key, HystrixCommandGroupKey commandGroup, HystrixCommandProperties properties) {         return getInstance(key, commandGroup, null, properties);     }
public <C extends Collection<T>> Map<Boolean, C> partitioningTo(Predicate<? super T> predicate,             Supplier<C> collectionFactory) {         return collect(Collectors.partitioningBy(predicate, Collectors.toCollection(collectionFactory)));     }
static void overwrite(StringBuffer sb, int pos, String s) {         int len = s.length();         for (int i = 0; i < len; i++) {             sb.setCharAt(pos + i, s.charAt(i));         }     }
public static OutputAccessor from(ByteBuffer byteBuffer) {          ByteBufferOutputAccessor accessor = new ByteBufferOutputAccessor();         accessor.byteBuffer = byteBuffer;          return accessor;     }
public static Font createFont(File fontFile) {    try {     return Font.createFont(Font.TRUETYPE_FONT, fontFile);    } catch (FontFormatException e) {     // True Type字体无效时使用Type1字体     try {      return Font.createFont(Font.TYPE1_FONT, fontFile);     } catch (Exception e1) {      throw new UtilException(e);     }    } catch (IOException e) {     throw new IORuntimeException(e);    }   }
protected void appendDefType(SolrQuery solrQuery, @Nullable String defType) {   if (StringUtils.isNotBlank(defType)) {    solrQuery.set(""defType"", defType);   }  }
public String htmlPool(String pool) throws Exception {          StringBuffer html = new StringBuffer(256);          html.append(""<a href=\""javascript:switchview('"").append(pool).append(""');\"">"");         html.append(pool).append(""</a><br>\n"");         html.append(""\t<div id='"").append(pool).append(""' style='display: none;'>\n"");         html.append(""\t\t<table border='0'>\n"");         html.append(""\t\t\t<tr><td>JDBC Driver:</td><td>"" + getDbDriver(pool) + ""</td></tr>\n"");         html.append(""\t\t\t<tr><td>JDBC Connection Url:</td><td>"" + getDbUrl(pool) + ""</td></tr>\n"");         html.append(""\t\t\t<tr><td>JDBC Connection Url Params:</td><td>"" + getDbParams(pool) + ""</td></tr>\n"");         html.append(""\t\t\t<tr><td>Database User:</td><td>"" + getDbUser(pool) + ""</td></tr>\n"");         html.append(""\t\t</table>\n"");         html.append(""\t</div>\n"");          return html.toString();     }
private String getClassLabel(EntityIdValue entityIdValue) {   ClassRecord classRecord = this.classRecords.get(entityIdValue);   String label;   if (classRecord == null || classRecord.itemDocument == null) {    label = entityIdValue.getId();   } else {    label = getLabel(entityIdValue, classRecord.itemDocument);   }    EntityIdValue labelOwner = this.labels.get(label);   if (labelOwner == null) {    this.labels.put(label, entityIdValue);    return label;   } else if (labelOwner.equals(entityIdValue)) {    return label;   } else {    return label + "" ("" + entityIdValue.getId() + "")"";   }  }
public void assignAmounts(XTrace trace, Map<String, Double> amounts) {    XCostAmount.instance().assignValues(trace, amounts);   }
private void setFilePosition(FileWindow w, int line) {         boolean activate = true;         JTextArea ta = w.textArea;         try {             if (line == -1) {                 w.setPosition(-1);                 if (currentWindow == w) {                     currentWindow = null;                 }             } else {                 int loc = ta.getLineStartOffset(line-1);                 if (currentWindow != null && currentWindow != w) {                     currentWindow.setPosition(-1);                 }                 w.setPosition(loc);                 currentWindow = w;             }         } catch (BadLocationException exc) {             // fix me         }         if (activate) {             if (w.isIcon()) {                 desk.getDesktopManager().deiconifyFrame(w);             }             desk.getDesktopManager().activateFrame(w);             try {                 w.show();                 w.toFront();  // required for correct frame layering (JDK 1.4.1)                 w.setSelected(true);             } catch (Exception exc) {             }         }     }
public static void writeJsonValue(JsonWriter writer, Node node, String name, Object value,                                       Integer type, MappingRules mapping)             throws RepositoryException, IOException {         Value jcrValue = value instanceof Value ? (Value) value : null;         switch (type) {             case PropertyType.BINARY:                 if (node != null && jcrValue != null) {                     if (mapping.propertyFormat.binary == MappingRules.PropertyFormat.Binary.link) {                         String uri = ""/bin/cpm/nodes/property.bin""                                 + LinkUtil.encodePath(node.getPath())                                 + ""?name="" + LinkUtil.encodePath(name);                         boolean htmlSafe = writer.isHtmlSafe();                         writer.setHtmlSafe(false);                         writer.value(uri);                         writer.setHtmlSafe(htmlSafe);                     } else if (mapping.propertyFormat.binary == MappingRules.PropertyFormat.Binary.base64) {                         Binary binary = jcrValue.getBinary();                         byte[] buffer = IOUtils.toByteArray(binary.getStream());                         String encoded = Base64.encodeBase64String(buffer);                         writer.value(getValueString(encoded, type, mapping));                     } else {                         writer.nullValue();                     }                 } else {                     writer.nullValue();                 }                 break;             case PropertyType.BOOLEAN:                 writer.value(jcrValue != null ? jcrValue.getBoolean()                         : (value instanceof Boolean ? (Boolean) value : Boolean.valueOf(value.toString())));                 break;             case PropertyType.DATE:                 Calendar cal = jcrValue != null ? jcrValue.getDate()                         : (value instanceof Calendar ? (Calendar) value : null);                 if (cal != null) {                     SimpleDateFormat dateFormat = new SimpleDateFormat(MappingRules.MAP_DATE_FORMAT);                     dateFormat.setTimeZone(cal.getTimeZone());                     writer.value(getValueString(dateFormat.format(cal.getTime()), type, mapping));                 }                 break;             case PropertyType.DECIMAL:                 writer.value(getValueString(jcrValue != null                         ? jcrValue.getDecimal() : (value instanceof BigDecimal ? (BigDecimal) value                         : new BigDecimal(value.toString())), type, mapping));                 break;             case PropertyType.DOUBLE:                 writer.value(getValueString(jcrValue != null                         ? jcrValue.getDouble() : (value instanceof Double ? (Double) value                         : Double.valueOf(value.toString())), type, mapping));                 break;             case PropertyType.LONG:                 writer.value(jcrValue != null ? jcrValue.getLong()                         : (value instanceof Long ? (Long) value : Long.valueOf(value.toString())));                 break;             case PropertyType.NAME:             case PropertyType.PATH:             case PropertyType.REFERENCE:             case PropertyType.STRING:             case PropertyType.URI:             case PropertyType.WEAKREFERENCE:                 writer.value(getValueString(jcrValue != null                         ? jcrValue.getString() : value.toString(), type, mapping));                 break;             case PropertyType.UNDEFINED:                 writer.nullValue();                 break;         }     }
public final void setTimeRange (final Calendar rangeStartingCalendar, final Calendar rangeEndingCalendar)   {     setTimeRange (rangeStartingCalendar.get (Calendar.HOUR_OF_DAY),                   rangeStartingCalendar.get (Calendar.MINUTE),                   rangeStartingCalendar.get (Calendar.SECOND),                   rangeStartingCalendar.get (Calendar.MILLISECOND),                   rangeEndingCalendar.get (Calendar.HOUR_OF_DAY),                   rangeEndingCalendar.get (Calendar.MINUTE),                   rangeEndingCalendar.get (Calendar.SECOND),                   rangeEndingCalendar.get (Calendar.MILLISECOND));   }
public List<MessageDestinationRefType<WebFragmentDescriptor>> getAllMessageDestinationRef()    {       List<MessageDestinationRefType<WebFragmentDescriptor>> list = new ArrayList<MessageDestinationRefType<WebFragmentDescriptor>>();       List<Node> nodeList = model.get(""message-destination-ref"");       for(Node node: nodeList)       {          MessageDestinationRefType<WebFragmentDescriptor>  type = new MessageDestinationRefTypeImpl<WebFragmentDescriptor>(this, ""message-destination-ref"", model, node);          list.add(type);       }       return list;    }
@Override     public Object visitNegation(ExcellentParser.NegationContext ctx) {         return Conversions.toDecimal(visit(ctx.expression()), m_evalContext).negate();     }
public void setType(String type) throws PageException {  if (type == null) return;  try {      this.type = toType(type);  }  catch (SearchException e) {      throw Caster.toPageException(e);  }     }
public static String subjectToString(final Subject subject) {          final String result;          if (subject == null) {              result = ""null"";          } else {              StringBuffer buffer = new StringBuffer(""["");             buffer.append(subject.getClass().getName());             buffer.append(""@"");             buffer                             .append(Integer.toHexString(System                                             .identityHashCode(subject)));             buffer.append("" <principals="");             buffer.append(subject.getPrincipals());             buffer.append("">]"");             result = buffer.toString();          }          return result;      }
public Long addSubscriberLocationReportRequest(LCSEvent lcsEvent, LCSClientID lcsClientID, LCSLocationInfo lcsLocationInfo,             ISDNAddressString msisdn, IMSI imsi, IMEI imei, ISDNAddressString naEsrd, ISDNAddressString naEsrk,             ExtGeographicalInformation locationEstimate, Integer ageOfLocationEstimate,             SLRArgExtensionContainer slrArgExtensionContainer, AddGeographicalInformation addLocationEstimate,             DeferredmtlrData deferredmtlrData, Integer lcsReferenceNumber, PositioningDataInformation geranPositioningData,             UtranPositioningDataInfo utranPositioningData, CellGlobalIdOrServiceAreaIdOrLAI cellIdOrSai,             GSNAddress hgmlcAddress, Integer lcsServiceTypeID, boolean saiPresent, boolean pseudonymIndicator,             AccuracyFulfilmentIndicator accuracyFulfilmentIndicator, VelocityEstimate velocityEstimate, Integer sequenceNumber,             PeriodicLDRInfo periodicLDRInfo, boolean moLrShortCircuitIndicator,             GeranGANSSpositioningData geranGANSSpositioningData, UtranGANSSpositioningData utranGANSSpositioningData,             ServingNodeAddress targetServingNodeForHandover) throws MAPException {         return this.addSubscriberLocationReportRequest(_Timer_Default, lcsEvent, lcsClientID, lcsLocationInfo, msisdn, imsi,                 imei, naEsrd, naEsrk, locationEstimate, ageOfLocationEstimate, slrArgExtensionContainer, addLocationEstimate,                 deferredmtlrData, lcsReferenceNumber, geranPositioningData, utranPositioningData, cellIdOrSai, hgmlcAddress,                 lcsServiceTypeID, saiPresent, pseudonymIndicator, accuracyFulfilmentIndicator, velocityEstimate,                 sequenceNumber, periodicLDRInfo, moLrShortCircuitIndicator, geranGANSSpositioningData,                 utranGANSSpositioningData, targetServingNodeForHandover);     }
public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass) {         return reflectionEquals(lhs, rhs, testTransients, reflectUpToClass, null);     }
public static List<JSModule> createJsModules(List<JsModuleSpec> specs, List<SourceFile> inputs)       throws IOException {     checkState(specs != null);     checkState(!specs.isEmpty());     checkState(inputs != null);      List<String> moduleNames = new ArrayList<>(specs.size());     Map<String, JSModule> modulesByName = new LinkedHashMap<>();     Map<String, Integer> modulesFileCountMap = new LinkedHashMap<>();     int numJsFilesExpected = 0;     int minJsFilesRequired = 0;     for (JsModuleSpec spec : specs) {       if (modulesByName.containsKey(spec.name)) {         throw new FlagUsageException(""Duplicate module name: "" + spec.name);       }       JSModule module = new JSModule(spec.name);        for (String dep : spec.deps) {         JSModule other = modulesByName.get(dep);         if (other == null) {           throw new FlagUsageException(               ""Module '""                   + spec.name                   + ""' depends on unknown module '""                   + dep                   + ""'. Be sure to list modules in dependency order."");         }         module.addDependency(other);       }        // We will allow modules of zero input.       if (spec.numJsFiles < 0) {         numJsFilesExpected = -1;       } else {         minJsFilesRequired += spec.numJsFiles;       }        if (numJsFilesExpected >= 0) {         numJsFilesExpected += spec.numJsFiles;       }        // Add modules in reverse order so that source files are allocated to       // modules in reverse order. This allows the first module       // (presumably the base module) to have a size of 'auto'       moduleNames.add(0, spec.name);       modulesFileCountMap.put(spec.name, spec.numJsFiles);       modulesByName.put(spec.name, module);     }      final int totalNumJsFiles = inputs.size();      if (numJsFilesExpected >= 0 || minJsFilesRequired > totalNumJsFiles) {       if (minJsFilesRequired > totalNumJsFiles) {         numJsFilesExpected = minJsFilesRequired;       }        if (numJsFilesExpected > totalNumJsFiles) {         throw new FlagUsageException(             ""Not enough JS files specified. Expected ""                 + numJsFilesExpected                 + "" but found ""                 + totalNumJsFiles);       } else if (numJsFilesExpected < totalNumJsFiles) {         throw new FlagUsageException(             ""Too many JS files specified. Expected ""                 + numJsFilesExpected                 + "" but found ""                 + totalNumJsFiles);       }     }      int numJsFilesLeft = totalNumJsFiles;     int moduleIndex = 0;     for (String moduleName : moduleNames) {       // Parse module inputs.       int numJsFiles = modulesFileCountMap.get(moduleName);       JSModule module = modulesByName.get(moduleName);        // Check if the first js module specified 'auto' for the number of files       if (moduleIndex == moduleNames.size() - 1 && numJsFiles == -1) {         numJsFiles = numJsFilesLeft;       }        List<SourceFile> moduleFiles = inputs.subList(numJsFilesLeft - numJsFiles, numJsFilesLeft);       for (SourceFile input : moduleFiles) {         module.add(input);       }       numJsFilesLeft -= numJsFiles;       moduleIndex++;     }      return new ArrayList<>(modulesByName.values());   }
public SftpClientBuilder sessionConfigs(Map<String, String> sessionConfigs) {         endpoint.getEndpointConfiguration().setSessionConfigs(sessionConfigs);         return this;     }
protected Tree<FeatureStructure> populateTree(JCas jcas) {   Tree<FeatureStructure> tree = new Tree<FeatureStructure>(jcas.getDocumentAnnotationFs());   for (TOP a : JCasUtil.select(jcas, annotationTypes.get(0))) {    tree.add(populateTree(jcas, a, 1));   }   return tree;   }
private static Optional<String> getMethodReturnValueName(ConstraintViolation<?> violation) {         int returnValueNames = -1;          final StringBuilder result = new StringBuilder(""server response"");         for (Path.Node node : violation.getPropertyPath()) {             if (node.getKind().equals(ElementKind.RETURN_VALUE)) {                 returnValueNames = 0;             } else if (returnValueNames >= 0) {                 result.append(returnValueNames++ == 0 ? "" "" : ""."").append(node);             }         }          return returnValueNames >= 0 ? Optional.of(result.toString()) : Optional.empty();     }
public void setDeploymentJobs(java.util.Collection<DeploymentJob> deploymentJobs) {         if (deploymentJobs == null) {             this.deploymentJobs = null;             return;         }          this.deploymentJobs = new java.util.ArrayList<DeploymentJob>(deploymentJobs);     }
public ResolvableType getGeneric(int... indexes) {         try {             if (indexes == null || indexes.length == 0) {                 return getGenerics()[0];             }             ResolvableType generic = this;             for (int index : indexes) {                 generic = generic.getGenerics()[index];             }             return generic;         } catch (IndexOutOfBoundsException ex) {             return NONE;         }     }
public static CopticCalendar of(         int cyear,         int cmonth,         int cdom     ) {          if (!CALSYS.isValid(CopticEra.ANNO_MARTYRUM, cyear, cmonth, cdom)) {             throw new IllegalArgumentException(                 ""Invalid Coptic date: year="" + cyear + "", month="" + cmonth + "", day="" + cdom);         }          return new CopticCalendar(cyear, cmonth, cdom);      }
public <T> Consumer<T> wrap(Throwing.Consumer<T> consumer) {   return val -> {    try {     consumer.accept(val);    } catch (Throwable e) {     handler.accept(e);    }   };  }
public ImmutableList<EscapingMode> getEscapingModesForNode(SoyNode node) {     ImmutableList<EscapingMode> modes = nodeToEscapingModes.get(node);     if (modes == null) {       modes = ImmutableList.of();     }     return modes;   }
String concatIconTitles(String main, String secondary) {          if (main == null) {             main = """";         }         if (secondary == null) {             secondary = """";         }          if (secondary.length() == 0) {             return main;         }         return main + "" ["" + secondary + ""]"";      }
private Expr parseMultiplicativeExpression(EnclosingScope scope, boolean terminated) {   int start = index;   Expr lhs = parseAccessExpression(scope, terminated);    Token lookahead = tryAndMatch(terminated, Star, RightSlash, Percent);   if (lookahead != null) {    Expr rhs = parseAccessExpression(scope, terminated);    switch (lookahead.kind) {    case Star:     lhs = new Expr.IntegerMultiplication(Type.Void, lhs, rhs);     break;    case RightSlash:     lhs = new Expr.IntegerDivision(Type.Void, lhs, rhs);     break;    case Percent:     lhs = new Expr.IntegerRemainder(Type.Void, lhs, rhs);     break;    default:     throw new RuntimeException(""deadcode""); // dead-code    }    lhs = annotateSourceLocation(lhs, start);   }    return lhs;  }
private void putFrame() {     final int numLocal = currentFrame[1];     final int numStack = currentFrame[2];     if (symbolTable.getMajorVersion() < Opcodes.V1_6) {       // Generate a StackMap attribute entry, which are always uncompressed.       stackMapTableEntries.putShort(currentFrame[0]).putShort(numLocal);       putAbstractTypes(3, 3 + numLocal);       stackMapTableEntries.putShort(numStack);       putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);       return;     }     final int offsetDelta =         stackMapTableNumberOfEntries == 0             ? currentFrame[0]             : currentFrame[0] - previousFrame[0] - 1;     final int previousNumlocal = previousFrame[1];     final int numLocalDelta = numLocal - previousNumlocal;     int type = Frame.FULL_FRAME;     if (numStack == 0) {       switch (numLocalDelta) {         case -3:         case -2:         case -1:           type = Frame.CHOP_FRAME;           break;         case 0:           type = offsetDelta < 64 ? Frame.SAME_FRAME : Frame.SAME_FRAME_EXTENDED;           break;         case 1:         case 2:         case 3:           type = Frame.APPEND_FRAME;           break;         default:           // Keep the FULL_FRAME type.           break;       }     } else if (numLocalDelta == 0 && numStack == 1) {       type =           offsetDelta < 63               ? Frame.SAME_LOCALS_1_STACK_ITEM_FRAME               : Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;     }     if (type != Frame.FULL_FRAME) {       // Verify if locals are the same as in the previous frame.       int frameIndex = 3;       for (int i = 0; i < previousNumlocal && i < numLocal; i++) {         if (currentFrame[frameIndex] != previousFrame[frameIndex]) {           type = Frame.FULL_FRAME;           break;         }         frameIndex++;       }     }     switch (type) {       case Frame.SAME_FRAME:         stackMapTableEntries.putByte(offsetDelta);         break;       case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME:         stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);         putAbstractTypes(3 + numLocal, 4 + numLocal);         break;       case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:         stackMapTableEntries             .putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)             .putShort(offsetDelta);         putAbstractTypes(3 + numLocal, 4 + numLocal);         break;       case Frame.SAME_FRAME_EXTENDED:         stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);         break;       case Frame.CHOP_FRAME:         stackMapTableEntries             .putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta)             .putShort(offsetDelta);         break;       case Frame.APPEND_FRAME:         stackMapTableEntries             .putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta)             .putShort(offsetDelta);         putAbstractTypes(3 + previousNumlocal, 3 + numLocal);         break;       case Frame.FULL_FRAME:       default:         stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(numLocal);         putAbstractTypes(3, 3 + numLocal);         stackMapTableEntries.putShort(numStack);         putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);         break;     }   }
public static String computeGrantFormsHash(Document xml) throws Exception {   XPathExecutor executor = new XPathExecutor(null);   executor.setDoc(xml);   GrantApplicationXpath xpath = new GrantApplicationXpath(null);   xpath.setExecutor(executor);   return _hash(xpath);  }
public void addHttpSessionListener(ArrayList al, String j2eeName) {         if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_CORE.isLoggable(Level.FINE)) {             LoggingUtil.SESSION_LOGGER_CORE.entering(methodClassName, methodNames[ADD_HTTP_SESSION_LISTENER], ""addHttpSessionListener:"" + al);         }         if (j2eeName != null) {             addToJ2eeNameList(j2eeName, al.size(), mHttpSessionListenersJ2eeNames);         }         synchronized (mHttpSessionListeners) {             mHttpSessionListeners.addAll(al);             if (mHttpSessionListeners.size() > 0) {                 sessionListener = true;                 _coreHttpSessionManager.getIStore().setHttpSessionListener(true);                 boolean mIBMSessionListenerImplemented = isIBMSessionListenerImplemented(al); // PQ81248                 if (mIBMSessionListenerImplemented) {                     wasHttpSessionObserver.setDoesContainIBMSessionListener(true);                 }             }         }          if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_CORE.isLoggable(Level.FINE)) {             LoggingUtil.SESSION_LOGGER_CORE.exiting(methodClassName, methodNames[ADD_HTTP_SESSION_LISTENER], ""addHttpSessionListener:"" + al);         }     }
public EClass getLNC() {   if (lncEClass == null) {    lncEClass = (EClass)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(285);   }   return lncEClass;  }
private static void free(ByteBuffer buf) {         Cleaner cleaner = ((DirectBuffer)buf).cleaner();         if (cleaner != null) {             cleaner.clean();         }     }
public boolean matches(String surt, Date captureDate, Date retrievalDate, String who2) {         return (who == null || who.length() == 0 || who.equals(who2))          && matches(surt, captureDate, retrievalDate);     }
void registerTaskStarted(Task task) {         synchronized (m_activeTasks) {             String mapKey = createMapKey(task.getTenant(), task.getTaskID());             if (m_activeTasks.put(mapKey, task) != null) {                 m_logger.warn(""Task {} registered as started but was already running"", mapKey);             }         }     }
@Override   public synchronized void start() {     if (thread != null) {       throw new IllegalThreadStateException(""Parser already started"");     }      String name = getThreadName() + ""("" + getUri().toString() + "")"";      CountDownLatch startSignal = new CountDownLatch(1);     Runnable runnable = getRunnable(startSignal);      thread = new Thread(runnable, name);     thread.start();      // Block until the thread has started     try {       startSignal.await();     } catch (InterruptedException e) {       Thread.currentThread().interrupt();     }   }
public final void setCssLinkFlavor(String cssLinkFlavor) {   if (CSSHTMLBundleLinkRenderer.FLAVORS_HTML.equalsIgnoreCase(cssLinkFlavor)     || CSSHTMLBundleLinkRenderer.FLAVORS_XHTML.equalsIgnoreCase(cssLinkFlavor)     || CSSHTMLBundleLinkRenderer.FLAVORS_XHTML_EXTENDED.equalsIgnoreCase(cssLinkFlavor))    CSSHTMLBundleLinkRenderer.setClosingTag(cssLinkFlavor);   else {    throw new IllegalArgumentException(""The value for the jawr.csslinks.flavor "" + ""property ["" + cssLinkFlavor      + ""] is invalid. "" + ""Please check the docs for valid values "");   }  }
public void marshall(UploadArchiveRequest uploadArchiveRequest, ProtocolMarshaller protocolMarshaller) {          if (uploadArchiveRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {             protocolMarshaller.marshall(uploadArchiveRequest.getVaultName(), VAULTNAME_BINDING);             protocolMarshaller.marshall(uploadArchiveRequest.getAccountId(), ACCOUNTID_BINDING);             protocolMarshaller.marshall(uploadArchiveRequest.getArchiveDescription(), ARCHIVEDESCRIPTION_BINDING);             protocolMarshaller.marshall(uploadArchiveRequest.getChecksum(), CHECKSUM_BINDING);             protocolMarshaller.marshall(uploadArchiveRequest.getBody(), BODY_BINDING);             protocolMarshaller.marshall(uploadArchiveRequest.getContentLength(), CONTENTLENGTH_BINDING);         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
public static String emptyToNull(String string) {     return string == null || string.isEmpty() ? null : string;   }
@Override      public EnhanceEntity findById(Object primaryKey, EntityMetadata m, Client client)      {          List<String> relationNames = m.getRelationNames();          if (relationNames != null && !relationNames.isEmpty())          {              Set<String> keys = new HashSet<String>(1);              keys.add(primaryKey.toString());              String query = getSqlQueryFromJPA(m, relationNames, keys);              List<EnhanceEntity> results = populateEnhanceEntities(m, relationNames, client, query);              return results != null && !results.isEmpty() ? results.get(0) : null;          }          else          {              Object o;              try              {                  o = client.find(m.getEntityClazz(), primaryKey);              }              catch (Exception e)              {                  throw new PersistenceException(e);              }              return o != null ? new EnhanceEntity(o, getId(o, m), null) : null;          }            // return super.findById(primaryKey, m, client);      }
public IOProvider.Readable getIOProviderFrom(String name, AbstractClassLoader first) {    if (name.length() == 0) return null;    if (name.charAt(0) == '/') name = name.substring(1);    IOProvider.Readable provider = null;       // try with the first one       if (first != null)        provider = first.get(name);       // then, try on other libraries       if (provider == null) {           for (int i = 0; i < libs.size(); i++) {            AbstractClassLoader cl = libs.get(i);            if (cl == first) continue;            provider = cl.get(name);            if (provider != null) break;           }          }          if (provider != null)           return provider;          // then try on the core one          return coreIOProvider.get(name);   }
public VALUEFROM decodeFromRaw(Object o) {         if (o == null && !isOptional()) return null;         return decodeFromRawInternal(o);     }
protected void checkLPSEnablement() {         if (tc.isEntryEnabled())             Tr.entry(tc, ""checkLPSEnablement"");          // If this is in a tran enabled for LPS via beginLPSEnabledTx return without         // checking for LPS enablement         if (_LPSEnabledTx) {             if (tc.isEntryEnabled())                 Tr.exit(tc, ""checkLPSEnablement - LPSEnabledTx"");             return;         }          final boolean debug = tc.isDebugEnabled();          // If we are not debugging and LPS is disabled, return immediately.         if (!debug) {             if (_LPSProhibited) {                 if (tc.isEntryEnabled())                     Tr.exit(tc, ""checkLPSEnablement"");                 return;             }         }          final boolean isLPSEnabled = _transaction._configProvider.getRuntimeMetaDataProvider().isHeuristicHazardAccepted();          if (debug)             Tr.debug(tc, ""LPSEnabled"", isLPSEnabled);          // If this application does not allow the LPS function then ensure that we record         // this fact. This flag will remain false until the first application that does         // not allow LPS drives an enlist. At this point it will be set to true and is         // not changed back to false.         if (!isLPSEnabled) {             _LPSProhibited = true;         }          if (tc.isEntryEnabled())             Tr.exit(tc, ""checkLPSEnablement : LPSEnabled="" + isLPSEnabled + "" LPSProhibited="" + _LPSProhibited);     }
@SuppressWarnings(""unchecked"")     public static <T> T[] tail(T[] self) {         if (self.length == 0) {             throw new NoSuchElementException(""Cannot access tail() for an empty array"");         }         T[] result = createSimilarArray(self, self.length - 1);         System.arraycopy(self, 1, result, 0, self.length - 1);         return result;     }
public synchronized void checkIfCreateNonPersistentTimerAllowed(EJBModuleMetaDataImpl mmd) {         if (ivStopping) {             throw new EJBStoppedException(ivName);         }          if (mmd != null && mmd.ivStopping) {             throw new EJBStoppedException(mmd.getJ2EEName().toString());         }     }
private JSONObject getNodeConfig() {     JSONObject res = new JSONObject();     try {       res.put(""class"", ""org.openqa.grid.common.RegistrationRequest"");       res.put(""configuration"", getConfiguration());       JSONArray caps = new JSONArray();       JSONArray devices = driver.getSupportedDevices();       for (int i = 0; i < devices.length(); i++) {         JSONObject device = (JSONObject) devices.get(i);         for (int x = 0; x < driver.getSupportedApps().length(); x++) {           caps.put(getDeviceConfig(device, driver.getSupportedApps().getJSONObject(x)));         }       }       res.put(""capabilities"", caps);     } catch (JSONException e) {       throw new SelendroidException(e.getMessage(), e);     }     return res;   }
public boolean delete(String geoPackage, String tableName, long id) {         return delete(getGeoPackageId(geoPackage), tableName, id);     }
@SuppressWarnings({""unchecked""})     public static <T> T[] arrayOf(T firstElement, T... moreElements) {         checkArgNotNull(moreElements, ""moreElements"");         Class elementType = moreElements.getClass().getComponentType();         T[] array = (T[]) Array.newInstance(elementType, moreElements.length + 1);         array[0] = firstElement;         System.arraycopy(moreElements, 0, array, 1, moreElements.length);         return array;     }
public static String getEventName(String channelName) {         int i = channelName.indexOf(EVENT_PREFIX);         return i < 0 ? channelName : channelName.substring(i + EVENT_PREFIX.length());     }
public static void readShape(Connection connection, String fileName, String tableReference,String forceEncoding) throws IOException, SQLException {         File file = URIUtilities.fileFromString(fileName);         if (FileUtil.isFileImportable(file, ""shp"")) {             SHPDriverFunction shpDriverFunction = new SHPDriverFunction();             shpDriverFunction.importFile(connection, TableLocation.parse(tableReference, true).toString(true),                     file, new EmptyProgressVisitor(), forceEncoding);         }     }
private static void recursiveFindBadNodesInTable(Node n, Node cellroot, Vector<Node> nodes)     {         Node cell = cellroot;                  if (n.getNodeType() == Node.ELEMENT_NODE)         {             String tag = n.getNodeName();             if (tag.equalsIgnoreCase(""table""))             {                 if (cell != null) //do not enter nested tables                     return;             }             else if (tag.equalsIgnoreCase(""tbody"") ||                       tag.equalsIgnoreCase(""thead"") ||                       tag.equalsIgnoreCase(""tfoot"") ||                      tag.equalsIgnoreCase(""tr"") ||                      tag.equalsIgnoreCase(""col"") ||                      tag.equalsIgnoreCase(""colgroup""))             {             }             else if (tag.equalsIgnoreCase(""td"") || tag.equalsIgnoreCase(""th"") || tag.equalsIgnoreCase(""caption""))             {                 cell = n;             }             else //other elements             {                 if (cell == null)                 {                     nodes.add(n);                     return;                 }             }         } //other nodes         else if (n.getNodeType() == Node.TEXT_NODE)         {             if (cell == null && n.getNodeValue().trim().length() > 0)             {                 nodes.add(n);                 return;             }         }                  NodeList child = n.getChildNodes();         for (int i = 0; i < child.getLength(); i++)             recursiveFindBadNodesInTable(child.item(i), cell, nodes);     }
@Override   public NamingRegisterRequest decode(final byte[] buf) {     final AvroNamingRegisterRequest avroNamingRegisterRequest =         AvroUtils.fromBytes(buf, AvroNamingRegisterRequest.class);     return new NamingRegisterRequest(         new NameAssignmentTuple(factory.getNewInstance(avroNamingRegisterRequest.getId().toString()),             new InetSocketAddress(avroNamingRegisterRequest.getHost().toString(), avroNamingRegisterRequest.getPort()))     );   }
public List<String> getCategories(){   List<String> categories = FieldUtil.getCategories(getField());    if(categories != null && !categories.isEmpty()){    return categories;   }    return null;  }
private File createJar( List<String> classPath, String mainClass )         throws IOException     {         File file = File.createTempFile( ""maven-exec"", "".jar"" );         file.deleteOnExit();         FileOutputStream fos = new FileOutputStream( file );         JarOutputStream jos = new JarOutputStream( fos );         jos.setLevel( JarOutputStream.STORED );         JarEntry je = new JarEntry( ""META-INF/MANIFEST.MF"" );         jos.putNextEntry( je );          Manifest man = new Manifest();          // we can't use StringUtils.join here since we need to add a '/' to         // the end of directory entries - otherwise the jvm will ignore them.         StringBuilder cp = new StringBuilder();         for ( String el : classPath )         {             // NOTE: if File points to a directory, this entry MUST end in '/'.             cp.append( new URL( new File( el ).toURI().toASCIIString() ).toExternalForm() + "" "" );         }          man.getMainAttributes().putValue( ""Manifest-Version"", ""1.0"" );         man.getMainAttributes().putValue( ""Class-Path"", cp.toString().trim() );         man.getMainAttributes().putValue( ""Main-Class"", mainClass );          man.write( jos );         jos.close();          return file;     }
public I_CmsExtractionResult extractContent(          CmsObject cms,          CmsResource resource,          I_CmsSearchIndex index,          Locale forceLocale)      throws CmsException {            logContentExtraction(resource, index);          I_CmsExtractionResult ex = null;          try {              CmsFile file = readFile(cms, resource);              CmsXmlContainerPage containerPage = CmsXmlContainerPageFactory.unmarshal(cms, file);                List<I_CmsExtractionResult> all = new ArrayList<I_CmsExtractionResult>();              CmsContainerPageBean containerBean = containerPage.getContainerPage(cms);              if (containerBean != null) {                  for (CmsContainerElementBean element : containerBean.getElements()) {                      // check all elements in this container                      // get the formatter configuration for this element                      try {                          element.initResource(cms);                          CmsResource elementResource = element.getResource();                          if (!(cms.readProject(index.getProject()).isOnlineProject()                              && elementResource.isExpired(System.currentTimeMillis()))) {                              CmsADEConfigData adeConfig = OpenCms.getADEManager().lookupConfiguration(                                  cms,                                  file.getRootPath());                              CmsFormatterConfiguration formatters = adeConfig.getFormatters(cms, element.getResource());                              if ((formatters != null)                                  && (element.getFormatterId() != null)                                  && formatters.isSearchContent(element.getFormatterId())) {                                  // the content of this element must be included for the container page                                  all.add(                                      CmsSolrDocumentXmlContent.extractXmlContent(                                          cms,                                          elementResource,                                          index,                                          forceLocale));                              }                          }                      } catch (CmsException e) {                          LOG.debug(                              Messages.get().getBundle().key(                                  Messages.LOG_SKIPPING_CONTAINERPAGE_ELEMENT_WITH_UNREADABLE_RESOURCE_2,                                  file.getRootPath(),                                  element.getId()),                              e);                      }                  }              }              // we have to overwrite the resource and content locales with the one from this container page              // TODO: Is this really the wanted behavior? It seems to be done like this before.              Map<String, String> fieldMappings = new HashMap<String, String>(1);              // Add to each container page the contents in all available locales,              // in case one containerpage is used in multiple languages.              List<Locale> localesAvailable = OpenCms.getLocaleManager().getAvailableLocales(cms, resource);              Map<Locale, LinkedHashMap<String, String>> multilingualValues = new HashMap<Locale, LinkedHashMap<String, String>>(                  localesAvailable.size());              for (Locale localeAvailable : localesAvailable) {                  multilingualValues.put(localeAvailable, new LinkedHashMap<String, String>());              }              Locale locale = forceLocale != null              ? forceLocale              : index.getLocaleForResource(cms, resource, containerPage.getLocales());              ex = new CmsExtractionResult(locale, multilingualValues, fieldMappings);              ex = ex.merge(all);              return ex;          } catch (Exception e) {              throw new CmsIndexException(                  Messages.get().container(Messages.ERR_TEXT_EXTRACTION_1, resource.getRootPath()),                  e);          }      }
public static <E> E notNull(E obj, String msg) {         if (obj == null) {             throw (msg == null) ? new NullPointerException() : new NullPointerException(msg);         }         return obj;     }
public static void e(String msg, Element element) {   messager.printMessage(Diagnostic.Kind.ERROR, msg, element);  }
private static boolean polygonContainsMultiPoint_(Polygon polygon_a,    MultiPoint multipoint_b, double tolerance,    ProgressTracker progress_tracker) {   Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();   polygon_a.queryEnvelope2D(env_a);   multipoint_b.queryEnvelope2D(env_b);    // Quick envelope rejection test for false equality.   if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))    return false;    // Quick rasterize test to see whether the the geometries are disjoint,   // or if one is contained in the other.   int relation = tryRasterizedContainsOrDisjoint_(polygon_a,     multipoint_b, tolerance, false);    if (relation == Relation.disjoint)    return false;    if (relation == Relation.contains)    return true;          boolean b_interior = false;         Point2D ptB;          MultiPathImpl polygon_a_impl = (MultiPathImpl)polygon_a._getImpl();          Polygon pa = null;         Polygon p_polygon_a = polygon_a;          boolean b_checked_polygon_a_quad_tree = false;          for (int i = 0; i < multipoint_b.getPointCount(); i++)         {             ptB = multipoint_b.getXY(i);              if (!env_a.contains(ptB))                 return false;              PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_a, ptB, tolerance);              if (result == PolygonUtils.PiPResult.PiPInside)                 b_interior = true;             else if (result == PolygonUtils.PiPResult.PiPOutside)                 return false;              if (!b_checked_polygon_a_quad_tree) {                 if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multipoint_b.getPointCount() - 1) && (polygon_a_impl._getAccelerators() == null || polygon_a_impl._getAccelerators().getQuadTree() == null)) {                     pa = new Polygon();                     polygon_a.copyTo(pa);                     ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);                     p_polygon_a = pa;                 } else {                     p_polygon_a = polygon_a;                 }                  b_checked_polygon_a_quad_tree = true;             }         }          return b_interior;  }
public static File getCanonicalFile(final File file) {          // Check sanity         Validate.notNull(file, ""file"");          // All done         try {             return file.getCanonicalFile();         } catch (IOException e) {             throw new IllegalArgumentException(""Could not acquire the canonical file for [""                     + file.getAbsolutePath() + ""]"", e);         }     }
public void removeSprite (Sprite sprite)     {         _metamgr.removeSprite(sprite);          if (((sprite instanceof ActionSprite) ||              (sprite instanceof HoverSprite)) && (--_actionSpriteCount == 0)) {             removeMouseListener(_actionHandler);             removeMouseMotionListener(_actionHandler);         }     }
public static int indexOfDifference(String[] strs) {         if (strs == null || strs.length <= 1) {             return INDEX_NOT_FOUND;         }         boolean anyStringNull = false;         boolean allStringsNull = true;         int arrayLen = strs.length;         int shortestStrLen = Integer.MAX_VALUE;         int longestStrLen = 0;          // find the min and max string lengths; this avoids checking to make         // sure we are not exceeding the length of the string each time through         // the bottom loop.         for (int i = 0; i < arrayLen; i++) {             if (strs[i] == null) {                 anyStringNull = true;                 shortestStrLen = 0;             } else {                 allStringsNull = false;                 shortestStrLen = Math.min(strs[i].length(), shortestStrLen);                 longestStrLen = Math.max(strs[i].length(), longestStrLen);             }         }          // handle lists containing all nulls or all empty strings         if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {             return INDEX_NOT_FOUND;         }          // handle lists containing some nulls or some empty strings         if (shortestStrLen == 0) {             return 0;         }          // find the position with the first difference across all strings         int firstDiff = -1;         for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {             char comparisonChar = strs[0].charAt(stringPos);             for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {                 if (strs[arrayPos].charAt(stringPos) != comparisonChar) {                     firstDiff = stringPos;                     break;                 }             }             if (firstDiff != -1) {                 break;             }         }          if (firstDiff == -1 && shortestStrLen != longestStrLen) {             // we compared all of the characters up to the length of the             // shortest string and didn't find a match, but the string lengths             // vary, so return the length of the shortest string.             return shortestStrLen;         }         return firstDiff;     }
public static List<CPDefinition> findByUuid_C(String uuid, long companyId) {   return getPersistence().findByUuid_C(uuid, companyId);  }
public void marshall(EnableAWSOrganizationsAccessRequest enableAWSOrganizationsAccessRequest, ProtocolMarshaller protocolMarshaller) {          if (enableAWSOrganizationsAccessRequest == null) {             throw new SdkClientException(""Invalid argument passed to marshall(...)"");         }          try {         } catch (Exception e) {             throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);         }     }
DownloadState query(Uri uri) {     synchronized (currentRequests) {       for (DownloadRequest request : currentRequests) {         if (request.uri().toString().equals(uri.toString())) {           return request.downloadState();         }       }     }      return DownloadState.INVALID;   }
@Nonnull   public ClassLoader getClassLoader ()   {     return m_aBestCandidate == null ? Thread.currentThread ().getContextClassLoader ()                                     : m_aBestCandidate.getClassLoader ();   }
private void populateMetaData() throws SQLException    {       m_meta.clear();        ResultSetMetaData meta = m_rs.getMetaData();       int columnCount = meta.getColumnCount() + 1;       for (int loop = 1; loop < columnCount; loop++)       {          String name = meta.getColumnName(loop);          Integer type = Integer.valueOf(meta.getColumnType(loop));          m_meta.put(name, type);       }    }
public static InputStream decrypt(InputStream inputStream, byte[] key) {         checkNotNull(inputStream);         checkNotNull(key);         AESFastEngine aesEngine = new AESFastEngine();         PaddedBufferedBlockCipher cipher =                 new PaddedBufferedBlockCipher(aesEngine, new PKCS7Padding());         cipher.init(false, new KeyParameter(key));         return new CipherInputStream(inputStream, cipher);     }
@SuppressWarnings(""unchecked"")   private <T> T createMockResultOfCall() throws IOException {    final Object result;    final String request = url.toString();    if (!request.contains(HttpParameter.PART.getName() + '=')      && !request.contains(HttpParameter.JMX_VALUE.getName())      || request.contains(HttpPart.DEFAULT_WITH_CURRENT_REQUESTS.getName())) {     final String message = request.contains(""/test2"") ? null       : ""ceci est message pour le rapport"";     result = Arrays.asList(new Counter(Counter.HTTP_COUNTER_NAME, null),       new Counter(""services"", null), new Counter(Counter.ERROR_COUNTER_NAME, null),       new JavaInformations(null, true), message);    } else {     result = LabradorMock.createMockResultOfPartCall(request);    }    return (T) result;   }
@Pure  public Iterable<BusItineraryHalt> busHalts() {   final MultiCollection<BusItineraryHalt> halts = new MultiCollection<>();   halts.addCollection(this.validHalts);   halts.addCollection(this.invalidHalts);   return Collections.unmodifiableCollection(halts);  }
protected File createSREManifestFile(File filename) throws MojoExecutionException, MojoFailureException {   try {    final Manifest manifest = createSREManifest();    final File manifestFile;    if (filename == null) {     final File parent = new File(getMavenProject().getBuild().getOutputDirectory());     manifestFile = new File(parent.getParentFile(), ""SRE-MANIFEST.MF""); //$NON-NLS-1$    } else {     manifestFile = filename;    }     try (FileOutputStream fos = new FileOutputStream(manifestFile)) {     manifest.write(fos);    }     return manifestFile;   } catch (MojoFailureException exception) {    throw exception;   } catch (IOException exception) {    throw new MojoFailureException(exception.getLocalizedMessage(), exception);   }  }
public boolean removeKey(long key) {   int i = indexOfKey(key);   if (i<0) return false; // key not contained     this.state[i]=REMOVED;   this.values[i]=0; // delta   this.distinct--;     if (this.distinct < this.lowWaterMark) {    int newCapacity = chooseShrinkCapacity(this.distinct,this.minLoadFactor, this.maxLoadFactor);    rehash(newCapacity);   }      return true;   }
private DataSet doFixedLengthFile(final Reader dataSource) throws IOException {            final DefaultDataSet ds = new DefaultDataSet(getPzMetaData(), this);            try (BufferedReader br = new BufferedReader(dataSource)) {              // gather the conversion properties              ds.setPZConvertProps(ParserUtils.loadConvertProperties());                final Map<String, Integer> recordLengths = ParserUtils.calculateRecordLengths(getPzMetaData());                // Read in the flat file              String line = null;              int lineCount = 0;              // map of record lengths corresponding to the ID's in the columnMD              // array loop through each line in the file              while ((line = br.readLine()) != null) {                  lineCount++;                  // empty line skip past it                  if (line.trim().length() == 0) {                      continue;                  }                    final String mdkey = FixedWidthParserUtils.getCMDKey(getPzMetaData(), line);                  final int recordLength = recordLengths.get(mdkey);                    if (line.length() > recordLength) {                      // Incorrect record length on line log the error. Line will not                      // be included in the                      // dataset                      if (isIgnoreExtraColumns()) {                          // user has choosen to ignore the fact that we have too many bytes in the fixed                          // width file. Truncate the line to the correct length                          line = line.substring(0, recordLength);                          addError(ds, ""TRUNCATED LINE TO CORRECT LENGTH"", lineCount, 1);                      } else {                          addError(ds, ""LINE TOO LONG. LINE IS "" + line.length() + "" LONG. SHOULD BE "" + recordLength, lineCount, 2,                                  isStoreRawDataToDataError() ? line : null);                          continue;                      }                  } else if (line.length() < recordLength) {                      if (isHandlingShortLines()) {                          // We can pad this line out                          line += ParserUtils.padding(recordLength - line.length(), ' ');                            // log a warning                          addError(ds, ""PADDED LINE TO CORRECT RECORD LENGTH"", lineCount, 1);                        } else {                          addError(ds, ""LINE TOO SHORT. LINE IS "" + line.length() + "" LONG. SHOULD BE "" + recordLength, lineCount, 2,                                  isStoreRawDataToDataError() ? line : null);                          continue;                      }                  }                    final Row row = new Row();                  row.setMdkey(mdkey.equals(FPConstants.DETAIL_ID) ? null : mdkey); // try                    final List<ColumnMetaData> cmds = ParserUtils.getColumnMetaData(mdkey, getPzMetaData());                  row.addColumn(FixedWidthParserUtils.splitFixedText(cmds, line, isPreserveLeadingWhitespace(), isPreserveTrailingWhitespace()));                  row.setRowNumber(lineCount);                    if (isFlagEmptyRows()) {                      // user has elected to have the parser flag rows that are empty                      row.setEmpty(ParserUtils.isListElementsEmpty(row.getCols()));                  }                  if (isStoreRawDataToDataSet()) {                      // user told the parser to keep a copy of the raw data in the row                      // WARNING potential for high memory usage here                      row.setRawData(line);                  }                    // add the row to the array                  ds.addRow(row);              }          } finally {              closeReaders();          }          return ds;      }
@Override     public void setUsers(final String[] theUsers) {         mUsers = theUsers;         // Cleanup new line and ws         for (int i = 0; i < theUsers.length; i++) {             mUsers[i] = mUsers[i].trim();         }     }
public static void removeBottomSeparators(JPopupMenu popupMenu) {         int indexLastComponent = popupMenu.getComponentCount() - 1;         while (indexLastComponent >= 0 && isPopupMenuSeparator(popupMenu.getComponent(indexLastComponent))) {             popupMenu.remove(indexLastComponent);             indexLastComponent -= 1;         }     }
public static boolean isGreaterOrEqual(BigDecimal bigNum1, BigDecimal bigNum2) {    Assert.notNull(bigNum1);    Assert.notNull(bigNum2);    return bigNum1.compareTo(bigNum2) >= 0;   }
public static String packValues(List<String> unpackedValues) {         if (hasItems(unpackedValues)) {             final Iterator<String> it = unpackedValues.iterator();             final StringBuilder b = new StringBuilder();             while (it.hasNext()) {                 b.append(it.next());                 if (it.hasNext()) {                     b.append(PACKED_VALUES_DELIMITER);                 }             }              return b.toString();         }          return null;     }
@Override  public Tuple2<Long,Long> getCurrentState() throws IOException {   return new Tuple2<>(this.stream.getPos(), this.currentTransactionCounterInBlock);  }
public static Tag uri(RequestEvent event) {         ContainerResponse response = event.getContainerResponse();         if (response != null) {             int status = response.getStatus();             if (isRedirection(status)) {                 return URI_REDIRECTION;             }             if (status == 404) {                 return URI_NOT_FOUND;             }         }         String matchingPattern = getMatchingPattern(event);         if (matchingPattern.equals(""/"")) {             return URI_ROOT;         }         return Tag.of(""uri"", matchingPattern);     }
private static byte[] idInBytes(final short idwidth, final long lid) {     if (idwidth <= 0) {       throw new AssertionError(""negative idwidth: "" + idwidth);     }     final byte[] id = Bytes.fromLong(lid);     for (int i = 0; i < id.length - idwidth; i++) {       if (id[i] != 0) {         System.err.println(lid + "" is too large to fit on "" + idwidth             + "" bytes.  Maybe you forgot to adjust --idwidth?"");         return null;       }     }     return Arrays.copyOfRange(id, id.length - idwidth, id.length);   }
protected ItemState getLastItemState(String identifer)    {       List<ItemState> allStates = changesLog.getAllStates();       for (int i = allStates.size() - 1; i >= 0; i--)       {          ItemState state = allStates.get(i);          if (state.getData().getIdentifier().equals(identifer))             return state;       }       return null;    }
@Override     final public ManagedConnection matchManagedConnections(                                                            final Set connectionSet, final Subject subject,                                                            final ConnectionRequestInfo requestInfo) {          if (TraceComponent.isAnyTracingEnabled() && TRACE.isEntryEnabled()) {             SibTr.entry(TRACE, ""matchManagedConnections"", new Object[] {                                                                         connectionSet,                                                                         JmsJcaManagedConnection.subjectToString(subject),                                                                         requestInfo });         }          final SICoreConnection coreConnection = (requestInfo instanceof JmsJcaConnectionRequestInfo) ? ((JmsJcaConnectionRequestInfo) requestInfo)                         .getSICoreConnection()                         : null;          final JmsJcaUserDetails userDetails = getUserDetails(subject,                                                              requestInfo);          if (TraceComponent.isAnyTracingEnabled() && TRACE.isDebugEnabled()) {              if (userDetails != null) {                 SibTr.debug(TRACE, ""Got a username and password"");             } else {                 SibTr.debug(TRACE, ""Using subject"");             }          }          JmsJcaManagedConnection matchedConnection = null;          // Go through the set of managed connections and try and match one          for (final Iterator iterator = connectionSet.iterator(); iterator                         .hasNext();) {              final Object object = iterator.next();              // Skip over any non JmsJcaManagedConnections             if (object instanceof JmsJcaManagedConnection) {                  final JmsJcaManagedConnection managedConnection = (JmsJcaManagedConnection) object;                  // If we have a user name and password from either the                 // requestInfo or subject then we must try and match againgst                 // those                 if (userDetails != null) {                      if (managedConnection.match(userDetails, coreConnection)) {                          matchedConnection = managedConnection;                         if (TraceComponent.isAnyTracingEnabled() && TRACE.isDebugEnabled()) {                             SibTr                                             .debug(TRACE,                                                    ""Matched a connection against the subject username and password"");                         }                         break;                      }                  } else {                      // This is a subject where we couldnt get the userName and                     // password from..                      if (managedConnection.match(subject, coreConnection)) {                          matchedConnection = managedConnection;                         if (TraceComponent.isAnyTracingEnabled() && TRACE.isDebugEnabled()) {                             SibTr.debug(TRACE,                                         ""Matched a connection against the subject"");                         }                         break;                      }                  }             }         }          if (TraceComponent.isAnyTracingEnabled() && TRACE.isEntryEnabled()) {             SibTr.exit(TRACE, ""matchManagedConnections"", matchedConnection);         }         return matchedConnection;      }
